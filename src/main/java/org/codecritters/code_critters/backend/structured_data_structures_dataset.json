[
    {
        "chapter_title": "Data\tStructures",
        "subchapters": [
            {
                "subchapter_title": "And",
                "content": "Algorithms Made\tEasy -To\tAll\tMy\tReaders By Narasimha\tKarumanchi Copyright\u00a9\t2017\tby\tCareerMonk.com All\trights\treserved. Designed\tby\tNarasimha\tKarumanchi Copyright\u00a9\t2017\tCareerMonk\tPublications.\tAll\trights\treserved. All\trights\treserved.\tNo\tpart\tof\tthis\tbook\tmay\tbe\treproduced\tin\tany\tform\tor\tby\tany\telectronic\tor\tmechanical\tmeans,\tincluding information\tstorage\tand\tretrieval\tsystems,\twithout\twritten\tpermission\tfrom\tthe\tpublisher\tor\tauthor. Acknowledgements Mother\tand\tFather,\tit\tis\timpossible\tto\tthank\tyou\tadequately\tfor\teverything\tyou\thave\tdone,\tfrom loving\tme\tunconditionally\tto\traising\tme\tin\ta\tstable\thousehold,\twhere\tyour\tpersistent\tefforts\tand traditional\tvalues\ttaught\tyour\tchildren\tto\tcelebrate\tand\tembrace\tlife.\tI\tcould\tnot\thave\tasked\tfor better\tparents\tor\trole-models.\tYou\tshowed\tme\tthat\tanything\tis\tpossible\twith\tfaith,\thard\twork\tand determination. This\tbook\twould\tnot\thave\tbeen\tpossible\twithout\tthe\thelp\tof\tmany\tpeople.\tI\twould\tlike\tto\texpress my\tgratitude\tto\tall\tof\tthe\tpeople\twho\tprovided\tsupport,\ttalked\tthings\tover,\tread,\twrote,\toffered comments,\tallowed\tme\tto\tquote\ttheir\tremarks\tand\tassisted\tin\tthe\tediting,\tproofreading\tand\tdesign. In\tparticular,\tI\twould\tlike\tto\tthank\tthe\tfollowing\tindividuals: \u25aa Mohan\tMullapudi,\tIIT\tBombay,\tArchitect,\tdataRPM\tPvt.\tLtd. \u25aa Navin\tKumar\tJaiswal,\tSenior\tConsultant,\tJuniper\tNetworks\tInc. \u25aa A.\tVamshi\tKrishna,\tIIT\tKanpur,\tMentor\tGraphics\tInc. \u25aa Cathy\tReed,\tBA,\tMA,\tCopy\tEditor \u2013Narasimha\tKarumanchi M-Tech,\tIIT\tBombay Founder,\tCareerMonk.com Preface Dear\tReader, Please\thold\ton!\tI\tknow\tmany\tpeople\ttypically\tdo\tnot\tread\tthe\tPreface\tof\ta\tbook.\tBut\tI\tstrongly recommend\tthat\tyou\tread\tthis\tparticular\tPreface. It\tis\tnot\tthe\tmain\tobjective\tof\tthis\tbook\tto\tpresent\tyou\twith\tthe\ttheorems\tand\tproofs\ton\tdata structures\tand\talgorithms.\tI\thave\tfollowed\ta\tpattern\tof\timproving\tthe\tproblem\tsolutions\twith different\t complexities\t (for\t each\t problem,\t you\t will\t find\t multiple\t solutions\t with\t different,\t and reduced,\tcomplexities).\tBasically,\tit\u2019s\tan\tenumeration\tof\tpossible\tsolutions.\tWith\tthis\tapproach, even\tif\tyou\tget\ta\tnew\tquestion,\tit\twill\tshow\tyou\ta\tway\tto\tthink\tabout\tthe\tpossible\tsolutions.\tYou will\tfind\tthis\tbook\tuseful\tfor\tinterview\tpreparation,\tcompetitive\texams\tpreparation,\tand\tcampus interview\tpreparations. As\t a\t job\t seeker,\t if\t you\t read\t the\t complete\t book,\t I\t am\t sure\t you\t will\t be\t able\t to\t challenge\t the interviewers.\tIf\tyou\tread\tit\tas\tan\tinstructor,\tit\twill\thelp\tyou\tto\tdeliver\tlectures\twith\tan\tapproach that\tis\teasy\tto\tfollow,\tand\tas\ta\tresult\tyour\tstudents\twill\tappreciate\tthe\tfact\tthat\tthey\thave\topted\tfor Computer\tScience\t/\tInformation\tTechnology\tas\ttheir\tdegree. This\tbook\tis\talso\tuseful\tfor\tEngineering\tdegree\tstudents\tand\tMasters\tdegree\tstudents\t during their\t academic\t preparations.\t In\t all\t the\t chapters\t you\t will\t see\t that\t there\t is\t more\t emphasis\t on problems\tand\ttheir\tanalysis\trather\tthan\ton\ttheory.\tIn\teach\tchapter,\tyou\twill\tfirst\tread\tabout\tthe basic\trequired\ttheory,\twhich\tis\tthen\tfollowed\tby\ta\tsection\ton\tproblem\tsets.\tIn\ttotal,\tthere\tare approximately\t700\talgorithmic\tproblems,\tall\twith\tsolutions. If\t you\t read\t the\t book\t as\t a\t student\t preparing\t for\t competitive\t exams\t for\t Computer\t Science\t / Information\tTechnology,\tthe\tcontent\tcovers\tall\tthe\trequired\ttopics\tin\tfull\tdetail.\tWhile\twriting this\tbook,\tmy\tmain\tfocus\twas\tto\thelp\tstudents\twho\tare\tpreparing\tfor\tthese\texams. In\tall\tthe\tchapters\tyou\twill\tsee\tmore\temphasis\ton\tproblems\tand\tanalysis\trather\tthan\ton\ttheory.\tIn each\tchapter,\tyou\twill\tfirst\tsee\tthe\tbasic\trequired\ttheory\tfollowed\tby\tvarious\tproblems. For\tmany\tproblems,\tmultiple\tsolutions\tare\tprovided\twith\tdifferent\tlevels\tof\tcomplexity.\tWe\tstart with\tthe\tbrute\tforce\tsolution\tand\tslowly\tmove\ttoward\tthe\tbest\tsolution\tpossible\tfor\tthat\tproblem. For\teach\tproblem,\twe\tendeavor\tto\tunderstand\thow\tmuch\ttime\tthe\talgorithm\ttakes\tand\thow\tmuch memory\tthe\talgorithm\tuses. It\tis\trecommended\tthat\tthe\treader\tdoes\tat\tleast\tone\tcomplete\treading\tof\tthis\tbook\tto\tgain\ta\tfull understanding\t of\t all\t the\t topics\t that\t are\t covered.\t Then,\t in\t subsequent\t readings\t you\t can\t skip directly\tto\tany\tchapter\tto\trefer\tto\ta\tspecific\ttopic.\tEven\tthough\tmany\treadings\thave\tbeen\tdone\tfor the\tpurpose\tof\tcorrecting\terrors,\tthere\tcould\tstill\tbe\tsome\tminor\ttypos\tin\tthe\tbook.\tIf\tany\tare found,\t they\t will\t be\t updated\t at\t www.CareerMonk.com.\t You\t can\t monitor\t this\t site\t for\t any corrections\t and\t also\t for\t new\t problems\t and\t solutions.\t Also,\t please\t provide\t your\t valuable suggestions\tat:\tInfo@CareerMonk.com. I\twish\tyou\tall\tthe\tbest\tand\tI\tam\tconfident\tthat\tyou\twill\tfind\tthis\tbook\tuseful. \u2013Narasimha\tKarumanchi M-Tech,\tI\tIT\tBombay Founder,\tCareerMonk.com Other\tBooks\tby\tNarasimha\tKarumanchi IT\tInterview\tQuestions Data\tStructures\tand\tAlgorithms\tfor\tGATE Data\tStructures\tand\tAigorithms\tMade\tEasy\tin\tJava Coding\tInterview\tQuestions Peeling\tDesign\tPatterns Elements\tof\tComputer\tNetworking Data\tStructures\tand\tAlgorithmic\tThinking\twith\tPython Table\tof\tContents"
            }
        ]
    },
    {
        "chapter_title": "1.\t\t\tIntroduction",
        "subchapters": [
            {
                "subchapter_title": "1.1\u2003Variables",
                "content": ""
            },
            {
                "subchapter_title": "1.2\u2003Data\tTypes",
                "content": ""
            },
            {
                "subchapter_title": "1.3\u2003Data\tStructures",
                "content": ""
            },
            {
                "subchapter_title": "1.4\u2003Abstract\tData\tTypes\t(ADTs)",
                "content": ""
            },
            {
                "subchapter_title": "1.5\u2003What\tis\tan\tAlgorithm?",
                "content": ""
            },
            {
                "subchapter_title": "1.6\u2003Why\tthe\tAnalysis\tof\tAlgorithms?",
                "content": ""
            },
            {
                "subchapter_title": "1.7\u2003Goal\tof\tthe\tAnalysis\tof\tAlgorithms",
                "content": ""
            },
            {
                "subchapter_title": "1.8\u2003What\tis\tRunning\tTime\tAnalysis?",
                "content": ""
            },
            {
                "subchapter_title": "1.9\u2003How\tto\tCompare\tAlgorithms",
                "content": ""
            },
            {
                "subchapter_title": "1.10\u2002What\tis\tRate\tof\tGrowth?",
                "content": ""
            },
            {
                "subchapter_title": "1.11\u2002Commonly\tUsed\tRates\tof\tGrowth",
                "content": ""
            },
            {
                "subchapter_title": "1.12\u2002Types\tof\tAnalysis",
                "content": ""
            },
            {
                "subchapter_title": "1.13\u2002Asymptotic\tNotation",
                "content": ""
            },
            {
                "subchapter_title": "1.14\u2002Big-O\tNotation\t[Upper\tBounding\tFunction]",
                "content": ""
            },
            {
                "subchapter_title": "1.15\u2002Omega-Q\tNotation\t[Lower\tBounding\tFunction]",
                "content": ""
            },
            {
                "subchapter_title": "1.16\u2002Theta-\u0398\tNotation\t[Order\tFunction]",
                "content": ""
            },
            {
                "subchapter_title": "1.17\u2002Important\tNotes",
                "content": ""
            },
            {
                "subchapter_title": "1.18\u2002Why\tis\tit\tcalled\tAsymptotic\tAnalysis?",
                "content": ""
            },
            {
                "subchapter_title": "1.19\u2002Guidelines\tfor\tAsymptotic\tAnalysis",
                "content": ""
            },
            {
                "subchapter_title": "1.20\u2002Simplyfying\tproperties\tof\tasymptotic\tnotations",
                "content": ""
            },
            {
                "subchapter_title": "1.21\u2002Commonly\tused\tLogarithms\tand\tSummations",
                "content": ""
            },
            {
                "subchapter_title": "1.22\u2002Master\tTheorem\tfor\tDivide\tand\tConquer\tRecurrences",
                "content": ""
            },
            {
                "subchapter_title": "1.23\u2002Divide\tand\tConquer\tMaster\tTheorem:\tProblems\t&\tSolutions",
                "content": ""
            },
            {
                "subchapter_title": "1.24\u2002Master\tTheorem\tfor\tSubtract\tand\tConquer\tRecurrences",
                "content": ""
            },
            {
                "subchapter_title": "1.25\u2002Variant\tof\tSubtraction\tand\tConquer\tMaster\tTheorem",
                "content": ""
            },
            {
                "subchapter_title": "1.26\u2002Method\tof\tGuessing\tand\tConfirming",
                "content": ""
            },
            {
                "subchapter_title": "1.27\u2002Amortized\tAnalysis",
                "content": ""
            },
            {
                "subchapter_title": "1.28\u2002Algorithms\tAnalysis:\tProblems\t&\tSolutions",
                "content": ""
            }
        ]
    },
    {
        "chapter_title": "2.\t\t\tRecursion\tand\tBacktracking",
        "subchapters": [
            {
                "subchapter_title": "2.1\u2003Introduction",
                "content": ""
            },
            {
                "subchapter_title": "2.2\u2003What\tis\tRecursion?",
                "content": ""
            },
            {
                "subchapter_title": "2.3\u2003Why\tRecursion?",
                "content": ""
            },
            {
                "subchapter_title": "2.4\u2003Format\tof\ta\tRecursive\tFunction",
                "content": ""
            },
            {
                "subchapter_title": "2.5\u2003Recursion\tand\tMemory\t(Visualization)",
                "content": ""
            },
            {
                "subchapter_title": "2.6\u2003Recursion\tversus\tIteration",
                "content": ""
            },
            {
                "subchapter_title": "2.7\u2003Notes\ton\tRecursion",
                "content": ""
            },
            {
                "subchapter_title": "2.8\u2003Example\tAlgorithms\tof\tRecursion",
                "content": ""
            },
            {
                "subchapter_title": "2.9\u2003Recursion:\tProblems\t&\tSolutions",
                "content": ""
            },
            {
                "subchapter_title": "2.10\u2002What\tis\tBacktracking?",
                "content": ""
            },
            {
                "subchapter_title": "2.11\u2002Example\tAlgorithms\tof\tBacktracking",
                "content": ""
            },
            {
                "subchapter_title": "2.12\u2002Backtracking:\tProblems\t&\tSolutions",
                "content": ""
            }
        ]
    },
    {
        "chapter_title": "3.\t\t\tLinked\tLists",
        "subchapters": [
            {
                "subchapter_title": "3.1\u2003What\tis\ta\tLinked\tList?",
                "content": ""
            },
            {
                "subchapter_title": "3.2\u2003Linked\tLists\tADT",
                "content": ""
            },
            {
                "subchapter_title": "3.3\u2003Why\tLinked\tLists?",
                "content": ""
            },
            {
                "subchapter_title": "3.4\u2003Arrays\tOverview",
                "content": ""
            },
            {
                "subchapter_title": "3.5\u2003Comparison\tof\tLinked\tLists\twith\tArrays\t&\tDynamic\tArrays",
                "content": ""
            },
            {
                "subchapter_title": "3.6\u2003Singly\tLinked\tLists",
                "content": ""
            },
            {
                "subchapter_title": "3.7\u2003Doubly\tLinked\tLists",
                "content": ""
            },
            {
                "subchapter_title": "3.8\u2003Circular\tLinked\tLists",
                "content": ""
            },
            {
                "subchapter_title": "3.9\u2003A\tMemory-efficient\tDoubly\tLinked\tList",
                "content": ""
            },
            {
                "subchapter_title": "3.10\u2002Unrolled\tLinked\tLists",
                "content": ""
            },
            {
                "subchapter_title": "3.11\u2002Skip\tLists",
                "content": ""
            },
            {
                "subchapter_title": "3.12\u2002Linked\tLists:\tProblems\t&\tSolutions",
                "content": ""
            }
        ]
    },
    {
        "chapter_title": "4.\t\t\tStacks",
        "subchapters": [
            {
                "subchapter_title": "4.1\u2003What\tis\ta\tStack?",
                "content": ""
            },
            {
                "subchapter_title": "4.2\u2003How\tStacks\tare\tused",
                "content": ""
            },
            {
                "subchapter_title": "4.3\u2003Stack\tADT",
                "content": ""
            },
            {
                "subchapter_title": "4.4\u2003Applications",
                "content": ""
            },
            {
                "subchapter_title": "4.5\u2003Implementation",
                "content": ""
            },
            {
                "subchapter_title": "4.6\u2003Comparison\tof\tImplementations",
                "content": ""
            },
            {
                "subchapter_title": "4.7\u2003Stacks:\tProblems\t&\tSolutions",
                "content": ""
            }
        ]
    },
    {
        "chapter_title": "5.\t\t\tQueues",
        "subchapters": [
            {
                "subchapter_title": "5.1\u2003What\tis\ta\tQueue?",
                "content": ""
            },
            {
                "subchapter_title": "5.2\u2003How\tare\tQueues\tUsed?",
                "content": ""
            },
            {
                "subchapter_title": "5.3\u2003Queue\tADT",
                "content": ""
            },
            {
                "subchapter_title": "5.4\u2003Exceptions",
                "content": ""
            },
            {
                "subchapter_title": "5.5\u2003Applications",
                "content": ""
            },
            {
                "subchapter_title": "5.6\u2003Implementation",
                "content": ""
            },
            {
                "subchapter_title": "5.7\u2003Queues:\tProblems\t&\tSolutions",
                "content": ""
            }
        ]
    },
    {
        "chapter_title": "6.\t\t\tTrees",
        "subchapters": [
            {
                "subchapter_title": "6.1\u2003What\tis\ta\tTree?",
                "content": ""
            },
            {
                "subchapter_title": "6.2\u2003Glossary",
                "content": ""
            },
            {
                "subchapter_title": "6.3\u2003Binary\tTrees",
                "content": ""
            },
            {
                "subchapter_title": "6.4\u2003Types\tof\tBinary\tTrees",
                "content": ""
            },
            {
                "subchapter_title": "6.5\u2003Properties\tof\tBinary\tTrees",
                "content": ""
            },
            {
                "subchapter_title": "6.6\u2003Binary\tTree\tTraversals",
                "content": ""
            },
            {
                "subchapter_title": "6.7\u2003Generic\tTrees\t(N-ary\tTrees)",
                "content": ""
            },
            {
                "subchapter_title": "6.8\u2003Threaded\tBinary\tTree\tTraversals\t(Stack\tor\tQueue-less\tTraversals)",
                "content": ""
            },
            {
                "subchapter_title": "6.9\u2003Expression\tTrees",
                "content": ""
            },
            {
                "subchapter_title": "6.10\u2002XOR\tTrees",
                "content": ""
            },
            {
                "subchapter_title": "6.11\u2002Binary\tSearch\tTrees\t(BSTs)",
                "content": ""
            },
            {
                "subchapter_title": "6.12\u2003Balanced\tBinary\tSearch\tTrees",
                "content": ""
            },
            {
                "subchapter_title": "6.13\u2002AVL\t(Adelson-Velskii\tand\tLandis)\tTrees",
                "content": ""
            },
            {
                "subchapter_title": "6.14\u2002Other\tVariations\ton\tTrees",
                "content": ""
            }
        ]
    },
    {
        "chapter_title": "7.\t\t\tPriority\tQueues\tand\tHeaps",
        "subchapters": [
            {
                "subchapter_title": "7.1\u2003What\tis\ta\tPriority\tQueue?",
                "content": ""
            },
            {
                "subchapter_title": "7.2\u2003Priority\tQueue\tADT",
                "content": ""
            },
            {
                "subchapter_title": "7.3\u2003Priority\tQueue\tApplications",
                "content": ""
            },
            {
                "subchapter_title": "7.4\u2003Priority\tQueue\tImplementations",
                "content": ""
            },
            {
                "subchapter_title": "7.5\u2003Heaps\tand\tBinary\tHeaps",
                "content": ""
            },
            {
                "subchapter_title": "7.6\u2003Binary\tHeaps",
                "content": ""
            },
            {
                "subchapter_title": "7.7\u2003Heapsort",
                "content": ""
            },
            {
                "subchapter_title": "7.8\u2003Priority\tQueues\t[Heaps]:\tProblems\t&\tSolutions",
                "content": ""
            }
        ]
    },
    {
        "chapter_title": "8.\t\t\tDisjoint\tSets\tADT",
        "subchapters": [
            {
                "subchapter_title": "8.1\u2003Introduction",
                "content": ""
            },
            {
                "subchapter_title": "8.2\u2003Equivalence\tRelations\tand\tEquivalence\tClasses",
                "content": ""
            },
            {
                "subchapter_title": "8.3\u2003Disjoint\tSets\tADT",
                "content": ""
            },
            {
                "subchapter_title": "8.4\u2003Applications",
                "content": ""
            },
            {
                "subchapter_title": "8.5\u2003Tradeoffs\tin\tImplementing\tDisjoint\tSets\tADT",
                "content": ""
            },
            {
                "subchapter_title": "8.8\u2003Fast\tUNION\tImplementation\t(Slow\tFIND)",
                "content": ""
            },
            {
                "subchapter_title": "8.9\u2003Fast\tUNION\tImplementations\t(Quick\tFIND)",
                "content": ""
            },
            {
                "subchapter_title": "8.10\u2002Summary",
                "content": ""
            },
            {
                "subchapter_title": "8.11\u2002Disjoint\tSets:\tProblems\t&\tSolutions",
                "content": ""
            }
        ]
    },
    {
        "chapter_title": "9.\t\t\tGraph\tAlgorithms",
        "subchapters": [
            {
                "subchapter_title": "9.1\u2003Introduction",
                "content": ""
            },
            {
                "subchapter_title": "9.2\u2003Glossary",
                "content": ""
            },
            {
                "subchapter_title": "9.3\u2003Applications\tof\tGraphs",
                "content": ""
            },
            {
                "subchapter_title": "9.4\u2003Graph\tRepresentation",
                "content": ""
            },
            {
                "subchapter_title": "9.5\u2003Graph\tTraversals",
                "content": ""
            },
            {
                "subchapter_title": "9.6\u2003Topological\tSort",
                "content": ""
            },
            {
                "subchapter_title": "9.7\u2003Shortest\tPath\tAlgorithms",
                "content": ""
            },
            {
                "subchapter_title": "9.8\u2003Minimal\tSpanning\tTree",
                "content": ""
            },
            {
                "subchapter_title": "9.9\u2003Graph\tAlgorithms:\tProblems\t&\tSolutions",
                "content": ""
            }
        ]
    },
    {
        "chapter_title": "10.\t\tSorting",
        "subchapters": [
            {
                "subchapter_title": "10.1\u2003What\tis\tSorting?",
                "content": ""
            },
            {
                "subchapter_title": "10.2\u2003Why\tis\tSorting\tNecessary?",
                "content": ""
            },
            {
                "subchapter_title": "10.3\u2003Classification\tof\tSorting\tAlgorithms",
                "content": ""
            },
            {
                "subchapter_title": "10.4\u2003Other\tClassifications",
                "content": ""
            },
            {
                "subchapter_title": "10.5\u2003Bubble\tSort",
                "content": ""
            },
            {
                "subchapter_title": "10.6\u2003Selection\tSort",
                "content": ""
            },
            {
                "subchapter_title": "10.7\u2003Insertion\tSort",
                "content": ""
            },
            {
                "subchapter_title": "10.8\u2003Shell\tSort",
                "content": ""
            },
            {
                "subchapter_title": "10.9\u2003Merge\tSort",
                "content": ""
            },
            {
                "subchapter_title": "10.10\u2002Heap\tSort",
                "content": ""
            },
            {
                "subchapter_title": "10.11\u2002Quick\tSort",
                "content": ""
            },
            {
                "subchapter_title": "10.12\u2002Tree\tSort",
                "content": ""
            },
            {
                "subchapter_title": "10.13\u2002Comparison\tof\tSorting\tAlgorithms",
                "content": ""
            },
            {
                "subchapter_title": "10.14\u2002Linear\tSorting\tAlgorithms",
                "content": ""
            },
            {
                "subchapter_title": "10.15\u2002Counting\tSort",
                "content": ""
            },
            {
                "subchapter_title": "10.16\u2002Bucket\tSort\t(or\tBin\tSort)",
                "content": ""
            },
            {
                "subchapter_title": "10.17\u2002Radix\tSort",
                "content": ""
            },
            {
                "subchapter_title": "10.18\u2002Topological\tSort",
                "content": ""
            },
            {
                "subchapter_title": "10.19\u2002External\tSorting",
                "content": ""
            },
            {
                "subchapter_title": "10.20\u2002Sorting:\tProblems\t&\tSolutions",
                "content": ""
            }
        ]
    },
    {
        "chapter_title": "11.\t\tSearching",
        "subchapters": [
            {
                "subchapter_title": "11.1\u2003What\tis\tSearching?",
                "content": ""
            },
            {
                "subchapter_title": "11.2\u2003Why\tdo\twe\tneed\tSearching?",
                "content": ""
            },
            {
                "subchapter_title": "11.3\u2003Types\tof\tSearching",
                "content": ""
            },
            {
                "subchapter_title": "11.4\u2003Unordered\tLinear\tSearch",
                "content": ""
            },
            {
                "subchapter_title": "11.5\u2003Sorted/Ordered\tLinear\tSearch",
                "content": ""
            },
            {
                "subchapter_title": "11.6\u2003Binary\tSearch",
                "content": ""
            },
            {
                "subchapter_title": "11.7\u2003Interpolation\tSearch",
                "content": ""
            },
            {
                "subchapter_title": "11.8\u2003Comparing\tBasic\tSearching\tAlgorithms",
                "content": ""
            },
            {
                "subchapter_title": "11.9\u2003Symbol\tTables\tand\tHashing",
                "content": ""
            },
            {
                "subchapter_title": "11.10\u2002String\tSearching\tAlgorithms",
                "content": ""
            },
            {
                "subchapter_title": "11.11\u2002Searching:\tProblems\t&\tSolutions",
                "content": ""
            }
        ]
    },
    {
        "chapter_title": "12.\t\tSelection\tAlgorithms\t[Medians]",
        "subchapters": [
            {
                "subchapter_title": "12.1\u2003What\tare\tSelection\tAlgorithms?",
                "content": ""
            },
            {
                "subchapter_title": "12.2\u2003Selection\tby\tSorting",
                "content": ""
            },
            {
                "subchapter_title": "12.3\u2003Partition-based\tSelection\tAlgorithm",
                "content": ""
            },
            {
                "subchapter_title": "12.4\u2003Linear\tSelection\tAlgorithm\t-\tMedian\tof\tMedians\tAlgorithm",
                "content": ""
            },
            {
                "subchapter_title": "12.5\u2003Finding\tthe\tK\tSmallest\tElements\tin\tSorted\tOrder",
                "content": ""
            },
            {
                "subchapter_title": "12.6\u2003Selection\tAlgorithms:\tProblems\t&\tSolutions",
                "content": ""
            }
        ]
    },
    {
        "chapter_title": "13.\t\tSymbol\tTables",
        "subchapters": [
            {
                "subchapter_title": "13.1\u2003Introduction",
                "content": ""
            },
            {
                "subchapter_title": "13.2\u2003What\tare\tSymbol\tTables?",
                "content": ""
            },
            {
                "subchapter_title": "13.3\u2003Symbol\tTable\tImplementations",
                "content": ""
            },
            {
                "subchapter_title": "13.4\u2003Comparison\tTable\tof\tSymbols\tfor\tImplementations",
                "content": ""
            }
        ]
    },
    {
        "chapter_title": "14.\t\tHashing",
        "subchapters": [
            {
                "subchapter_title": "14.1\u2003What\tis\tHashing?",
                "content": ""
            },
            {
                "subchapter_title": "14.2\u2003Why\tHashing?",
                "content": ""
            },
            {
                "subchapter_title": "14.3\u2003HashTable\tADT",
                "content": ""
            },
            {
                "subchapter_title": "14.4\u2003Understanding\tHashing",
                "content": ""
            },
            {
                "subchapter_title": "14.5\u2003Components\tof\tHashing",
                "content": ""
            },
            {
                "subchapter_title": "14.6\u2003Hash\tTable",
                "content": ""
            },
            {
                "subchapter_title": "14.7\u2003Hash\tFunction",
                "content": ""
            },
            {
                "subchapter_title": "14.8\u2003Load\tFactor",
                "content": ""
            },
            {
                "subchapter_title": "14.9\u2003Collisions",
                "content": ""
            },
            {
                "subchapter_title": "14.10\u2002Collision\tResolution\tTechniques",
                "content": ""
            },
            {
                "subchapter_title": "14.11\u2002Separate\tChaining",
                "content": ""
            },
            {
                "subchapter_title": "14.12\u2002Open\tAddressing",
                "content": ""
            },
            {
                "subchapter_title": "14.13\u2002Comparison\tof\tCollision\tResolution\tTechniques",
                "content": ""
            },
            {
                "subchapter_title": "14.14\u2002How\tHashing\tGets\tO(1)\tComplexity?",
                "content": ""
            },
            {
                "subchapter_title": "14.15\u2002Hashing\tTechniques",
                "content": ""
            },
            {
                "subchapter_title": "14.16\u2002Problems\tfor\twhich\tHash\tTables\tare\tnot\tsuitable",
                "content": ""
            },
            {
                "subchapter_title": "14.17\u2002Bloom\tFilters",
                "content": ""
            },
            {
                "subchapter_title": "14.18\u2002Hashing:\tProblems\t&\tSolutions",
                "content": ""
            }
        ]
    },
    {
        "chapter_title": "15.\t\tString\tAlgorithms",
        "subchapters": [
            {
                "subchapter_title": "15.1\u2003Introduction",
                "content": ""
            },
            {
                "subchapter_title": "15.2\u2003String\tMatching\tAlgorithms",
                "content": ""
            },
            {
                "subchapter_title": "15.3\u2003Brute\tForce\tMethod",
                "content": ""
            },
            {
                "subchapter_title": "15.4\u2003Rabin-Karp\tString\tMatching\tAlgorithm",
                "content": ""
            },
            {
                "subchapter_title": "15.5\u2003String\tMatching\twith\tFinite\tAutomata",
                "content": ""
            },
            {
                "subchapter_title": "15.6\u2003KMP\tAlgorithm",
                "content": ""
            },
            {
                "subchapter_title": "15.7\u2003Boyer-Moore\tAlgorithm",
                "content": ""
            },
            {
                "subchapter_title": "15.8\u2003Data\tStructures\tfor\tStoring\tStrings",
                "content": ""
            },
            {
                "subchapter_title": "15.9\u2003Hash\tTables\tfor\tStrings",
                "content": ""
            },
            {
                "subchapter_title": "15.10\u2002Binary\tSearch\tTrees\tfor\tStrings",
                "content": ""
            },
            {
                "subchapter_title": "15.11\u2002Tries",
                "content": ""
            },
            {
                "subchapter_title": "15.12\u2002Ternary\tSearch\tTrees",
                "content": ""
            },
            {
                "subchapter_title": "15.13\u2002Comparing\tBSTs,\tTries\tand\tTSTs",
                "content": ""
            },
            {
                "subchapter_title": "15.14\u2002Suffix\tTrees",
                "content": ""
            },
            {
                "subchapter_title": "15.15\u2002String\tAlgorithms:\tProblems\t&\tSolutions",
                "content": ""
            }
        ]
    },
    {
        "chapter_title": "16.\t\tAlgorithms\tDesign\tTechniques",
        "subchapters": [
            {
                "subchapter_title": "16.1\u2003Introduction",
                "content": ""
            },
            {
                "subchapter_title": "16.2\u2003Classification",
                "content": ""
            },
            {
                "subchapter_title": "16.3\u2003Classification\tby\tImplementation\tMethod",
                "content": ""
            },
            {
                "subchapter_title": "16.4\u2003Classification\tby\tDesign\tMethod",
                "content": ""
            },
            {
                "subchapter_title": "16.5\u2003Other\tClassifications",
                "content": ""
            }
        ]
    },
    {
        "chapter_title": "17.\t\tGreedy\tAlgorithms",
        "subchapters": [
            {
                "subchapter_title": "17.1\u2003Introduction",
                "content": ""
            },
            {
                "subchapter_title": "17.2\u2003Greedy\tStrategy",
                "content": ""
            },
            {
                "subchapter_title": "17.3\u2003Elements\tof\tGreedy\tAlgorithms",
                "content": ""
            },
            {
                "subchapter_title": "17.4\u2003Does\tGreedy\tAlways\tWork?",
                "content": ""
            },
            {
                "subchapter_title": "17.5\u2003Advantages\tand\tDisadvantages\tof\tGreedy\tMethod",
                "content": ""
            },
            {
                "subchapter_title": "17.6\u2003Greedy\tApplications",
                "content": ""
            },
            {
                "subchapter_title": "17.7\u2003Understanding\tGreedy\tTechnique",
                "content": ""
            },
            {
                "subchapter_title": "17.8\u2003Greedy\tAlgorithms:\tProblems\t&\tSolutions",
                "content": ""
            }
        ]
    },
    {
        "chapter_title": "18.\t\tDivide\tand\tConquer\tAlgorithms",
        "subchapters": [
            {
                "subchapter_title": "18.1\u2003Introduction",
                "content": ""
            },
            {
                "subchapter_title": "18.2\u2003What\tis\tthe\tDivide\tand\tConquer\tStrategy?",
                "content": ""
            },
            {
                "subchapter_title": "18.3\u2003Does\tDivide\tand\tConquer\tAlways\tWork?",
                "content": ""
            },
            {
                "subchapter_title": "18.4\u2003Divide\tand\tConquer\tVisualization",
                "content": ""
            },
            {
                "subchapter_title": "18.5\u2003Understanding\tDivide\tand\tConquer",
                "content": ""
            },
            {
                "subchapter_title": "18.6\u2003Advantages\tof\tDivide\tand\tConquer",
                "content": ""
            },
            {
                "subchapter_title": "18.7\u2003Disadvantages\tof\tDivide\tand\tConquer",
                "content": ""
            },
            {
                "subchapter_title": "18.8\u2003Master\tTheorem",
                "content": ""
            },
            {
                "subchapter_title": "18.9\u2003Divide\tand\tConquer\tApplications",
                "content": ""
            },
            {
                "subchapter_title": "18.10\u2002Divide\tand\tConquer:\tProblems\t&\tSolutions",
                "content": ""
            }
        ]
    },
    {
        "chapter_title": "19.\t\tDynamic\tProgramming",
        "subchapters": [
            {
                "subchapter_title": "19.1\u2003Introduction",
                "content": ""
            },
            {
                "subchapter_title": "19.2\u2003What\tis\tDynamic\tProgramming\tStrategy?",
                "content": ""
            },
            {
                "subchapter_title": "19.3\u2003Properties\tof\tDynamic\tProgramming\tStrategy",
                "content": ""
            },
            {
                "subchapter_title": "19.4\u2003Can\tDynamic\tProgramming\tSolve\tAll\tProblems?",
                "content": ""
            },
            {
                "subchapter_title": "19.5\u2003Dynamic\tProgramming\tApproaches",
                "content": ""
            },
            {
                "subchapter_title": "19.6\u2003Examples\tof\tDynamic\tProgramming\tAlgorithms",
                "content": ""
            },
            {
                "subchapter_title": "19.7\u2003Understanding\tDynamic\tProgramming",
                "content": ""
            },
            {
                "subchapter_title": "19.8\u2003Longest\tCommon\tSubsequence",
                "content": ""
            },
            {
                "subchapter_title": "19.9\u2003Dynamic\tProgramming:\tProblems\t&\tSolutions",
                "content": ""
            }
        ]
    },
    {
        "chapter_title": "20.\t\tComplexity\tClasses",
        "subchapters": [
            {
                "subchapter_title": "20.1\u2003Introduction",
                "content": ""
            },
            {
                "subchapter_title": "20.2\u2003Polynomial/Exponential\tTime",
                "content": ""
            },
            {
                "subchapter_title": "20.3\u2003What\tis\ta\tDecision\tProblem?",
                "content": ""
            },
            {
                "subchapter_title": "20.4\u2003Decision\tProcedure",
                "content": ""
            },
            {
                "subchapter_title": "20.5\u2003What\tis\ta\tComplexity\tClass?",
                "content": ""
            },
            {
                "subchapter_title": "20.6\u2003Types\tof\tComplexity\tClasses",
                "content": ""
            },
            {
                "subchapter_title": "20.7\u2003Reductions",
                "content": ""
            },
            {
                "subchapter_title": "20.8\u2003Complexity\tClasses:\tProblems\t&\tSolutions",
                "content": ""
            }
        ]
    },
    {
        "chapter_title": "21.\t\tMiscellaneous\tConcepts",
        "subchapters": [
            {
                "subchapter_title": "21.1\u2003Introduction",
                "content": ""
            },
            {
                "subchapter_title": "21.2\u2003Hacks\ton\tBit-wise\tProgramming",
                "content": ""
            },
            {
                "subchapter_title": "21.3\u2003Other\tProgramming\tQuestions",
                "content": "References The\t objective\t of\t this\t chapter\t is\t to\t explain\t the\t importance\t of\t the\t analysis\t of\t algorithms,\t their notations,\t relationships\t and\t solving\t as\t many\t problems\t as\t possible.\t Let\t us\t first\t focus\t on understanding\tthe\tbasic\telements\tof\talgorithms,\tthe\timportance\tof\talgorithm\tanalysis,\tand\tthen slowly\t move\t toward\t the\t other\t topics\t as\t mentioned\t above.\t After\t completing\t this\t chapter,\t you should\tbe\table\tto\tfind\tthe\tcomplexity\tof\tany\tgiven\talgorithm\t(especially\trecursive\tfunctions)."
            },
            {
                "subchapter_title": "1.1\tVariables",
                "content": "Before\tgoing\tto\tthe\tdefinition\tof\tvariables,\tlet\tus\trelate\tthem\tto\told\tmathematical\tequations.\tAll\tof us\thave\tsolved\tmany\tmathematical\tequations\tsince\tchildhood.\tAs\tan\texample,\tconsider\tthe\tbelow equation: We\t don\u2019t\t have\t to\t worry\t about\t the\t use\t of\t this\t equation.\t The\t important\t thing\t that\t we\t need\t to understand\tis\tthat\tthe\tequation\thas\tnames\t(x\tand\ty),\twhich\thold\tvalues\t(data).\tThat\tmeans\tthe names\t (x\t and\t y)\t are\t placeholders\t for\t representing\t data.\t Similarly,\t in\t computer\t science programming\twe\tneed\tsomething\tfor\tholding\tdata,\tand\tvariables\tis\tthe\tway\tto\tdo\tthat."
            },
            {
                "subchapter_title": "1.2\tData\tTypes",
                "content": "In\t the\t above-mentioned\t equation,\t the\t variables\t x\t and\t y\t can\t take\t any\t values\t such\t as\t integral numbers\t(10,\t20),\treal\tnumbers\t(0.23,\t5.5),\tor\tjust\t0\tand\t1.\tTo\tsolve\tthe\tequation,\twe\tneed\tto relate\tthem\tto\tthe\tkind\tof\tvalues\tthey\tcan\ttake,\tand\tdata\ttype\tis\tthe\tname\tused\tin\tcomputer\tscience programming\t for\t this\t purpose.\t A\t data\t type\t in\t a\t programming\t language\t is\t a\t set\t of\t data\t with predefined\t values.\t Examples\t of\t data\t types\t are:\t integer,\t floating\t point,\t unit\t number,\t character, string,\tetc. Computer\tmemory\tis\tall\tfilled\twith\tzeros\tand\tones.\tIf\twe\thave\ta\tproblem\tand\twe\twant\tto\tcode\tit, it\u2019s\tvery\tdifficult\tto\tprovide\tthe\tsolution\tin\tterms\tof\tzeros\tand\tones.\tTo\thelp\tusers,\tprogramming languages\tand\tcompilers\tprovide\tus\twith\tdata\ttypes.\tFor\texample,\tinteger\ttakes\t2\tbytes\t(actual value\tdepends\ton\tcompiler),\tfloat\ttakes\t4\tbytes,\tetc.\tThis\tsays\tthat\tin\tmemory\twe\tare\tcombining 2\tbytes\t(16\tbits)\tand\tcalling\tit\tan\tinteger.\tSimilarly,\tcombining\t4\tbytes\t(32\tbits)\tand\tcalling\tit\ta float.\tA\tdata\ttype\treduces\tthe\tcoding\teffort.\tAt\tthe\ttop\tlevel,\tthere\tare\ttwo\ttypes\tof\tdata\ttypes: \u2022 System-defined\tdata\ttypes\t(also\tcalled\tPrimitive\tdata\ttypes) \u2022 User-defined\tdata\ttypes System-defined\tdata\ttypes\t(Primitive\tdata\ttypes) Data\ttypes\tthat\tare\tdefined\tby\tsystem\tare\tcalled\tprimitive\tdata\ttypes.\tThe\tprimitive\tdata\ttypes provided\tby\tmany\tprogramming\tlanguages\tare:\tint,\tfloat,\tchar,\tdouble,\tbool,\tetc.\tThe\tnumber\tof bits\tallocated\tfor\teach\tprimitive\tdata\ttype\tdepends\ton\tthe\tprogramming\tlanguages,\tthe\tcompiler and\tthe\toperating\tsystem.\tFor\tthe\tsame\tprimitive\tdata\ttype,\tdifferent\tlanguages\tmay\tuse\tdifferent sizes.\t Depending\t on\t the\t size\t of\t the\t data\t types,\t the\t total\t available\t values\t (domain)\t will\t also change. For\texample,\t\u201cint\u201d\tmay\ttake\t2\tbytes\tor\t4\tbytes.\tIf\tit\ttakes\t2\tbytes\t(16\tbits),\tthen\tthe\ttotal\tpossible values\t are\t minus\t 32,768\t to\t plus\t 32,767\t (-215\t to\t 215-1).\t If\t it\t takes\t 4\t bytes\t (32\t bits),\t then\t the possible\tvalues\tare\tbetween\t-2,147,483,648\tand\t+2,147,483,647\t(-231\tto\t231-1).\tThe\tsame\tis\tthe case\twith\tother\tdata\ttypes. User\tdefined\tdata\ttypes If\tthe\tsystem-defined\tdata\ttypes\tare\tnot\tenough,\tthen\tmost\tprogramming\tlanguages\tallow\tthe\tusers to\tdefine\ttheir\town\tdata\ttypes,\tcalled\tuser\t\u2013\tdefined\tdata\ttypes.\tGood\texamples\tof\tuser\tdefined data\ttypes\tare:\tstructures\tin\tC/C\t+\t+\tand\tclasses\tin\tJava.\tFor\texample,\tin\tthe\tsnippet\tbelow,\twe are\tcombining\tmany\tsystem-defined\tdata\ttypes\tand\tcalling\tthe\tuser\tdefined\tdata\ttype\tby\tthe\tname \u201cnewType\u201d.\tThis\tgives\tmore\tflexibility\tand\tcomfort\tin\tdealing\twith\tcomputer\tmemory."
            },
            {
                "subchapter_title": "1.3\tData\tStructures",
                "content": "Based\ton\tthe\tdiscussion\tabove,\tonce\twe\thave\tdata\tin\tvariables,\twe\tneed\tsome\tmechanism\tfor manipulating\t that\t data\t to\t solve\t problems.\t Data\t structure\t is\t a\t particular\t way\t of\t storing\t and organizing\tdata\tin\ta\tcomputer\tso\tthat\tit\tcan\tbe\tused\tefficiently.\tA\tdata\t structure\t is\t a\t special format\tfor\torganizing\tand\tstoring\tdata.\tGeneral\tdata\tstructure\ttypes\tinclude\tarrays,\tfiles,\tlinked lists,\tstacks,\tqueues,\ttrees,\tgraphs\tand\tso\ton. Depending\ton\tthe\torganization\tof\tthe\telements,\tdata\tstructures\tare\tclassified\tinto\ttwo\ttypes: 1) Linear\t data\t structures:\t Elements\t are\t accessed\t in\t a\t sequential\t order\t but\t it\t is\t not compulsory\tto\tstore\tall\telements\tsequentially.\tExamples:\tLinked\tLists,\tStacks\tand Queues. 2) Non\t\u2013\tlinear\tdata\tstructures:\tElements\tof\tthis\tdata\tstructure\tare\tstored/accessed\tin\ta non-linear\torder.\tExamples:\tTrees\tand\tgraphs."
            },
            {
                "subchapter_title": "1.4\tAbstract\tData\tTypes\t(ADTs)",
                "content": "Before\t defining\t abstract\t data\t types,\t let\t us\t consider\t the\t different\t view\t of\t system-defined\t data types.\t We\t all\t know\t that,\t by\t default,\t all\t primitive\t data\t types\t (int,\t float,\t etc.)\t support\t basic operations\t such\t as\t addition\t and\t subtraction.\t The\t system\t provides\t the\t implementations\t for\t the primitive\t data\t types.\t For\t user-defined\t data\t types\t we\t also\t need\t to\t define\t operations.\t The implementation\tfor\tthese\toperations\tcan\tbe\tdone\twhen\twe\twant\tto\tactually\tuse\tthem.\tThat\tmeans, in\tgeneral,\tuser\tdefined\tdata\ttypes\tare\tdefined\talong\twith\ttheir\toperations. To\tsimplify\tthe\tprocess\tof\tsolving\tproblems,\twe\tcombine\tthe\tdata\tstructures\twith\ttheir\toperations and\twe\tcall\tthis\tAbstract\tData\tTypes\t(ADTs).\tAn\tADT\tconsists\tof\ttwo\tparts:"
            }
        ]
    },
    {
        "chapter_title": "1.",
        "subchapters": [
            {
                "subchapter_title": "Declaration\tof\tdata",
                "content": ""
            }
        ]
    },
    {
        "chapter_title": "2.",
        "subchapters": [
            {
                "subchapter_title": "Declaration\tof\toperations",
                "content": "Commonly\t used\t ADTs\t include:\t Linked\t Lists,\t Stacks,\t Queues,\t Priority\t Queues,\t Binary\t Trees, Dictionaries,\t Disjoint\t Sets\t (Union\t and\t Find),\t Hash\t Tables,\t Graphs,\t and\t many\t others.\t For example,\tstack\tuses\tLIFO\t(Last-In-First-Out)\tmechanism\twhile\tstoring\tthe\tdata\tin\tdata\tstructures. The\tlast\telement\tinserted\tinto\tthe\tstack\tis\tthe\tfirst\telement\tthat\tgets\tdeleted.\tCommon\toperations of\tit\tare:\tcreating\tthe\tstack,\tpushing\tan\telement\tonto\tthe\tstack,\tpopping\tan\telement\tfrom\tstack, finding\tthe\tcurrent\ttop\tof\tthe\tstack,\tfinding\tnumber\tof\telements\tin\tthe\tstack,\tetc. While\t defining\t the\t ADTs\t do\t not\t worry\t about\t the\t implementation\t details.\t They\t come\t into\t the picture\tonly\twhen\twe\twant\tto\tuse\tthem.\tDifferent\tkinds\tof\tADTs\tare\tsuited\tto\tdifferent\tkinds\tof applications,\tand\tsome\tare\thighly\tspecialized\tto\tspecific\ttasks.\tBy\tthe\tend\tof\tthis\tbook,\twe\twill go\tthrough\tmany\tof\tthem\tand\tyou\twill\tbe\tin\ta\tposition\tto\trelate\tthe\tdata\tstructures\tto\tthe\tkind\tof problems\tthey\tsolve."
            },
            {
                "subchapter_title": "1.5\tWhat\tis\tan\tAlgorithm?",
                "content": "Let\tus\tconsider\tthe\tproblem\tof\tpreparing\tan\tomelette.\tTo\tprepare\tan\tomelette,\twe\tfollow\tthe steps\tgiven\tbelow: 1) Get\tthe\tfrying\tpan. 2) Get\tthe\toil. a. Do\twe\thave\toil? \t\ti.\tIf\tyes,\tput\tit\tin\tthe\tpan. ii.\tIf\tno,\tdo\twe\twant\tto\tbuy\toil?"
            }
        ]
    },
    {
        "chapter_title": "1. If\tyes,\tthen\tgo\tout\tand\tbuy.",
        "subchapters": [
            {
                "subchapter_title": "",
                "content": ""
            }
        ]
    },
    {
        "chapter_title": "2. If\tno,\twe\tcan\tterminate.",
        "subchapters": [
            {
                "subchapter_title": "3)",
                "content": "Turn\ton\tthe\tstove,\tetc... What\twe\tare\tdoing\tis,\tfor\ta\tgiven\tproblem\t(preparing\tan\tomelette),\twe\tare\tproviding\ta\tstep-by- step\tprocedure\tfor\tsolving\tit.\tThe\tformal\tdefinition\tof\tan\talgorithm\tcan\tbe\tstated\tas: An\talgorithm\tis\tthe\tstep-by-step\tunambiguous\tinstructions\tto\tsolve\ta\tgiven\tproblem. In\t the\t traditional\t study\t of\t algorithms,\t there\t are\t two\t main\t criteria\t for\t judging\t the\t merits\t of algorithms:\tcorrectness\t(does\tthe\talgorithm\tgive\tsolution\tto\tthe\tproblem\tin\ta\tfinite\tnumber\tof steps?)\tand\tefficiency\t(how\tmuch\tresources\t(in\tterms\tof\tmemory\tand\ttime)\tdoes\tit\ttake\tto\texecute the). Note:\tWe\tdo\tnot\thave\tto\tprove\teach\tstep\tof\tthe\talgorithm."
            },
            {
                "subchapter_title": "1.6\tWhy\tthe\tAnalysis\tof\tAlgorithms?",
                "content": "To\tgo\tfrom\tcity\t\u201cA\u201d\tto\tcity\t\u201cB\u201d,\tthere\tcan\tbe\tmany\tways\tof\taccomplishing\tthis:\tby\tflight,\tby\tbus, by\ttrain\tand\talso\tby\tbicycle.\tDepending\ton\tthe\tavailability\tand\tconvenience,\twe\tchoose\tthe\tone that\t suits\t us.\t Similarly,\t in\t computer\t science,\t multiple\t algorithms\t are\t available\t for\t solving\t the same\tproblem\t(for\texample,\ta\tsorting\tproblem\thas\tmany\talgorithms,\tlike\tinsertion\tsort,\tselection sort,\tquick\tsort\tand\tmany\tmore).\tAlgorithm\tanalysis\thelps\tus\tto\tdetermine\twhich\talgorithm\tis most\tefficient\tin\tterms\tof\ttime\tand\tspace\tconsumed."
            },
            {
                "subchapter_title": "1.7\tGoal\tof\tthe\tAnalysis\tof\tAlgorithms",
                "content": "The\tgoal\tof\tthe\tanalysis\tof\talgorithms\tis\tto\tcompare\talgorithms\t(or\tsolutions)\tmainly\tin\tterms\tof running\ttime\tbut\talso\tin\tterms\tof\tother\tfactors\t(e.g.,\tmemory,\tdeveloper\teffort,\tetc.)"
            },
            {
                "subchapter_title": "1.8\tWhat\tis\tRunning\tTime\tAnalysis?",
                "content": "It\tis\tthe\tprocess\tof\tdetermining\thow\tprocessing\ttime\tincreases\tas\tthe\tsize\tof\tthe\tproblem\t(input size)\tincreases.\tInput\tsize\tis\tthe\tnumber\tof\telements\tin\tthe\tinput,\tand\tdepending\ton\tthe\tproblem type,\tthe\tinput\tmay\tbe\tof\tdifferent\ttypes.\tThe\tfollowing\tare\tthe\tcommon\ttypes\tof\tinputs. \u2022 Size\tof\tan\tarray \u2022 Polynomial\tdegree \u2022 Number\tof\telements\tin\ta\tmatrix \u2022 Number\tof\tbits\tin\tthe\tbinary\trepresentation\tof\tthe\tinput \u2022 Vertices\tand\tedges\tin\ta\tgraph."
            },
            {
                "subchapter_title": "1.9\tHow\tto\tCompare\tAlgorithms",
                "content": "To\tcompare\talgorithms,\tlet\tus\tdefine\ta\tfew\tobjective\tmeasures: Execution\ttimes?\tNot\ta\tgood\tmeasure\tas\texecution\ttimes\tare\tspecific\tto\ta\tparticular\tcomputer. Number\tof\tstatements\texecuted?\tNot\ta\tgood\tmeasure,\tsince\tthe\tnumber\tof\tstatements\tvaries with\tthe\tprogramming\tlanguage\tas\twell\tas\tthe\tstyle\tof\tthe\tindividual\tprogrammer. Ideal\tsolution?\tLet\tus\tassume\tthat\twe\texpress\tthe\trunning\ttime\tof\ta\tgiven\talgorithm\tas\ta\tfunction of\t the\t input\t size\t n\t (i.e.,\t f(n))\t and\t compare\t these\t different\t functions\t corresponding\t to\t running times.\tThis\tkind\tof\tcomparison\tis\tindependent\tof\tmachine\ttime,\tprogramming\tstyle,\tetc."
            },
            {
                "subchapter_title": "1.10\tWhat\tis\tRate\tof\tGrowth?",
                "content": "The\trate\tat\twhich\tthe\trunning\ttime\tincreases\tas\ta\tfunction\tof\tinput\tis\tcalled\trate\tof\tgrowth.\tLet\tus assume\tthat\tyou\tgo\tto\ta\tshop\tto\tbuy\ta\tcar\tand\ta\tbicycle.\tIf\tyour\tfriend\tsees\tyou\tthere\tand\tasks what\tyou\tare\tbuying,\tthen\tin\tgeneral\tyou\tsay\tbuying\ta\tcar.\tThis\tis\tbecause\tthe\tcost\tof\tthe\tcar\tis high\tcompared\tto\tthe\tcost\tof\tthe\tbicycle\t(approximating\tthe\tcost\tof\tthe\tbicycle\tto\tthe\tcost\tof\tthe car). For\tthe\tabove-mentioned\texample,\twe\tcan\trepresent\tthe\tcost\tof\tthe\tcar\tand\tthe\tcost\tof\tthe\tbicycle in\t terms\t of\t function,\t and\t for\t a\t given\t function\t ignore\t the\t low\t order\t terms\t that\t are\t relatively insignificant\t(for\tlarge\tvalue\tof\tinput\tsize,\tn).\tAs\tan\texample,\tin\tthe\tcase\tbelow,\tn4,\t2n2,\t100n and\t500\tare\tthe\tindividual\tcosts\tof\tsome\tfunction\tand\tapproximate\tto\tn4\tsince\tn4\tis\tthe\thighest rate\tof\tgrowth."
            },
            {
                "subchapter_title": "1.11\tCommonly\tUsed\tRates\tof\tGrowth",
                "content": "The\tdiagram\tbelow\tshows\tthe\trelationship\tbetween\tdifferent\trates\tof\tgrowth. Below\tis\tthe\tlist\tof\tgrowth\trates\tyou\twill\tcome\tacross\tin\tthe\tfollowing\tchapters."
            },
            {
                "subchapter_title": "1.12\tTypes\tof\tAnalysis",
                "content": "To\tanalyze\tthe\tgiven\talgorithm,\twe\tneed\tto\tknow\twith\twhich\tinputs\tthe\talgorithm\ttakes\tless\ttime (performing\twel1)\tand\twith\twhich\tinputs\tthe\talgorithm\ttakes\ta\tlong\ttime.\tWe\thave\talready\tseen that\tan\talgorithm\tcan\tbe\trepresented\tin\tthe\tform\tof\tan\texpression.\tThat\tmeans\twe\trepresent\tthe algorithm\twith\tmultiple\texpressions:\tone\tfor\tthe\tcase\twhere\tit\ttakes\tless\ttime\tand\tanother\tfor\tthe case\twhere\tit\ttakes\tmore\ttime. In\tgeneral,\tthe\tfirst\tcase\tis\tcalled\tthe\tbest\tcase\tand\tthe\tsecond\tcase\tis\tcalled\tthe\tworst\tcase\tfor the\talgorithm.\tTo\tanalyze\tan\talgorithm\twe\tneed\tsome\tkind\tof\tsyntax,\tand\tthat\tforms\tthe\tbase\tfor asymptotic\tanalysis/notation.\tThere\tare\tthree\ttypes\tof\tanalysis: \u2022 Worst\tcase \u25cb Defines\tthe\tinput\tfor\twhich\tthe\talgorithm\ttakes\ta\tlong\ttime\t(slowest time\tto\tcomplete). \u25cb Input\tis\tthe\tone\tfor\twhich\tthe\talgorithm\truns\tthe\tslowest. \u2022 Best\tcase \u25cb Defines\tthe\tinput\tfor\twhich\tthe\talgorithm\ttakes\tthe\tleast\ttime\t(fastest time\tto\tcomplete). \u25cb Input\tis\tthe\tone\tfor\twhich\tthe\talgorithm\truns\tthe\tfastest. \u2022 Average\tcase \u25cb Provides\ta\tprediction\tabout\tthe\trunning\ttime\tof\tthe\talgorithm. \u25cb Run\t the\t algorithm\t many\t times,\tusing\t many\t different\t inputs\t that\t come from\tsome\tdistribution\tthat\tgenerates\tthese\tinputs,\tcompute\tthe\ttotal running\t time\t (by\t adding\t the\t individual\t times),\t and\t divide\t by\t the number\tof\ttrials. \u25cb Assumes\tthat\tthe\tinput\tis\trandom. Lower\tBound\t<=\tAverage\tTime\t<=\tUpper\tBound For\t a\t given\t algorithm,\t we\t can\t represent\t the\t best,\t worst\t and\t average\t cases\t in\t the\t form\t of expressions.\tAs\tan\texample,\tlet\tf(n)\tbe\tthe\tfunction\twhich\trepresents\tthe\tgiven\talgorithm. Similarly\tfor\tthe\taverage\tcase.\tThe\texpression\tdefines\tthe\tinputs\twith\twhich\tthe\talgorithm\ttakes the\taverage\trunning\ttime\t(or\tmemory)."
            },
            {
                "subchapter_title": "1.13\tAsymptotic\tNotation",
                "content": "Having\t the\t expressions\t for\t the\t best,\t average\t and\t worst\t cases,\t for\t all\t three\t cases\t we\t need\t to identify\tthe\tupper\tand\tlower\tbounds.\tTo\trepresent\tthese\tupper\tand\tlower\tbounds,\twe\tneed\tsome kind\tof\tsyntax,\tand\tthat\tis\tthe\tsubject\tof\tthe\tfollowing\tdiscussion.\tLet\tus\tassume\tthat\tthe\tgiven algorithm\tis\trepresented\tin\tthe\tform\tof\tfunction\tf(n)."
            },
            {
                "subchapter_title": "1.14\tBig-O\tNotation\t[Upper\tBounding\tFunction]",
                "content": "This\tnotation\tgives\tthe\ttight\tupper\tbound\tof\tthe\tgiven\tfunction.\tGenerally,\tit\tis\trepresented\tas\tf(n) =\tO(g(n)).\tThat\tmeans,\tat\tlarger\tvalues\tof\tn,\tthe\tupper\tbound\tof\tf(n)\tis\tg(n).\tFor\texample,\tif\tf(n) =\t n4\t +\t100n2\t +\t 10n\t +\t 50\t is\t the\t given\t algorithm,\t then\t n4\t is\t g(n).\t That\t means\t g(n)\t gives\t the maximum\trate\tof\tgrowth\tfor\tf(n)\tat\tlarger\tvalues\tof\tn. Let\tus\tsee\tthe\tO\u2013notation\twith\ta\tlittle\tmore\tdetail.\tO\u2013notation\tdefined\tas\tO(g(n))\t=\t{f(n):\tthere exist\tpositive\tconstants\tc\tand\tn0\tsuch\tthat\t0\t\u2264\tf(n)\t\u2264\tcg(n)\tfor\tall\tn\t>\tn0}.\tg(n)\tis\tan\tasymptotic tight\tupper\tbound\tfor\tf(n).\tOur\t objective\t is\t to\t give\t the\t smallest\trate\t of\tgrowth\tg(n)\t which\t is greater\tthan\tor\tequal\tto\tthe\tgiven\talgorithms\u2019\trate\tof\tgrowth\t/(n). Generally\twe\tdiscard\tlower\tvalues\tof\tn.\tThat\tmeans\tthe\trate\tof\tgrowth\tat\tlower\tvalues\tof\tn\tis\tnot important.\tIn\tthe\tfigure,\tn0\tis\tthe\tpoint\tfrom\twhich\twe\tneed\tto\tconsider\tthe\trate\tof\tgrowth\tfor\ta given\talgorithm.\tBelow\tn0,\tthe\trate\tof\tgrowth\tcould\tbe\tdifferent.\tn0\tis\tcalled\tthreshold\tfor\tthe given\tfunction. Big-O\tVisualization O(g(n))\tis\tthe\tset\tof\tfunctions\twith\tsmaller\tor\tthe\tsame\torder\tof\tgrowth\tas\tg(n).\tFor\texample; O(n2)\tincludes\tO(1),\tO(n),\tO(nlogn),\tetc. Note:\tAnalyze\tthe\talgorithms\tat\tlarger\tvalues\tof\tn\tonly.\tWhat\tthis\tmeans\tis,\tbelow\tn0\twe\tdo\tnot care\tabout\tthe\trate\tof\tgrowth. Big-O\tExamples Example-1\tFind\tupper\tbound\tfor\tf(n)\t=\t3n\t+\t8 Solution:\t3n\t+\t8\t\u2264\t4n,\tfor\tall\tn\t\u2265\t8 \u2234\t3n\t+\t8\t=\tO(n)\twith\tc\t=\t4\tand\tn0\t=\t8 Example-2\tFind\tupper\tbound\tfor\tf(n)\t=\tn2\t+\t1 Solution:\tn2\t+\t1\t\u2264\t2n2,\tfor\tall\tn\t\u2265\t1 \u2234\tn2\t+\t1\t=\tO(n2)\twith\tc\t=\t2\tand\tn0\t=\t1 Example-3\tFind\tupper\tbound\tfor\tf(n)\t=\tn4\t+\t100n2\t+\t50 Solution:\tn4\t+\t100n2\t+\t50\t\u2264\t2n4,\tfor\tall\tn\t\u2265\t11 \u2234\tn4\t+\t100n2\t+\t50\t=\tO(n4\t)\twith\tc\t=\t2\tand\tn0\t=\t11 Example-4\tFind\tupper\tbound\tfor\tf(n)\t=\t2n3\t\u2013\t2n2 Solution:\t2n3\t\u2013\t2n2\t\u2264\t2n3,\tfor\tall\tn\t>\t1 \u2234\t2n3\t\u2013\t2n2\t=\tO(n3\t)\twith\tc\t=\t2\tand\tn0\t=\t1 Example-5\tFind\tupper\tbound\tfor\tf(n)\t=\tn Solution:\tn\t\u2264\tn,\tfor\tall\tn\t\u2265\t1 \u2234\tn\t=\tO(n)\twith\tc\t=\t1\tand\tn0\t=\t1 Example-6\tFind\tupper\tbound\tfor\tf(n)\t=\t410 Solution:\t410\t\u2264\t410,\tfor\tall\tn\t>\t1 \u2234\t410\t=\tO(1)\twith\tc\t=\t1\tand\tn0\t=\t1 No\tUniqueness? There\tis\tno\tunique\tset\tof\tvalues\tfor\tn0\tand\tc\tin\tproving\tthe\tasymptotic\tbounds.\tLet\tus\tconsider, 100n\t+\t5\t=\tO(n).\tFor\tthis\tfunction\tthere\tare\tmultiple\tn0\tand\tc\tvalues\tpossible. Solution1:\t100n\t+\t5\t\u2264\t100n\t+\tn\t=\t101n\t\u2264\t101n,\tfor\tall\tn\t\u2265\t5,\tn0\t=\t5\tand\tc\t=\t101\tis\ta\tsolution. Solution2:\t100n\t+\t5\t\u2264\t100n\t+\t5n\t=\t105n\t\u2264\t105n,\tfor\tall\tn\t>\t1,\tn0\t=\t1\tand\tc\t=\t105\tis\talso\ta solution."
            },
            {
                "subchapter_title": "1.15\tOmega-Q\tNotation\t[Lower\tBounding\tFunction]",
                "content": "Similar\tto\tthe\tO\tdiscussion,\tthis\tnotation\tgives\tthe\ttighter\tlower\tbound\tof\tthe\tgiven\talgorithm\tand we\trepresent\tit\tas\tf(n)\t=\t\u2126(g(n)).\tThat\tmeans,\tat\tlarger\tvalues\tof\tn,\tthe\ttighter\tlower\tbound\tof f(n)\tis\tg(n).\tFor\texample,\tif\tf(n)\t=\t100n2\t+\t10n\t+\t50,\tg(n)\tis\t\u2126(n2). The\t\u2126\tnotation\tcan\tbe\tdefined\tas\t\u2126(g(n))\t=\t{f(n):\tthere\texist\tpositive\tconstants\tc\tand\tn0\tsuch\tthat 0\t\u2264\tcg(n)\t\u2264\tf(n)\tfor\tall\tn\t\u2265\tn0}.\tg(n)\tis\tan\tasymptotic\ttight\tlower\tbound\tfor\tf(n).\tOur\tobjective\tis to\tgive\tthe\tlargest\trate\tof\tgrowth\tg(n)\twhich\tis\tless\tthan\tor\tequal\tto\tthe\tgiven\talgorithm\u2019s\trate\tof growth\tf(n). \u2126\tExamples Example-1\tFind\tlower\tbound\tfor\tf(n)\t=\t5n2. Solution:\t\u2203\tc,\tn0\tSuch\tthat:\t0\t\u2264\tcn2\u2264\t5n2\t\u21d2\tcn2\t\u2264\t5n2\t\u21d2\tc\t=\t5\tand\tn0\t=\t1 \u2234\t5n2\t=\t\u2126(n2)\twith\tc\t=\t5\tand\tn0\t=\t1 Example-2\tProve\tf(n)\t=\t100n\t+\t5\t\u2260\t\u2126(n2). Solution:\t\u2203\tc,\tn0\tSuch\tthat:\t0\t\u2264\tcn2\t\u2264\t100n\t+\t5 100n\t+\t5\t\u2264\t100n\t+\t5n(\u2200n\t\u2265\t1)\t=\t105n cn2\t\u2264\t105n\t\u21d2\tn(cn\t-\t105)\t\u2264\t0 Since\tn\tis\tpositive\t\u21d2cn\t-\t105\t\u22640\t\u21d2\tn\t\u2264105/c \u21d2\tContradiction:\tn\tcannot\tbe\tsmaller\tthan\ta\tconstant Example-3\t2n\t=\tQ(n),\tn3\t=\tQ(n3),\t=\tO(logn)."
            },
            {
                "subchapter_title": "1.16\tTheta-\u0398\tNotation\t[Order\tFunction]",
                "content": "This\tnotation\tdecides\twhether\tthe\tupper\tand\tlower\tbounds\tof\ta\tgiven\tfunction\t(algorithm)\tare\tthe same.\tThe\taverage\trunning\ttime\tof\tan\talgorithm\tis\talways\tbetween\tthe\tlower\tbound\tand\tthe\tupper bound.\tIf\tthe\tupper\tbound\t(O)\tand\tlower\tbound\t(\u2126)\tgive\tthe\tsame\tresult,\tthen\tthe\t\u0398\tnotation\twill also\thave\tthe\tsame\trate\tof\tgrowth. As\tan\texample,\tlet\tus\tassume\tthat\tf(n)\t=\t10n\t+\tn\tis\tthe\texpression.\tThen,\tits\ttight\tupper\tbound g(n)\tis\tO(n).\tThe\trate\tof\tgrowth\tin\tthe\tbest\tcase\tis\tg(n)\t=\tO(n). In\tthis\tcase,\tthe\trates\tof\tgrowth\tin\tthe\tbest\tcase\tand\tworst\tcase\tare\tthe\tsame.\tAs\ta\tresult,\tthe average\t case\t will\t also\t be\t the\t same.\t For\t a\t given\t function\t (algorithm),\t if\t the\t rates\t of\t growth (bounds)\tfor\tO\tand\t\u2126\tare\tnot\tthe\tsame,\tthen\tthe\trate\tof\tgrowth\tfor\tthe\t\u0398\tcase\tmay\tnot\tbe\tthe\tsame. In\tthis\tcase,\twe\tneed\tto\tconsider\tall\tpossible\ttime\tcomplexities\tand\ttake\tthe\taverage\tof\tthose\t(for example,\tfor\ta\tquick\tsort\taverage\tcase,\trefer\tto\tthe\tSorting\tchapter). Now\tconsider\tthe\tdefinition\tof\t\u0398\tnotation.\tIt\tis\tdefined\tas\t\u0398(g(n))\t=\t{f(n):\tthere\texist\tpositive constants\tc1,c2\tand\tn0\tsuch\tthat\t0\t\u2264\tc1g(n)\t\u2264\tf(n)\t\u2264\tc2g(n)\tfor\tall\tn\t\u2265\tn0}.\tg(n)\tis\tan\tasymptotic tight\tbound\tfor\tf(n).\t\u0398(g(n))\tis\tthe\tset\tof\tfunctions\twith\tthe\tsame\torder\tof\tgrowth\tas\tg(n). \u0398\tExamples Example\t1\tFind\t\u0398\tbound\tfor\t Solution:\t \tfor\tall,\tn\t\u2265\t2 \u2234\t \twith\tc1\t=\t1/5,c2\t=\t1\tand\tn0\t=\t2 Example\t2\tProve\tn\t\u2260\t\u0398(n2) Solution:\tc1\tn2\t\u2264\tn\t\u2264\tc2n2\t\u21d2\tonly\tholds\tfor:\tn\t\u2264\t1/c1 \u2234\tn\t\u2260\t\u0398(n2) Example\t3\tProve\t6n3\t\u2260\t\u0398(n2) Solution:\tc1\tn2\u2264\t6n3\t\u2264\tc2\tn2\t\u21d2\tonly\tholds\tfor:\tn\t\u2264\tc2\t/6 \u2234\t6n3\t\u2260\t\u0398(n2) Example\t4\tProve\tn\t\u2260\t\u0398(logn) Solution:\tc1logn\t\u2264\tn\t\u2264\tc2logn\t\u21d2\tc2\t\u2265\t ,\t\u2200\tn\t\u2265\tn0\t\u2013\tImpossible"
            },
            {
                "subchapter_title": "1.17\tImportant\tNotes",
                "content": "For\tanalysis\t(best\tcase,\tworst\tcase\tand\taverage),\twe\ttry\tto\tgive\tthe\tupper\tbound\t(O)\tand\tlower bound\t(\u2126)\tand\taverage\trunning\ttime\t(\u0398).\tFrom\tthe\tabove\texamples,\tit\tshould\talso\tbe\tclear\tthat, for\ta\tgiven\tfunction\t(algorithm),\tgetting\tthe\tupper\tbound\t(O)\tand\tlower\tbound\t(\u2126)\tand\taverage running\ttime\t(\u0398)\tmay\tnot\talways\tbe\tpossible.\tFor\texample,\tif\twe\tare\tdiscussing\tthe\tbest\tcase\tof an\talgorithm,\twe\ttry\tto\tgive\tthe\tupper\tbound\t(O)\tand\tlower\tbound\t(\u2126)\tand\taverage\trunning\ttime (\u0398). In\tthe\tremaining\tchapters,\twe\tgenerally\tfocus\ton\tthe\tupper\tbound\t(O)\tbecause\tknowing\tthe\tlower bound\t(\u2126)\tof\tan\talgorithm\tis\tof\tno\tpractical\timportance,\tand\twe\tuse\tthe\t\u0398\tnotation\tif\tthe\tupper bound\t(O)\tand\tlower\tbound\t(\u2126)\tare\tthe\tsame."
            },
            {
                "subchapter_title": "1.18\tWhy\tis\tit\tcalled\tAsymptotic\tAnalysis?",
                "content": "From\tthe\tdiscussion\tabove\t(for\tall\tthree\tnotations:\tworst\tcase,\tbest\tcase,\tand\taverage\tcase),\twe can\teasily\tunderstand\tthat,\tin\tevery\tcase\tfor\ta\tgiven\tfunction\tf(n)\twe\tare\ttrying\tto\tfind\tanother function\t g(n)\twhich\t approximates\t f(n)\t at\t higher\t values\t of\t n.\t That\tmeans\t g(n)\t is\talso\t a\t curve which\tapproximates\tf(n)\tat\thigher\tvalues\tof\tn. In\tmathematics\twe\tcall\tsuch\ta\tcurve\tan\tasymptotic\tcurve.\tIn\tother\tterms,\tg(n)\tis\tthe\tasymptotic curve\tfor\tf(n).\tFor\tthis\treason,\twe\tcall\talgorithm\tanalysis\tasymptotic\tanalysis."
            },
            {
                "subchapter_title": "1.19\tGuidelines\tfor\tAsymptotic\tAnalysis",
                "content": "There\tare\tsome\tgeneral\trules\tto\thelp\tus\tdetermine\tthe\trunning\ttime\tof\tan\talgorithm. 1) Loops:\t The\t running\t time\t of\t a\t loop\t is,\t at\t most,\t the\t running\t time\t of\t the\t statements inside\tthe\tloop\t(including\ttests)\tmultiplied\tby\tthe\tnumber\tof\titerations. Total\ttime\t=\ta\tconstant\tc\t\u00d7\tn\t=\tc\tn\t=\tO(n). 2) Nested\tloops:\tAnalyze\tfrom\tthe\tinside\tout.\tTotal\trunning\ttime\tis\tthe\tproduct\tof\tthe sizes\tof\tall\tthe\tloops. Total\ttime\t=\tc\t\u00d7\tn\t\u00d7\tn\t=\tcn2\t=\tO(n2). 3) Consecutive\tstatements:\tAdd\tthe\ttime\tcomplexities\tof\teach\tstatement. Total\ttime\t=\tc0\t+\tc1n\t+\tc2n2\t=\tO(n2). 4) If-then-else\tstatements:\tWorst-case\trunning\ttime:\tthe\ttest,\tplus\teither\tthe\tthen\tpart or\tthe\telse\tpart\t(whichever\tis\tthe\tlarger). Total\ttime\t=\tc0\t+\tc1\t+\t(c2\t+\tc3)\t*\tn\t=\tO(n). 5) Logarithmic\tcomplexity:\tAn\talgorithm\tis\tO(logn)\tif\tit\ttakes\ta\tconstant\ttime\tto\tcut the\tproblem\tsize\tby\ta\tfraction\t(usually\tby\t\u00bd).\tAs\tan\texample\tlet\tus\tconsider\tthe following\tprogram: If\twe\tobserve\tcarefully,\tthe\tvalue\tof\ti\tis\tdoubling\tevery\ttime.\tInitially\ti\t=\t1,\tin\tnext\tstep\ti =\t2,\tand\tin\tsubsequent\tsteps\ti\t=\t4,8\tand\tso\ton.\tLet\tus\tassume\tthat\tthe\tloop\tis\texecuting some\tk\ttimes.\tAt\tkth\tstep\t2k\t=\tn,\tand\tat\t(k\t+\t1)th\tstep\twe\tcome\tout\tof\tthe\tloop.\t Taking logarithm\ton\tboth\tsides,\tgives Total\ttime\t=\tO(logn). Note:\t Similarly,\t for\t the\t case\t below,\t the\t worst\t case\t rate\t of\t growth\t is\t O(logn).\t The\t same discussion\tholds\tgood\tfor\tthe\tdecreasing\tsequence\tas\twell. Another\texample:\tbinary\tsearch\t(finding\ta\tword\tin\ta\tdictionary\tof\tn\tpages) \u2022 Look\tat\tthe\tcenter\tpoint\tin\tthe\tdictionary \u2022 Is\tthe\tword\ttowards\tthe\tleft\tor\tright\tof\tcenter? \u2022 Repeat\tthe\tprocess\twith\tthe\tleft\tor\tright\tpart\tof\tthe\tdictionary\tuntil\tthe\tword\tis\tfound."
            },
            {
                "subchapter_title": "1.20\tSimplyfying\tproperties\tof\tasymptotic\tnotations",
                "content": "\u2022 Transitivity:\tf(n)\t=\t\u0398(g(n))\tand\tg(n)\t=\t\u0398(h(n))\t\u21d2\tf(n)\t=\t\u0398(h(n)).\tValid\tfor\tO\tand\t\u2126 as\twell. \u2022 Reflexivity:\tf(n)\t=\t\u0398(f(n)).\tValid\tfor\tO\tand\t\u2126. \u2022 Symmetry:\tf(n)\t=\t\u0398(g(n))\tif\tand\tonly\tif\tg(n)\t=\t\u0398(f(n)). \u2022 Transpose\tsymmetry:\tf(n)\t=\tO(g(n))\tif\tand\tonly\tif\tg(n)\t=\t\u2126(f(n)). \u2022 If\tf(n)\tis\tin\tO(kg(n))\tfor\tany\tconstant\tk\t>\t0,\tthen\tf(n)\tis\tin\tO(g(n)). \u2022 If\tf1(n)\tis\tin\tO(g1(n))\tand\tf2(n)\tis\tin\tO(g2(n)),\tthen\t(f1\t+\tf2)(n)\tis\tin\tO(max(g1(n)), (g1(n))). \u2022 If\tf1(n)\tis\tin\tO(g1(n))\tand\tf2(n)\tis\tin\tO(g2(n))\tthen\tf1(n)\tf2(n)\tis\tin\tO(g1(n)\tg1(n))."
            },
            {
                "subchapter_title": "1.21\tCommonly\tused\tLogarithms\tand\tSummations",
                "content": "Logarithms Arithmetic\tseries Geometric\tseries Harmonic\tseries Other\timportant\tformulae"
            },
            {
                "subchapter_title": "1.22\tMaster\tTheorem\tfor\tDivide\tand\tConquer\tRecurrences",
                "content": "All\tdivide\tand\tconquer\talgorithms\t(also\tdiscussed\tin\tdetail\tin\tthe\tDivide\tand\tConquer\tchapter) divide\tthe\tproblem\tinto\tsub-problems,\teach\tof\twhich\tis\tpart\tof\tthe\toriginal\tproblem,\tand\tthen perform\t some\t additional\t work\t to\t compute\t the\t final\t answer.\t As\t an\t example,\t a\t merge\t sort algorithm\t[for\tdetails,\trefer\tto\tSorting\tchapter]\toperates\ton\ttwo\tsub-problems,\teach\tof\twhich\tis half\tthe\tsize\tof\tthe\toriginal,\tand\tthen\tperforms\tO(n)\tadditional\twork\tfor\tmerging.\tThis\tgives\tthe running\ttime\tequation: The\t following\t theorem\t can\t be\t used\t to\t determine\t the\t running\t time\t of\t divide\t and\t conquer algorithms.\tFor\ta\tgiven\tprogram\t(algorithm),\tfirst\twe\ttry\tto\tfind\tthe\trecurrence\trelation\tfor\tthe problem.\tIf\tthe\trecurrence\tis\tof\tthe\tbelow\tform\tthen\twe\tcan\tdirectly\tgive\tthe\tanswer\twithout\tfully solving\tit.\tIf\tthe\trecurrence\tis\tof\tthe\tform\t ,\twhere\ta\t\u2265\t1,b\t> 1,k\t\u2265\t0\tand\tp\tis\ta\treal\tnumber,\tthen: 1) If\ta\t>\tbk,\tthen\t 2) If\ta=\tbk a. If\tp\t>\t\u20131,\tthen\t b. If\tp\t=\t\u20131,\tthen\t c. If\tp\t<\t\u20131,\tthen\t 3) If\ta\t<\tbk a. If\tp\t\u2265\t0,\tthen\tT(n)\t=\t\u0398(nklogpn) b. If\tp\t<\t0,\tthen\tT(n)\t=\tO(nk)"
            },
            {
                "subchapter_title": "1.23\tDivide\tand\tConquer\tMaster\tTheorem:\tProblems\t&\tSolutions",
                "content": "For\teach\tof\tthe\tfollowing\trecurrences,\tgive\tan\texpression\tfor\tthe\truntime\tT(n)\tif\tthe\trecurrence can\tbe\tsolved\twith\tthe\tMaster\tTheorem.\tOtherwise,\tindicate\tthat\tthe\tMaster\tTheorem\tdoes\tnot apply. Problem-1\u2003\u2003T(n)\t=\t3T\t(n/2)\t+\tn2 Solution:\tT(n)\t=\t3T\t(n/2)\t+\tn2\t=>\tT\t(n)\t=\u0398(n2)\t(Master\tTheorem\tCase\t3.a) Problem-2\u2003\u2003T(n)\t=\t4T\t(n/2)\t+\tn2 Solution:\tT(n)\t=\t4T\t(n/2)\t+\tn2\t=>\tT\t(n)\t=\t\u0398(n2logn)\t(Master\tTheorem\tCase\t2.a) Problem-3\u2003\u2003T(n)\t=\tT(n/2)\t+\tn2 Solution:\tT(n)\t=\tT(n/2)\t+\tn2\t=>\t\u0398(n2)\t(Master\tTheorem\tCase\t3.a) Problem-4\u2003\u2003T(n)\t=\t2nT(n/2)\t+\tnn Solution:\tT(n)\t=\t2nT(n/2)\t+\tnn\t=>\tDoes\tnot\tapply\t(a\tis\tnot\tconstant) Problem-5\u2003\u2003T(n)\t=\t16T(n/4)\t+\tn Solution:\tT(n)\t=\t16T\t(n/4)\t+\tn\t=>\tT(n)\t=\t\u0398(n2)\t(Master\tTheorem\tCase\t1) Problem-6\u2003\u2003T(n)\t=\t2T(n/2)\t+\tnlogn Solution:\tT(n)\t=\t2T(n/2)\t+\tnlogn\t=>\tT(n)\t=\t\u0398(nlog2n)\t(Master\tTheorem\tCase\t2.a) Problem-7\u2003\u2003T(n)\t=\t2T(n/2)\t+\tn/logn Solution:\tT(n)\t=\t2T(n/2)+\tn/logn\t=>T(n)\t=\t\u0398(nloglogn)\t(Master\tTheorem\tCase\t2.\tb) Problem-8\u2003\u2003T(n)\t=\t2T\t(n/4)\t+\tn051 Solution:\tT(n)\t=\t2T(n/4)\t+\tn051\t=>\tT\t(n)\t=\t\u0398(n0.51)\t(Master\tTheorem\tCase\t3.b) Problem-9\u2003\u2003T(n)\t=\t0.5T(n/2)\t+\t1/n Solution:\tT(n)\t=\t0.5T(n/2)\t+\t1/n\t=>\tDoes\tnot\tapply\t(a\t<\t1) Problem-10\u2003\u2003T\t(n)\t=\t6T(n/3)+\tn2\tlogn Solution:\tT(n)\t=\t6T(n/3)\t+\tn2logn\t=>\tT(n)\t=\t\u0398(n2logn)\t(Master\tTheorem\tCase\t3.a) Problem-11\u2003\u2003T(n)\t=\t64T(n/8)\t\u2013\tn2logn Solution:\tT(n)\t=\t64T(n/8)\t\u2013\tn2logn\t=>\tDoes\tnot\tapply\t(function\tis\tnot\tpositive) Problem-12\u2003\u2003T(n)\t=\t7T(n/3)\t+\tn2 Solution:\tT(n)\t=\t7T(n/3)\t+\tn2\t=>\tT(n)\t=\t\u0398(n2)\t(Master\tTheorem\tCase\t3.as) Problem-13\u2003\u2003T(n)\t=\t4T(n/2)\t+\tlogn Solution:\tT(n)\t=\t4T(n/2)\t+\tlogn\t=>\tT(n)\t=\t\u0398(n2)\t(Master\tTheorem\tCase\t1) Problem-14\u2003\u2003T(n)\t=\t16T\t(n/4)\t+\tn! Solution:\tT(n)\t=\t16T\t(n/4)\t+\tn!\t=>\tT(n)\t=\t\u0398(n!)\t(Master\tTheorem\tCase\t3.a) Problem-15\u2003\u2003T(n)\t=\t T(n/2)\t+\tlogn Solution:\tT(n)\t=\t T(n/2)\t+\tlogn\t=>\tT(n)\t=\t\u0398( )\t(Master\tTheorem\tCase\t1) Problem-16\u2003\u2003T(n)\t=\t3T(n/2)\t+\tn Solution:\tT(n)\t=\t3T(n/2)\t+\tn\t=>T(n)\t=\t\u0398(nlog3)\t(Master\tTheorem\tCase\t1) Problem-17\u2003\u2003T(n)\t=\t3T(n/3)\t+\t Solution:\tT(n)\t=\t3T(n/3)\t+\t \t=>\tT(n)\t=\t\u0398(n)\t(Master\tTheorem\tCase\t1) Problem-18\u2003\u2003T(n)\t=\t4T(n/2)\t+\tcn Solution:\tT(n)\t=\t4T(n/2)\t+\tcn\t=>\tT(n)\t=\t\u0398(n2)\t(Master\tTheorem\tCase\t1) Problem-19\u2003\u2003T(n)\t=\t3T(n/4)\t+\tnlogn Solution:\tT(n)\t=\t3T(n/4)\t+\tnlogn\t=>\tT(n)\t=\t\u0398(nlogn)\t(Master\tTheorem\tCase\t3.a) Problem-20\u2003\u2003T\t(n)\t=\t3T(n/3)\t+\tn/2 Solution:\tT(n)\t=\t3T(n/3)+\tn/2\t=>\tT\t(n)\t=\t\u0398(nlogn)\t(Master\tTheorem\tCase\t2.a)"
            },
            {
                "subchapter_title": "1.24\tMaster\tTheorem\tfor\tSubtract\tand\tConquer\tRecurrences",
                "content": "Let\tT(n)\tbe\ta\tfunction\tdefined\ton\tpositive\tn,\tand\thaving\tthe\tproperty for\tsome\tconstants\tc,a\t>\t0,b\t\u2265\t0,k\t\u2265\t0,\tand\tfunction\tf(n).\tIf\tf(n)\tis\tin\tO(nk),\tthen"
            },
            {
                "subchapter_title": "1.25\tVariant\tof\tSubtraction\tand\tConquer\tMaster\tTheorem",
                "content": "The\tsolution\tto\tthe\tequation\tT(n)\t=\tT(\u03b1\tn)\t+\tT((1\t\u2013\t\u03b1)n)\t+\t\u03b2n,\twhere\t0\t<\t\u03b1\t<\t1\tand\t\u03b2\t>\t0\tare constants,\tis\tO(nlogn)."
            },
            {
                "subchapter_title": "1.26\tMethod\tof\tGuessing\tand\tConfirming",
                "content": "Now,\tlet\tus\tdiscuss\ta\tmethod\twhich\tcan\tbe\tused\tto\tsolve\tany\trecurrence.\tThe\tbasic\tidea\tbehind this\tmethod\tis: guess\tthe\tanswer;\tand\tthen\tprove\tit\tcorrect\tby\tinduction. In\tother\twords,\tit\taddresses\tthe\tquestion:\tWhat\tif\tthe\tgiven\trecurrence\tdoesn\u2019t\tseem\tto\tmatch\twith any\tof\tthese\t(master\ttheorem)\tmethods?\tIf\twe\tguess\ta\tsolution\tand\tthen\ttry\tto\tverify\tour\tguess inductively,\tusually\teither\tthe\tproof\twill\tsucceed\t(in\twhich\tcase\twe\tare\tdone),\tor\tthe\tproof\twill fail\t(in\twhich\tcase\tthe\tfailure\twill\thelp\tus\trefine\tour\tguess). As\t an\t example,\t consider\t the\t recurrence\t .\t This\t doesn\u2019t\t fit\t into\t the\t form required\tby\tthe\tMaster\tTheorems.\tCarefully\tobserving\tthe\trecurrence\tgives\tus\tthe\timpression\tthat it\tis\tsimilar\tto\tthe\tdivide\tand\tconquer\tmethod\t(dividing\tthe\tproblem\tinto\t \tsubproblems\teach with\tsize\t ).\tAs\twe\tcan\tsee,\tthe\tsize\tof\tthe\tsubproblems\tat\tthe\tfirst\tlevel\tof\trecursion\tis\tn.\tSo, let\tus\tguess\tthat\tT(n)\t=\tO(nlogn),\tand\tthen\ttry\tto\tprove\tthat\tour\tguess\tis\tcorrect. Let\u2019s\tstart\tby\ttrying\tto\tprove\tan\tupper\tbound\tT(n)\t<\tcnlogn: The\tlast\tinequality\tassumes\tonly\tthat\t1\t\u2264\tc. .logn.\tThis\tis\tcorrect\tif\tn\tis\tsufficiently\tlarge\tand\tfor any\tconstant\tc,\tno\tmatter\thow\tsmall.\tFrom\tthe\tabove\tproof,\twe\tcan\tsee\tthat\tour\tguess\tis\tcorrect for\tthe\tupper\tbound.\tNow,\tlet\tus\tprove\tthe\tlower\tbound\tfor\tthis\trecurrence. The\tlast\tinequality\tassumes\tonly\tthat\t1\t\u2265\tk. .logn.\tThis\tis\tincorrect\tif\tn\tis\tsufficiently\tlarge\tand for\tany\tconstant\tk.\tFrom\tthe\tabove\tproof,\twe\tcan\tsee\tthat\tour\tguess\tis\tincorrect\tfor\tthe\tlower bound. From\tthe\tabove\tdiscussion,\twe\tunderstood\tthat\t\u0398(nlogn)\tis\ttoo\tbig.\tHow\tabout\t\u0398(n)?\tThe\tlower bound\tis\teasy\tto\tprove\tdirectly: Now,\tlet\tus\tprove\tthe\tupper\tbound\tfor\tthis\t\u0398(n). From\tthe\tabove\tinduction,\twe\tunderstood\tthat\t\u0398(n)\tis\ttoo\tsmall\tand\t\u0398(nlogn)\tis\ttoo\tbig.\tSo,\twe need\tsomething\tbigger\tthan\tn\tand\tsmaller\tthan\tnlogn.\tHow\tabout\t ? Proving\tthe\tupper\tbound\tfor\t : Proving\tthe\tlower\tbound\tfor\t : The\tlast\tstep\tdoesn\u2019t\twork.\tSo,\t\u0398( )\tdoesn\u2019t\twork.\tWhat\telse\tis\tbetween\tn\tand\tnlogn? How\tabout\tnloglogn?\tProving\tupper\tbound\tfor\tnloglogn: Proving\tlower\tbound\tfor\tnloglogn: From\tthe\tabove\tproofs,\twe\tcan\tsee\tthat\tT(n)\t\u2264\tcnloglogn,\tif\tc\t\u2265\t1\tand\tT(n)\t\u2265\tknloglogn,\tif\tk\t\u2264\t1. Technically,\twe\u2019re\tstill\tmissing\tthe\tbase\tcases\tin\tboth\tproofs,\tbut\twe\tcan\tbe\tfairly\tconfident\tat this\tpoint\tthat\tT(n)\t=\t\u0398(nloglogn)."
            },
            {
                "subchapter_title": "1.27\tAmortized\tAnalysis",
                "content": "Amortized\t analysis\t refers\t to\t determining\t the\t time-averaged\t running\t time\t for\t a\t sequence\t of operations.\tIt\tis\tdifferent\tfrom\taverage\tcase\tanalysis,\tbecause\tamortized\tanalysis\tdoes\tnot\tmake any\tassumption\tabout\tthe\tdistribution\tof\tthe\tdata\tvalues,\twhereas\taverage\tcase\tanalysis\tassumes the\tdata\tare\tnot\t\u201cbad\u201d\t(e.g.,\tsome\tsorting\talgorithms\tdo\twell\ton\taverage\tover\tall\tinput\torderings but\tvery\tbadly\ton\tcertain\tinput\torderings).\tThat\tis,\tamortized\tanalysis\tis\ta\tworst-case\tanalysis, but\tfor\ta\tsequence\tof\toperations\trather\tthan\tfor\tindividual\toperations. The\t motivation\t for\t amortized\t analysis\t is\t to\t better\t understand\t the\t running\t time\t of\t certain techniques,\twhere\tstandard\tworst\tcase\tanalysis\tprovides\tan\toverly\tpessimistic\tbound.\tAmortized analysis\tgenerally\tapplies\tto\ta\tmethod\tthat\tconsists\tof\ta\tsequence\tof\toperations,\twhere\tthe\tvast majority\tof\tthe\toperations\tare\tcheap,\tbut\tsome\tof\tthe\toperations\tare\texpensive.\tIf\twe\tcan\tshow that\tthe\texpensive\toperations\tare\tparticularly\trare\twe\tcan\tchange\tthem\tto\tthe\tcheap\toperations, and\tonly\tbound\tthe\tcheap\toperations. The\tgeneral\tapproach\tis\tto\tassign\tan\tartificial\tcost\tto\teach\toperation\tin\tthe\tsequence,\tsuch\tthat\tthe total\tof\tthe\tartificial\tcosts\tfor\tthe\tsequence\tof\toperations\tbounds\tthe\ttotal\tof\tthe\treal\tcosts\tfor\tthe sequence.\tThis\tartificial\tcost\tis\tcalled\tthe\tamortized\tcost\tof\tan\toperation.\tTo\tanalyze\tthe\trunning time,\tthe\tamortized\tcost\tthus\tis\ta\tcorrect\tway\tof\tunderstanding\tthe\toverall\trunning\ttime\t\u2013\tbut\tnote that\tparticular\toperations\tcan\tstill\ttake\tlonger\tso\tit\tis\tnot\ta\tway\tof\tbounding\tthe\trunning\ttime\tof any\tindividual\toperation\tin\tthe\tsequence. When\tone\tevent\tin\ta\tsequence\taffects\tthe\tcost\tof\tlater\tevents: \u2022 One\tparticular\ttask\tmay\tbe\texpensive. \u2022 But\tit\tmay\tleave\tdata\tstructure\tin\ta\tstate\tthat\tthe\tnext\tfew\toperations\tbecome\teasier. Example:\t Let\t us\t consider\t an\t array\t of\t elements\t from\t which\t we\t want\t to\t find\t the\t kth\t smallest element.\tWe\tcan\tsolve\tthis\tproblem\tusing\tsorting.\tAfter\tsorting\tthe\tgiven\tarray,\twe\tjust\tneed\tto return\tthe\tkth\telement\tfrom\tit.\tThe\tcost\tof\tperforming\tthe\tsort\t(assuming\tcomparison\tbased\tsorting algorithm)\tis\tO(nlogn).\tIf\twe\tperform\tn\tsuch\tselections\tthen\tthe\taverage\tcost\tof\teach\tselection\tis O(nlogn/n)\t =\t O(logn).\t This\t clearly\t indicates\t that\t sorting\t once\t is\t reducing\t the\t complexity\t of subsequent\toperations."
            },
            {
                "subchapter_title": "1.28\tAlgorithms\tAnalysis:\tProblems\t&\tSolutions",
                "content": "Note:\t From\t the\t following\t problems,\t try\t to\t understand\t the\t cases\t which\t have\t different complexities\t(O(n),\tO(logn),\tO(loglogn)\tetc.). Problem-21\u2003\u2003Find\tthe\tcomplexity\tof\tthe\tbelow\trecurrence: Solution:\tLet\tus\ttry\tsolving\tthis\tfunction\twith\tsubstitution. T(n)\t=\t3T(n\t\u2013\t1) T(n)\t=\t3(3T(n\t\u2013\t2))\t=\t32T(n\t\u2013\t2) T(n)\t=\t32(3T(n\t\u2013\t3)) . . T(n)\t=\t3nT(n\t\u2013\tn)\t=\t3nT(0)\t=\t3n This\tclearly\tshows\tthat\tthe\tcomplexity\tof\tthis\tfunction\tis\tO(3n). Note:\tWe\tcan\tuse\tthe\tSubtraction\tand\tConquer\tmaster\ttheorem\tfor\tthis\tproblem. Problem-22\u2003\u2003Find\tthe\tcomplexity\tof\tthe\tbelow\trecurrence: Solution:\tLet\tus\ttry\tsolving\tthis\tfunction\twith\tsubstitution. T(n)\t=\t2T(n\t\u2013\t1)\t\u2013\t1 T(n)\t=\t2(2T(n\t\u2013\t2)\t\u2013\t1)\t\u2013\t1\t=\t22T(n\t\u2013\t2)\t\u2013\t2\t\u2013\t1 T(n)\t=\t22(2T(n\t\u2013\t3)\t\u2013\t2\t\u2013\t1)\t\u2013\t1\t=\t23T(n\t\u2013\t4)\t\u2013\t22\t\u2013\t21\t\u2013\t20 T(n)\t=\t2nT(n\t\u2013\tn)\t\u2013\t2n\u20131\t\u2013\t2n\u20132\t\u2013\t2n\u20133\t....\t22\t\u2013\t21\t\u2013\t20 T(n)\t=2n\t\u2013\t2n\u20131\t\u2013\t2n\u20132\t\u2013\t2n\t\u2013\t3\t....\t22\t\u2013\t21\t\u2013\t20 T(n)\t=2n\t\u2013\t(2n\t\u2013\t1)\t[note:\t2n\u20131\t+\t2n\u20132\t+\t\u00b7\u00b7\u00b7\t+\t20\t=\t2n] T(n)\t=\t1 \u2234\t Time\t Complexity\t is\t O(1).\t Note\t that\t while\t the\t recurrence\t relation\t looks\t exponential,\t the solution\tto\tthe\trecurrence\trelation\there\tgives\ta\tdifferent\tresult. Problem-23\u2003\u2003What\tis\tthe\trunning\ttime\tof\tthe\tfollowing\tfunction? Solution:\tConsider\tthe\tcomments\tin\tthe\tbelow\tfunction: We\tcan\tdefine\tthe\t\u2018s\u2019\tterms\taccording\tto\tthe\trelation\tsi\t=\tsi\u20131\t+\ti.\tThe\tvalue\toft\u2019\tincreases\tby\t1 for\teach\titeration.\tThe\tvalue\tcontained\tin\t\u2018s\u2019\tat\tthe\tith\titeration\tis\tthe\tsum\tof\tthe\tfirst\t\u2018(\u2018positive integers.\tIf\tk\tis\tthe\ttotal\tnumber\tof\titerations\ttaken\tby\tthe\tprogram,\tthen\tthe\twhile\tloop\tterminates if: Problem-24\u2003\u2003Find\tthe\tcomplexity\tof\tthe\tfunction\tgiven\tbelow. Solution: In\tthe\tabove-mentioned\tfunction\tthe\tloop\twill\tend,\tif\ti2\t>\tn\t\u21d2\tT(n)\t=\tO( ).\tThis\tis\tsimilar\tto Problem-23. Problem-25\u2003\u2003What\tis\tthe\tcomplexity\tof\tthe\tprogram\tgiven\tbelow: Solution:\tConsider\tthe\tcomments\tin\tthe\tfollowing\tfunction. The\tcomplexity\tof\tthe\tabove\tfunction\tis\tO(n2logn). Problem-26\u2003\u2003What\tis\tthe\tcomplexity\tof\tthe\tprogram\tgiven\tbelow: Solution:\tConsider\tthe\tcomments\tin\tthe\tfollowing\tfunction. The\tcomplexity\tof\tthe\tabove\tfunction\tis\tO(nlog2n). Problem-27\u2003\u2003Find\tthe\tcomplexity\tof\tthe\tprogram\tbelow. Solution:\tConsider\tthe\tcomments\tin\tthe\tfunction\tbelow. The\tcomplexity\tof\tthe\tabove\tfunction\tis\tO(n).\tEven\tthough\tthe\tinner\tloop\tis\tbounded\tby\tn,\tdue\tto the\tbreak\tstatement\tit\tis\texecuting\tonly\tonce. Problem-28\u2003\u2003Write\ta\trecursive\tfunction\tfor\tthe\trunning\ttime\tT(n)\tof\tthe\tfunction\tgiven\tbelow. Prove\tusing\tthe\titerative\tmethod\tthat\tT(n)\t=\t\u0398(n3). Solution:\tConsider\tthe\tcomments\tin\tthe\tfunction\tbelow: The\trecurrence\tfor\tthis\tcode\tis\tclearly\tT(n)\t=\tT(n\t\u2013\t3)\t+\tcn2\tfor\tsome\tconstant\tc\t>\t0\tsince\teach call\tprints\tout\tn2\tasterisks\tand\tcalls\titself\trecursively\ton\tn\t\u2013\t3.\tUsing\tthe\titerative\tmethod\twe\tget: T(n)\t=\tT(n\t\u2013\t3)\t+\tcn2.\tUsing\tthe\tSubtraction\tand\tConquer\tmaster\ttheorem,\twe\tget\tT(n)\t=\t\u0398(n3). Problem-29\u2003\u2003Determine\t\u0398\tbounds\tfor\tthe\trecurrence\trelation:\t Solution:\tUsing\tDivide\tand\tConquer\tmaster\ttheorem,\twe\tget\tO(nlog2n). Problem-30\u2003\u2003Determine\t \u0398\t bounds\t for\t the\t recurrence:\t Solution:\t Substituting\t in\t the\t recurrence\t equation,\t we\t get:\t ,\t where\t k\t is\t a\t constant.\t This\t clearly says\t\u0398(n). Problem-31\u2003\u2003Determine\t\u0398\tbounds\tfor\tthe\trecurrence\trelation:\tT(n)\t=\tT(\u2308n/2\u2309)\t+\t7. Solution:\tUsing\tMaster\tTheorem\twe\tget:\t\u0398(logn). Problem-32\u2003\u2003Prove\tthat\tthe\trunning\ttime\tof\tthe\tcode\tbelow\tis\t\u2126(logn). Solution:\tThe\twhile\tloop\twill\tterminate\tonce\tthe\tvalue\tof\t\u2018k\u2019\tis\tgreater\tthan\tor\tequal\tto\tthe\tvalue of\t\u2018n\u2019.\tIn\teach\titeration\tthe\tvalue\tof\t\u2018k\u2019\tis\tmultiplied\tby\t3.\tIf\ti\tis\tthe\tnumber\tof\titerations,\tthen\t\u2018k\u2019 has\tthe\tvalue\tof\t3i\tafter\ti\titerations.\tThe\tloop\tis\tterminated\tupon\treaching\ti\titerations\twhen\t3i\t\u2265\tn \u2194\ti\t\u2265\tlog3\tn,\twhich\tshows\tthat\ti\t=\t\u2126(logn). Problem-33\u2003\u2003Solve\tthe\tfollowing\trecurrence. Solution:\tBy\titeration: Note:\tWe\tcan\tuse\tthe\tSubtraction\tand\tConquer\tmaster\ttheorem\tfor\tthis\tproblem. Problem-34\u2003\u2003Consider\tthe\tfollowing\tprogram: Solution:\tThe\trecurrence\trelation\tfor\tthe\trunning\ttime\tof\tthis\tprogram\tis:\tT(n)\t=\tT(n\t\u2013\t1)\t+\tT(n\t\u2013 2)\t+\tc.\tNote\tT(n)\thas\ttwo\trecurrence\tcalls\tindicating\ta\tbinary\ttree.\tEach\tstep\trecursively\tcalls\tthe program\tfor\tn\treduced\tby\t1\tand\t2,\tso\tthe\tdepth\tof\tthe\trecurrence\ttree\tis\tO(n).\tThe\tnumber\tof leaves\t at\t depth\t n\t is\t 2n\t since\t this\t is\t a\t full\t binary\t tree,\t and\t each\t leaf\t takes\t at\t least\t O(1) computations\tfor\tthe\tconstant\tfactor.\tRunning\ttime\tis\tclearly\texponential\tin\tn\tand\tit\tis\tO(2n). Problem-35\u2003\u2003Running\ttime\tof\tfollowing\tprogram? Solution:\tConsider\tthe\tcomments\tin\tthe\tfunction\tbelow: In\t the\t above\t code,\t inner\t loop\t executes\t n/i\t times\t for\t each\t value\t of\t i.\t Its\t running\t time\t is\t . Problem-36\u2003\u2003What\tis\tthe\tcomplexity\tof\t Solution:\tUsing\tthe\tlogarithmic\tproperty,\tlogxy\t=\tlogx\t+\tlogy,\twe\tcan\tsee\tthat\tthis\tproblem\tis equivalent\tto This\tshows\tthat\tthe\ttime\tcomplexity\t=\tO(nlogn). Problem-37\u2003\u2003What\t is\t the\t running\t time\t of\t the\t following\t recursive\t function\t (specified\t as\t a function\t of\t the\t input\t value\t n)?\t First\t write\t the\t recurrence\t formula\t and\t then\t find\t its complexity. Solution:\tConsider\tthe\tcomments\tin\tthe\tbelow\tfunction: We\tcan\tassume\tthat\tfor\tasymptotical\tanalysis\tk\t=\t\u2308k\u2309\tfor\tevery\tinteger\tk\t\u2265\t1.\tThe\trecurrence\tfor this\tcode\tis\t .\tUsing\tmaster\ttheorem,\twe\tget\tT(n)\t=\t\u0398(n). Problem-38\u2003\u2003What\t is\t the\t running\t time\t of\t the\t following\t recursive\t function\t (specified\t as\t a function\tof\tthe\tinput\tvalue\tn)?\tFirst\twrite\ta\trecurrence\tformula,\tand\tshow\tits\tsolution\tusing induction. Solution:\tConsider\tthe\tcomments\tin\tthe\tfunction\tbelow: The\tif\tstatement\trequires\tconstant\ttime\t[O(1)].\tWith\tthe\tfor\tloop,\twe\tneglect\tthe\tloop\toverhead and\tonly\tcount\tthree\ttimes\tthat\tthe\tfunction\tis\tcalled\trecursively.\tThis\timplies\ta\ttime\tcomplexity recurrence: Using\tthe\tSubtraction\tand\tConquer\tmaster\ttheorem,\twe\tget\tT(n)\t=\t\u0398(3n). Problem-39\u2003\u2003Write\ta\trecursion\tformula\tfor\tthe\trunning\ttime\tT(n)\tof\tthe\tfunction\twhose\tcode is\tbelow. Solution:\tConsider\tthe\tcomments\tin\tthe\tfunction\tbelow: The\trecurrence\tfor\tthis\tpiece\tof\tcode\tis\tT(n)\t=\tT(.8n)\t+\tO(n)\t=\tT(4/5n)\t+\tO(n)\t=4/5\tT(n)\t+\tO(n). Applying\tmaster\ttheorem,\twe\tget\tT(n)\t=\tO(n). Problem-40\u2003\u2003Find\tthe\tcomplexity\tof\tthe\trecurrence:\tT(n)\t=\t2T( )\t+\tlogn Solution:\tThe\tgiven\trecurrence\tis\tnot\tin\tthe\tmaster\ttheorem\tformat.\tLet\tus\ttry\tto\tconvert\tthis\tto\tthe master\ttheorem\tformat\tby\tassuming\tn\t=\t2m.\tApplying\tthe\tlogarithm\ton\tboth\tsides\tgives,\tlogn\t= mlogl\t\u21d2\tm\t=\tlogn.\tNow,\tthe\tgiven\tfunction\tbecomes: To\t make\t it\t simple\t we\t assume\t . Applying\tthe\tmaster\ttheorem\tformat\twould\tresult\tin\tS(m)\t=\tO(mlogm). If\twe\tsubstitute\tm\t=\tlogn\tback,\tT(n)\t=\tS(logn)\t=\tO((logn)\tloglogn). Problem-41\u2003\u2003Find\tthe\tcomplexity\tof\tthe\trecurrence:\tT(n)\t=\tT( )\t+\t1 Solution:\t Applying\t the\t logic\t of\t Problem-40\t gives\t .\t Applying\t the\t master theorem\t would\t result\t in\t S(m)\t =\t O(logm).\t Substituting\t m\t =\t logn,\t gives\t T(n)\t =\t S(logn)\t = O(loglogn). Problem-42\u2003\u2003Find\tthe\tcomplexity\tof\tthe\trecurrence:\tT(n)\t=\t2T( )\t+\t1 Solution:\t Applying\t the\t logic\t of\t Problem-40\t gives:\t .\t Using\t the\t master theorem\tresults\tS(m)\t=\t .\tSubstituting\tm\t=\tlogn\tgives\tT(n)\t=O(logn). Problem-43\u2003\u2003Find\tthe\tcomplexity\tof\tthe\tbelow\tfunction. Solution:\tConsider\tthe\tcomments\tin\tthe\tfunction\tbelow: For\tthe\tabove\tcode,\tthe\trecurrence\tfunction\tcan\tbe\tgiven\tas:\tT(n)\t=\tT( )\t+\t1.\tThis\tis\tsame\tas that\tof\tProblem-41. Problem-44\u2003\u2003Analyze\tthe\trunning\ttime\tof\tthe\tfollowing\trecursive\tpseudo-code\tas\ta\tfunction\tof n. Solution:\tConsider\tthe\tcomments\tin\tbelow\tpseudo-code\tand\tcall\trunning\ttime\tof\tfunction(n)\tas T(n). T(n)\tcan\tbe\tdefined\tas\tfollows: Using\tthe\tmaster\ttheorem\tgives:\t . Problem-45\u2003\u2003Find\tthe\tcomplexity\tof\tthe\tbelow\tpseudocode: Solution:\tConsider\tthe\tcomments\tin\tthe\tpseudocode\tbelow: The\trecurrence\tfor\tthis\tfunction\tis\tT(n)\t=\tT(n/2)\t+\tn.\tUsing\tmaster\ttheorem,\twe\tget\tT(n)\t=\tO(n). Problem-46\u2003\u2003Running\ttime\tof\tthe\tfollowing\tprogram? Solution:\tConsider\tthe\tcomments\tin\tthe\tbelow\tfunction: Complexity\tof\tabove\tprogram\tis:\tO(nlogn). Problem-47\u2003\u2003Running\ttime\tof\tthe\tfollowing\tprogram? Solution:\tConsider\tthe\tcomments\tin\tthe\tbelow\tfunction: The\ttime\tcomplexity\tof\tthis\tprogram\tis:\tO(n2). Problem-48\u2003\u2003Find\tthe\tcomplexity\tof\tthe\tbelow\tfunction: Solution:\tConsider\tthe\tcomments\tin\tthe\tbelow\tfunction: The\trecurrence\tfor\tthis\tfunction\tis:\t .\tUsing\tmaster\ttheorem,\twe\tget\tT(n)\t= O(n). Problem-49\u2003\u2003Find\tthe\tcomplexity\tof\tthe\tbelow\tfunction: Solution: Time\tComplexity:\tO(logn\t*\tlogn)\t=\tO(log2n). Problem-50\u2003\u2003\u2211i\u2264k\u2264n\tO(n),\twhere\tO(n)\tstands\tfor\torder\tn\tis: (A) O(n) (B) O(n2) (C) O(n3) (D) O(3n2) (E) O(1.5n2) Solution:\t(B).\t\u2211i\u2264k\u2264n\tO(n)\t=\tO(n)\t\u2211i\u2264k\u2264n\t1\t=\tO(n2). Problem-51\u2003\u2003Which\tof\tthe\tfollowing\tthree\tclaims\tare\tcorrect? I\u2003(n\t+\tk)m\t=\t\u0398(nm),\twhere\tk\tand\tm\tare\tconstants II\u20032n+1\t=\tO(2n) III\u200322n+1\t=\tO(2n) (A) I\tand\tII (B) I\tand\tIII (C) II\tand\tIII (D) I,\tII\tand\tIII Solution:\t(A).\t(I)\t(n\t+\tk)m\t=nh\t+\tc1*nk\u20131\t+\t...\tkm\t=\t\u0398(nh)\tand\t(II)\t2n+1\t=\t2*2n\t=\tO(2n) Problem-52\u2003\u2003Consider\tthe\tfollowing\tfunctions: f(n)\t=\t2n g(n)\t=\tn! h(n)\t=\tnlogn Which\tof\tthe\tfollowing\tstatements\tabout\tthe\tasymptotic\tbehavior\tof\tf(n),\tg(n),\tand\th(n)\tis true? (A) f(n)\t=\tO(g(n));\tg(n)\t=\tO(h(n)) (B) f(n)\t=\t\u2126\t(g(n));\tg(n)\t=\tO(h(n)) (C) g(n)\t=\tO(f(n));\th(n)\t=\tO(f(n)) (D) h(n)\t=\tO(f(n));\tg(n)\t=\t\u2126\t(f(n)) Solution:\t(D).\tAccording\tto\tthe\trate\tof\tgrowth:\th(n)\t<\tf(n)\t<\tg(n)\t(g(n)\tis\tasymptotically\tgreater than\t f(n),\t and\tf(n)\t is\t asymptotically\t greater\t than\t h(n)).\t We\t can\t easily\t see\tthe\t above\t order\t by taking\tlogarithms\tof\tthe\tgiven\t3\tfunctions:\tlognlogn\t<\tn\t<\tlog(n!).\tNote\tthat,\tlog(n!)\t=\tO(nlogn). Problem-53\u2003\u2003Consider\tthe\tfollowing\tsegment\tof\tC-code: The\tnumber\tof\tcomparisons\tmade\tin\tthe\texecution\tof\tthe\tloop\tfor\tany\tn\t>\t0\tis: (A) (B) n (C) (D) Solution:\t(a).\tLet\tus\tassume\tthat\tthe\tloop\texecutes\tk\ttimes.\tAfter\tkth\tstep\tthe\tvalue\tof\tj\t is\t 2k. Taking\tlogarithms\ton\tboth\tsides\tgives\t .\tSince\twe\tare\tdoing\tone\tmore\tcomparison\tfor exiting\tfrom\tthe\tloop,\tthe\tanswer\tis\t . Problem-54\u2003\u2003Consider\tthe\tfollowing\tC\tcode\tsegment.\tLet\tT(n)\tdenote\tthe\tnumber\tof\ttimes\tthe for\tloop\tis\texecuted\tby\tthe\tprogram\ton\tinput\tn.\tWhich\tof\tthe\tfollowing\tis\ttrue? (A) T(n)\t=\tO( )\tand\tT(n)\t=\t\u2126( ) (B) T(n)\t=\tO( )\tand\tT(n)\t=\t\u2126(1) (C) T(n)\t=\tO(n)\tand\tT(n)\t=\t\u2126( ) (D) None\tof\tthe\tabove Solution:\t(B).\tBig\tO\tnotation\tdescribes\tthe\ttight\tupper\tbound\tand\tBig\tOmega\tnotation\tdescribes the\ttight\tlower\tbound\tfor\tan\talgorithm.\tThe\tfor\tloop\tin\tthe\tquestion\tis\trun\tmaximum\t \ttimes\tand minimum\t1\ttime.\tTherefore,\tT(n)\t=\tO( )\tand\tT(n)\t=\t\u2126(1). Problem-55\u2003\u2003In\tthe\tfollowing\tC\tfunction,\tlet\tn\t\u2265\tm.\tHow\tmany\trecursive\tcalls\tare\tmade\tby this\tfunction? (A) (B) \u2126(n) (C) (D) \u0398(n) Solution:\tNo\toption\tis\tcorrect.\tBig\tO\tnotation\tdescribes\tthe\ttight\tupper\tbound\tand\tBig\tOmega notation\tdescribes\tthe\ttight\tlower\tbound\tfor\tan\talgorithm.\tFor\tm\t=\t2\tand\tfor\tall\tn\t=\t2i,\tthe\trunning time\tis\tO(1)\twhich\tcontradicts\tevery\toption. Problem-56\u2003\u2003Suppose\tT(n)\t=\t2T(n/2)\t+\tn,\tT(O)=T(1)=1.\tWhich\tone\tof\tthe\tfollowing\tis\tfalse? (A) T(n)\t=\tO(n2) (B) T(n)\t=\t\u0398(nlogn) (C) T(n)\t=\tQ(n2) (D) T(n)\t=\tO(nlogn) Solution:\t(C).\tBig\tO\tnotation\tdescribes\tthe\ttight\tupper\tbound\tand\tBig\tOmega\tnotation\tdescribes the\ttight\tlower\tbound\tfor\tan\talgorithm.\tBased\ton\tmaster\ttheorem,\twe\tget\tT(n)\t=\t\u0398(nlogn).\tThis indicates\tthat\ttight\tlower\tbound\tand\ttight\tupper\tbound\tare\tthe\tsame.\tThat\tmeans,\tO(nlogn)\tand \u2126(nlogn)\tare\tcorrect\tfor\tgiven\trecurrence.\tSo\toption\t(C)\tis\twrong. Problem-57\u2003\u2003Find\tthe\tcomplexity\tof\tthe\tbelow\tfunction: Solution: Time\tComplexity:\tO(n5). Problem-58\u2003\u2003To\tcalculate\t9n,\tgive\tan\talgorithm\tand\tdiscuss\tits\tcomplexity. Solution:\tStart\twith\t1\tand\tmultiply\tby\t9\tuntil\treaching\t9n. Time\tComplexity:\tThere\tare\tn\t\u2013\t1\tmultiplications\tand\teach\ttakes\tconstant\ttime\tgiving\ta\t\u0398(n) algorithm. Problem-59\u2003\u2003For\tProblem-58,\tcan\twe\timprove\tthe\ttime\tcomplexity? Solution:\tRefer\tto\tthe\tDivide\tand\tConquer\tchapter. Problem-60\u2003\u2003Find\tthe\ttime\tcomplexity\tof\trecurrence\t . Solution:\tLet\tus\tsolve\tthis\tproblem\tby\tmethod\tof\tguessing.\tThe\ttotal\tsize\ton\teach\tlevel\tof\tthe recurrance\ttree\tis\tless\tthan\tn,\tso\twe\tguess\tthat\tf(n)\t=\tn\twill\tdominate.\tAssume\tfor\tall\ti\t<\tn\tthat c1n\t\u2264\tT(i)\t<\tc2n.\tThen, If\tc1\t\u2265\t8k\tand\tc2\t\u2264\t8k,\tthen\tc1n\t=\tT(n)\t=\tc2n.\tSo,\tT(n)\t=\t\u0398(n).\tIn\tgeneral,\tif\tyou\thave\tmultiple recursive\tcalls,\tthe\tsum\tof\tthe\targuments\tto\tthose\tcalls\tis\tless\tthan\tn\t(in\tthis\tcase\t ), and\tf(n)\tis\treasonably\tlarge,\ta\tgood\tguess\tis\tT(n)\t=\t\u0398(f(n)). Problem-61\u2003\u2003Solve\t the\t following\t recurrence\t relation\t using\t the\t recursion\t tree\t method:\t . Solution:\tHow\tmuch\twork\tdo\twe\tdo\tin\teach\tlevel\tof\tthe\trecursion\ttree? In\tlevel\t0,\twe\ttake\tn2\ttime.\tAt\tlevel\t1,\tthe\ttwo\tsubproblems\ttake\ttime: At\t level\t 2\t the\t four\t subproblems\t are\t of\t size\t \t and\t \t respectively.\t These\t two subproblems\ttake\ttime: Similarly\tthe\tamount\tof\twork\tat\tlevel\tk\tis\tat\tmost\t . Let\t ,\tthe\ttotal\truntime\tis\tthen: That\tis,\tthe\tfirst\tlevel\tprovides\ta\tconstant\tfraction\tof\tthe\ttotal\truntime. Problem-62\u2003\u2003Rank\tthe\tfollowing\tfunctions\tby\torder\tof\tgrowth:\t(n\t+\t1)!,\tn!,\t4n,\tn\t\u00d7\t3n,\t3n\t+\tn2 +\t20n,\t ,\tn2\t+\t200,\t20n\t+\t500,\t2lgn,\tn2/3,\t1. Solution: Problem-63\u2003\u2003Find\tthe\tcomplexity\tof\tthe\tbelow\tfunction: Solution:\tConsider\tthe\tworst-case. Time\tComplexity:\tO(n2). Problem-64\u2003\u2003Can\twe\tsay\t ? Solution:\tYes:\tbecause\t Problem-65\u2003\u2003Can\twe\tsay\t23n\t=\tO(2n)? Solution:\tNo:\tbecause\t23n\t=\t(23)n\t=\t8n\tnot\tless\tthan\t2n."
            },
            {
                "subchapter_title": "2.1\tIntroduction",
                "content": "In\tthis\tchapter,\twe\twill\tlook\tat\tone\tof\tthe\timportant\ttopics,\t\u201crecursion\u201d,\twhich\twill\tbe\tused\tin almost\tevery\tchapter,\tand\talso\tits\trelative\t\u201cbacktracking\u201d."
            },
            {
                "subchapter_title": "2.2\tWhat\tis\tRecursion?",
                "content": "Any\t function\t which\t calls\t itself\t is\t called\t recursive.\t A\t recursive\t method\t solves\t a\t problem\t by calling\t a\t copy\t of\t itself\t to\t work\t on\t a\t smaller\t problem.\t This\t is\t called\t the\t recursion\t step.\t The recursion\tstep\tcan\tresult\tin\tmany\tmore\tsuch\trecursive\tcalls. It\tis\timportant\tto\tensure\tthat\tthe\trecursion\tterminates.\tEach\ttime\tthe\tfunction\tcalls\titself\twith\ta slightly\t simpler\t version\t of\t the\t original\t problem.\t The\t sequence\t of\t smaller\t problems\t must eventually\tconverge\ton\tthe\tbase\tcase."
            },
            {
                "subchapter_title": "2.3\tWhy\tRecursion?",
                "content": "Recursion\tis\ta\tuseful\ttechnique\tborrowed\tfrom\tmathematics.\tRecursive\tcode\tis\tgenerally\tshorter and\teasier\tto\twrite\tthan\titerative\tcode.\tGenerally,\tloops\tare\tturned\tinto\trecursive\tfunctions\twhen they\tare\tcompiled\tor\tinterpreted. Recursion\tis\tmost\tuseful\tfor\ttasks\tthat\tcan\tbe\tdefined\tin\tterms\tof\tsimilar\tsubtasks.\tFor\texample, sort,\tsearch,\tand\ttraversal\tproblems\toften\thave\tsimple\trecursive\tsolutions."
            },
            {
                "subchapter_title": "2.4\tFormat\tof\ta\tRecursive\tFunction",
                "content": "A\trecursive\tfunction\tperforms\ta\ttask\tin\tpart\tby\tcalling\titself\tto\tperform\tthe\tsubtasks.\tAt\tsome point,\tthe\tfunction\tencounters\ta\tsubtask\tthat\tit\tcan\tperform\twithout\tcalling\titself.\tThis\tcase,\twhere the\tfunction\tdoes\tnot\trecur,\tis\tcalled\tthe\tbase\tcase.\tThe\tformer,\twhere\tthe\tfunction\tcalls\titself\tto perform\ta\tsubtask,\tis\treferred\tto\tas\tthe\tecursive\tcase.\tWe\tcan\twrite\tall\trecursive\tfunctions\tusing the\tformat: As\tan\texample\tconsider\tthe\tfactorial\tfunction:\tn!\tis\tthe\tproduct\tof\tall\tintegers\tbetween\tn\tand\t1. The\tdefinition\tof\trecursive\tfactorial\tlooks\tlike: This\t definition\t can\t easily\t be\t converted\t to\t recursive\t implementation.\t Here\t the\t problem\t is determining\t the\t value\t of\t n!,\t and\t the\t subproblem\t is\t determining\t the\t value\t of\t (n\t \u2013\t l)!.\t In\t the recursive\tcase,\twhen\tn\tis\tgreater\tthan\t1,\tthe\tfunction\tcalls\titself\tto\tdetermine\tthe\tvalue\tof\t(n\t\u2013\tl)! and\tmultiplies\tthat\twith\tn. In\tthe\tbase\tcase,\twhen\tn\tis\t0\tor\t1,\tthe\tfunction\tsimply\treturns\t1.\tThis\tlooks\tlike\tthe\tfollowing:"
            },
            {
                "subchapter_title": "2.5\tRecursion\tand\tMemory\t(Visualization)",
                "content": "Each\trecursive\tcall\tmakes\ta\tnew\tcopy\tof\tthat\tmethod\t(actually\tonly\tthe\tvariables)\tin\tmemory. Once\ta\tmethod\tends\t(that\tis,\treturns\tsome\tdata),\tthe\tcopy\tof\tthat\treturning\tmethod\tis\tremoved from\tmemory.\tThe\trecursive\tsolutions\tlook\tsimple\tbut\tvisualization\tand\ttracing\ttakes\ttime.\tFor better\tunderstanding,\tlet\tus\tconsider\tthe\tfollowing\texample. For\tthis\texample,\tif\twe\tcall\tthe\tprint\tfunction\twith\tn=4,\tvisually\tour\tmemory\tassignments\tmay look\tlike: Now,\tlet\tus\tconsider\tour\tfactorial\tfunction.\tThe\tvisualization\tof\tfactorial\tfunction\twith\tn=4\twill look\tlike:"
            },
            {
                "subchapter_title": "2.6\tRecursion\tversus\tIteration",
                "content": "While\t discussing\t recursion,\t the\t basic\t question\t that\t comes\t to\t mind\t is:\t which\t way\t is\t better?\t \u2013 iteration\t or\t recursion?\t The\t answer\t to\t this\t question\t depends\t on\t what\t we\t are\t trying\t to\t do.\t A recursive\tapproach\tmirrors\tthe\tproblem\tthat\twe\tare\ttrying\tto\tsolve.\tA\trecursive\tapproach\tmakes it\tsimpler\tto\tsolve\ta\tproblem\tthat\tmay\tnot\thave\tthe\tmost\tobvious\tof\tanswers.\tBut,\trecursion\tadds overhead\tfor\teach\trecursive\tcall\t(needs\tspace\ton\tthe\tstack\tframe). Recursion \u2022 Terminates\twhen\ta\tbase\tcase\tis\treached. \u2022 Each\trecursive\tcall\trequires\textra\tspace\ton\tthe\tstack\tframe\t(memory). \u2022 If\twe\tget\tinfinite\trecursion,\tthe\tprogram\tmay\trun\tout\tof\tmemory\tand\tresult\tin\tstack overflow. \u2022 Solutions\tto\tsome\tproblems\tare\teasier\tto\tformulate\trecursively. Iteration \u2022 Terminates\twhen\ta\tcondition\tis\tproven\tto\tbe\tfalse. \u2022 Each\titeration\tdoes\tnot\trequire\textra\tspace. \u2022 An\tinfinite\tloop\tcould\tloop\tforever\tsince\tthere\tis\tno\textra\tmemory\tbeing\tcreated. \u2022 Iterative\t solutions\t to\t a\t problem\t may\t not\t always\t be\t as\t obvious\t as\t a\t recursive solution."
            },
            {
                "subchapter_title": "2.7\tNotes\ton\tRecursion",
                "content": "\u2022 Recursive\talgorithms\thave\ttwo\ttypes\tof\tcases,\trecursive\tcases\tand\tbase\tcases. \u2022 Every\trecursive\tfunction\tcase\tmust\tterminate\tat\ta\tbase\tcase. \u2022 Generally,\titerative\tsolutions\tare\tmore\tefficient\tthan\trecursive\tsolutions\t[due\tto\tthe overhead\tof\tfunction\tcalls]. \u2022 A\trecursive\talgorithm\tcan\tbe\timplemented\twithout\trecursive\tfunction\tcalls\tusing\ta stack,\tbut\tit\u2019s\tusually\tmore\ttrouble\tthan\tits\tworth.\tThat\tmeans\tany\tproblem\tthat\tcan be\tsolved\trecursively\tcan\talso\tbe\tsolved\titeratively. \u2022 For\tsome\tproblems,\tthere\tare\tno\tobvious\titerative\talgorithms. \u2022 Some\tproblems\tare\tbest\tsuited\tfor\trecursive\tsolutions\twhile\tothers\tare\tnot."
            },
            {
                "subchapter_title": "2.8\tExample\tAlgorithms\tof\tRecursion",
                "content": "\u2022 Fibonacci\tSeries,\tFactorial\tFinding \u2022 Merge\tSort,\tQuick\tSort \u2022 Binary\tSearch \u2022 Tree\tTraversals\tand\tmany\tTree\tProblems:\tInOrder,\tPreOrder\tPostOrder \u2022 Graph\tTraversals:\tDFS\t[Depth\tFirst\tSearch]\tand\tBFS\t[Breadth\tFirst\tSearch] \u2022 Dynamic\tProgramming\tExamples \u2022 Divide\tand\tConquer\tAlgorithms \u2022 Towers\tof\tHanoi \u2022 Backtracking\tAlgorithms\t[we\twill\tdiscuss\tin\tnext\tsection]"
            },
            {
                "subchapter_title": "2.9\tRecursion:\tProblems\t&\tSolutions",
                "content": "In\tthis\tchapter\twe\tcover\ta\tfew\tproblems\twith\trecursion\tand\twe\twill\tdiscuss\tthe\trest\tin\tother chapters.\tBy\tthe\ttime\tyou\tcomplete\treading\tthe\tentire\tbook,\tyou\twill\tencounter\tmany\trecursion problems. Problem-1\u2003\u2003Discuss\tTowers\tof\tHanoi\tpuzzle. Solution:\tThe\tTowers\tof\tHanoi\tis\ta\tmathematical\tpuzzle.\tIt\tconsists\tof\tthree\trods\t(or\tpegs\tor towers),\tand\ta\tnumber\tof\tdisks\tof\tdifferent\tsizes\twhich\tcan\tslide\tonto\tany\trod.\tThe\tpuzzle\tstarts with\tthe\tdisks\ton\tone\trod\tin\tascending\torder\tof\tsize,\tthe\tsmallest\tat\tthe\ttop,\tthus\tmaking\ta\tconical shape.\t The\t objective\t of\t the\t puzzle\t is\t to\t move\t the\t entire\t stack\t to\t another\t rod,\t satisfying\t the following\trules: \u2022 Only\tone\tdisk\tmay\tbe\tmoved\tat\ta\ttime. \u2022 Each\tmove\tconsists\tof\ttaking\tthe\tupper\tdisk\tfrom\tone\tof\tthe\trods\tand\tsliding\tit\tonto another\trod,\ton\ttop\tof\tthe\tother\tdisks\tthat\tmay\talready\tbe\tpresent\ton\tthat\trod. \u2022 No\tdisk\tmay\tbe\tplaced\ton\ttop\tof\ta\tsmaller\tdisk. Algorithm: \u2022 Move\tthe\ttop\tn\t\u2013\t1\tdisks\tfrom\tSource\tto\tAuxiliary\ttower, \u2022 Move\tthe\tnth\tdisk\tfrom\tSource\tto\tDestination\ttower, \u2022 Move\tthe\tn\t\u2013\t1\tdisks\tfrom\tAuxiliary\ttower\tto\tDestination\ttower. \u2022 Transferring\tthe\ttop\tn\t\u2013\t1\tdisks\tfrom\tSource\tto\tAuxiliary\ttower\tcan\tagain\tbe\tthought of\tas\ta\tfresh\tproblem\tand\tcan\tbe\tsolved\tin\tthe\tsame\tmanner.\tOnce\twe\tsolve\tTowers of\tHanoi\twith\tthree\tdisks,\twe\tcan\tsolve\tit\twith\tany\tnumber\tof\tdisks\twith\tthe\tabove algorithm. Problem-2\u2003\u2003Given\tan\tarray,\tcheck\twhether\tthe\tarray\tis\tin\tsorted\torder\twith\trecursion. Solution: Time\tComplexity:\tO(n).\tSpace\tComplexity:\tO(n)\tfor\trecursive\tstack\tspace."
            },
            {
                "subchapter_title": "2.10\tWhat\tis\tBacktracking?",
                "content": "Backtracking\t is\t an\t improvement\t of\t the\t brute\t force\t approach.\t It\t systematically\t searches\t for\t a solution\tto\ta\tproblem\tamong\tall\tavailable\toptions.\tIn\tbacktracking,\twe\tstart\twith\tone\tpossible option\tout\tof\tmany\tavailable\toptions\tand\ttry\tto\tsolve\tthe\tproblem\tif\twe\tare\table\tto\tsolve\tthe problem\twith\tthe\tselected\tmove\tthen\twe\twill\tprint\tthe\tsolution\telse\twe\twill\tbacktrack\tand\tselect some\tother\toption\tand\ttry\tto\tsolve\tit.\tIf\tnone\tif\tthe\toptions\twork\tout\twe\twill\tclaim\tthat\tthere\tis\tno solution\tfor\tthe\tproblem. Backtracking\tis\ta\tform\tof\trecursion.\tThe\tusual\tscenario\tis\tthat\tyou\tare\tfaced\twith\ta\tnumber\tof options,\tand\tyou\tmust\tchoose\tone\tof\tthese.\tAfter\tyou\tmake\tyour\tchoice\tyou\twill\tget\ta\tnew\tset\tof options;\tjust\twhat\tset\tof\toptions\tyou\tget\tdepends\ton\twhat\tchoice\tyou\tmade.\tThis\tprocedure\tis repeated\tover\tand\tover\tuntil\tyou\treach\ta\tfinal\tstate.\tIf\tyou\tmade\ta\tgood\tsequence\tof\tchoices,\tyour final\tstate\tis\ta\tgoal\tstate;\tif\tyou\tdidn\u2019t,\tit\tisn\u2019t. Backtracking\tcan\tbe\tthought\tof\tas\ta\tselective\ttree/graph\ttraversal\tmethod.\tThe\ttree\tis\ta\tway\tof representing\t some\t initial\t starting\t position\t (the\t root\t node)\t and\t a\t final\t goal\t state\t (one\t of\t the leaves).\t Backtracking\t allows\t us\t to\t deal\t with\t situations\t in\t which\t a\t raw\t brute-force\t approach would\texplode\tinto\tan\timpossible\tnumber\tof\toptions\tto\tconsider.\tBacktracking\tis\ta\tsort\tof\trefined brute\tforce.\tAt\teach\tnode,\twe\teliminate\tchoices\tthat\tare\tobviously\tnot\tpossible\tand\tproceed\tto recursively\tcheck\tonly\tthose\tthat\thave\tpotential. What\u2019s\tinteresting\tabout\tbacktracking\tis\tthat\twe\tback\tup\tonly\tas\tfar\tas\tneeded\tto\treach\ta\tprevious decision\tpoint\twith\tan\tas-yet-unexplored\talternative.\tIn\tgeneral,\tthat\twill\tbe\tat\tthe\tmost\trecent decision\tpoint.\tEventually,\tmore\tand\tmore\tof\tthese\tdecision\tpoints\twill\thave\tbeen\tfully\texplored, and\twe\twill\thave\tto\tbacktrack\tfurther\tand\tfurther.\tIf\twe\tbacktrack\tall\tthe\tway\tto\tour\tinitial\tstate and\t have\t explored\t all\t alternatives\t from\t there,\t we\t can\t conclude\t the\t particular\t problem\t is unsolvable.\tIn\tsuch\ta\tcase,\twe\twill\thave\tdone\tall\tthe\twork\tof\tthe\texhaustive\trecursion\tand\tknown that\tthere\tis\tno\tviable\tsolution\tpossible. \u2022 Sometimes\tthe\tbest\talgorithm\tfor\ta\tproblem\tis\tto\ttry\tall\tpossibilities. \u2022 This\tis\talways\tslow,\tbut\tthere\tare\tstandard\ttools\tthat\tcan\tbe\tused\tto\thelp. \u2022 Tools:\t algorithms\t for\t generating\t basic\t objects,\t such\t as\t binary\t strings\t [2n possibilities\t for\t n-bit\t string],\t permutations\t [n!],\t combinations\t [n!/r!(n\t \u2013\t r)!], general\tstrings\t[k\t\u2013ary\tstrings\tof\tlength\tn\thas\tkn\tpossibilities],\tetc... \u2022 Backtracking\tspeeds\tthe\texhaustive\tsearch\tby\tpruning."
            },
            {
                "subchapter_title": "2.11\tExample\tAlgorithms\tof\tBacktracking",
                "content": "\u2022 Binary\tStrings:\tgenerating\tall\tbinary\tstrings \u2022 Generating\tk\t\u2013\tary\tStrings \u2022 N-Queens\tProblem \u2022 The\tKnapsack\tProblem \u2022 Generalized\tStrings \u2022 Hamiltonian\tCycles\t[refer\tto\tGraphs\tchapter] \u2022 Graph\tColoring\tProblem"
            },
            {
                "subchapter_title": "2.12\tBacktracking:\tProblems\t&\tSolutions",
                "content": "Problem-3\u2003\u2003Generate\tall\tthe\tstrings\tof\tn\tbits.\tAssume\tA[0..n\t\u2013\t1]\tis\tan\tarray\tof\tsize\tn. Solution: Let\tT(n)\tbe\tthe\trunning\ttime\tof\tbinary(n).\tAssume\tfunction\tprintf\ttakes\ttime\tO(1). Using\tSubtraction\tand\tConquer\tMaster\ttheorem\twe\tget:\tT(n)\t=\tO(2n).\tThis\tmeans\tthe\talgorithm for\tgenerating\tbit-strings\tis\toptimal. Problem-4\u2003\u2003Generate\tall\tthe\tstrings\tof\tlength\tn\tdrawn\tfrom\t0...\tk\t\u2013\t1. Solution:\tLet\tus\tassume\twe\tkeep\tcurrent\tk-ary\tstring\tin\tan\tarray\tA[0..\tn\t\u2013\t1].\tCall\tfunction\tk- string(n,\tk): Let\tT(n)\tbe\tthe\trunning\ttime\tof\tk\t\u2013\tstring(n).\tThen, Using\tSubtraction\tand\tConquer\tMaster\ttheorem\twe\tget:\tT(n)\t=\tO(kn). Note:\tFor\tmore\tproblems,\trefer\tto\tString\tAlgorithms\tchapter. Problem-5\u2003\u2003Finding\tthe\tlength\tof\tconnected\tcells\tof\t1s\t(regions)\tin\tan\tmatrix\tof\tOs\tand 1s:\tGiven\ta\tmatrix,\teach\tof\twhich\tmay\tbe\t1\tor\t0.\tThe\tfilled\tcells\tthat\tare\tconnected\tform\ta region.\tTwo\tcells\tare\tsaid\tto\tbe\tconnected\tif\tthey\tare\tadjacent\tto\teach\tother\thorizontally, vertically\tor\tdiagonally.\tThere\tmay\tbe\tseveral\tregions\tin\tthe\tmatrix.\tHow\tdo\tyou\tfind\tthe largest\tregion\t(in\tterms\tof\tnumber\tof\tcells)\tin\tthe\tmatrix? Solution:\tThe\tsimplest\tidea\tis:\tfor\teach\tlocation\ttraverse\tin\tall\t8\tdirections\tand\tin\teach\tof\tthose directions\tkeep\ttrack\tof\tmaximum\tregion\tfound. Sample\tCall: Problem-6\u2003\u2003Solve\tthe\trecurrence\tT(n)\t=\t2T(n\t\u2013\t1)\t+\t2n. Solution:\t At\t each\t level\t of\t the\t recurrence\t tree,\t the\t number\t of\t problems\t is\t double\t from\t the previous\tlevel,\twhile\tthe\tamount\tof\twork\tbeing\tdone\tin\teach\tproblem\tis\thalf\tfrom\tthe\tprevious level.\tFormally,\tthe\tith\tlevel\thas\t2i\tproblems,\teach\trequiring\t2n\u2013i\twork.\tThus\tthe\tith\tlevel\trequires exactly\t2n\twork.\tThe\tdepth\tof\tthis\ttree\tis\tn,\tbecause\tat\tthe\tith\tlevel,\tthe\toriginating\tcall\twill\tbe T(n\t\u2013\ti).\tThus\tthe\ttotal\tcomplexity\tfor\tT(n)\tis\tT(n2n)."
            },
            {
                "subchapter_title": "3.1\tWhat\tis\ta\tLinked\tList?",
                "content": "A\tlinked\tlist\tis\ta\tdata\tstructure\tused\tfor\tstoring\tcollections\tof\tdata.\tA\tlinked\tlist\thas\tthe\tfollowing properties. \u2022 Successive\telements\tare\tconnected\tby\tpointers \u2022 The\tlast\telement\tpoints\tto\tNULL \u2022 Can\tgrow\tor\tshrink\tin\tsize\tduring\texecution\tof\ta\tprogram \u2022 Can\tbe\tmade\tjust\tas\tlong\tas\trequired\t(until\tsystems\tmemory\texhausts) \u2022 Does\t not\t waste\t memory\t space\t (but\t takes\t some\t extra\t memory\t for\t pointers).\t It allocates\tmemory\tas\tlist\tgrows."
            },
            {
                "subchapter_title": "3.2\tLinked\tLists\tADT",
                "content": "The\tfollowing\toperations\tmake\tlinked\tlists\tan\tADT: Main\tLinked\tLists\tOperations \u2022 Insert:\tinserts\tan\telement\tinto\tthe\tlist \u2022 Delete:\tremoves\tand\treturns\tthe\tspecified\tposition\telement\tfrom\tthe\tlist Auxiliary\tLinked\tLists\tOperations \u2022 Delete\tList:\tremoves\tall\telements\tof\tthe\tlist\t(disposes\tthe\tlist) \u2022 Count:\treturns\tthe\tnumber\tof\telements\tin\tthe\tlist \u2022 Find\tnth\tnode\tfrom\tthe\tend\tof\tthe\tlist"
            },
            {
                "subchapter_title": "3.3\tWhy\tLinked\tLists?",
                "content": "There\t are\t many\t other\t data\t structures\t that\t do\t the\t same\t thing\t as\t linked\t lists.\t Before\t discussing linked\t lists\t it\t is\t important\t to\t understand\t the\t difference\t between\t linked\t lists\t and\t arrays.\t Both linked\tlists\tand\tarrays\tare\tused\tto\tstore\tcollections\tof\tdata,\tand\tsince\tboth\tare\tused\tfor\tthe\tsame purpose,\twe\tneed\tto\tdifferentiate\ttheir\tusage.\tThat\tmeans\tin\twhich\tcases\tarrays\tare\tsuitable\tand in\twhich\tcases\tlinked\tlists\tare\tsuitable."
            },
            {
                "subchapter_title": "3.4\tArrays\tOverview",
                "content": "One\tmemory\tblock\tis\tallocated\tfor\tthe\tentire\tarray\tto\thold\tthe\telements\tof\tthe\tarray.\tThe\tarray elements\t can\t be\t accessed\t in\t constant\t time\t by\t using\t the\t index\t of\t the\t particular\t element\t as\t the subscript. Why\tConstant\tTime\tfor\tAccessing\tArray\tElements? To\taccess\tan\tarray\telement,\tthe\taddress\tof\tan\telement\tis\tcomputed\tas\tan\toffset\tfrom\tthe\tbase address\tof\tthe\tarray\tand\tone\tmultiplication\tis\tneeded\tto\tcompute\twhat\tis\tsupposed\tto\tbe\tadded\tto the\tbase\taddress\tto\tget\tthe\tmemory\taddress\tof\tthe\telement.\tFirst\tthe\tsize\tof\tan\telement\tof\tthat\tdata type\tis\tcalculated\tand\tthen\tit\tis\tmultiplied\twith\tthe\tindex\tof\tthe\telement\tto\tget\tthe\tvalue\tto\tbe added\tto\tthe\tbase\taddress. This\tprocess\ttakes\tone\tmultiplication\tand\tone\taddition.\tSince\tthese\ttwo\toperations\ttake\tconstant time,\twe\tcan\tsay\tthe\tarray\taccess\tcan\tbe\tperformed\tin\tconstant\ttime. Advantages\tof\tArrays \u2022 Simple\tand\teasy\tto\tuse \u2022 Faster\taccess\tto\tthe\telements\t(constant\taccess) Disadvantages\tof\tArrays \u2022 Preallocates\tall\tneeded\tmemory\tup\tfront\tand\twastes\tmemory\tspace\tfor\tindices\tin\tthe array\tthat\tare\tempty. \u2022 Fixed\tsize:\tThe\tsize\tof\tthe\tarray\tis\tstatic\t(specify\tthe\tarray\tsize\tbefore\tusing\tit). \u2022 One\tblock\tallocation:\tTo\tallocate\tthe\tarray\titself\tat\tthe\tbeginning,\tsometimes\tit\tmay not\tbe\tpossible\tto\tget\tthe\tmemory\tfor\tthe\tcomplete\tarray\t(if\tthe\tarray\tsize\tis\tbig). \u2022 Complex\tposition-based\tinsertion:\tTo\tinsert\tan\telement\tat\ta\tgiven\tposition,\twe\tmay need\tto\tshift\tthe\texisting\telements.\tThis\twill\tcreate\ta\tposition\tfor\tus\tto\tinsert\tthe new\telement\tat\tthe\tdesired\tposition.\tIf\tthe\tposition\tat\twhich\twe\twant\tto\tadd\tan element\tis\tat\tthe\tbeginning,\tthen\tthe\tshifting\toperation\tis\tmore\texpensive. Dynamic\tArrays Dynamic\tarray\t(also\tcalled\tas\tgrowable\tarray,\tresizable\tarray,\tdynamic\ttable,\tor\tarray\tlist)\tis\ta random\taccess,\tvariable-size\tlist\tdata\tstructure\tthat\tallows\telements\tto\tbe\tadded\tor\tremoved. One\tsimple\tway\tof\timplementing\tdynamic\tarrays\tis\tto\tinitially\tstart\twith\tsome\tfixed\tsize\tarray. As\tsoon\tas\tthat\tarray\tbecomes\tfull,\tcreate\tthe\tnew\tarray\tdouble\tthe\tsize\tof\tthe\toriginal\tarray. Similarly,\treduce\tthe\tarray\tsize\tto\thalf\tif\tthe\telements\tin\tthe\tarray\tare\tless\tthan\thalf. Note:\tWe\twill\tsee\tthe\timplementation\tfor\tdynamic\tarrays\tin\tthe\tStacks,\tQueues\tand\tHashing chapters. Advantages\tof\tLinked\tLists Linked\tlists\thave\tboth\tadvantages\tand\tdisadvantages.\tThe\tadvantage\tof\tlinked\tlists\tis\tthat\tthey\tcan be\texpanded\tin\tconstant\ttime.\tTo\tcreate\tan\tarray,\twe\tmust\tallocate\tmemory\tfor\ta\tcertain\tnumber of\telements.\tTo\tadd\tmore\telements\tto\tthe\tarray\twhen\tfull,\twe\tmust\tcreate\ta\tnew\tarray\tand\tcopy the\told\tarray\tinto\tthe\tnew\tarray.\tThis\tcan\ttake\ta\tlot\tof\ttime. We\tcan\tprevent\tthis\tby\tallocating\tlots\tof\tspace\tinitially\tbut\tthen\twe\tmight\tallocate\tmore\tthan\twe need\tand\twaste\tmemory.\tWith\ta\tlinked\tlist,\twe\tcan\tstart\twith\tspace\tfor\tjust\tone\tallocated\telement and\tadd\ton\tnew\telements\teasily\twithout\tthe\tneed\tto\tdo\tany\tcopying\tand\treallocating. Issues\twith\tLinked\tLists\t(Disadvantages) There\tare\ta\tnumber\tof\tissues\twith\tlinked\tlists.\tThe\tmain\tdisadvantage\tof\tlinked\tlists\tis\taccess time\tto\tindividual\telements.\tArray\tis\trandom-access,\twhich\tmeans\tit\ttakes\tO(1)\tto\taccess\tany element\tin\tthe\tarray.\tLinked\tlists\ttake\tO(n)\tfor\taccess\tto\tan\telement\tin\tthe\tlist\tin\tthe\tworst\tcase. Another\tadvantage\tof\tarrays\tin\taccess\ttime\tis\tspacial\tlocality\tin\tmemory.\tArrays\tare\tdefined\tas contiguous\tblocks\tof\tmemory,\tand\tso\tany\tarray\telement\twill\tbe\tphysically\tnear\tits\tneighbors.\tThis greatly\tbenefits\tfrom\tmodern\tCPU\tcaching\tmethods. Although\tthe\tdynamic\tallocation\tof\tstorage\tis\ta\tgreat\tadvantage,\tthe\toverhead\twith\tstoring\tand retrieving\tdata\tcan\tmake\ta\tbig\tdifference.\tSometimes\tlinked\tlists\tare\thard\tto\tmanipulate.\tIf\tthe last\titem\tis\tdeleted,\tthe\tlast\tbut\tone\tmust\tthen\thave\tits\tpointer\tchanged\tto\thold\ta\tNULL\treference. This\trequires\tthat\tthe\tlist\tis\ttraversed\tto\tfind\tthe\tlast\tbut\tone\tlink,\tand\tits\tpointer\tset\tto\ta\tNULL reference. Finally,\tlinked\tlists\twaste\tmemory\tin\tterms\tof\textra\treference\tpoints."
            },
            {
                "subchapter_title": "3.5\tComparison\tof\tLinked\tLists\twith\tArrays\t&\tDynamic\tArrays",
                "content": ""
            },
            {
                "subchapter_title": "3.6\tSingly\tLinked\tLists",
                "content": "Generally\t\u201clinked\tlist\u201d\tmeans\ta\tsingly\tlinked\tlist.\tThis\tlist\tconsists\tof\ta\tnumber\tof\tnodes\tin\twhich each\tnode\thas\ta\tnext\tpointer\tto\tthe\tfollowing\telement.\tThe\tlink\tof\tthe\tlast\tnode\tin\tthe\tlist\tis NULL,\twhich\tindicates\tthe\tend\tof\tthe\tlist. Following\tis\ta\ttype\tdeclaration\tfor\ta\tlinked\tlist\tof\tintegers: Basic\tOperations\ton\ta\tList \u2022 Traversing\tthe\tlist \u2022 Inserting\tan\titem\tin\tthe\tlist \u2022 Deleting\tan\titem\tfrom\tthe\tlist Traversing\tthe\tLinked\tList Let\tus\tassume\tthat\tthe\thead\tpoints\tto\tthe\tfirst\tnode\tof\tthe\tlist.\tTo\ttraverse\tthe\tlist\twe\tdo\tthe following \u2022 Follow\tthe\tpointers. \u2022 Display\tthe\tcontents\tof\tthe\tnodes\t(or\tcount)\tas\tthey\tare\ttraversed. \u2022 Stop\twhen\tthe\tnext\tpointer\tpoints\tto\tNULL. The\tListLength()\tfunction\ttakes\ta\tlinked\tlist\tas\tinput\tand\tcounts\tthe\tnumber\tof\tnodes\tin\tthe\tlist. The\tfunction\tgiven\tbelow\tcan\tbe\tused\tfor\tprinting\tthe\tlist\tdata\twith\textra\tprint\tfunction. Time\tComplexity:\tO(n),\tfor\tscanning\tthe\tlist\tof\tsize\tn. Space\tComplexity:\tO(1),\tfor\tcreating\ta\ttemporary\tvariable. Singly\tLinked\tList\tInsertion Insertion\tinto\ta\tsingly-linked\tlist\thas\tthree\tcases: \u2022 Inserting\ta\tnew\tnode\tbefore\tthe\thead\t(at\tthe\tbeginning) \u2022 Inserting\ta\tnew\tnode\tafter\tthe\ttail\t(at\tthe\tend\tof\tthe\tlist) \u2022 Inserting\ta\tnew\tnode\tat\tthe\tmiddle\tof\tthe\tlist\t(random\tlocation) Note:\tTo\tinsert\tan\telement\tin\tthe\tlinked\tlist\tat\tsome\tposition\tp,\tassume\tthat\tafter\tinserting\tthe element\tthe\tposition\tof\tthis\tnew\tnode\tis\tp. Inserting\ta\tNode\tin\tSingly\tLinked\tList\tat\tthe\tBeginning In\tthis\tcase,\ta\tnew\tnode\tis\tinserted\tbefore\tthe\tcurrent\thead\tnode.\tOnly\tone\tnext\tpointer\tneeds\tto be\tmodified\t(new\tnode\u2019s\tnext\tpointer)\tand\tit\tcan\tbe\tdone\tin\ttwo\tsteps: \u2022 Update\tthe\tnext\tpointer\tof\tnew\tnode,\tto\tpoint\tto\tthe\tcurrent\thead. \u2022 Update\thead\tpointer\tto\tpoint\tto\tthe\tnew\tnode. Inserting\ta\tNode\tin\tSingly\tLinked\tList\tat\tthe\tEnding In\tthis\tcase,\twe\tneed\tto\tmodify\ttwo\tnext\tpointers\t(last\tnodes\tnext\tpointer\tand\tnew\tnodes\tnext pointer). \u2022 New\tnodes\tnext\tpointer\tpoints\tto\tNULL. \u2022 Last\tnodes\tnext\tpointer\tpoints\tto\tthe\tnew\tnode. Inserting\ta\tNode\tin\tSingly\tLinked\tList\tat\tthe\tMiddle Let\tus\tassume\tthat\twe\tare\tgiven\ta\tposition\twhere\twe\twant\tto\tinsert\tthe\tnew\tnode.\tIn\tthis\tcase also,\twe\tneed\tto\tmodify\ttwo\tnext\tpointers. \u2022 If\twe\twant\tto\tadd\tan\telement\tat\tposition\t3\tthen\twe\tstop\tat\tposition\t2.\tThat\tmeans\twe traverse\t 2\t nodes\t and\t insert\t the\t new\t node.\t For\t simplicity\t let\t us\t assume\t that\t the second\tnode\tis\tcalled\tposition\tnode.\tThe\tnew\tnode\tpoints\tto\tthe\tnext\tnode\tof\tthe position\twhere\twe\twant\tto\tadd\tthis\tnode. \u2022 Position\tnode\u2019s\tnext\tpointer\tnow\tpoints\tto\tthe\tnew\tnode. Let\tus\twrite\tthe\tcode\tfor\tall\tthree\tcases.\tWe\tmust\tupdate\tthe\tfirst\telement\tpointer\tin\tthe\tcalling function,\tnot\tjust\tin\tthe\tcalled\tfunction.\tFor\tthis\treason\twe\tneed\tto\tsend\ta\tdouble\tpointer.\tThe following\tcode\tinserts\ta\tnode\tin\tthe\tsingly\tlinked\tlist. Note:\tWe\tcan\timplement\tthe\tthree\tvariations\tof\tthe\tinsert\toperation\tseparately. Time\tComplexity:\tO(n),\tsince,\tin\tthe\tworst\tcase,\twe\tmay\tneed\tto\tinsert\tthe\tnode\tat\tthe\tend\tof\tthe list. Space\tComplexity:\tO(1),\tfor\tcreating\tone\ttemporary\tvariable. Singly\tLinked\tList\tDeletion Similar\tto\tinsertion,\there\twe\talso\thave\tthree\tcases. \u2022 Deleting\tthe\tfirst\tnode \u2022 Deleting\tthe\tlast\tnode \u2022 Deleting\tan\tintermediate\tnode. Deleting\tthe\tFirst\tNode\tin\tSingly\tLinked\tList First\tnode\t(current\thead\tnode)\tis\tremoved\tfrom\tthe\tlist.\tIt\tcan\tbe\tdone\tin\ttwo\tsteps: \u2022 Create\ta\ttemporary\tnode\twhich\twill\tpoint\tto\tthe\tsame\tnode\tas\tthat\tof\thead. \u2022 Now,\tmove\tthe\thead\tnodes\tpointer\tto\tthe\tnext\tnode\tand\tdispose\tof\tthe\ttemporary node. Deleting\tthe\tLast\tNode\tin\tSingly\tLinked\tList In\tthis\tcase,\tthe\tlast\tnode\tis\tremoved\tfrom\tthe\tlist.\tThis\toperation\tis\ta\tbit\ttrickier\tthan\tremoving the\tfirst\tnode,\tbecause\tthe\talgorithm\tshould\tfind\ta\tnode,\twhich\tis\tprevious\tto\tthe\ttail.\tIt\tcan\tbe done\tin\tthree\tsteps: \u2022 Traverse\tthe\tlist\tand\twhile\ttraversing\tmaintain\tthe\tprevious\tnode\taddress\talso.\tBy the\ttime\twe\treach\tthe\tend\tof\tthe\tlist,\twe\twill\thave\ttwo\tpointers,\tone\tpointing\tto\tthe tail\tnode\tand\tthe\tother\tpointing\tto\tthe\tnode\tbefore\tthe\ttail\tnode. \u2022 Update\tprevious\tnode\u2019s\tnext\tpointer\twith\tNULL. \u2022 Dispose\tof\tthe\ttail\tnode. Deleting\tan\tIntermediate\tNode\tin\tSingly\tLinked\tList In\tthis\tcase,\tthe\tnode\tto\tbe\tremoved\tis\talways\tlocated\tbetween\ttwo\tnodes.\tHead\tand\ttail\tlinks are\tnot\tupdated\tin\tthis\tcase.\tSuch\ta\tremoval\tcan\tbe\tdone\tin\ttwo\tsteps: \u2022 Similar\tto\tthe\tprevious\tcase,\tmaintain\tthe\tprevious\tnode\twhile\ttraversing\tthe\tlist. Once\twe\tfind\tthe\tnode\tto\tbe\tdeleted,\tchange\tthe\tprevious\tnode\u2019s\tnext\tpointer\tto\tthe next\tpointer\tof\tthe\tnode\tto\tbe\tdeleted. \u2022 Dispose\tof\tthe\tcurrent\tnode\tto\tbe\tdeleted. Time\tComplexity:\tO(n).\tIn\tthe\tworst\tcase,\twe\tmay\tneed\tto\tdelete\tthe\tnode\tat\tthe\tend\tof\tthe\tlist. Space\tComplexity:\tO(1),\tfor\tone\ttemporary\tvariable. Deleting\tSingly\tLinked\tList This\tworks\tby\tstoring\tthe\tcurrent\tnode\tin\tsome\ttemporary\tvariable\tand\tfreeing\tthe\tcurrent\tnode. After\t freeing\t the\t current\t node,\t go\t to\t the\t next\t node\t with\t a\t temporary\t variable\t and\t repeat\t this process\tfor\tall\tnodes. Time\tComplexity:\tO(n),\tfor\tscanning\tthe\tcomplete\tlist\tof\tsize\tn. Space\tComplexity:\tO(1),\tfor\tcreating\tone\ttemporary\tvariable."
            },
            {
                "subchapter_title": "3.7\tDoubly\tLinked\tLists",
                "content": "The\tadvantage\tof\ta\tdoubly\tlinked\tlist\t(also\tcalled\ttwo\t\u2013\tway\tlinked\tlist)\tis\tthat\tgiven\ta\tnode\tin the\tlist,\twe\tcan\tnavigate\tin\tboth\tdirections.\tA\tnode\tin\ta\tsingly\tlinked\tlist\tcannot\tbe\tremoved unless\twe\thave\tthe\tpointer\tto\tits\tpredecessor.\tBut\tin\ta\tdoubly\tlinked\tlist,\twe\tcan\tdelete\ta\tnode even\tif\twe\tdon\u2019t\thave\tthe\tprevious\tnode\u2019s\taddress\t(since\teach\tnode\thas\ta\tleft\tpointer\tpointing\tto the\tprevious\tnode\tand\tcan\tmove\tbackward). The\tprimary\tdisadvantages\tof\tdoubly\tlinked\tlists\tare: \u2022 Each\tnode\trequires\tan\textra\tpointer,\trequiring\tmore\tspace. \u2022 The\tinsertion\tor\tdeletion\tof\ta\tnode\ttakes\ta\tbit\tlonger\t(more\tpointer\toperations). Similar\t to\t a\t singly\t linked\t list,\t let\t us\t implement\t the\t operations\t of\t a\t doubly\t linked\t list.\t If\t you understand\t the\t singly\t linked\t list\t operations,\t then\t doubly\t linked\t list\t operations\t are\t obvious. Following\tis\ta\ttype\tdeclaration\tfor\ta\tdoubly\tlinked\tlist\tof\tintegers: Doubly\tLinked\tList\tInsertion Insertion\tinto\ta\tdoubly-linked\tlist\thas\tthree\tcases\t(same\tas\tsingly\tlinked\tlist): \u2022 Inserting\ta\tnew\tnode\tbefore\tthe\thead. \u2022 Inserting\ta\tnew\tnode\tafter\tthe\ttail\t(at\tthe\tend\tof\tthe\tlist). \u2022 Inserting\ta\tnew\tnode\tat\tthe\tmiddle\tof\tthe\tlist. Inserting\ta\tNode\tin\tDoubly\tLinked\tList\tat\tthe\tBeginning In\tthis\tcase,\tnew\tnode\tis\tinserted\tbefore\tthe\thead\tnode.\tPrevious\tand\tnext\tpointers\tneed\tto\tbe modified\tand\tit\tcan\tbe\tdone\tin\ttwo\tsteps: \u2022 Update\tthe\tright\tpointer\tof\tthe\tnew\tnode\tto\tpoint\tto\tthe\tcurrent\thead\tnode\t(dotted link\tin\tbelow\tfigure)\tand\talso\tmake\tleft\tpointer\tof\tnew\tnode\tas\tNULL. \u2022 Update\t head\t node\u2019s\t left\t pointer\t to\t point\t to\t the\t new\t node\t and\t make\t new\t node\t as head.\tHead Inserting\ta\tNode\tin\tDoubly\tLinked\tList\tat\tthe\tEnding In\tthis\tcase,\ttraverse\tthe\tlist\ttill\tthe\tend\tand\tinsert\tthe\tnew\tnode. \u2022 New\tnode\tright\tpointer\tpoints\tto\tNULL\tand\tleft\tpointer\tpoints\tto\tthe\tend\tof\tthe\tlist. \u2022 Update\tright\tpointer\tof\tlast\tnode\tto\tpoint\tto\tnew\tnode. Inserting\ta\tNode\tin\tDoubly\tLinked\tList\tat\tthe\tMiddle As\tdiscussed\tin\tsingly\tlinked\tlists,\ttraverse\tthe\tlist\tto\tthe\tposition\tnode\tand\tinsert\tthe\tnew\tnode. \u2022 New\tnode\tright\tpointer\tpoints\tto\tthe\tnext\tnode\tof\tthe\tposition\tnode\twhere\twe\twant to\tinsert\tthe\tnew\tnode.\tAlso,\tnew\tnode\tleft\tpointer\tpoints\tto\tthe\tposition\tnode. \u2022 Position\tnode\tright\tpointer\tpoints\tto\tthe\tnew\tnode\tand\tthe\tnext\tnode\tof\tposition\tnode left\tpointer\tpoints\tto\tnew\tnode. Now,\tlet\tus\twrite\tthe\tcode\tfor\tall\tof\tthese\tthree\tcases.\tWe\tmust\tupdate\tthe\tfirst\telement\tpointer\tin the\t calling\t function,\t not\t just\t in\t the\t called\t function.\t For\t this\t reason\t we\t need\t to\t send\t a\t double pointer.\tThe\tfollowing\tcode\tinserts\ta\tnode\tin\tthe\tdoubly\tlinked\tlist Time\tComplexity:\tO(n).\tIn\tthe\tworst\tcase,\twe\tmay\tneed\tto\tinsert\tthe\tnode\tat\tthe\tend\tof\tthe\tlist. Space\tComplexity:\tO(1),\tfor\tcreating\tone\ttemporary\tvariable. Doubly\tLinked\tList\tDeletion Similar\tto\tsingly\tlinked\tlist\tdeletion,\there\twe\thave\tthree\tcases: \u2022 Deleting\tthe\tfirst\tnode \u2022 Deleting\tthe\tlast\tnode \u2022 Deleting\tan\tintermediate\tnode Deleting\tthe\tFirst\tNode\tin\tDoubly\tLinked\tList In\tthis\tcase,\tthe\tfirst\tnode\t(current\thead\tnode)\tis\tremoved\tfrom\tthe\tlist.\tIt\tcan\tbe\tdone\tin\ttwo steps: \u2022 Create\ta\ttemporary\tnode\twhich\twill\tpoint\tto\tthe\tsame\tnode\tas\tthat\tof\thead. \u2022 Now,\tmove\tthe\thead\tnodes\tpointer\tto\tthe\tnext\tnode\tand\tchange\tthe\theads\tleft\tpointer to\tNULL.\tThen,\tdispose\tof\tthe\ttemporary\tnode. Deleting\tthe\tLast\tNode\tin\tDoubly\tLinked\tList This\toperation\tis\ta\tbit\ttrickier\tthan\tremoving\tthe\tfirst\tnode,\tbecause\tthe\talgorithm\tshould\tfind\ta node,\twhich\tis\tprevious\tto\tthe\ttail\tfirst.\tThis\tcan\tbe\tdone\tin\tthree\tsteps: \u2022 Traverse\tthe\tlist\tand\twhile\ttraversing\tmaintain\tthe\tprevious\tnode\taddress\talso.\tBy the\ttime\twe\treach\tthe\tend\tof\tthe\tlist,\twe\twill\thave\ttwo\tpointers,\tone\tpointing\tto\tthe tail\tand\tthe\tother\tpointing\tto\tthe\tnode\tbefore\tthe\ttail. \u2022 Update\tthe\tnext\tpointer\tof\tprevious\tnode\tto\tthe\ttail\tnode\twith\tNULL. \u2022 Dispose\tthe\ttail\tnode. Deleting\tan\tIntermediate\tNode\tin\tDoubly\tLinked\tList In\tthis\tcase,\tthe\tnode\tto\tbe\tremoved\tis\talways\tlocated\tbetween\ttwo\tnodes,\tand\tthe\thead\tand\ttail links\tare\tnot\tupdated.\tThe\tremoval\tcan\tbe\tdone\tin\ttwo\tsteps: \u2022 Similar\tto\tthe\tprevious\tcase,\tmaintain\tthe\tprevious\tnode\twhile\talso\ttraversing\tthe list.\tUpon\tlocating\tthe\tnode\tto\tbe\tdeleted,\tchange\tthe\tprevious\tnode\u2019s\tnext\tpointer to\tthe\tnext\tnode\tof\tthe\tnode\tto\tbe\tdeleted. \u2022 Dispose\tof\tthe\tcurrent\tnode\tto\tbe\tdeleted. Time\tComplexity:\tO(n),\tfor\tscanning\tthe\tcomplete\tlist\tof\tsize\tn. Space\tComplexity:\tO(1),\tfor\tcreating\tone\ttemporary\tvariable."
            },
            {
                "subchapter_title": "3.8\tCircular\tLinked\tLists",
                "content": "In\tsingly\tlinked\tlists\tand\tdoubly\tlinked\tlists,\tthe\tend\tof\tlists\tare\tindicated\twith\tNULL\tvalue.\tBut circular\tlinked\tlists\tdo\tnot\thave\tends.\tWhile\ttraversing\tthe\tcircular\tlinked\tlists\twe\tshould\tbe careful;\totherwise\twe\twill\tbe\ttraversing\tthe\tlist\tinfinitely.\tIn\tcircular\tlinked\tlists,\teach\tnode\thas\ta successor.\tNote\tthat\tunlike\tsingly\tlinked\tlists,\tthere\tis\tno\tnode\twith\tNULL\tpointer\tin\ta\tcircularly linked\tlist.\tIn\tsome\tsituations,\tcircular\tlinked\tlists\tare\tuseful. For\texample,\twhen\tseveral\tprocesses\tare\tusing\tthe\tsame\tcomputer\tresource\t(CPU)\tfor\tthe\tsame amount\t of\t time,\t we\t have\t to\t assure\t that\t no\t process\t accesses\t the\t resource\t before\t all\t other processes\tdo\t(round\trobin\talgorithm).\tThe\tfollowing\tis\ta\ttype\tdeclaration\tfor\ta\tcircular\tlinked list\tof\tintegers: In\ta\tcircular\tlinked\tlist,\twe\taccess\tthe\telements\tusing\tthe\thead\tnode\t(similar\tto\thead\t node\t in singly\tlinked\tlist\tand\tdoubly\tlinked\tlists). Counting\tNodes\tin\ta\tCircular\tLinked\tList The\tcircular\tlist\tis\taccessible\tthrough\tthe\tnode\tmarked\thead.\tTo\tcount\tthe\tnodes,\tthe\tlist\thas\tto\tbe traversed\t from\t the\t node\t marked\t head,\t with\t the\t help\t of\t a\t dummy\t node\t current,\t and\t stop\t the counting\twhen\tcurrent\treaches\tthe\tstarting\tnode\thead. If\tthe\tlist\tis\tempty,\thead\twill\tbe\tNULL,\tand\tin\tthat\tcase\tset\tcount\t=\t0.\tOtherwise,\tset\tthe\tcurrent pointer\tto\tthe\tfirst\tnode,\tand\tkeep\ton\tcounting\ttill\tthe\tcurrent\tpointer\treaches\tthe\tstarting\tnode. Time\tComplexity:\tO(n),\tfor\tscanning\tthe\tcomplete\tlist\tof\tsize\tn. Space\tComplexity:\tO(1),\tfor\tcreating\tone\ttemporary\tvariable. Printing\tthe\tContents\tof\ta\tCircular\tLinked\tList We\tassume\there\tthat\tthe\tlist\tis\tbeing\taccessed\tby\tits\thead\tnode.\tSince\tall\tthe\tnodes\tare\tarranged in\ta\tcircular\tfashion,\tthe\ttail\tnode\tof\tthe\tlist\twill\tbe\tthe\tnode\tprevious\tto\tthe\thead\tnode.\tLet\tus assume\twe\twant\tto\tprint\tthe\tcontents\tof\tthe\tnodes\tstarting\twith\tthe\thead\tnode.\tPrint\tits\tcontents, move\tto\tthe\tnext\tnode\tand\tcontinue\tprinting\ttill\twe\treach\tthe\thead\tnode\tagain. Time\tComplexity:\tO(n),\tfor\tscanning\tthe\tcomplete\tlist\tof\tsize\tn. Space\tComplexity:\tO(1),\tfor\ttemporary\tvariable. Inserting\ta\tNode\tat\tthe\tEnd\tof\ta\tCircular\tLinked\tList Let\tus\tadd\ta\tnode\tcontaining\tdata,\tat\tthe\tend\tof\ta\tlist\t(circular\tlist)\theaded\tby\thead.\tThe\tnew node\twill\tbe\tplaced\tjust\tafter\tthe\ttail\tnode\t(which\tis\tthe\tlast\tnode\tof\tthe\tlist),\twhich\tmeans\tit\twill have\tto\tbe\tinserted\tin\tbetween\tthe\ttail\tnode\tand\tthe\tfirst\tnode. \u2022 Create\ta\tnew\tnode\tand\tinitially\tkeep\tits\tnext\tpointer\tpointing\tto\titself. \u2022 Update\tthe\tnext\tpointer\tof\tthe\tnew\tnode\twith\tthe\thead\tnode\tand\talso\ttraverse\tthe\tlist to\tthe\ttail.\tThat\tmeans\tin\ta\tcircular\tlist\twe\tshould\tstop\tat\tthe\tnode\twhose\tnext\tnode is\thead. \u2022 Update\tthe\tnext\tpointer\tof\tthe\tprevious\tnode\tto\tpoint\tto\tthe\tnew\tnode\tand\twe\tget\tthe list\tas\tshown\tbelow. Time\tComplexity:\tO(n),\tfor\tscanning\tthe\tcomplete\tlist\tof\tsize\tn. Space\tComplexity:\tO(1),\tfor\ttemporary\tvariable. Inserting\ta\tNode\tat\tthe\tFront\tof\ta\tCircular\tLinked\tList The\tonly\tdifference\tbetween\tinserting\ta\tnode\tat\tthe\tbeginning\tand\tat\tthe\tend\tis\tthat,\tafter\tinserting the\tnew\tnode,\twe\tjust\tneed\tto\tupdate\tthe\tpointer.\tThe\tsteps\tfor\tdoing\tthis\tare\tgiven\tbelow: \u2022 Create\ta\tnew\tnode\tand\tinitially\tkeep\tits\tnext\tpointer\tpointing\tto\titself. \u2022 Update\tthe\tnext\tpointer\tof\tthe\tnew\tnode\twith\tthe\thead\tnode\tand\talso\ttraverse\tthe\tlist until\tthe\ttail.\tThat\tmeans\tin\ta\tcircular\tlist\twe\tshould\tstop\tat\tthe\tnode\twhich\tis\tits previous\tnode\tin\tthe\tlist. \u2022 Update\tthe\tprevious\thead\tnode\tin\tthe\tlist\tto\tpoint\tto\tthe\tnew\tnode. \u2022 Make\tthe\tnew\tnode\tas\tthe\thead. Time\tComplexity:\tO(n),\tfor\tscanning\tthe\tcomplete\tlist\tof\tsize\tn. Space\tComplexity:\tO(1),\tfor\ttemporary\tvariable. Deleting\tthe\tLast\tNode\tin\ta\tCircular\tLinked\tList The\tlist\thas\tto\tbe\ttraversed\tto\treach\tthe\tlast\tbut\tone\tnode.\tThis\thas\tto\tbe\tnamed\tas\tthe\ttail\tnode, and\tits\tnext\tfield\thas\tto\tpoint\tto\tthe\tfirst\tnode.\tConsider\tthe\tfollowing\tlist. To\tdelete\tthe\tlast\tnode\t40,\tthe\tlist\thas\tto\tbe\ttraversed\ttill\tyou\treach\t7.\tThe\tnext\tfield\tof\t7\thas\tto be\tchanged\tto\tpoint\tto\t60,\tand\tthis\tnode\tmust\tbe\trenamed\tpTail. \u2022 Traverse\tthe\tlist\tand\tfind\tthe\ttail\tnode\tand\tits\tprevious\tnode. \u2022 Update\tthe\tnext\tpointer\tof\ttail\tnode\u2019s\tprevious\tnode\tto\tpoint\tto\thead. \u2022 Dispose\tof\tthe\ttail\tnode. Time\tComplexity:\tO(n),\tfor\tscanning\tthe\tcomplete\tlist\tof\tsize\tn.\tSpace\tComplexity:\tO(1),\tfor\ta temporary\tvariable. Deleting\tthe\tFirst\tNode\tin\ta\tCircular\tList The\tfirst\tnode\tcan\tbe\tdeleted\tby\tsimply\treplacing\tthe\tnext\tfield\tof\tthe\ttail\tnode\twith\tthe\tnext\tfield of\tthe\tfirst\tnode. \u2022 Find\tthe\ttail\tnode\tof\tthe\tlinked\tlist\tby\ttraversing\tthe\tlist.\tTail\tnode\tis\tthe\tprevious node\tto\tthe\thead\tnode\twhich\twe\twant\tto\tdelete. \u2022 Create\ta\ttemporary\tnode\twhich\twill\tpoint\tto\tthe\thead.\tAlso,\tupdate\tthe\ttail\tnodes next\tpointer\tto\tpoint\tto\tnext\tnode\tof\thead\t(as\tshown\tbelow). \u2022 Now,\tmove\tthe\thead\tpointer\tto\tnext\tnode.\tCreate\ta\ttemporary\tnode\twhich\twill\tpoint to\thead.\tAlso,\tupdate\tthe\ttail\tnodes\tnext\tpointer\tto\tpoint\tto\tnext\tnode\tof\thead\t(as shown\tbelow). Time\tComplexity:\tO(n),\tfor\tscanning\tthe\tcomplete\tlist\tof\tsize\tn. Space\tComplexity:\tO(1),\tfor\ta\ttemporary\tvariable. Applications\tof\tCircular\tList Circular\tlinked\tlists\tare\tused\tin\tmanaging\tthe\tcomputing\tresources\tof\ta\tcomputer.\tWe\tcan\tuse circular\tlists\tfor\timplementing\tstacks\tand\tqueues."
            },
            {
                "subchapter_title": "3.9\tA\tMemory-efficient\tDoubly\tLinked\tList",
                "content": "In\tconventional\timplementation,\twe\tneed\tto\tkeep\ta\tforward\tpointer\tto\tthe\tnext\titem\ton\tthe\tlist\tand a\t backward\t pointer\t to\t the\t previous\t item.\t That\t means\t elements\t in\t doubly\t linked\t list implementations\tconsist\tof\tdata,\ta\tpointer\tto\tthe\tnext\tnode\tand\ta\tpointer\tto\tthe\tprevious\tnode\tin the\tlist\tas\tshown\tbelow. Conventional\tNode\tDefinition Recently\ta\tjournal\t(Sinha)\tpresented\tan\talternative\timplementation\tof\tthe\tdoubly\tlinked\tlist\tADT, with\t insertion,\t traversal\t and\t deletion\t operations.\t This\t implementation\t is\t based\t on\t pointer difference.\tEach\tnode\tuses\tonly\tone\tpointer\tfield\tto\ttraverse\tthe\tlist\tback\tand\tforth. New\tNode\tDefinition The\t ptrdiff\t pointer\t field\t contains\t the\t difference\t between\t the\t pointer\t to\t the\t next\t node\t and\t the pointer\t to\t the\t previous\t node.\t The\t pointer\t difference\t is\t calculated\t by\t using\t exclusive-or\t (\u2295) operation. ptrdiff\t=\tpointer\tto\tprevious\tnode\t\u2295\tpointer\tto\tnext\tnode. The\tptrdiff\tof\tthe\tstart\tnode\t(head\tnode)\tis\tthe\t\u2295\tof\tNULL\tand\tnext\tnode\t(next\tnode\tto\thead). Similarly,\tthe\tptrdiff\tof\tend\tnode\tis\tthe\t\u2295\tof\tprevious\tnode\t(previous\tto\tend\tnode)\tand\tNULL.\tAs an\texample,\tconsider\tthe\tfollowing\tlinked\tlist. In\tthe\texample\tabove, \u2022 The\tnext\tpointer\tof\tA\tis:\tNULL\t\u2295\tB \u2022 The\tnext\tpointer\tof\tB\tis:\tA\t\u2295\tC \u2022 The\tnext\tpointer\tof\tC\tis:\tB\t\u2295\tD \u2022 The\tnext\tpointer\tof\tD\tis:\tC\t\u2295\tNULL Why\tdoes\tit\twork? To\tfind\tthe\tanswer\tto\tthis\tquestion\tlet\tus\tconsider\tthe\tproperties\tof\t\u2295: X\t\u2295\tX=0 X\t\u2295\t0\t=\tX X\t\u2295\tY\t=\tY\t\u2295\tX\t(symmetric) (X\t\u2295\tY)\t\u2295\tZ\t=\tX\t\u2295\t(Y\t\u2295\tZ)\t(transitive) For\tthe\texample\tabove,\tlet\tus\tassume\tthat\twe\tare\tat\tC\tnode\tand\twant\tto\tmove\tto\tB.\tWe\tknow\tthat C\u2019s\tptrdiff\tis\tdefined\tas\tB\t\u2295\tD.\tIf\twe\twant\tto\tmove\tto\tB,\tperforming\t\u2295\ton\tC\u2019s\tptrdiff\twith\tD would\tgive\tB.\tThis\tis\tdue\tto\tthe\tfact\tthat (B\t\u2295\tD)\t\u2295\tD\t=\tB(since,\tD\t\u2295\tD=\t0) Similarly,\tif\twe\twant\tto\tmove\tto\tD,\tthen\twe\thave\tto\tapply\t\u2295\tto\tC\u2019s\tptrdiff\twith\tB\tto\tgive\tD. (B\t\u2295\tD)\t\u2295\tB\t=\tD\t(since,\tB\t\u00a9\tB=0) From\tthe\tabove\tdiscussion\twe\tcan\tsee\tthat\tjust\tby\tusing\ta\tsingle\tpointer,\twe\tcan\tmove\tback\tand forth.\t A\t memory-efficient\t implementation\t of\t a\t doubly\t linked\t list\t is\t possible\t with\t minimal compromising\tof\ttiming\tefficiency."
            },
            {
                "subchapter_title": "3.10\tUnrolled\tLinked\tLists",
                "content": "One\t of\t the\t biggest\t advantages\t of\t linked\t lists\t over\t arrays\t is\t that\t inserting\t an\t element\t at\t any location\ttakes\tonly\tO(1)\ttime.\tHowever,\tit\ttakes\tO(n)\tto\tsearch\tfor\tan\telement\tin\ta\tlinked\tlist. There\tis\ta\tsimple\tvariation\tof\tthe\tsingly\tlinked\tlist\tcalled\tunrolled\tlinked\tlists. An\t unrolled\t linked\t list\t stores\t multiple\t elements\t in\t each\t node\t (let\t us\t call\t it\t a\t block\t for\t our convenience).\tIn\teach\tblock,\ta\tcircular\tlinked\tlist\tis\tused\tto\tconnect\tall\tnodes. Assume\tthat\tthere\twill\tbe\tno\tmore\tthan\tn\telements\tin\tthe\tunrolled\tlinked\tlist\tat\tany\ttime.\tTo simplify\tthis\tproblem,\tall\tblocks,\texcept\tthe\tlast\tone,\tshould\tcontain\texactly\t \telements.\tThus, there\twill\tbe\tno\tmore\tthan\t \tblocks\tat\tany\ttime. Searching\tfor\tan\telement\tin\tUnrolled\tLinked\tLists In\tunrolled\tlinked\tlists,\twe\tcan\tfind\tthe\tkth\telement\tin\tO( ):"
            }
        ]
    },
    {
        "chapter_title": "1.",
        "subchapters": [
            {
                "subchapter_title": "Traverse\t the\t list\t of\tblocks\t to\t the\t one\t that\t contains\t the\t kth\t node,\t i.e.,\t the",
                "content": "block.\t It\t takes\t O( )\t since\t we\t may\t find\t it\t by\t going\t through\t no\t more\t than\t blocks."
            }
        ]
    },
    {
        "chapter_title": "2.",
        "subchapters": [
            {
                "subchapter_title": "Find\tthe\t(k\tmod",
                "content": ")th\tnode\tin\tthe\tcircular\tlinked\tlist\tof\tthis\tblock.\tIt\talso\ttakes\tO( )\tsince\tthere\tare\tno\tmore\tthan\t \tnodes\tin\ta\tsingle\tblock. Inserting\tan\telement\tin\tUnrolled\tLinked\tLists When\tinserting\ta\tnode,\twe\thave\tto\tre-arrange\tthe\tnodes\tin\tthe\tunrolled\tlinked\tlist\tto\tmaintain\tthe properties\tpreviously\tmentioned,\tthat\teach\tblock\tcontains\t \tnodes.\tSuppose\tthat\twe\tinsert\ta node\tx\tafter\tthe\tith\tnode,\tand\tx\tshould\tbe\tplaced\tin\tthe\tjth\tblock.\tNodes\tin\tthe\tjth\tblock\tand\tin\tthe blocks\tafter\tthe\tjth\tblock\thave\tto\tbe\tshifted\ttoward\tthe\ttail\tof\tthe\tlist\tso\tthat\teach\tof\tthem\tstill have\t \tnodes.\tIn\taddition,\ta\tnew\tblock\tneeds\tto\tbe\tadded\tto\tthe\ttail\tif\tthe\tlast\tblock\tof\tthe\tlist is\tout\tof\tspace,\ti.e.,\tit\thas\tmore\tthan\t \tnodes. Performing\tShift\tOperation Note\tthat\teach\tshift\toperation,\twhich\tincludes\tremoving\ta\tnode\tfrom\tthe\ttail\tof\tthe\tcircular\tlinked list\tin\ta\tblock\tand\tinserting\ta\tnode\tto\tthe\thead\tof\tthe\tcircular\tlinked\tlist\tin\tthe\tblock\tafter,\ttakes only\tO(1).\tThe\ttotal\ttime\tcomplexity\tof\tan\tinsertion\toperation\tfor\tunrolled\tlinked\tlists\tis\ttherefore O( );\tthere\tare\tat\tmost\tO( )\tblocks\tand\ttherefore\tat\tmost\tO( )\tshift\toperations."
            }
        ]
    },
    {
        "chapter_title": "1.",
        "subchapters": [
            {
                "subchapter_title": "A\ttemporary\tpointer\tis\tneeded\tto\tstore\tthe\ttail\tof\tA.",
                "content": ""
            }
        ]
    },
    {
        "chapter_title": "2.",
        "subchapters": [
            {
                "subchapter_title": "In\tblock\tA,\tmove\tthe\tnext\tpointer\tof\tthe\thead\tnode\tto\tpoint\tto\tthe\tsecond-to-last",
                "content": "node,\tso\tthat\tthe\ttail\tnode\tof\tA\tcan\tbe\tremoved."
            }
        ]
    },
    {
        "chapter_title": "3.",
        "subchapters": [
            {
                "subchapter_title": "Let\tthe\tnext\tpointer\tof\tthe\tnode,\twhich\twill\tbe\tshifted\t(the\ttail\tnode\tof\tA),\tpoint",
                "content": "to\tthe\ttail\tnode\tof\tB."
            }
        ]
    },
    {
        "chapter_title": "4.",
        "subchapters": [
            {
                "subchapter_title": "Let\tthe\tnext\tpointer\tof\tthe\thead\tnode\tof\tB\tpoint\tto\tthe\tnode\ttemp\tpoints\tto.",
                "content": ""
            }
        ]
    },
    {
        "chapter_title": "5.",
        "subchapters": [
            {
                "subchapter_title": "Finally,\tset\tthe\thead\tpointer\tof\tB\tto\tpoint\tto\tthe\tnode\ttemp\tpoints\tto.\tNow\tthe",
                "content": "node\ttemp\tpoints\tto\tbecomes\tthe\tnew\thead\tnode\tof\tB."
            }
        ]
    },
    {
        "chapter_title": "6.",
        "subchapters": [
            {
                "subchapter_title": "temp\tpointer\tcan\tbe\tthrown\taway.\tWe\thave\tcompleted\tthe\tshift\toperation\tto",
                "content": "move\tthe\toriginal\ttail\tnode\tof\tA\tto\tbecome\tthe\tnew\thead\tnode\tof\tB. Performance With\tunrolled\tlinked\tlists,\tthere\tare\ta\tcouple\tof\tadvantages,\tone\tin\tspeed\tand\tone\tin\tspace.\tFirst, if\tthe\tnumber\tof\telements\tin\teach\tblock\tis\tappropriately\tsized\t(e.g.,\tat\tmost\tthe\tsize\tof\tone\tcache line),\twe\tget\tnoticeably\tbetter\tcache\tperformance\tfrom\tthe\timproved\tmemory\tlocality.\tSecond, since\twe\thave\tO(n/m)\tlinks,\twhere\tn\tis\tthe\tnumber\tof\telements\tin\tthe\tunrolled\tlinked\tlist\tand\tm\tis the\tnumber\tof\telements\twe\tcan\tstore\tin\tany\tblock,\twe\tcan\talso\tsave\tan\tappreciable\tamount\tof space,\twhich\tis\tparticularly\tnoticeable\tif\teach\telement\tis\tsmall. Comparing\tLinked\tLists\tand\tUnrolled\tLinked\tLists To\t compare\t the\t overhead\t for\t an\t unrolled\t list,\t elements\t in\t doubly\t linked\t list\t implementations consist\tof\tdata,\ta\tpointer\tto\tthe\tnext\tnode,\tand\ta\tpointer\tto\tthe\tprevious\tnode\tin\tthe\tlist,\tas\tshown below. Assuming\twe\thave\t4\tbyte\tpointers,\teach\tnode\tis\tgoing\tto\ttake\t8\tbytes.\tBut\tthe\tallocation\toverhead for\tthe\tnode\tcould\tbe\tanywhere\tbetween\t8\tand\t16\tbytes.\tLet\u2019s\tgo\twith\tthe\tbest\tcase\tand\tassume\tit will\t be\t 8\t bytes.\t So,\t if\t we\t want\t to\t store\t IK\t items\t in\t this\t list,\t we\t are\t going\t to\t have\t 16KB\t of overhead. Now,\t let\u2019s\t think\t about\t an\t unrolled\t linked\t list\t node\t (let\t us\t call\t it\t LinkedBlock).\t It\t will\t look something\tlike\tthis: Therefore,\t allocating\t a\t single\t node\t (12\t bytes\t +\t 8\t bytes\t of\t overhead)\t with\t an\t array\t of\t 100 elements\t(400\tbytes\t+\t8\tbytes\tof\toverhead)\twill\tnow\tcost\t428\tbytes,\tor\t4.28\tbytes\tper\telement. Thinking\tabout\tour\tIK\titems\tfrom\tabove,\tit\twould\ttake\tabout\t4.2KB\tof\toverhead,\twhich\tis\tclose to\t4x\tbetter\tthan\tour\toriginal\tlist.\tEven\tif\tthe\tlist\tbecomes\tseverely\tfragmented\tand\tthe\titem\tarrays are\tonly\t1/2\tfull\ton\taverage,\tthis\tis\tstill\tan\timprovement.\tAlso,\tnote\tthat\twe\tcan\ttune\tthe\tarray size\tto\twhatever\tgets\tus\tthe\tbest\toverhead\tfor\tour\tapplication. Implementation"
            },
            {
                "subchapter_title": "3.11\tSkip\tLists",
                "content": "Binary\ttrees\tcan\tbe\tused\tfor\trepresenting\tabstract\tdata\ttypes\tsuch\tas\tdictionaries\tand\tordered lists.\t They\t work\t well\t when\t the\t elements\t are\t inserted\t in\t a\t random\t order.\t Some\t sequences\t of operations,\tsuch\tas\tinserting\tthe\telements\tin\torder,\tproduce\tdegenerate\tdata\tstructures\tthat\tgive very\tpoor\tperformance.\tIf\tit\twere\tpossible\tto\trandomly\tpermute\tthe\tlist\tof\titems\tto\tbe\tinserted, trees\twould\twork\twell\twith\thigh\tprobability\tfor\tany\tinput\tsequence.\tIn\tmost\tcases\tqueries\tmust be\tanswered\ton-line,\tso\trandomly\tpermuting\tthe\tinput\tis\timpractical.\tBalanced\ttree\talgorithms\tre- arrange\tthe\ttree\tas\toperations\tare\tperformed\tto\tmaintain\tcertain\tbalance\tconditions\tand\tassure good\tperformance. Skip\tlists\tare\ta\tprobabilistic\talternative\tto\tbalanced\ttrees.\tSkip\tlist\tis\ta\tdata\tstructure\tthat\tcan\tbe used\tas\tan\talternative\tto\tbalanced\tbinary\ttrees\t(refer\tto\tTrees\tchapter).\tAs\tcompared\tto\ta\tbinary tree,\tskip\tlists\tallow\tquick\tsearch,\tinsertion\tand\tdeletion\tof\telements.\tThis\tis\tachieved\tby\tusing probabilistic\t balancing\t rather\t than\t strictly\t enforce\t balancing.\t It\t is\t basically\t a\t linked\t list\t with additional\t pointers\t such\t that\t intermediate\t nodes\t can\t be\t skipped.\t It\t uses\t a\t random\t number generator\tto\tmake\tsome\tdecisions. In\tan\tordinary\tsorted\tlinked\tlist,\tsearch,\tinsert,\tand\tdelete\tare\tin\tO(n)\tbecause\tthe\tlist\tmust\tbe scanned\tnode-by-node\tfrom\tthe\thead\tto\tfind\tthe\trelevant\tnode.\tIf\tsomehow\twe\tcould\tscan\tdown the\tlist\tin\tbigger\tsteps\t(skip\tdown,\tas\tit\twere),\twe\twould\treduce\tthe\tcost\tof\tscanning.\tThis\tis\tthe fundamental\tidea\tbehind\tSkip\tLists. Skip\tLists\twith\tOne\tLevel Skip\tLists\twith\tTwo\tLevels Skip\tLists\twith\tThree\tLevels Performance In\ta\tsimple\tlinked\tlist\tthat\tconsists\tof\tn\telements,\tto\tperform\ta\tsearch\tn\tcomparisons\tare\trequired in\t the\t worst\t case.\t If\t a\t second\t pointer\t pointing\t two\t nodes\t ahead\t is\t added\t to\t every\t node,\t the number\tof\tcomparisons\tgoes\tdown\tto\tn/2\t+\t1\tin\tthe\tworst\tcase. Adding\tone\tmore\tpointer\tto\tevery\tfourth\tnode\tand\tmaking\tthem\tpoint\tto\tthe\tfourth\tnode\tahead reduces\tthe\tnumber\tof\tcomparisons\tto\t\u2308n/2\u2309\t+\t2.\tIf\tthis\tstrategy\tis\tcontinued\tso\tthat\tevery\tnode with\ti\tpointers\tpoints\tto\t2\t*\ti\t\u2013\t1\tnodes\tahead,\tO(logn)\tperformance\tis\tobtained\tand\tthe\tnumber of\tpointers\thas\tonly\tdoubled\t(n\t+\tn/2\t+\tn/4\t+\tn/8\t+\tn/16\t+\t....\t=\t2n). The\tfind,\tinsert,\tand\tremove\toperations\ton\tordinary\tbinary\tsearch\ttrees\tare\tefficient,\tO(logn), when\tthe\tinput\tdata\tis\trandom;\tbut\tless\tefficient,\tO(n),\twhen\tthe\tinput\tdata\tis\tordered.\tSkip\tList performance\tfor\tthese\tsame\toperations\tand\tfor\tany\tdata\tset\tis\tabout\tas\tgood\tas\tthat\tof\trandomly- built\tbinary\tsearch\ttrees\t-\tnamely\tO(logn). Comparing\tSkip\tLists\tand\tUnrolled\tLinked\tLists In\tsimple\tterms,\tSkip\tLists\tare\tsorted\tlinked\tlists\twith\ttwo\tdifferences: \u2022 The\tnodes\tin\tan\tordinary\tlist\thave\tone\tnext\treference.\tThe\tnodes\tin\ta\tSkip\tList\thave many\tnext\treferences\t(also\tcalled\tforward\treferences). \u2022 The\tnumber\tof\tforward\treferences\tfor\ta\tgiven\tnode\tis\tdetermined\tprobabilistically. We\tspeak\tof\ta\tSkip\tList\tnode\thaving\tlevels,\tone\tlevel\tper\tforward\treference.\tThe\tnumber\tof levels\tin\ta\tnode\tis\tcalled\tthe\tsize\tof\tthe\tnode.\tIn\tan\tordinary\tsorted\tlist,\tinsert,\tremove,\tand\tfind operations\trequire\tsequential\ttraversal\tof\tthe\tlist.\tThis\tresults\tin\tO(n)\tperformance\tper\toperation. Skip\tLists\tallow\tintermediate\tnodes\tin\tthe\tlist\tto\tbe\tskipped\tduring\ta\ttraversal\t-\tresulting\tin\tan expected\tperformance\tof\tO(logn)\tper\toperation. Implementation"
            },
            {
                "subchapter_title": "3.12\tLinked\tLists:\tProblems\t&\tSolutions",
                "content": "Problem-1\u2003\u2003Implement\tStack\tusing\tLinked\tList. Solution:\tRefer\tto\tStacks\tchapter. Problem-2\u2003\u2003Find\tnth\tnode\tfrom\tthe\tend\tof\ta\tLinked\tList. Solution:\tBrute-Force\tMethod:\tStart\twith\tthe\tfirst\tnode\tand\tcount\tthe\tnumber\tof\tnodes\tpresent after\tthat\tnode.\tIf\tthe\tnumber\tof\tnodes\tis\t<\tn\t\u2013\t1\tthen\treturn\tsaying\t\u201cfewer\tnumber\tof\tnodes\tin\tthe list\u201d.\tIf\tthe\tnumber\tof\tnodes\tis\t>\tn\t\u2013\t1\tthen\tgo\tto\tnext\tnode.\tContinue\tthis\tuntil\tthe\tnumbers\tof nodes\tafter\tcurrent\tnode\tare\tn\t\u2013\t1. Time\tComplexity:\tO(n2),\tfor\tscanning\tthe\tremaining\tlist\t(from\tcurrent\tnode)\tfor\teach\tnode. Space\tComplexity:\tO(1). Problem-3\u2003\u2003Can\twe\timprove\tthe\tcomplexity\tof\tProblem-2? Solution:\tYes,\tusing\thash\ttable.\tAs\tan\texample\tconsider\tthe\tfollowing\tlist. In\tthis\tapproach,\tcreate\ta\thash\ttable\twhose\tentries\tare\t<\tposition\tof\tnode,\tnode\taddress\t>.\tThat means,\tkey\tis\tthe\tposition\tof\tthe\tnode\tin\tthe\tlist\tand\tvalue\tis\tthe\taddress\tof\tthat\tnode. Position\tin\tList Address\tof\tNode 1 Address\tof\t5\tnode 2 Address\tof\t1\tnode 3 Address\tof\t17\tnode 4 Address\tof\t4\tnode By\tthe\ttime\twe\ttraverse\tthe\tcomplete\tlist\t(for\tcreating\tthe\thash\ttable),\twe\tcan\tfind\tthe\tlist\tlength. Let\tus\tsay\tthe\tlist\tlength\tis\tM.\tTo\tfind\tnth\tfrom\tthe\tend\tof\tlinked\tlist,\twe\tcan\tconvert\tthis\tto\tM-\tn +\t 1th\t from\t the\t beginning.\t Since\t we\t already\t know\t the\t length\t of\t the\t list,\t it\t is\t just\t a\t matter\t of returning\tM-\tn\t+\t1th\tkey\tvalue\tfrom\tthe\thash\ttable. Time\tComplexity:\tTime\tfor\tcreating\tthe\thash\ttable,\tT(m)\t=\tO(m). Space\tComplexity:\tSince\twe\tneed\tto\tcreate\ta\thash\ttable\tof\tsize\tm,\tO(m). Problem-4\u2003\u2003Can\twe\tuse\tthe\tProblem-3\tapproach\tfor\tsolving\tProblem-2\twithout\tcreating\tthe hash\ttable? Solution:\tYes.\tIf\twe\tobserve\tthe\tProblem-3\tsolution,\twhat\twe\tare\tactually\tdoing\tis\tfinding\tthe size\tof\tthe\tlinked\tlist.\tThat\tmeans\twe\tare\tusing\tthe\thash\ttable\tto\tfind\tthe\tsize\tof\tthe\tlinked\tlist.\tWe can\tfind\tthe\tlength\tof\tthe\tlinked\tlist\tjust\tby\tstarting\tat\tthe\thead\tnode\tand\ttraversing\tthe\tlist. So,\twe\tcan\tfind\tthe\tlength\tof\tthe\tlist\twithout\tcreating\tthe\thash\ttable.\tAfter\tfinding\tthe\tlength, compute\tM\t\u2013\tn\t+\t1\tand\twith\tone\tmore\tscan\twe\tcan\tget\tthe\tM\t\u2013\tn+\t1th\tnode\tfrom\tthe\tbeginning. This\tsolution\tneeds\ttwo\tscans:\tone\tfor\tfinding\tthe\tlength\tof\tthe\tlist\tand\tthe\tother\tfor\tfinding\tM\t\u2013 n+\t1th\tnode\tfrom\tthe\tbeginning. Time\tComplexity:\tTime\tfor\tfinding\tthe\tlength\t+\tTime\tfor\tfinding\tthe\tM\t\u2013\tn\t+\t1th\tnode\tfrom\tthe beginning.\tTherefore,\tT(n)\t=\tO(n)\t+\tO(n)\t\u2248\tO(n).\tSpace\tComplexity:\tO(1).\tHence,\tno\tneed\tto create\tthe\thash\ttable. Problem-5\u2003\u2003Can\twe\tsolve\tProblem-2\tin\tone\tscan? Solution:\tYes.\tEfficient\tApproach:\tUse\ttwo\tpointers\tpNthNode\tand\tpTemp.\tInitially,\tboth\tpoint to\thead\tnode\tof\tthe\tlist.\tpNthNode\tstarts\tmoving\tonly\tafter\tpTemp\thas\tmade\tn\tmoves. From\tthere\tboth\tmove\tforward\tuntil\tpTemp\t reaches\t the\t end\t of\t the\t list.\t As\t a\t result\t pNthNode points\tto\tnth\tnode\tfrom\tthe\tend\tof\tthe\tlinked\tlist. Note:\tAt\tany\tpoint\tof\ttime\tboth\tmove\tone\tnode\tat\ta\ttime. Time\tComplexity:\tO(n).\tSpace\tComplexity:\tO(1). Problem-6\u2003\u2003Check\twhether\tthe\tgiven\tlinked\tlist\tis\teither\tNULL-terminated\tor\tends\tin\ta\tcycle (cyclic). Solution:\tBrute-Force\tApproach.\tAs\tan\texample,\tconsider\tthe\tfollowing\tlinked\tlist\twhich\thas\ta loop\tin\tit.\tThe\tdifference\tbetween\tthis\tlist\tand\tthe\tregular\tlist\tis\tthat,\tin\tthis\tlist,\tthere\tare\ttwo nodes\twhose\tnext\tpointers\tare\tthe\tsame.\tIn\tregular\tsingly\tlinked\tlists\t(without\ta\tloop)\teach\tnode\u2019s next\tpointer\tis\tunique. That\tmeans\tthe\trepetition\tof\tnext\tpointers\tindicates\tthe\texistence\tof\ta\tloop. One\tsimple\tand\tbrute\tforce\tway\tof\tsolving\tthis\tis,\tstart\twith\tthe\tfirst\tnode\tand\tsee\twhether\tthere is\tany\tnode\twhose\tnext\tpointer\tis\tthe\tcurrent\tnode\u2019s\taddress.\tIf\tthere\tis\ta\tnode\twith\tthe\tsame address\tthen\tthat\tindicates\tthat\tsome\tother\tnode\tis\tpointing\tto\tthe\tcurrent\tnode\tand\twe\tcan\tsay\ta loop\texists.\tContinue\tthis\tprocess\tfor\tall\tthe\tnodes\tof\tthe\tlinked\tlist. Does\tthis\tmethod\twork?\tAs\tper\tthe\talgorithm,\twe\tare\tchecking\tfor\tthe\tnext\tpointer\taddresses, but\thow\tdo\twe\tfind\tthe\tend\tof\tthe\tlinked\tlist\t(otherwise\twe\twill\tend\tup\tin\tan\tinfinite\tloop)? Note:\tIf\twe\tstart\twith\ta\tnode\tin\ta\tloop,\tthis\tmethod\tmay\twork\tdepending\ton\tthe\tsize\tof\tthe\tloop. Problem-7\u2003\u2003Can\twe\tuse\tthe\thashing\ttechnique\tfor\tsolving\tProblem-6? Solution:\tYes.\tUsing\tHash\tTables\twe\tcan\tsolve\tthis\tproblem. Algorithm: \u2022 Traverse\tthe\tlinked\tlist\tnodes\tone\tby\tone. \u2022 Check\tif\tthe\taddress\tof\tthe\tnode\tis\tavailable\tin\tthe\thash\ttable\tor\tnot. \u2022 If\tit\tis\talready\tavailable\tin\tthe\thash\ttable,\tthat\tindicates\tthat\twe\tare\tvisiting\tthe\tnode that\twas\talready\tvisited.\tThis\tis\tpossible\tonly\tif\tthe\tgiven\tlinked\tlist\thas\ta\tloop\tin it. \u2022 If\tthe\taddress\tof\tthe\tnode\tis\tnot\tavailable\tin\tthe\thash\ttable,\tinsert\tthat\tnode\u2019s\taddress into\tthe\thash\ttable. \u2022 Continue\tthis\tprocess\tuntil\twe\treach\tthe\tend\tof\tthe\tlinked\tlist\tor\twe\tfind\tthe\tloop. Time\tComplexity;\tO(n)\tfor\tscanning\tthe\tlinked\tlist.\tNote\tthat\twe\tare\tdoing\ta\tscan\tof\tonly\tthe input. Space\tComplexity;\tO(n)\tfor\thash\ttable. Problem-8\u2003\u2003Can\twe\tsolve\tProblem-6\tusing\tthe\tsorting\ttechnique? Solution:\tNo.\tConsider\tthe\tfollowing\talgorithm\twhich\tis\tbased\ton\tsorting.\tThen\twe\tsee\twhy\tthis algorithm\tfails. Algorithm: \u2022 Traverse\tthe\tlinked\tlist\tnodes\tone\tby\tone\tand\ttake\tall\tthe\tnext\tpointer\tvalues\tinto\tan array. \u2022 Sort\tthe\tarray\tthat\thas\tthe\tnext\tnode\tpointers. \u2022 If\tthere\tis\ta\tloop\tin\tthe\tlinked\tlist,\tdefinitely\ttwo\tnext\tnode\tpointers\twill\tbe\tpointing to\tthe\tsame\tnode. \u2022 After\tsorting\tif\tthere\tis\ta\tloop\tin\tthe\tlist,\tthe\tnodes\twhose\tnext\tpointers\tare\tthe\tsame will\tend\tup\tadjacent\tin\tthe\tsorted\tlist. \u2022 If\tany\tsuch\tpair\texists\tin\tthe\tsorted\tlist\tthen\twe\tsay\tthe\tlinked\tlist\thas\ta\tloop\tin\tit. Time\tComplexity;\tO(nlogn)\tfor\tsorting\tthe\tnext\tpointers\tarray. Space\tComplexity;\tO(n)\tfor\tthe\tnext\tpointers\tarray. Problem\twith\tthe\tabove\talgorithm:\tThe\tabove\talgorithm\tworks\tonly\tif\twe\tcan\tfind\tthe\tlength\tof the\tlist.\tBut\tif\tthe\tlist\thas\ta\tloop\tthen\twe\tmay\tend\tup\tin\tan\tinfinite\tloop.\tDue\tto\tthis\treason\tthe algorithm\tfails. Problem-9\u2003\u2003Can\twe\tsolve\tthe\tProblem-6\tin\tO(n)? Solution:\t Yes.\t Efficient\t Approach\t (Memoryless\t Approach):\t This\t problem\t was\t solved\t by Floyd.\tThe\tsolution\tis\tnamed\tthe\tFloyd\tcycle\tfinding\talgorithm.\tIt\tuses\ttwo\tpointers\tmoving\tat different\tspeeds\tto\twalk\tthe\tlinked\tlist.\tOnce\tthey\tenter\tthe\tloop\tthey\tare\texpected\tto\tmeet,\twhich denotes\tthat\tthere\tis\ta\tloop. This\tworks\tbecause\tthe\tonly\tway\ta\tfaster\tmoving\tpointer\twould\tpoint\tto\tthe\tsame\tlocation\tas\ta slower\tmoving\tpointer\tis\tif\tsomehow\tthe\tentire\tlist\tor\ta\tpart\tof\tit\tis\tcircular.\tThink\tof\ta\ttortoise and\ta\thare\trunning\ton\ta\ttrack.\tThe\tfaster\trunning\thare\twill\tcatch\tup\twith\tthe\ttortoise\tif\tthey\tare running\t in\t a\t loop.\t As\t an\t example,\t consider\t the\t following\t example\t and\t trace\t out\t the\t Floyd algorithm.\tFrom\tthe\tdiagrams\tbelow\twe\tcan\tsee\tthat\tafter\tthe\tfinal\tstep\tthey\tare\tmeeting\tat\tsome point\tin\tthe\tloop\twhich\tmay\tnot\tbe\tthe\tstarting\tpoint\tof\tthe\tloop. Note:\tslowPtr\t(tortoise)\tmoves\tone\tpointer\tat\ta\ttime\tand\tfastPtr\t(hare)\tmoves\ttwo\tpointers\tat\ta time. Time\tComplexity:\tO(n).\tSpace\tComplexity:\tO(1). Problem-10\u2003\u2003are\t given\t a\t pointer\t to\t the\t first\t element\t of\t a\t linked\t list\t L.\t There\t are\t two possibilities\t for\t L:\t it\t either\t ends\t (snake)\t or\t its\t last\t element\t points\t back\t to\t one\t of\t the earlier\telements\tin\tthe\tlist\t(snail).\tGive\tan\talgorithm\tthat\ttests\twhether\ta\tgiven\tlist\tL\tis\ta snake\tor\ta\tsnail. Solution:\tIt\tis\tthe\tsame\tas\tProblem-6. Problem-11\u2003\u2003Check\t whether\t the\t given\t linked\t list\t is\t NULL-terminated\t or\t not.\t If\t there\t is\t a cycle\tfind\tthe\tstart\tnode\tof\tthe\tloop. Solution:\tThe\tsolution\tis\tan\textension\tto\tthe\tsolution\tin\tProblem-9.\tAfter\tfinding\tthe\tloop\tin\tthe linked\tlist,\twe\tinitialize\tthe\tslowPtr\tto\tthe\thead\tof\tthe\tlinked\tlist.\tFrom\tthat\tpoint\tonwards\tboth slowPtr\tand\tfastPtr\tmove\tonly\tone\tnode\tat\ta\ttime.\tThe\tpoint\tat\twhich\tthey\tmeet\tis\tthe\tstart\tof\tthe loop.\tGenerally\twe\tuse\tthis\tmethod\tfor\tremoving\tthe\tloops. Time\tComplexity:\tO(n).\tSpace\tComplexity:\tO(1). Problem-12\u2003\u2003From\tthe\tprevious\tdiscussion\tand\tproblems\twe\tunderstand\tthat\tthe\tmeeting\tof tortoise\tand\thare\tconcludes\tthe\texistence\tof\tthe\tloop,\tbut\thow\tdoes\tmoving\tthe\ttortoise\tto the\tbeginning\tof\tthe\tlinked\tlist\twhile\tkeeping\tthe\thare\tat\tthe\tmeeting\tplace,\tfollowed\tby moving\tboth\tone\tstep\tat\ta\ttime,\tmake\tthem\tmeet\tat\tthe\tstarting\tpoint\tof\tthe\tcycle? Solution:\tThis\tproblem\tis\tat\tthe\theart\tof\tnumber\ttheory.\tIn\tthe\tFloyd\tcycle\tfinding\talgorithm, notice\tthat\tthe\ttortoise\tand\tthe\thare\twill\tmeet\twhen\tthey\tare\tn\t\u00d7\tL,\twhere\tL\tis\tthe\tloop\tlength. Furthermore,\tthe\ttortoise\tis\tat\tthe\tmidpoint\tbetween\tthe\thare\tand\tthe\tbeginning\tof\tthe\tsequence because\tof\tthe\tway\tthey\tmove.\tTherefore\tthe\ttortoise\tis\tn\t\u00d7\tL\taway\tfrom\tthe\tbeginning\tof\tthe sequence\tas\twell.\tIf\twe\tmove\tboth\tone\tstep\tat\ta\ttime,\tfrom\tthe\tposition\tof\tthe\ttortoise\tand\tfrom the\tstart\tof\tthe\tsequence,\twe\tknow\tthat\tthey\twill\tmeet\tas\tsoon\tas\tboth\tare\tin\tthe\tloop,\tsince\tthey are\tn\t\u00d7\tL,\ta\tmultiple\tof\tthe\tloop\tlength,\tapart.\tOne\tof\tthem\tis\talready\tin\tthe\tloop,\tso\twe\tjust\tmove the\tother\tone\tin\tsingle\tstep\tuntil\tit\tenters\tthe\tloop,\tkeeping\tthe\tother\tn\t\u00d7\tL\taway\tfrom\tit\tat\tall times. Problem-13\u2003\u2003In\t the\t Floyd\t cycle\t finding\t algorithm,\t does\t it\t work\t if\t we\t use\t steps\t 2\t and\t 3 instead\tof\t1\tand\t2? Solution:\tYes,\tbut\tthe\tcomplexity\tmight\tbe\thigh.\tTrace\tout\tan\texample. Problem-14\u2003\u2003Check\twhether\tthe\tgiven\tlinked\tlist\tis\tNULL-terminated.\tIf\tthere\tis\ta\tcycle,\tfind the\tlength\tof\tthe\tloop. Solution:\tThis\tsolution\tis\talso\tan\textension\tof\tthe\tbasic\tcycle\tdetection\tproblem.\tAfter\tfinding\tthe loop\tin\tthe\tlinked\tlist,\tkeep\tthe\tslowPtr\tas\tit\tis.\tThe\tfastPtr\tkeeps\ton\tmoving\tuntil\tit\tagain\tcomes back\tto\tslowPtr.\tWhile\tmoving\tfastPtr,\tuse\ta\tcounter\tvariable\twhich\tincrements\tat\tthe\trate\tof\t1. Time\tComplexity:\tO(n).\tSpace\tComplexity:\tO(1). Problem-15\u2003\u2003Insert\ta\tnode\tin\ta\tsorted\tlinked\tlist. Solution:\tTraverse\tthe\tlist\tand\tfind\ta\tposition\tfor\tthe\telement\tand\tinsert\tit. Time\tComplexity:\tO(n).\tSpace\tComplexity:\tO(1). Problem-16\u2003\u2003Reverse\ta\tsingly\tlinked\tlist. Solution: Time\tComplexity:\tO(n).\tSpace\tComplexity:\tO(1). Recursive\tversion:\tWe\twill\tfind\tit\teasier\tto\tstart\tfrom\tthe\tbottom\tup,\tby\tasking\tand\tanswering tiny\tquestions\t(this\tis\tthe\tapproach\tin\tThe\tLittle\tLisper): \u2022 What\tis\tthe\treverse\tof\tNULL\t(the\tempty\tlist)?\tNULL. \u2022 What\tis\tthe\treverse\tof\ta\tone\telement\tlist?\tThe\telement\titself. \u2022 What\tis\tthe\treverse\tof\tan\tn\telement\tlist?\tThe\treverse\tof\tthe\tsecond\telement\tfollowed by\tthe\tfirst\telement. Time\tComplexity:\tO(n).\tSpace\tComplexity:\tO(n),for\trecursive\tstack. Problem-17\u2003\u2003Suppose\tthere\tare\ttwo\tsingly\tlinked\tlists\tboth\tof\twhich\tintersect\tat\tsome\tpoint and\tbecome\ta\tsingle\tlinked\tlist.\tThe\thead\tor\tstart\tpointers\tof\tboth\tthe\tlists\tare\tknown,\tbut the\tintersecting\tnode\tis\tnot\tknown.\tAlso,\tthe\tnumber\tof\tnodes\tin\teach\tof\tthe\tlists\tbefore they\tintersect\tis\tunknown\tand\tmay\tbe\tdifferent\tin\teach\tlist.\tList1\tmay\thave\tn\tnodes\tbefore it\t reaches\t the\t intersection\t point,\t and\t List2\t might\t have\t m\t nodes\t before\t it\t reaches\t the intersection\tpoint\twhere\tm\tand\tn\tmay\tbe\tm\t=\tn,m\t<\tn\tor\tm\t>\tn.\tGive\tan\talgorithm\tfor finding\tthe\tmerging\tpoint. Solution:\tBrute-Force\tApproach:\tOne\teasy\tsolution\tis\tto\tcompare\tevery\tnode\tpointer\tin\tthe\tfirst list\twith\tevery\tother\tnode\tpointer\tin\tthe\tsecond\tlist\tby\twhich\tthe\tmatching\tnode\tpointers\twill\tlead us\tto\tthe\tintersecting\tnode.\tBut,\tthe\ttime\tcomplexity\tin\tthis\tcase\twill\tbe\tO(mn)\twhich\twill\tbe high. Time\tComplexity:\tO(mn).\tSpace\tComplexity:\tO(1). Problem-18\u2003\u2003Can\twe\tsolve\tProblem-17\tusing\tthe\tsorting\ttechnique? Solution:\t No.\t Consider\t the\t following\t algorithm\t which\t is\t based\t on\t sorting\t and\t see\t why\t this algorithm\tfails. Algorithm: \u2022 Take\tfirst\tlist\tnode\tpointers\tand\tkeep\tthem\tin\tsome\tarray\tand\tsort\tthem. \u2022 Take\tsecond\tlist\tnode\tpointers\tand\tkeep\tthem\tin\tsome\tarray\tand\tsort\tthem. \u2022 After\tsorting,\tuse\ttwo\tindexes:\tone\tfor\tthe\tfirst\tsorted\tarray\tand\tthe\tother\tfor\tthe second\tsorted\tarray. \u2022 Start\t comparing\t values\t at\t the\t indexes\t and\t increment\t the\t index\t according\t to whichever\thas\tthe\tlower\tvalue\t(increment\tonly\tif\tthe\tvalues\tare\tnot\tequal). \u2022 At\tany\tpoint,\tif\twe\tare\table\tto\tfind\ttwo\tindexes\twhose\tvalues\tare\tthe\tsame,\tthen\tthat indicates\t that\t those\t two\t nodes\t are\t pointing\t to\t the\t same\t node\t and\t we\t return\t that node. Time\tComplexity:\tTime\tfor\tsorting\tlists\t+\tTime\tfor\tscanning\t(for\tcomparing) =\tO(mlogm)\t+O(nlogn)\t+O(m\t+\tn)\tWe\tneed\tto\tconsider\tthe\tone\tthat\tgives\tthe maximum\tvalue. Space\tComplexity:\tO(1). Any\t problem\t with\t the\t above\t algorithm?\t Yes.\t In\t the\t algorithm,\t we\t are\t storing\t all\t the\t node pointers\tof\tboth\tthe\tlists\tand\tsorting.\tBut\twe\tare\tforgetting\tthe\tfact\tthat\tthere\tcan\tbe\tmany\trepeated elements.\tThis\tis\tbecause\tafter\tthe\tmerging\tpoint,\tall\tnode\tpointers\tare\tthe\tsame\tfor\tboth\tthe\tlists. The\talgorithm\tworks\tfine\tonly\tin\tone\tcase\tand\tit\tis\twhen\tboth\tlists\thave\tthe\tending\tnode\tat\ttheir merge\tpoint. Problem-19\u2003\u2003Can\twe\tsolve\tProblem-17\tusing\thash\ttables? Solution:\tYes. Algorithm: \u2022 Select\t a\t list\t which\t has\t less\t number\t of\t nodes\t (If\t we\t do\t not\t know\t the\t lengths beforehand\tthen\tselect\tone\tlist\trandomly). \u2022 Now,\ttraverse\tthe\tother\tlist\tand\tfor\teach\tnode\tpointer\tof\tthis\tlist\tcheck\twhether\tthe same\tnode\tpointer\texists\tin\tthe\thash\ttable. \u2022 If\tthere\tis\ta\tmerge\tpoint\tfor\tthe\tgiven\tlists\tthen\twe\twill\tdefinitely\tencounter\tthe\tnode pointer\tin\tthe\thash\ttable. Time\tComplexity:\tTime\tfor\tcreating\tthe\thash\ttable\t+\tTime\tfor\tscanning\tthe\tsecond\tlist\t=\tO(m)\t+ O(n)\t(or\tO(n)\t+\tO(m),\tdepending\ton\twhich\tlist\twe\tselect\tfor\tcreating\tthe\thash\ttable.\tBut\tin\tboth cases\tthe\ttime\tcomplexity\tis\tthe\tsame.\tSpace\tComplexity:\tO(n)\tor\tO(m). Problem-20\u2003\u2003Can\twe\tuse\tstacks\tfor\tsolving\tthe\tProblem-17? Solution:\tYes. Algorithm: \u2022 Create\ttwo\tstacks:\tone\tfor\tthe\tfirst\tlist\tand\tone\tfor\tthe\tsecond\tlist. \u2022 Traverse\tthe\tfirst\tlist\tand\tpush\tall\tthe\tnode\taddresses\tonto\tthe\tfirst\tstack. \u2022 Traverse\tthe\tsecond\tlist\tand\tpush\tall\tthe\tnode\taddresses\tonto\tthe\tsecond\tstack. \u2022 Now\tboth\tstacks\tcontain\tthe\tnode\taddress\tof\tthe\tcorresponding\tlists. \u2022 Now\tcompare\tthe\ttop\tnode\taddress\tof\tboth\tstacks. \u2022 If\tthey\tare\tthe\tsame,\ttake\tthe\ttop\telements\tfrom\tboth\tthe\tstacks\tand\tkeep\tthem\tin some\ttemporary\tvariable\t(since\tboth\tnode\taddresses\tare\tnode,\tit\tis\tenough\tif\twe use\tone\ttemporary\tvariable). \u2022 Continue\tthis\tprocess\tuntil\tthe\ttop\tnode\taddresses\tof\tthe\tstacks\tare\tnot\tthe\tsame. \u2022 This\tpoint\tis\tthe\tone\twhere\tthe\tlists\tmerge\tinto\ta\tsingle\tlist. \u2022 Return\tthe\tvalue\tof\tthe\ttemporary\tvariable. Time\tComplexity:\tO(m\t+\tn),\tfor\tscanning\tboth\tthe\tlists. Space\tComplexity:\tO(m\t+\tn),\tfor\tcreating\ttwo\tstacks\tfor\tboth\tthe\tlists. Problem-21\u2003\u2003Is\tthere\tany\tother\tway\tof\tsolving\tProblem-17? Solution:\t Yes.\t Using\t \u201cfinding\t the\t first\t repeating\t number\u201d\t approach\t in\t an\t array\t (for\t algorithm refer\tto\tSearching\tchapter). Algorithm: \u2022 Create\tan\tarray\tA\tand\tkeep\tall\tthe\tnext\tpointers\tof\tboth\tthe\tlists\tin\tthe\tarray. \u2022 In\t the\t array\t find\t the\t first\t repeating\t element\t [Refer\t to\t Searching\t chapter\t for algorithm]. \u2022 The\tfirst\trepeating\tnumber\tindicates\tthe\tmerging\tpoint\tof\tboth\tthe\tlists. Time\tComplexity:\tO(m\t+\tn).\tSpace\tComplexity:\tO(m\t+\tn). Problem-22\u2003\u2003Can\twe\tstill\tthink\tof\tfinding\tan\talternative\tsolution\tfor\tProblem-17? Solution:\tYes.\tBy\tcombining\tsorting\tand\tsearch\ttechniques\twe\tcan\treduce\tthe\tcomplexity. Algorithm: \u2022 Create\tan\tarray\tA\tand\tkeep\tall\tthe\tnext\tpointers\tof\tthe\tfirst\tlist\tin\tthe\tarray. \u2022 Sort\tthese\tarray\telements. \u2022 Then,\tfor\teach\tof\tthe\tsecond\tlist\telements,\tsearch\tin\tthe\tsorted\tarray\t(let\tus\tassume that\twe\tare\tusing\tbinary\tsearch\twhich\tgives\tO(logn)). \u2022 Since\twe\tare\tscanning\tthe\tsecond\tlist\tone\tby\tone,\tthe\tfirst\trepeating\telement\tthat appears\tin\tthe\tarray\tis\tnothing\tbut\tthe\tmerging\tpoint. Time\tComplexity:\tTime\tfor\tsorting\t+\tTime\tfor\tsearching\t=\tO(Max(mlogm,\tnlogn)). Space\tComplexity:\tO(Max(m,\tn)). Problem-23\u2003\u2003Can\twe\timprove\tthe\tcomplexity\tfor\tProblem-17? Solution:\tYes. Efficient\tApproach: \u2022 Find\tlengths\t(L1\tand\tL2)\tof\tboth\tlists\t-\tO(n)\t+\tO(m)\t=\tO(max(m,\tn)). \u2022 Take\tthe\tdifference\td\tof\tthe\tlengths\t--\tO(1). \u2022 Make\td\tsteps\tin\tlonger\tlist\t--\tO(d). \u2022 Step\tin\tboth\tlists\tin\tparallel\tuntil\tlinks\tto\tnext\tnode\tmatch\t--\tO(min(m,\tn)). \u2022 Total\ttime\tcomplexity\t=\tO(max(m,\tn)). \u2022 Space\tComplexity\t=\tO(1). Problem-24\u2003\u2003How\twill\tyou\tfind\tthe\tmiddle\tof\tthe\tlinked\tlist? Solution:\tBrute-Force\tApproach:\tFor\teach\tof\tthe\tnode,\tcount\thow\tmany\tnodes\tare\tthere\tin\tthe list,\tand\tsee\twhether\tit\tis\tthe\tmiddle\tnode\tof\tthe\tlist. Time\tComplexity:\tO(n2).\tSpace\tComplexity:\tO(1). Problem-25\u2003\u2003Can\twe\timprove\tthe\tcomplexity\tof\tProblem-24? Solution:\tYes. Algorithm: \u2022 Traverse\tthe\tlist\tand\tfind\tthe\tlength\tof\tthe\tlist. \u2022 After\tfinding\tthe\tlength,\tagain\tscan\tthe\tlist\tand\tlocate\tn/2\tnode\tfrom\tthe\tbeginning. Time\tComplexity:\tTime\tfor\tfinding\tthe\tlength\tof\tthe\tlist\t+\tTime\tfor\tlocating\tmiddle\tnode\t=\tO(n)\t+ O(n)\t\u2248\tO(n). Space\tComplexity:\tO(1). Problem-26\u2003\u2003Can\twe\tuse\tthe\thash\ttable\tfor\tsolving\tProblem-24? Solution:\tYes.\tThe\treasoning\tis\tthe\tsame\tas\tthat\tof\tProblem-3. Time\tComplexity:\tTime\tfor\tcreating\tthe\thash\ttable.\tTherefore,\tT(n)\t=\tO(n). Space\tComplexity:\tO(n).\tSince\twe\tneed\tto\tcreate\ta\thash\ttable\tof\tsize\tn. Problem-27\u2003\u2003Can\twe\tsolve\tProblem-24\tjust\tin\tone\tscan? Solution:\tEfficient\tApproach:\t Use\t two\t pointers.\t Move\t one\t pointer\t at\t twice\t the\t speed\t of\t the second.\tWhen\tthe\tfirst\tpointer\treaches\tthe\tend\tof\tthe\tlist,\tthe\tsecond\tpointer\twill\tbe\tpointing\tto the\tmiddle\tnode. Note:\tIf\tthe\tlist\thas\tan\teven\tnumber\tof\tnodes,\tthe\tmiddle\tnode\twill\tbe\tof\t\u230an/2\u230b. Time\tComplexity:\tO(n).\tSpace\tComplexity:\tO(1). Problem-28\u2003\u2003How\twill\tyou\tdisplay\ta\tLinked\tList\tfrom\tthe\tend? Solution:\tTraverse\trecursively\ttill\tthe\tend\tof\tthe\tlinked\tlist.\tWhile\tcoming\tback,\tstart\tprinting\tthe elements. Time\tComplexity:\tO(n).\tSpace\tComplexity:\tO(n)\u2192\tfor\tStack. Problem-29\u2003\u2003Check\twhether\tthe\tgiven\tLinked\tList\tlength\tis\teven\tor\todd? Solution:\tUse\ta\t2x\tpointer.\tTake\ta\tpointer\tthat\tmoves\tat\t2x\t[two\tnodes\tat\ta\ttime].\tAt\tthe\tend,\tif the\tlength\tis\teven,\tthen\tthe\tpointer\twill\tbe\tNULL;\totherwise\tit\twill\tpoint\tto\tthe\tlast\tnode. Time\tComplexity:\tO(\u230an/2\u230b)\t\u2248\tO(n).\tSpace\tComplexity:\tO(1). Problem-30\u2003\u2003If\tthe\thead\tof\ta\tLinked\tList\tis\tpointing\tto\tkth\telement,\tthen\thow\twill\tyou\tget\tthe elements\tbefore\tkth\telement? Solution:\tUse\tMemory\tEfficient\tLinked\tLists\t[XOR\tLinked\tLists]. Problem-31\u2003\u2003Given\ttwo\tsorted\tLinked\tLists,\thow\tto\tmerge\tthem\tinto\tthe\tthird\tlist\tin\tsorted order? Solution:\tAssume\tthe\tsizes\tof\tlists\tare\tm\tand\tn. Recursive: Time\tComplexity:\tO(n\t+\tm),\twhere\tn\tand\tm\tare\tlengths\tof\ttwo\tlists. Iterative: Time\tComplexity:\tO(n\t+\tm),\twhere\tn\tand\tm\tare\tlengths\tof\ttwo\tlists. Problem-32\u2003\u2003Reverse\tthe\tlinked\tlist\tin\tpairs.\tIf\tyou\thave\ta\tlinked\tlist\tthat\tholds\t1\t\u2192\t2\t\u2192\t3 \u2192\t4\t\u2192\tX,\tthen\tafter\tthe\tfunction\thas\tbeen\tcalled\tthe\tlinked\tlist\twould\thold\t2\t\u2192\t1\t\u2192\t4\t\u2192 3\t\u2192\tX. Solution: Recursive: Iterative: Time\tComplexity:\tO(n).\tSpace\tComplexity:\tO(1). Problem-33\u2003\u2003Given\ta\tbinary\ttree\tconvert\tit\tto\tdoubly\tlinked\tlist. Solution:\tRefer\tTrees\tchapter. Problem-34\u2003\u2003How\tdo\twe\tsort\tthe\tLinked\tLists? Solution:\tRefer\tSorting\tchapter. Problem-35\u2003\u2003Split\ta\tCircular\tLinked\tList\tinto\ttwo\tequal\tparts.\tIf\tthe\tnumber\tof\tnodes\tin\tthe list\tare\todd\tthen\tmake\tfirst\tlist\tone\tnode\textra\tthan\tsecond\tlist. Solution: Algorithm: \u2022 Store\tthe\tmid\tand\tlast\tpointers\tof\tthe\tcircular\tlinked\tlist\tusing\tFloyd\tcycle\tfinding algorithm. \u2022 Make\tthe\tsecond\thalf\tcircular. \u2022 Make\tthe\tfirst\thalf\tcircular. \u2022 Set\thead\tpointers\tof\tthe\ttwo\tlinked\tlists. As\tan\texample,\tconsider\tthe\tfollowing\tcircular\tlist. After\tthe\tsplit,\tthe\tabove\tlist\twill\tlook\tlike: Time\tComplexity:\tO(n).\tSpace\tComplexity:\tO(1). Problem-36\u2003\u2003If\twe\twant\tto\tconcatenate\ttwo\tlinked\tlists\twhich\tof\tthe\tfollowing\tgives\tO(1) complexity? 1) Singly\tlinked\tlists 2) Doubly\tlinked\tlists 3) Circular\tdoubly\tlinked\tlists Solution:\tCircular\tDoubly\tLinked\tLists.\tThis\tis\tbecause\tfor\tsingly\tand\tdoubly\tlinked\tlists,\twe need\tto\ttraverse\tthe\tfirst\tlist\ttill\tthe\tend\tand\tappend\tthe\tsecond\tlist.\tBut\tin\tthe\tcase\tof\tcircular doubly\tlinked\tlists\twe\tdon\u2019t\thave\tto\ttraverse\tthe\tlists. Problem-37\u2003\u2003How\twill\tyou\tcheck\tif\tthe\tlinked\tlist\tis\tpalindrome\tor\tnot? Solution: Algorithm:"
            }
        ]
    },
    {
        "chapter_title": "1.",
        "subchapters": [
            {
                "subchapter_title": "Get\tthe\tmiddle\tof\tthe\tlinked\tlist.",
                "content": ""
            }
        ]
    },
    {
        "chapter_title": "2.",
        "subchapters": [
            {
                "subchapter_title": "Reverse\tthe\tsecond\thalf\tof\tthe\tlinked\tlist.",
                "content": ""
            }
        ]
    },
    {
        "chapter_title": "3.",
        "subchapters": [
            {
                "subchapter_title": "Compare\tthe\tfirst\thalf\tand\tsecond\thalf.",
                "content": ""
            }
        ]
    },
    {
        "chapter_title": "4.",
        "subchapters": [
            {
                "subchapter_title": "Construct\t the\t original\t linked\t list\t by\t reversing\t the\t second\t half\t again\t and",
                "content": "attaching\tit\tback\tto\tthe\tfirst\thalf. Time\tComplexity:\tO(n).\tSpace\tComplexity:\tO(1). Problem-38\u2003\u2003For\ta\tgiven\tK\tvalue\t(K\t>\t0)\treverse\tblocks\tof\tK\tnodes\tin\ta\tlist. Example:\tInput:\t1\t2\t3\t4\t5\t6\t7\t8\t9\t10.\tOutput\tfor\tdifferent\tK\tvalues: For\tK\t=\t2:\t2\t1\t4\t3\t6\t5\t8\t7\t10\t9 For\tK\t=\t3:\t3\t2\t1\t6\t5\t4\t9\t8\t7\t10 For\tK\t=\t4:\t4\t3\t2\t1\t8\t7\t6\t5\t9\t10 Solution: Algorithm:\tThis\tis\tan\textension\tof\tswapping\tnodes\tin\ta\tlinked\tlist. 1) Check\tif\tremaining\tlist\thas\tK\tnodes. a. If\tyes\tget\tthe\tpointer\tof\tK\t+\t1th\tnode. b. Else\treturn. 2) Reverse\tfirst\tK\tnodes. 3) Set\tnext\tof\tlast\tnode\t(after\treversal)\tto\tK\t+\t1th\tnode. 4) Move\tto\tK\t+\t1th\tnode. 5) Go\tto\tstep\t1. 6) K\t\u2013\t1th\tnode\tof\tfirst\tK\tnodes\tbecomes\tthe\tnew\thead\tif\tavailable.\tOtherwise,\twe\tcan return\tthe\thead. Problem-39\u2003\u2003Is\tit\tpossible\tto\tget\tO(1)\taccess\ttime\tfor\tLinked\tLists? Solution:\tYes.\tCreate\ta\tlinked\tlist\tand\tat\tthe\tsame\ttime\tkeep\tit\tin\ta\thash\ttable.\tFor\tn\telements\twe have\tto\tkeep\tall\tthe\telements\tin\ta\thash\ttable\twhich\tgives\ta\tpreprocessing\ttime\tof\tO(n).To\tread any\telement\twe\trequire\tonly\tconstant\ttime\tO(1)\tand\tto\tread\tn\telements\twe\trequire\tn\t*\t1\tunit\tof time\t =\t n\t units.\t Hence\t by\t using\t amortized\t analysis\t we\t can\t say\t that\t element\t access\t can\t be performed\twithin\tO(1)\ttime. Time\tComplexity\t\u2013\tO(1)\t[Amortized].\tSpace\tComplexity\t-\tO(n)\tfor\tHash\tTable. Problem-40\u2003\u2003Josephus\t Circle:\t N\t people\t have\t decided\t to\t elect\t a\t leader\t by\t arranging themselves\tin\ta\tcircle\tand\teliminating\tevery\tMth\tperson\taround\tthe\tcircle,\tclosing\tranks\tas each\tperson\tdrops\tout.\tFind\twhich\tperson\twill\tbe\tthe\tlast\tone\tremaining\t(with\trank\t1). Solution:\tAssume\tthe\tinput\tis\ta\tcircular\tlinked\tlist\twith\tN\tnodes\tand\teach\tnode\thas\ta\tnumber (range\t1\tto\tN)\tassociated\twith\tit.\tThe\thead\tnode\thas\tnumber\t1\tas\tdata. Problem-41\u2003\u2003Given\ta\tlinked\tlist\tconsists\tof\tdata,\ta\tnext\tpointer\tand\talso\ta\trandom\tpointer which\tpoints\tto\ta\trandom\tnode\tof\tthe\tlist.\tGive\tan\talgorithm\tfor\tcloning\tthe\tlist. Solution:\tWe\tcan\tuse\ta\thash\ttable\tto\tassociate\tnewly\tcreated\tnodes\twith\tthe\tinstances\tof\tnode\tin the\tgiven\tlist. Algorithm: \u2022 Scan\tthe\toriginal\tlist\tand\tfor\teach\tnode\tX,\tcreate\ta\tnew\tnode\tY\twith\tdata\tof\tX,\tthen store\tthe\tpair\t(X,\tY)\tin\thash\ttable\tusing\tX\tas\ta\tkey.\tNote\tthat\tduring\tthis\tscan\tset\tY \u2192\tnext\tand\tY\t\u2192\trandom\tto\tNULL\tand\twe\twill\tfix\tthem\tin\tthe\tnext\tscan. \u2022 Now\tfor\teach\tnode\tX\tin\tthe\toriginal\tlist\twe\thave\ta\tcopy\tY\tstored\tin\tour\thash\ttable. We\tscan\tthe\toriginal\tlist\tagain\tand\tset\tthe\tpointers\tbuilding\tthe\tnew\tlist. Time\tComplexity:\tO(n).\tSpace\tComplexity:\tO(n). Problem-42\u2003\u2003Can\twe\tsolve\tProblem-41\twithout\tany\textra\tspace? Solution:\tYes. Time\tComplexity:\tO(3n)\t\u2248\tO(n).\tSpace\tComplexity:\tO(1). Problem-43\u2003\u2003We\tare\tgiven\ta\tpointer\tto\ta\tnode\t(not\tthe\ttail\tnode)\tin\ta\tsingly\tlinked\tlist.\tDelete that\tnode\tfrom\tthe\tlinked\tlist. Solution:\tTo\tdelete\ta\tnode,\twe\thave\tto\tadjust\tthe\tnext\tpointer\tof\tthe\tprevious\tnode\tto\tpoint\tto\tthe next\tnode\tinstead\tof\tthe\tcurrent\tone.\tSince\twe\tdon\u2019t\thave\ta\tpointer\tto\tthe\tprevious\tnode,\twe\tcan\u2019t redirect\tits\tnext\tpointer.\tSo\twhat\tdo\twe\tdo?\tWe\tcan\teasily\tget\taway\tby\tmoving\tthe\tdata\tfrom\tthe next\tnode\tinto\tthe\tcurrent\tnode\tand\tthen\tdeleting\tthe\tnext\tnode. Time\tComplexity:\tO(1).\tSpace\tComplexity:\tO(1). Problem-44\u2003\u2003Given\ta\tlinked\tlist\twith\teven\tand\todd\tnumbers,\tcreate\tan\talgorithm\tfor\tmaking changes\tto\tthe\tlist\tin\tsuch\ta\tway\tthat\tall\teven\tnumbers\tappear\tat\tthe\tbeginning. Solution:\tTo\tsolve\tthis\tproblem,\twe\tcan\tuse\tthe\tsplitting\tlogic.\tWhile\ttraversing\tthe\tlist,\tsplit\tthe linked\tlist\tinto\ttwo:\tone\tcontains\tall\teven\tnodes\tand\tthe\tother\tcontains\tall\todd\tnodes.\tNow,\tto\tget the\tfinal\tlist,\twe\tcan\tsimply\tappend\tthe\todd\tnode\tlinked\tlist\tafter\tthe\teven\tnode\tlinked\tlist. To\tsplit\tthe\tlinked\tlist,\ttraverse\tthe\toriginal\tlinked\tlist\tand\tmove\tall\todd\tnodes\tto\ta\tseparate linked\tlist\tof\tall\todd\tnodes.\tAt\tthe\tend\tof\tthe\tloop,\tthe\toriginal\tlist\twill\thave\tall\tthe\teven\tnodes and\tthe\todd\tnode\tlist\twill\thave\tall\tthe\todd\tnodes.\tTo\tkeep\tthe\tordering\tof\tall\tnodes\tthe\tsame,\twe must\tinsert\tall\tthe\todd\tnodes\tat\tthe\tend\tof\tthe\todd\tnode\tlist. Time\tComplexity:\tO(n).\tSpace\tComplexity:\tO(1). Problem-45\u2003\u2003In\ta\tlinked\tlist\twith\tn\tnodes,\tthe\ttime\ttaken\tto\tinsert\tan\telement\tafter\tan\telement pointed\tby\tsome\tpointer\tis (A) O(1) (B) O(logn) (C) O(n) (D) O(nlogn) Solution:\tA. Problem-46\u2003\u2003Find\tmodular\tnode:\tGiven\ta\tsingly\tlinked\tlist,\twrite\ta\tfunction\tto\tfind\tthe\tlast element\tfrom\tthe\tbeginning\twhose\tn%k\t==\t0,\twhere\tn\tis\tthe\tnumber\tof\telements\tin\tthe\tlist and\tk\tis\tan\tinteger\tconstant.\tFor\texample,\tif\tn\t=\t19\tand\tk\t=\t3\tthen\twe\tshould\treturn\t18th node. Solution:\tFor\tthis\tproblem\tthe\tvalue\tof\tn\tis\tnot\tknown\tin\tadvance. Time\tComplexity:\tO(n).\tSpace\tComplexity:\tO(1). Problem-47\u2003\u2003Find\tmodular\tnode\tfrom\tthe\tend:\tGiven\ta\tsingly\tlinked\tlist,\twrite\ta\tfunction\tto find\tthe\tfirst\tfrom\tthe\tend\twhose\tn%k\t==\t0,\twhere\tn\tis\tthe\tnumber\tof\telements\tin\tthe\tlist and\tk\tis\tan\tinteger\tconstant.\tIf\tn\t=\t19\tand\tk\t=\t3\tthen\twe\tshould\treturn\t16th\tnode. Solution:\tFor\tthis\tproblem\tthe\tvalue\tof\tn\tis\tnot\tknown\tin\tadvance\tand\tit\tis\tthe\tsame\tas\tfinding\tthe kth\telement\tfrom\tthe\tend\tof\tthe\tthe\tlinked\tlist. Time\tComplexity:\tO(n).\tSpace\tComplexity:\tO(1). Problem-48\u2003\u2003Find\tfractional\tnode:\tGiven\ta\tsingly\tlinked\tlist,\twrite\ta\tfunction\tto\tfind\tthe\t \telement,\twhere\tn\tis\tthe\tnumber\tof\telements\tin\tthe\tlist. Solution:\tFor\tthis\tproblem\tthe\tvalue\tof\tn\tis\tnot\tknown\tin\tadvance. Time\tComplexity:\tO(n).\tSpace\tComplexity:\tO(1). Problem-49\u2003\u2003Find\t \tnode:\tGiven\ta\tsingly\tlinked\tlist,\twrite\ta\tfunction\tto\tfind\tthe\t element,\twhere\tn\tis\tthe\tnumber\tof\telements\tin\tthe\tlist.\tAssume\tthe\tvalue\tof\tn\tis\tnot\tknown in\tadvance. Solution:\tFor\tthis\tproblem\tthe\tvalue\tof\tn\tis\tnot\tknown\tin\tadvance. Time\tComplexity:\tO(n).\tSpace\tComplexity:\tO(1). Problem-50\u2003\u2003Given\ttwo\tlists\tList\t1\t=\t{A1,\tA2,\t.\t.\t.\t,\tAn)\tand\tList2\t=\t{B1,\tB2,\t.\t.\t.\t,\tBm}\twith data\t(both\tlists)\tin\tascending\torder.\tMerge\tthem\tinto\tthe\tthird\tlist\tin\tascending\torder\tso that\tthe\tmerged\tlist\twill\tbe: Solution: Time\tComplexity:\tThe\twhile\tloop\ttakes\tO(min(n,m))\ttime\tas\tit\twill\trun\tfor\tmin(n,m)\ttimes.\tThe other\tsteps\trun\tin\tO(1).\tTherefore\tthe\ttotal\ttime\tcomplexity\tis\tO(min(n,m)).\tSpace\tComplexity: O(1). Problem-51\u2003\u2003Median\tin\tan\tinfinite\tseries\tof\tintegers Solution:\tMedian\tis\tthe\tmiddle\tnumber\tin\ta\tsorted\tlist\tof\tnumbers\t(if\twe\thave\tan\todd\tnumber\tof elements).\t If\t we\t have\t an\t even\t number\t of\t elements,\t the\t median\t is\t the\t average\t of\t two\t middle numbers\tin\ta\tsorted\tlist\tof\tnumbers.\tWe\tcan\tsolve\tthis\tproblem\twith\tlinked\tlists\t(with\tboth\tsorted and\tunsorted\tlinked\tlists). First,\tlet\tus\ttry\twith\tan\tunsorted\tlinked\tlist.\tIn\tan\tunsorted\tlinked\tlist,\twe\tcan\tinsert\tthe\telement either\tat\tthe\thead\tor\tat\tthe\ttail.\tThe\tdisadvantage\twith\tthis\tapproach\tis\tthat\tfinding\tthe\tmedian takes\tO(n).\tAlso,\tthe\tinsertion\toperation\ttakes\tO(1). Now,\tlet\tus\ttry\twith\ta\tsorted\tlinked\tlist.\tWe\tcan\tfind\tthe\tmedian\tin\tO(1)\ttime\tif\twe\tkeep\ttrack\tof the\tmiddle\telements.\tInsertion\tto\ta\tparticular\tlocation\tis\talso\tO(1)\tin\tany\tlinked\tlist.\tBut,\tfinding the\tright\tlocation\tto\tinsert\tis\tnot\tO(logn)\tas\tin\ta\tsorted\tarray,\tit\tis\tinstead\tO(n)\tbecause\twe\tcan\u2019t perform\tbinary\tsearch\tin\ta\tlinked\tlist\teven\tif\tit\tis\tsorted.\tSo,\tusing\ta\tsorted\tlinked\tlist\tisn\u2019t\tworth the\teffort\tas\tinsertion\tis\tO(n)\tand\tfinding\tmedian\tis\tO(1),\tthe\tsame\tas\tthe\tsorted\tarray.\tIn\tthe sorted\tarray\tthe\tinsertion\tis\tlinear\tdue\tto\tshifting,\tbut\there\tit\u2019s\tlinear\tbecause\twe\tcan\u2019t\tdo\ta\tbinary search\tin\ta\tlinked\tlist. Note:\tFor\tan\tefficient\talgorithm\trefer\tto\tthe\tPriority\tQueues\tand\tHeaps\tchapter. Problem-52\u2003\u2003Given\ta\tlinked\tlist,\thow\tdo\tyou\tmodify\tit\tsuch\tthat\tall\tthe\teven\tnumbers\tappear before\tall\tthe\todd\tnumbers\tin\tthe\tmodified\tlinked\tlist? Solution: Time\tComplexity:\tO(n).\tSpace\tComplexity:\tO(1). Problem-53\u2003\u2003Given\t two\t linked\t lists,\t each\t list\t node\t with\t one\t integer\t digit,\t add\t these\t two linked\tlists.\tThe\tresult\tshould\tbe\tstored\tin\tthe\tthird\tlinked\tlist.\tAlso\tnote\tthat\tthe\thead\tnode contains\tthe\tmost\tsignificant\tdigit\tof\tthe\tnumber. Solution:\tSince\tthe\tinteger\taddition\tstarts\tfrom\tthe\tleast\tsignificant\tdigit,\twe\tfirst\tneed\tto\tvisit\tthe last\tnode\tof\tboth\tlists\tand\tadd\tthem\tup,\tcreate\ta\tnew\tnode\tto\tstore\tthe\tresult,\ttake\tcare\tof\tthe\tcarry if\tany,\tand\tlink\tthe\tresulting\tnode\tto\tthe\tnode\twhich\twill\tbe\tadded\tto\tthe\tsecond\tleast\tsignificant node\tand\tcontinue. First\tof\tall,\twe\tneed\tto\ttake\tinto\taccount\tthe\tdifference\tin\tthe\tnumber\tof\tdigits\tin\tthe\ttwo\tnumbers. So\tbefore\tstarting\trecursion,\twe\tneed\tto\tdo\tsome\tcalculation\tand\tmove\tthe\tlonger\tlist\tpointer\tto the\tappropriate\tplace\tso\tthat\twe\tneed\tthe\tlast\tnode\tof\tboth\tlists\tat\tthe\tsame\ttime.\tThe\tother\tthing we\tneed\tto\ttake\tcare\tof\tis\tcarry.\tIf\ttwo\tdigits\tadd\tup\tto\tmore\tthan\t10,\twe\tneed\tto\tforward\tthe carry\tto\tthe\tnext\tnode\tand\tadd\tit.\tIf\tthe\tmost\tsignificant\tdigit\taddition\tresults\tin\ta\tcarry,\twe\tneed to\tcreate\tan\textra\tnode\tto\tstore\tthe\tcarry. The\t function\t below\t is\t actually\t a\t wrapper\t function\t which\t does\t all\t the\t housekeeping\t like calculating\tlengths\tof\tlists,\tcalling\trecursive\timplementation,\tcreating\tan\textra\tnode\tfor\tthe\tcarry in\tthe\tmost\tsignificant\tdigit,\tand\tadding\tany\tremaining\tnodes\tleft\tin\tthe\tlonger\tlist. Time\tComplexity:\tO(max(List1\tlength,List2\tlength)). Space\tComplexity:\tO(min(List1\tlength,\tList1\tlength))\tfor\trecursive\tstack. Note:\tIt\tcan\talso\tbe\tsolved\tusing\tstacks. Problem-54\u2003\u2003Which\tsorting\talgorithm\tis\teasily\tadaptable\tto\tsingly\tlinked\tlists? Solution:\tSimple\tInsertion\tsort\tis\teasily\tadabtable\tto\tsingly\tlinked\tlists.\tTo\tinsert\tan\telement,\tthe linked\tlist\tis\ttraversed\tuntil\tthe\tproper\tposition\tis\tfound,\tor\tuntil\tthe\tend\tof\tthe\tlist\tis\treached.\tIt is\tinserted\tinto\tthe\tlist\tby\tmerely\tadjusting\tthe\tpointers\twithout\tshifting\tany\telements,\tunlike\tin\tthe array.\tThis\treduces\tthe\ttime\trequired\tfor\tinsertion\tbut\tnot\tthe\ttime\trequired\tfor\tsearching\tfor\tthe proper\tposition. Problem-55\u2003\u2003Given\t a\t list,\t List1\t =\t {A1,\t A2,\t .\t .\t .\t An\u20131;\t An)\t with\t data,\t reorder\t it\t to\t {A1, An,A2,An\u20131}\twithout\tusing\tany\textra\tspace. Solution:\tFind\tthe\tmiddle\tof\tthe\tlinked\tlist.\tWe\tcan\tdo\tit\tby\tslow\tand\tfast\tpointer\tapproach.\tAfter finding\tthe\tmiddle\tnode,\twe\treverse\tthe\tright\thalfl\tthen\twe\tdo\ta\tin\tplace\tmerge\tof\tthe\ttwo\thalves of\tthe\tlinked\tlist. Problem-56\u2003\u2003Given\t two\t sorted\t linked\t lists,\t given\t an\t algorithm\t for\t the\t printing\t common elements\tof\tthem. Solution:\tThe\tsolution\tis\tbased\ton\tmerge\tsort\tlogic.\tAssume\tthe\tgiven\ttwo\tlinked\tlists\tare:\tlist1 and\tlist2.\tSince\tthe\telements\tare\tin\tsorted\torder,\twe\trun\ta\tloop\ttill\twe\treach\tthe\tend\tof\teither\tof the\tlist.\tWe\tcompare\tthe\tvalues\tof\tlist1\tand\tlist2.\tIf\tthe\tvalues\tare\tequal,\twe\tadd\tit\tto\tthe\tcommon list.\tWe\tmove\tlist1/list2/both\tnodes\tahead\tto\tthe\tnext\tpointer\tif\tthe\tvalues\tpointed\tby\tlist1\twas less\t/\tmore\t/\tequal\tto\tthe\tvalue\tpointed\tby\tlist2. Time\t complexity\t O(m\t +\t n),\t where\t m\t is\t the\t lengh\t of\t list1\t and\t n\t is\t the\t length\t of\t list2.\t Space Complexity:\tO(1)."
            },
            {
                "subchapter_title": "4.1\tWhat\tis\ta\tStack?",
                "content": "A\tstack\tis\ta\tsimple\tdata\tstructure\tused\tfor\tstoring\tdata\t(similar\tto\tLinked\tLists).\tIn\ta\tstack,\tthe order\tin\twhich\tthe\tdata\tarrives\tis\timportant.\tA\tpile\tof\tplates\tin\ta\tcafeteria\tis\ta\tgood\texample\tof\ta stack.\tThe\tplates\tare\tadded\tto\tthe\tstack\tas\tthey\tare\tcleaned\tand\tthey\tare\tplaced\ton\tthe\ttop.\tWhen\ta plate,\tis\trequired\tit\tis\ttaken\tfrom\tthe\ttop\tof\tthe\tstack.\tThe\tfirst\tplate\tplaced\ton\tthe\tstack\tis\tthe\tlast one\tto\tbe\tused. Definition:\tA\tstack\tis\tan\tordered\tlist\tin\twhich\tinsertion\tand\tdeletion\tare\tdone\tat\tone\tend,\tcalled top.\tThe\tlast\telement\tinserted\tis\tthe\tfirst\tone\tto\tbe\tdeleted.\tHence,\tit\tis\tcalled\tthe\tLast\tin\tFirst\tout (LIFO)\tor\tFirst\tin\tLast\tout\t(FILO)\tlist. Special\tnames\tare\tgiven\tto\tthe\ttwo\tchanges\tthat\tcan\tbe\tmade\tto\ta\tstack.\tWhen\tan\telement\tis inserted\tin\ta\tstack,\tthe\tconcept\tis\tcalled\tpush,\tand\twhen\tan\telement\tis\tremoved\tfrom\tthe\tstack,\tthe concept\tis\tcalled\tpop.\tTrying\tto\tpop\tout\tan\tempty\tstack\tis\tcalled\tunderflow\tand\ttrying\tto\tpush\tan element\tin\ta\tfull\tstack\tis\tcalled\toverflow.\tGenerally,\twe\ttreat\tthem\tas\texceptions.\tAs\tan\texample, consider\tthe\tsnapshots\tof\tthe\tstack."
            },
            {
                "subchapter_title": "4.2\tHow\tStacks\tare\tused",
                "content": "Consider\t a\t working\t day\t in\t the\t office.\t Let\t us\t assume\t a\t developer\t is\t working\t on\t a\t long-term project.\t The\t manager\t then\t gives\t the\t developer\t a\t new\t task\t which\t is\t more\t important.\t The developer\tputs\tthe\tlong-term\tproject\taside\tand\tbegins\twork\ton\tthe\tnew\ttask.\tThe\tphone\trings,\tand this\tis\tthe\thighest\tpriority\tas\tit\tmust\tbe\tanswered\timmediately.\tThe\tdeveloper\tpushes\tthe\tpresent task\tinto\tthe\tpending\ttray\tand\tanswers\tthe\tphone. When\tthe\tcall\tis\tcomplete\tthe\ttask\tthat\twas\tabandoned\tto\tanswer\tthe\tphone\tis\tretrieved\tfrom\tthe pending\ttray\tand\twork\tprogresses.\tTo\ttake\tanother\tcall,\tit\tmay\thave\tto\tbe\thandled\tin\tthe\tsame manner,\tbut\teventually\tthe\tnew\ttask\twill\tbe\tfinished,\tand\tthe\tdeveloper\tcan\tdraw\tthe\tlong-term project\tfrom\tthe\tpending\ttray\tand\tcontinue\twith\tthat."
            },
            {
                "subchapter_title": "4.3\tStack\tADT",
                "content": "The\tfollowing\toperations\tmake\ta\tstack\tan\tADT.\tFor\tsimplicity,\tassume\tthe\tdata\tis\tan\tinteger\ttype. Main\tstack\toperations \u2022 Push\t(int\tdata):\tInserts\tdata\tonto\tstack. \u2022 int\tPop():\tRemoves\tand\treturns\tthe\tlast\tinserted\telement\tfrom\tthe\tstack. Auxiliary\tstack\toperations \u2022 int\tTop():\tReturns\tthe\tlast\tinserted\telement\twithout\tremoving\tit. \u2022 int\tSize():\tReturns\tthe\tnumber\tof\telements\tstored\tin\tthe\tstack. \u2022 int\tIsEmptyStack():\tIndicates\twhether\tany\telements\tare\tstored\tin\tthe\tstack\tor\tnot. \u2022 int\tIsFullStack():\tIndicates\twhether\tthe\tstack\tis\tfull\tor\tnot. Exceptions Attempting\t the\t execution\t of\t an\t operation\t may\t sometimes\t cause\t an\t error\t condition,\t called\t an exception.\tExceptions\tare\tsaid\tto\tbe\t\u201cthrown\u201d\tby\tan\toperation\tthat\tcannot\tbe\texecuted.\tIn\tthe Stack\tADT,\toperations\tpop\tand\ttop\tcannot\tbe\tperformed\tif\tthe\tstack\tis\tempty.\tAttempting\tthe execution\tof\tpop\t(top)\ton\tan\tempty\tstack\tthrows\tan\texception.\tTrying\tto\tpush\tan\telement\tin\ta\tfull stack\tthrows\tan\texception."
            },
            {
                "subchapter_title": "4.4\tApplications",
                "content": "Following\tare\tsome\tof\tthe\tapplications\tin\twhich\tstacks\tplay\tan\timportant\trole. Direct\tapplications \u2022 Balancing\tof\tsymbols \u2022 Infix-to-postfix\tconversion \u2022 Evaluation\tof\tpostfix\texpression \u2022 Implementing\tfunction\tcalls\t(including\trecursion) \u2022 Finding\tof\tspans\t(finding\tspans\tin\tstock\tmarkets,\trefer\tto\tProblems\tsection) \u2022 Page-visited\thistory\tin\ta\tWeb\tbrowser\t[Back\tButtons] \u2022 Undo\tsequence\tin\ta\ttext\teditor \u2022 Matching\tTags\tin\tHTML\tand\tXML Indirect\tapplications \u2022 Auxiliary\tdata\tstructure\tfor\tother\talgorithms\t(Example:\tTree\ttraversal\talgorithms) \u2022 Component\t of\t other\t data\t structures\t (Example:\t Simulating\t queues,\t refer\t Queues chapter)"
            },
            {
                "subchapter_title": "4.5\tImplementation",
                "content": "There\tare\tmany\tways\tof\timplementing\tstack\tADT;\tbelow\tare\tthe\tcommonly\tused\tmethods. \u2022 Simple\tarray\tbased\timplementation \u2022 Dynamic\tarray\tbased\timplementation \u2022 Linked\tlists\timplementation Simple\tArray\tImplementation This\timplementation\tof\tstack\tADT\tuses\tan\tarray.\tIn\tthe\tarray,\twe\tadd\telements\tfrom\tleft\tto\tright and\tuse\ta\tvariable\tto\tkeep\ttrack\tof\tthe\tindex\tof\tthe\ttop\telement. The\tarray\tstoring\tthe\tstack\telements\tmay\tbecome\tfull.\tA\tpush\toperation\twill\tthen\tthrow\ta\tfull stack\texception.\tSimilarly,\tif\twe\ttry\tdeleting\tan\telement\tfrom\tan\tempty\tstack\tit\twill\tthrow\tstack empty\texception. Performance\t&\tLimitations Performance Let\t n\t be\t the\t number\t of\t elements\t in\t the\t stack.\t The\t complexities\t of\t stack\t operations\t with\t this representation\tcan\tbe\tgiven\tas: Space\tComplexity\t(for\tn\tpush\toperations) O(n) Time\tComplexity\tof\tPush() O(1) Time\tComplexity\tof\tPop() O(1) Time\tComplexity\tof\tSize() O(1) Time\tComplexity\tof\tIsEmptyStack() O(1) Time\tComplexity\tof\tIsFullStackf) O(1) Time\tComplexity\tof\tDeleteStackQ O(1) Limitations The\tmaximum\tsize\tof\tthe\tstack\tmust\tfirst\tbe\tdefined\tand\tit\tcannot\tbe\tchanged.\tTrying\tto\tpush\ta new\telement\tinto\ta\tfull\tstack\tcauses\tan\timplementation-specific\texception. Dynamic\tArray\tImplementation First,\tlet\u2019s\tconsider\thow\twe\timplemented\ta\tsimple\tarray\tbased\tstack.\tWe\ttook\tone\tindex\tvariable top\twhich\tpoints\tto\tthe\tindex\tof\tthe\tmost\trecently\tinserted\telement\tin\tthe\tstack.\tTo\tinsert\t(or\tpush) an\telement,\twe\tincrement\ttop\tindex\tand\tthen\tplace\tthe\tnew\telement\tat\tthat\tindex. Similarly,\tto\tdelete\t(or\tpop)\tan\telement\twe\ttake\tthe\telement\tat\ttop\tindex\tand\tthen\tdecrement\tthe top\tindex.\tWe\trepresent\tan\tempty\tqueue\twith\ttop\tvalue\tequal\tto\t\u20131.\tThe\tissue\tthat\tstill\tneeds\tto be\tresolved\tis\twhat\twe\tdo\twhen\tall\tthe\tslots\tin\tthe\tfixed\tsize\tarray\tstack\tare\toccupied? First\ttry:\tWhat\tif\twe\tincrement\tthe\tsize\tof\tthe\tarray\tby\t1\tevery\ttime\tthe\tstack\tis\tfull? \u2022 Push();\tincrease\tsize\tof\tS[]\tby\t1 \u2022 Pop():\tdecrease\tsize\tof\tS[]\tby\t1 Problems\twith\tthis\tapproach? This\t way\t of\t incrementing\t the\t array\t size\t is\t too\t expensive.\t Let\t us\t see\t the\t reason\t for\t this.\t For example,\tat\tn\t=\t1,\tto\tpush\tan\telement\tcreate\ta\tnew\tarray\tof\tsize\t2\tand\tcopy\tall\tthe\told\tarray elements\tto\tthe\tnew\tarray,\tand\tat\tthe\tend\tadd\tthe\tnew\telement.\tAt\tn\t=\t2,\tto\tpush\tan\telement\tcreate a\tnew\tarray\tof\tsize\t3\tand\tcopy\tall\tthe\told\tarray\telements\tto\tthe\tnew\tarray,\tand\tat\tthe\tend\tadd\tthe new\telement. Similarly,\tat\tn\t=\tn\t\u2013\t1,\tif\twe\twant\tto\tpush\tan\telement\tcreate\ta\tnew\tarray\tof\tsize\tn\tand\tcopy\tall\tthe old\tarray\telements\tto\tthe\tnew\tarray\tand\tat\tthe\tend\tadd\tthe\tnew\telement.\tAfter\tn\tpush\toperations the\ttotal\ttime\tT(n)\t(number\tof\tcopy\toperations)\tis\tproportional\tto\t1\t+\t2\t+\t...\t+\tn\t\u2248\tO(n2). Alternative\tApproach:\tRepeated\tDoubling Let\tus\timprove\tthe\tcomplexity\tby\tusing\tthe\tarray\tdoubling\ttechnique.\tIf\tthe\tarray\tis\tfull,\tcreate\ta new\tarray\tof\ttwice\tthe\tsize,\tand\tcopy\tthe\titems.\tWith\tthis\tapproach,\tpushing\tn\titems\ttakes\ttime proportional\tto\tn\t(not\tn2). For\tsimplicity,\tlet\tus\tassume\tthat\tinitially\twe\tstarted\twith\tn\t=\t1\tand\tmoved\tup\tto\tn\t=\t32.\tThat means,\twe\tdo\tthe\tdoubling\tat\t1,2,4,8,16.\tThe\tother\tway\tof\tanalyzing\tthe\tsame\tapproach\tis:\tat\tn\t= 1,\t if\t we\t want\t to\t add\t (push)\t an\t element,\t double\t the\t current\t size\t of\t the\t array\t and\t copy\t all\t the elements\tof\tthe\told\tarray\tto\tthe\tnew\tarray. At\tn\t=\t1,\twe\tdo\t1\tcopy\toperation,\tat\tn\t=\t2,\twe\tdo\t2\tcopy\toperations,\tand\tat\tn\t=\t4,\twe\tdo\t4\tcopy operations\tand\tso\ton.\tBy\tthe\ttime\twe\treach\tn\t=\t32,\tthe\ttotal\tnumber\tof\tcopy\toperations\tis\t1+2\t+\t4 +\t8+16\t=\t31\twhich\tis\tapproximately\tequal\tto\t2n\tvalue\t(32).\tIf\twe\tobserve\tcarefully,\twe\tare doing\t the\t doubling\t operation\t logn\t times.\t Now,\t let\t us\t generalize\t the\t discussion.\t For\t n\t push operations\t we\t double\t the\t array\t size\t logn\t times.\t That\t means,\t we\t will\t have\t logn\t terms\t in\t the expression\tbelow.\tThe\ttotal\ttime\tT(n)\tof\ta\tseries\tof\tn\tpush\toperations\tis\tproportional\tto T(n)\tis\tO(n)\tand\tthe\tamortized\ttime\tof\ta\tpush\toperation\tis\tO(1)\t. Performance Let\t n\t be\t the\t number\t of\t elements\t in\t the\t stack.\t The\t complexities\t for\t operations\t with\t this representation\tcan\tbe\tgiven\tas: Space\tComplexity\t(for\tn\tpush\toperations) O(n) Time\tComplexity\tof\tCreateStack() O(1) Time\tComplexity\tof\tPushQ O(1)\t(Average) Time\tComplexity\tof\tPopQ O(1) Time\tComplexity\tof\tTop() O(1) Time\tComplexity\tof\tIsEmpryStackf) O(1)) Time\tComplexity\tof\tIsFullStackf) O(1) Time\tComplexity\tof\tDeleteStackQ O(1) Note:\tToo\tmany\tdoublings\tmay\tcause\tmemory\toverflow\texception. Linked\tList\tImplementation The\tother\tway\tof\timplementing\tstacks\tis\tby\tusing\tLinked\tlists.\tPush\toperation\tis\timplemented\tby inserting\telement\tat\tthe\tbeginning\tof\tthe\tlist.\tPop\toperation\tis\timplemented\tby\tdeleting\tthe\tnode from\tthe\tbeginning\t(the\theader/top\tnode). Performance Let\t n\t be\t the\t number\t of\t elements\t in\t the\t stack.\t The\t complexities\t for\t operations\t with\t this representation\tcan\tbe\tgiven\tas: Space\tComplexity\t(for\tn\tpush\toperations) O(n) Time\tComplexity\tof\tCreateStack() O(1) Time\tComplexity\tof\tPush() O(1)\t(Average) Time\tComplexity\tof\tPop() O(1) Time\tComplexity\tof\tTop() O(1) Time\tComplexity\tof\tIsEmptyStack() O(1) Time\tComplexity\tof\tDeleteStack() O(n)"
            },
            {
                "subchapter_title": "4.6\tComparison\tof\tImplementations",
                "content": "Comparing\tIncremental\tStrategy\tand\tDoubling\tStrategy We\t compare\t the\t incremental\t strategy\t and\t doubling\t strategy\t by\t analyzing\t the\t total\t time\t T(n) needed\tto\tperform\ta\tseries\tof\tn\tpush\toperations.\tWe\tstart\twith\tan\tempty\tstack\trepresented\tby\tan array\tof\tsize\t1. We\tcall\tamortized\ttime\tof\ta\tpush\toperation\tis\tthe\taverage\ttime\ttaken\tby\ta\tpush\tover\tthe\tseries\tof operations,\tthat\tis,\tT(n)/n. Incremental\tStrategy The\tamortized\ttime\t(average\ttime\tper\toperation)\tof\ta\tpush\toperation\tis\tO(n)\t[O(n2)/n]. Doubling\tStrategy In\tthis\tmethod,\tthe\tamortized\ttime\tof\ta\tpush\toperation\tis\tO(1)\t[O(n)/n]. Note:\tFor\tanalysis,\trefer\tto\tthe\tImplementation\tsection. Comparing\tArray\tImplementation\tand\tLinked\tList\tImplementation Array\tImplementation \u2022 Operations\ttake\tconstant\ttime. \u2022 Expensive\tdoubling\toperation\tevery\tonce\tin\ta\twhile. \u2022 Any\tsequence\tof\tn\toperations\t(starting\tfrom\tempty\tstack)\t\u2013\t\u201camortized\u201d\tbound\ttakes time\tproportional\tto\tn. Linked\tList\tImplementation \u2022 Grows\tand\tshrinks\tgracefully. \u2022 Every\toperation\ttakes\tconstant\ttime\tO(1). \u2022 Every\toperation\tuses\textra\tspace\tand\ttime\tto\tdeal\twith\treferences."
            },
            {
                "subchapter_title": "4.7\tStacks:\tProblems\t&\tSolutions",
                "content": "Problem-1\u2003\u2003Discuss\thow\tstacks\tcan\tbe\tused\tfor\tchecking\tbalancing\tof\tsymbols. Solution:\tStacks\tcan\tbe\tused\tto\tcheck\twhether\tthe\tgiven\texpression\thas\tbalanced\tsymbols.\tThis algorithm\tis\tvery\tuseful\tin\tcompilers.\tEach\ttime\tthe\tparser\treads\tone\tcharacter\tat\ta\ttime.\tIf\tthe character\tis\tan\topening\tdelimiter\tsuch\tas\t(,\t{,\tor\t[-\tthen\tit\tis\twritten\tto\tthe\tstack.\tWhen\ta\tclosing delimiter\tis\tencountered\tlike\t),\t},\tor\t]-the\tstack\tis\tpopped. The\topening\tand\tclosing\tdelimiters\tare\tthen\tcompared.\tIf\tthey\tmatch,\tthe\tparsing\tof\tthe\tstring continues.\tIf\tthey\tdo\tnot\tmatch,\tthe\tparser\tindicates\tthat\tthere\tis\tan\terror\ton\tthe\tline.\tA\tlinear-time O(n)\talgorithm\tbased\ton\tstack\tcan\tbe\tgiven\tas: Algorithm: a) Create\ta\tstack. b) while\t(end\tof\tinput\tis\tnot\treached)\t{ 1) If\tthe\tcharacter\tread\tis\tnot\ta\tsymbol\tto\tbe\tbalanced,\tignore\tit. 2) If\tthe\tcharacter\tis\tan\topening\tsymbol\tlike\t(,\t[,\t{,\tpush\tit\tonto\tthe\tstack 3) If\tit\tis\ta\tclosing\tsymbol\tlike\t),],},\tthen\tif\tthe\tstack\tis\tempty\treport\tan error.\tOtherwise\tpop\tthe\tstack. 4) If\tthe\tsymbol\tpopped\tis\tnot\tthe\tcorresponding\topening\tsymbol,\treport\tan error. } c) At\tend\tof\tinput,\tif\tthe\tstack\tis\tnot\tempty\treport\tan\terror Examples: For\ttracing\tthe\talgorithm\tlet\tus\tassume\tthat\tthe\tinput\tis:\t()\t(()\t[()]) Time\tComplexity:\tO(n).\tSince\twe\tare\tscanning\tthe\tinput\tonly\tonce.\tSpace\tComplexity:\tO(n)\t[for stack]. Problem-2\u2003\u2003Discuss\tinfix\tto\tpostfix\tconversion\talgorithm\tusing\tstack. Solution:\t Before\t discussing\t the\t algorithm,\t first\t let\t us\t see\t the\t definitions\t of\t infix,\t prefix\t and postfix\texpressions. Infix:\tAn\tinfix\texpression\tis\ta\tsingle\tletter,\tor\tan\toperator,\tproceeded\tby\tone\tinfix\tstring\tand followed\tby\tanother\tInfix\tstring. Prefix:\t A\t prefix\t expression\t is\t a\t single\t letter,\t or\t an\t operator,\t followed\t by\t two\t prefix\t strings. Every\tprefix\tstring\tlonger\tthan\ta\tsingle\tvariable\tcontains\tan\toperator,\tfirst\toperand\tand\tsecond operand. Postfix:\t A\t postfix\t expression\t (also\t called\t Reverse\t Polish\t Notation)\t is\t a\t single\t letter\t or\t an operator,\t preceded\t by\t two\t postfix\t strings.\t Every\t postfix\t string\t longer\t than\t a\t single\t variable contains\tfirst\tand\tsecond\toperands\tfollowed\tby\tan\toperator. Prefix\tand\tpostfix\tnotions\tare\tmethods\tof\twriting\tmathematical\texpressions\twithout\tparenthesis. Time\tto\tevaluate\ta\tpostfix\tand\tprefix\texpression\tis\tO(n),\twhere\tn\tis\tthe\tnumber\tof\telements\tin\tthe array. Now,\t let\t us\t focus\t on\t the\t algorithm.\t In\t infix\t expressions,\t the\t operator\t precedence\t is\t implicit unless\twe\tuse\tparentheses.\tTherefore,\tfor\tthe\tinfix\tto\tpostfix\tconversion\talgorithm\twe\thave\tto define\tthe\toperator\tprecedence\t(or\tpriority)\tinside\tthe\talgorithm. The\ttable\tshows\tthe\tprecedence\tand\ttheir\tassociativity\t(order\tof\tevaluation)\tamong\toperators. Important\tProperties \u2022 Let\tus\tconsider\tthe\tinfix\texpression\t2\t+\t3*4\tand\tits\tpostfix\tequivalent\t234*+.\tNotice that\tbetween\tinfix\tand\tpostfix\tthe\torder\tof\tthe\tnumbers\t(or\toperands)\tis\tunchanged. It\tis\t2\t3\t4\tin\tboth\tcases.\tBut\tthe\torder\tof\tthe\toperators\t*\tand\t+\tis\taffected\tin\tthe\ttwo expressions. \u2022 Only\tone\tstack\tis\tenough\tto\tconvert\tan\tinfix\texpression\tto\tpostfix\texpression.\tThe stack\tthat\twe\tuse\tin\tthe\talgorithm\twill\tbe\tused\tto\tchange\tthe\torder\tof\toperators\tfrom infix\t to\t postfix.\t The\t stack\t we\t use\t will\t only\t contain\t operators\t and\t the\t open parentheses\tsymbol\t\u2018(\u2018. Postfix\texpressions\tdo\tnot\tcontain\tparentheses.\tWe\tshall\tnot\toutput\tthe\tparentheses\tin\tthe\tpostfix output. Algorithm: a) Create\ta\tstack b) for\teach\tcharacter\tt\tin\tthe\tinput\tstream} c) pop\tand\toutput\ttokens\tuntil\tthe\tstack\tis\tempty For\tbetter\tunderstanding\tlet\tus\ttrace\tout\tan\texample:\tA\t*\tB-\t(C\t+\tD)\t+\tE Problem-3\u2003\u2003Discuss\tpostfix\tevaluation\tusing\tstacks? Solution: Algorithm: 1 Scan\tthe\tPostfix\tstring\tfrom\tleft\tto\tright. 2 Initialize\tan\tempty\tstack. 3 Repeat\tsteps\t4\tand\t5\ttill\tall\tthe\tcharacters\tare\tscanned. 4 If\tthe\tscanned\tcharacter\tis\tan\toperand,\tpush\tit\tonto\tthe\tstack. 5 If\tthe\tscanned\tcharacter\tis\tan\toperator,\tand\tif\tthe\toperator\tis\ta\tunary\toperator,\tthen pop\tan\telement\tfrom\tthe\tstack.\tIf\tthe\toperator\tis\ta\tbinary\toperator,\tthen\tpop\ttwo elements\t from\t the\t stack.\t After\t popping\t the\t elements,\t apply\t the\t operator\t to\t those popped\telements.\tLet\tthe\tresult\tof\tthis\toperation\tbe\tretVal\tonto\tthe\tstack. 6 After\tall\tcharacters\tare\tscanned,\twe\twill\thave\tonly\tone\telement\tin\tthe\tstack. 7 Return\ttop\tof\tthe\tstack\tas\tresult. Example:\tLet\tus\tsee\thow\tthe\tabove-mentioned\talgorithm\tworks\tusing\tan\texample.\tAssume\tthat the\tpostfix\tstring\tis\t123*+5-. Initially\tthe\tstack\tis\tempty.\tNow,\tthe\tfirst\tthree\tcharacters\tscanned\tare\t1,\t2\tand\t3,\twhich\tare operands.\tThey\twill\tbe\tpushed\tinto\tthe\tstack\tin\tthat\torder. The\tnext\tcharacter\tscanned\tis\t\u201c*\u201d,\twhich\tis\tan\toperator.\tThus,\twe\tpop\tthe\ttop\ttwo\telements\tfrom the\tstack\tand\tperform\tthe\t\u201c*\u201d\toperation\twith\tthe\ttwo\toperands.\tThe\tsecond\toperand\twill\tbe\tthe first\telement\tthat\tis\tpopped. The\tvalue\tof\tthe\texpression\t(2*3)\tthat\thas\tbeen\tevaluated\t(6)\tis\tpushed\tinto\tthe\tstack. The\tnext\tcharacter\tscanned\tis\t\u201c+\u201d,\twhich\tis\tan\toperator.\tThus,\twe\tpop\tthe\ttop\ttwo\telements\tfrom the\tstack\tand\tperform\tthe\t\u201c+\u201d\toperation\twith\tthe\ttwo\toperands.\tThe\tsecond\toperand\twill\tbe\tthe first\telement\tthat\tis\tpopped. The\tvalue\tof\tthe\texpression\t(1+6)\tthat\thas\tbeen\tevaluated\t(7)\tis\tpushed\tinto\tthe\tstack. The\tnext\tcharacter\tscanned\tis\t\u201c5\u201d,\twhich\tis\tadded\tto\tthe\tstack. The\tnext\tcharacter\tscanned\tis\t\u201c-\u201d,\twhich\tis\tan\toperator.\tThus,\twe\tpop\tthe\ttop\ttwo\telements\tfrom the\tstack\tand\tperform\tthe\t\u201c-\u201d\toperation\twith\tthe\ttwo\toperands.\tThe\tsecond\toperand\twill\tbe\tthe first\telement\tthat\tis\tpopped. The\tvalue\tof\tthe\texpression(7-5)\tthat\thas\tbeen\tevaluated(23)\tis\tpushed\tinto\tthe\tstack. Now,\tsince\tall\tthe\tcharacters\tare\tscanned,\tthe\tremaining\telement\tin\tthe\tstack\t(there\twill\tbe\tonly one\telement\tin\tthe\tstack)\twill\tbe\treturned.\tEnd\tresult: \u2022 Postfix\tString\t:\t123*+5- \u2022 Result\t:\t2 Problem-4\u2003\u2003Can\twe\tevaluate\tthe\tinfix\texpression\twith\tstacks\tin\tone\tpass? Solution:\t Using\t 2\t stacks\t we\t can\t evaluate\t an\t infix\t expression\t in\t 1\t pass\t without\t converting\t to postfix. Algorithm: 1) Create\tan\tempty\toperator\tstack 2) Create\tan\tempty\toperand\tstack 3) For\teach\ttoken\tin\tthe\tinput\tstring a. Get\tthe\tnext\ttoken\tin\tthe\tinfix\tstring b. If\tnext\ttoken\tis\tan\toperand,\tplace\tit\ton\tthe\toperand\tstack c. If\tnext\ttoken\tis\tan\toperator \t\ti. Evaluate\tthe\toperator\t(next\top) 4) While\t operator\t stack\t is\t not\t empty,\t pop\t operator\t and\t operands\t (left\t and\t right), evaluate\tleft\toperator\tright\tand\tpush\tresult\tonto\toperand\tstack 5) Pop\tresult\tfrom\toperator\tstack Problem-5\u2003\u2003How\tto\tdesign\ta\tstack\tsuch\tthat\tGetMinimum(\t)\tshould\tbe\tO(1)? Solution:\tTake\tan\tauxiliary\tstack\tthat\tmaintains\tthe\tminimum\tof\tall\tvalues\tin\tthe\tstack.\tAlso, assume\tthat\teach\telement\tof\tthe\tstack\tis\tless\tthan\tits\tbelow\telements.\tFor\tsimplicity\tlet\tus\tcall\tthe auxiliary\tstack\tmin\tstack. When\twe\tpop\tthe\tmain\tstack,\tpop\tthe\tmin\tstack\ttoo.\tWhen\twe\tpush\tthe\tmain\tstack,\tpush\teither\tthe new\telement\tor\tthe\tcurrent\tminimum,\twhichever\tis\tlower.\tAt\tany\tpoint,\tif\twe\twant\tto\tget\tthe minimum,\tthen\twe\tjust\tneed\tto\treturn\tthe\ttop\telement\tfrom\tthe\tmin\tstack.\tLet\tus\ttake\tan\texample and\ttrace\tit\tout.\tInitially\tlet\tus\tassume\tthat\twe\thave\tpushed\t2,\t6,\t4,\t1\tand\t5.\tBased\ton\tthe\tabove- mentioned\talgorithm\tthe\tmin\tstack\twill\tlook\tlike: Main\tstack Min\tstack 5\t\u2192\ttop 1\t\u2192\ttop 1 1 4 2 6 2 2 2 After\tpopping\ttwice\twe\tget: Main\tstack Min\tstack 4\t-\u2192\ttop 2\t\u2192\ttop 6 2 2 2 Based\ton\tthe\tdiscussion\tabove,\tnow\tlet\tus\tcode\tthe\tpush,\tpop\tand\tGetMinimum()\toperations. Time\tcomplexity:\tO(1).\tSpace\tcomplexity:\tO(n)\t[for\tMin\tstack].\tThis\talgorithm\thas\tmuch\tbetter space\tusage\tif\twe\trarely\tget\ta\t\u201cnew\tminimum\tor\tequal\u201d. Problem-6\u2003\u2003For\tProblem-5\tis\tit\tpossible\tto\timprove\tthe\tspace\tcomplexity? Solution:\tYes.\tThe\tmain\tproblem\tof\tthe\tprevious\tapproach\tis,\tfor\teach\tpush\toperation\twe\tare pushing\tthe\telement\ton\tto\tmin\tstack\talso\t(either\tthe\tnew\telement\tor\texisting\tminimum\telement). That\tmeans,\twe\tare\tpushing\tthe\tduplicate\tminimum\telements\ton\tto\tthe\tstack. Now,\tlet\tus\tchange\tthe\talgorithm\tto\timprove\tthe\tspace\tcomplexity.\tWe\tstill\thave\tthe\tmin\tstack,\tbut we\tonly\tpop\tfrom\tit\twhen\tthe\tvalue\twe\tpop\tfrom\tthe\tmain\tstack\tis\tequal\tto\tthe\tone\ton\tthe\tmin stack.\tWe\tonly\tpush\tto\tthe\tmin\tstack\twhen\tthe\tvalue\tbeing\tpushed\tonto\tthe\tmain\tstack\tis\tless\tthan or\tequal\tto\tthe\tcurrent\tmin\tvalue.\tIn\tthis\tmodified\talgorithm\talso,\tif\twe\twant\tto\tget\tthe\tminimum then\twe\tjust\tneed\tto\treturn\tthe\ttop\telement\tfrom\tthe\tmin\tstack.\tFor\texample,\ttaking\tthe\toriginal version\tand\tpushing\t1\tagain,\twe\u2019d\tget: Main\tstack Min\tstack 1\t\u2192\ttop \t 5 1 4 1\t\u2192\ttop 6 1 2 2 Popping\tfrom\tthe\tabove\tpops\tfrom\tboth\tstacks\tbecause\t1\t==\t1,\tleaving: Main\tstack Min\tstack 5\t\u2192\ttop \t 1 4 6 1\t\u2192\ttop 2 2 Popping\tagain\tonly\tpops\tfrom\tthe\tmain\tstack,\tbecause\t5\t>\t1: Main\tstack Min\tstack 1\t\u2192\ttop \t 4 6 1\t\u2192\ttop 2 2 Popping\tagain\tpops\tboth\tstacks\tbecause\t1\t==\t1: Main\tstack Min\tstack 4\t\u2192\ttop \t 6 \t 2 2\t\u2192\ttop Note:\tThe\tdifference\tis\tonly\tin\tpush\t&\tpop\toperations. Time\t complexity:\t O(1).\t Space\t complexity:\t O(n)\t [for\t Min\t stack].\t But\t this\t algorithm\t has\t much better\tspace\tusage\tif\twe\trarely\tget\ta\t\u201cnew\tminimum\tor\tequal\u201d. Problem-7\u2003\u2003For\ta\tgiven\tarray\twith\tn\tsymbols\thow\tmany\tstack\tpermutations\tare\tpossible? Solution:\tThe\tnumber\tof\tstack\tpermutations\twith\tn\tsymbols\tis\trepresented\tby\tCatalan\tnumber\tand we\twill\tdiscuss\tthis\tin\tthe\tDynamic\tProgramming\tchapter. Problem-8\u2003\u2003Given\tan\tarray\tof\tcharacters\tformed\twith\ta\u2019s\tand\tb\u2019s.\tThe\tstring\tis\tmarked\twith special\t character\t X\t which\t represents\t the\t middle\t of\t the\t list\t (for\t example: ababa...ababXbabab\tbaaa).\tCheck\twhether\tthe\tstring\tis\tpalindrome. Solution:\tThis\tis\tone\tof\tthe\tsimplest\talgorithms.\tWhat\twe\tdo\tis,\tstart\ttwo\tindexes,\tone\tat\tthe beginning\tof\tthe\tstring\tand\tthe\tother\tat\tthe\tend\tof\tthe\tstring.\tEach\ttime\tcompare\twhether\tthe\tvalues at\tboth\tthe\tindexes\tare\tthe\tsame\tor\tnot.\tIf\tthe\tvalues\tare\tnot\tthe\tsame\tthen\twe\tsay\tthat\tthe\tgiven string\tis\tnot\ta\tpalindrome. If\tthe\tvalues\tare\tthe\tsame\tthen\tincrement\tthe\tleft\tindex\tand\tdecrement\tthe\tright\tindex.\tContinue this\tprocess\tuntil\tboth\tthe\tindexes\tmeet\tat\tthe\tmiddle\t(at\tX)\tor\tif\tthe\tstring\tis\tnot\tpalindrome. Time\tComplexity:\tO(n).\tSpace\tComplexity:\tO(1). Problem-9\u2003\u2003For\tProblem-8,\tif\tthe\tinput\tis\tin\tsingly\tlinked\tlist\tthen\thow\tdo\twe\tcheck\twhether the\tlist\telements\tform\ta\tpalindrome\t(That\tmeans,\tmoving\tbackward\tis\tnot\tpossible). Solution:\tRefer\tLinked\tLists\tchapter. Problem-10\u2003\u2003Can\twe\tsolve\tProblem-8\tusing\tstacks? Solution:\tYes. Algorithm: \u2022 Traverse\tthe\tlist\ttill\twe\tencounter\tX\tas\tinput\telement. \u2022 During\tthe\ttraversal\tpush\tall\tthe\telements\t(until\tX)\ton\tto\tthe\tstack. \u2022 For\tthe\tsecond\thalf\tof\tthe\tlist,\tcompare\teach\telement\u2019s\tcontent\twith\ttop\tof\tthe\tstack. If\tthey\tare\tthe\tsame\tthen\tpop\tthe\tstack\tand\tgo\tto\tthe\tnext\telement\tin\tthe\tinput\tlist. \u2022 If\tthey\tare\tnot\tthe\tsame\tthen\tthe\tgiven\tstring\tis\tnot\ta\tpalindrome. \u2022 Continue\tthis\tprocess\tuntil\tthe\tstack\tis\tempty\tor\tthe\tstring\tis\tnot\ta\tpalindrome. Time\tComplexity:\tO(n).\tSpace\tComplexity:\tO(n/2)\t\u2248\tO(n). Problem-11\u2003\u2003Given\t a\t stack,\t how\t to\t reverse\t the\t elements\t of\t the\t stack\t using\t only\t stack operations\t(push\t&\tpop)? Solution: Algorithm: \u2022 First\tpop\tall\tthe\telements\tof\tthe\tstack\ttill\tit\tbecomes\tempty. \u2022 For\teach\tupward\tstep\tin\trecursion,\tinsert\tthe\telement\tat\tthe\tbottom\tof\tthe\tstack. Time\tComplexity:\tO(n2).\tSpace\tComplexity:\tO(n),\tfor\trecursive\tstack. Problem-12\u2003\u2003Show\t how\t to\t implement\t one\t queue\t efficiently\t using\t two\t stacks.\t Analyze\t the running\ttime\tof\tthe\tqueue\toperations. Solution:\tRefer\tQueues\tchapter. Problem-13\u2003\u2003Show\t how\t to\t implement\t one\t stack\t efficiently\t using\t two\t queues.\t Analyze\t the running\ttime\tof\tthe\tstack\toperations. Solution:\tRefer\tQueues\tchapter. Problem-14\u2003\u2003How\t do\t we\t implement\t two\t stacks\t using\t only\t one\t array?\t Our\t stack\t routines should\tnot\tindicate\tan\texception\tunless\tevery\tslot\tin\tthe\tarray\tis\tused? Solution: Algorithm: \u2022 Start\ttwo\tindexes\tone\tat\tthe\tleft\tend\tand\tthe\tother\tat\tthe\tright\tend. \u2022 The\tleft\tindex\tsimulates\tthe\tfirst\tstack\tand\tthe\tright\tindex\tsimulates\tthe\tsecond\tstack. \u2022 If\t we\t want\t to\t push\t an\t element\t into\t the\t first\t stack\t then\t put\t the\t element\t at\t the\t left index. \u2022 Similarly,\tif\twe\twant\tto\tpush\tan\telement\tinto\tthe\tsecond\tstack\tthen\tput\tthe\telement\tat the\tright\tindex. \u2022 The\tfirst\tstack\tgrows\ttowards\tthe\tright,\tand\tthe\tsecond\tstack\tgrows\ttowards\tthe\tleft. Time\tComplexity\tof\tpush\tand\tpop\tfor\tboth\tstacks\tis\tO(1).\tSpace\tComplexity\tis\tO(1). Problem-15\u2003\u20033\tstacks\tin\tone\tarray:\tHow\tto\timplement\t3\tstacks\tin\tone\tarray? Solution:\t For\t this\t problem,\t there\t could\t be\t other\t ways\t of\t solving\t it.\t Given\t below\t is\t one possibility\tand\tit\tworks\tas\tlong\tas\tthere\tis\tan\tempty\tspace\tin\tthe\tarray. To\timplement\t3\tstacks\twe\tkeep\tthe\tfollowing\tinformation. \u2022 The\tindex\tof\tthe\tfirst\tstack\t(Topi):\tthis\tindicates\tthe\tsize\tof\tthe\tfirst\tstack. \u2022 The\tindex\tof\tthe\tsecond\tstack\t(Top2):\tthis\tindicates\tthe\tsize\tof\tthe\tsecond\tstack. \u2022 Starting\tindex\tof\tthe\tthird\tstack\t(base\taddress\tof\tthird\tstack). \u2022 Top\tindex\tof\tthe\tthird\tstack. Now,\tlet\tus\tdefine\tthe\tpush\tand\tpop\toperations\tfor\tthis\timplementation. Pushing: \u2022 For\tpushing\ton\tto\tthe\tfirst\tstack,\twe\tneed\tto\tsee\tif\tadding\ta\tnew\telement\tcauses\tit\tto bump\tinto\tthe\tthird\tstack.\tIf\tso,\ttry\tto\tshift\tthe\tthird\tstack\tupwards.\tInsert\tthe\tnew element\tat\t(start1\t+\tTop1). \u2022 For\tpushing\tto\tthe\tsecond\tstack,\twe\tneed\tto\tsee\tif\tadding\ta\tnew\telement\tcauses\tit\tto bump\tinto\tthe\tthird\tstack.\tIf\tso,\ttry\tto\tshift\tthe\tthird\tstack\tdownward.\tInsert\tthe\tnew element\tat\t(start2\t-\tTop2). \u2022 When\tpushing\tto\tthe\tthird\tstack,\tsee\tif\tit\tbumps\tinto\tthe\tsecond\tstack.\tIf\tso,\ttry\tto shift\t the\t third\t stack\t downward\t and\t try\t pushing\t again.\t Insert\t the\t new\t element\t at (start3\t+\tTop3). Time\tComplexity:\tO(n).\tSince\twe\tmay\tneed\tto\tadjust\tthe\tthird\tstack.\tSpace\tComplexity:\tO(1). Popping:\tFor\tpopping,\twe\tdon\u2019t\tneed\tto\tshift,\tjust\tdecrement\tthe\tsize\tof\tthe\tappropriate\tstack. Time\tComplexity:\tO(1).\tSpace\tComplexity:\tO(1). Problem-16\u2003\u2003For\tProblem-15,\tis\tthere\tany\tother\tway\timplementing\tthe\tmiddle\tstack? Solution:\tYes.\t When\t either\t the\t left\t stack\t (which\t grows\t to\t the\t right)\t or\t the\t right\t stack\t (which grows\tto\tthe\tleft)\tbumps\tinto\tthe\tmiddle\tstack,\twe\tneed\tto\tshift\tthe\tentire\tmiddle\tstack\tto\tmake room.\tThe\tsame\thappens\tif\ta\tpush\ton\tthe\tmiddle\tstack\tcauses\tit\tto\tbump\tinto\tthe\tright\tstack. To\tsolve\tthe\tabove-mentioned\tproblem\t(number\tof\tshifts)\twhat\twe\tcan\tdo\tis:\talternating\tpushes can\tbe\tadded\tat\talternating\tsides\tof\tthe\tmiddle\tlist\t(For\texample,\teven\telements\tare\tpushed\tto\tthe left,\todd\telements\tare\tpushed\tto\tthe\tright).\tThis\twould\tkeep\tthe\tmiddle\tstack\tbalanced\tin\tthe center\tof\tthe\tarray\tbut\tit\twould\tstill\tneed\tto\tbe\tshifted\twhen\tit\tbumps\tinto\tthe\tleft\tor\tright\tstack, whether\tby\tgrowing\ton\tits\town\tor\tby\tthe\tgrowth\tof\ta\tneighboring\tstack.\tWe\tcan\toptimize\tthe initial\tlocations\tof\tthe\tthree\tstacks\tif\tthey\tgrow/shrink\tat\tdifferent\trates\tand\tif\tthey\thave\tdifferent average\tsizes.\tFor\texample,\tsuppose\tone\tstack\tdoesn\u2019t\tchange\tmuch.\tIf\twe\tput\tit\tat\tthe\tleft,\tthen the\tmiddle\tstack\twill\teventually\tget\tpushed\tagainst\tit\tand\tleave\ta\tgap\tbetween\tthe\tmiddle\tand right\tstacks,\twhich\tgrow\ttoward\teach\tother.\tIf\tthey\tcollide,\tthen\tit\u2019s\tlikely\twe\u2019ve\trun\tout\tof\tspace in\tthe\tarray.\tThere\tis\tno\tchange\tin\tthe\ttime\tcomplexity\tbut\tthe\taverage\tnumber\tof\tshifts\twill\tget reduced. Problem-17\u2003\u2003Multiple\t(m)\tstacks\tin\tone\tarray:\tSimilar\tto\tProblem-15,\twhat\tif\twe\twant\tto implement\tm\tstacks\tin\tone\tarray? Solution:\tLet\tus\tassume\tthat\tarray\tindexes\tare\tfrom\t1\tto\tn.\tSimilar\tto\tthe\tdiscussion\tin\tProblem- 15,\tto\timplement\tm\tstacks\tin\tone\tarray,\twe\tdivide\tthe\tarray\tinto\tm\tparts\t(as\tshown\tbelow).\tThe size\tof\teach\tpart\tis\t . From\tthe\tabove\trepresentation\twe\tcan\tsee\tthat,\tfirst\tstack\tis\tstarting\tat\tindex\t1\t(starting\tindex\tis stored\tin\tBase[l]),\tsecond\tstack\tis\tstarting\tat\tindex\t \t(starting\tindex\tis\tstored\tin\tBase[2]),\tthird stack\tis\tstarting\tat\tindex\t \t(starting\tindex\tis\tstored\tin\tBase[3]),\tand\tso\ton.\tSimilar\tto\tBase\tarray, let\tus\tassume\tthat\tTop\tarray\tstores\tthe\ttop\tindexes\tfor\teach\tof\tthe\tstack.\tConsider\tthe\tfollowing terminology\tfor\tthe\tdiscussion. \u2022 Top[i],\tfor\t1\t\u2264\ti\t\u2264\tm\twill\tpoint\tto\tthe\ttopmost\telement\tof\tthe\tstack\ti. \u2022 If\tBase[i]\t==\tTop[i],\tthen\twe\tcan\tsay\tthe\tstack\ti\tis\tempty. \u2022 If\tTop[i]\t==\tBase[i+1],\tthen\twe\tcan\tsay\tthe\tstack\ti\tis\tfull. Initially\tBase[i]\t=\tTop[i]\t=\t \t(i\t\u2013\t1),\tfor\t1\t\u2264\ti\t\u2264\tm. \u2022 The\tith\tstack\tgrows\tfrom\tBase[i]+1\tto\tBase[i+1]. Pushing\ton\tto\tith\tstack: 1) For\tpushing\ton\tto\tthe\tith\tstack,\twe\tcheck\twhether\tthe\ttop\tof\tith\tstack\tis\tpointing\tto Base[i+1]\t(this\tcase\tdefines\tthat\tith\tstack\tis\tfull).\tThat\tmeans,\twe\tneed\tto\tsee\tif adding\ta\tnew\telement\tcauses\tit\tto\tbump\tinto\tthe\ti\t+\t1th\tstack.\tIf\tso,\ttry\tto\tshift\tthe stacks\tfrom\ti\t+\t1th\tstack\tto\tmth\tstack\ttoward\tthe\tright.\tInsert\tthe\tnew\telement\tat (Base[i]\t+\tTop[i]). 2) If\tright\tshifting\tis\tnot\tpossible\tthen\ttry\tshifting\tthe\tstacks\tfrom\t1\tto\ti\t\u20131th\tstack\ttoward the\tleft. 3) If\tboth\tof\tthem\tare\tnot\tpossible\tthen\twe\tcan\tsay\tthat\tall\tstacks\tare\tfull. Time\tComplexity:\tO(n).\tSince\twe\tmay\tneed\tto\tadjust\tthe\tstacks.\tSpace\tComplexity:\tO(1). Popping\t from\t ith\t stack:\t For\t popping,\t we\t don\u2019t\t need\t to\t shift,\t just\t decrement\t the\t size\t of\t the appropriate\tstack.\tThe\tonly\tcase\tto\tcheck\tis\tstack\tempty\tcase. Time\tComplexity:\tO(1).\tSpace\tComplexity:\tO(1). Problem-18\u2003\u2003Consider\tan\tempty\tstack\tof\tintegers.\tLet\tthe\tnumbers\t1,2,3,4,5,6\tbe\tpushed\ton\tto this\tstack\tin\tthe\torder\tthey\tappear\tfrom\tleft\tto\tright.\tLet\t5\tindicate\ta\tpush\tand\tX\tindicate\ta pop\toperation.\tCan\tthey\tbe\tpermuted\tin\tto\tthe\torder\t325641(output)\tand\torder\t154623? Solution:\t SSSXXSSXSXXX\t outputs\t 325641.\t 154623\t cannot\t be\t output\t as\t 2\t is\t pushed\t much before\t3\tso\tcan\tappear\tonly\tafter\t3\tis\toutput. Problem-19\u2003\u2003Earlier\tin\tthis\tchapter,\twe\tdiscussed\tthat\tfor\tdynamic\tarray\timplementation\tof stacks,\t the\t \u2018repeated\t doubling\u2019\t approach\t is\t used.\t For\t the\t same\t problem,\t what\t is\t the complexity\tif\twe\tcreate\ta\tnew\tarray\twhose\tsize\tis\tn\t+\tif\tinstead\tof\tdoubling? Solution:\tLet\tus\tassume\tthat\tthe\tinitial\tstack\tsize\tis\t0.\tFor\tsimplicity\tlet\tus\tassume\tthat\tK\t=\t10. For\tinserting\tthe\telement\twe\tcreate\ta\tnew\tarray\twhose\tsize\tis\t0\t+\t10\t=\t10.\tSimilarly,\tafter\t10 elements\twe\tagain\tcreate\ta\tnew\tarray\twhose\tsize\tis\t10\t+\t10\t=\t20\tand\tthis\tprocess\tcontinues\tat values:\t 30,40\t ...\t That\t means,\t for\t a\t given\t n\t value,\t we\t are\t creating\t the\t new\t arrays\t at:\t \tThe\ttotal\tnumber\tof\tcopy\toperations\tis: If\twe\tare\tperforming\tn\tpush\toperations,\tthe\tcost\tper\toperation\tis\tO(logn). Problem-20\u2003\u2003Given\ta\tstring\tcontaining\tn\tS\u2019s\tand\tn\tX\u2019s\twhere\t5\tindicates\ta\tpush\toperation\tand X\tindicates\ta\tpop\toperation,\tand\twith\tthe\tstack\tinitially\tempty,\tformulate\ta\trule\tto\tcheck whether\ta\tgiven\tstring\t5\tof\toperations\tis\tadmissible\tor\tnot? Solution:\tGiven\ta\tstring\tof\tlength\t2n,\twe\twish\tto\tcheck\twhether\tthe\tgiven\tstring\tof\toperations\tis permissible\tor\tnot\twith\trespect\tto\tits\tfunctioning\ton\ta\tstack.\tThe\tonly\trestricted\toperation\tis\tpop whose\tprior\trequirement\tis\tthat\tthe\tstack\tshould\tnot\tbe\tempty.\tSo\twhile\ttraversing\tthe\tstring\tfrom left\tto\tright,\tprior\tto\tany\tpop\tthe\tstack\tshouldn\u2019t\tbe\tempty,\twhich\tmeans\tthe\tnumber\tof\tS\u2019s\t is always\tgreater\tthan\tor\tequal\tto\tthat\tof\tX\u2019s.\tHence\tthe\tcondition\tis\tat\tany\tstage\tof\tprocessing\tof\tthe string,\tthe\tnumber\tof\tpush\toperations\t(S)\tshould\tbe\tgreater\tthan\tthe\tnumber\tof\tpop\toperations\t(X). Problem-21\u2003\u2003Suppose\t there\t are\t two\t singly\t linked\t lists\t which\t intersect\t at\t some\t point\t and become\ta\tsingle\tlinked\tlist.\tThe\thead\tor\tstart\tpointers\tof\tboth\tthe\tlists\tare\tknown,\tbut\tthe intersecting\tnode\tis\tnot\tknown.\tAlso,\tthe\tnumber\tof\tnodes\tin\teach\tof\tthe\tlists\tbefore\tthey intersect\tare\tunknown\tand\tboth\tlists\tmay\thave\ta\tdifferent\tnumber.\tList1\tmay\thave\tn\tnodes before\tit\treaches\tthe\tintersection\tpoint\tand\tList2\tmay\thave\tm\tnodes\tbefore\tit\treaches\tthe intersection\tpoint\twhere\tm\tand\tn\tmay\tbe\tm\t=\tn,m\t<\tn\tor\tm\t>\tn.\tCan\twe\tfind\tthe\tmerging point\tusing\tstacks? Solution:\tYes.\tFor\talgorithm\trefer\tto\tLinked\tLists\tchapter. Problem-22\u2003\u2003Finding\tSpans:\tGiven\tan\tarray\tA,\tthe\tspan\tS[i]\tof\tA[i]\tis\tthe\tmaximum\tnumber of\tconsecutive\telements\tA[j]\timmediately\tpreceding\tA[i]\tand\tsuch\tthat\tA[j]\t<\tA[i]? Other\tway\tof\tasking:\tGiven\tan\tarray\tA\tof\tintegers,\tfind\tthe\tmaximum\tof\tj\t\u2013\ti\tsubjected\tto the\tconstraint\tof\tA[i]\t<\tA[j]. Solution: This\tis\ta\tvery\tcommon\tproblem\tin\tstock\tmarkets\tto\tfind\tthe\tpeaks.\tSpans\tare\tused\tin\tfinancial analysis\t (E.g.,\t stock\t at\t 52-week\t high).\t The\t span\t of\t a\t stock\t price\t on\t a\t certain\t day,\t i,\t is\t the maximum\tnumber\tof\tconsecutive\tdays\t(up\tto\tthe\tcurrent\tday)\tthe\tprice\tof\tthe\tstock\thas\tbeen\tless than\tor\tequal\tto\tits\tprice\ton\ti. As\tan\texample,\tlet\tus\tconsider\tthe\ttable\tand\tthe\tcorresponding\tspans\tdiagram.\tIn\tthe\tfigure\tthe arrows\tindicate\tthe\tlength\tof\tthe\tspans.\tNow,\tlet\tus\tconcentrate\ton\tthe\talgorithm\tfor\tfinding\tthe spans.\tOne\tsimple\tway\tis,\teach\tday,\tcheck\thow\tmany\tcontiguous\tdays\thave\ta\tstock\tprice\tthat\tis less\tthan\tthe\tcurrent\tprice. Time\tComplexity:\tO(n2).\tSpace\tComplexity:\tO(1). Problem-23\u2003\u2003Can\twe\timprove\tthe\tcomplexity\tof\tProblem-22? Solution:\tFrom\tthe\texample\tabove,\twe\tcan\tsee\tthat\tspan\tS[i]\ton\tday\ti\tcan\tbe\teasily\tcalculated\tif we\tknow\tthe\tclosest\tday\tpreceding\ti,\tsuch\tthat\tthe\tprice\tis\tgreater\ton\tthat\tday\tthan\tthe\tprice\ton day\ti.\tLet\tus\tcall\tsuch\ta\tday\tas\tP.\tIf\tsuch\ta\tday\texists\tthen\tthe\tspan\tis\tnow\tdefined\tas\tS[i]\t=\ti\t\u2013\tP. Time\tComplexity:\tEach\tindex\tof\tthe\tarray\tis\tpushed\tinto\tthe\tstack\texactly\tonce\tand\talso\tpopped from\tthe\tstack\tat\tmost\tonce.\tThe\tstatements\tin\tthe\twhile\tloop\tare\texecuted\tat\tmost\tn\ttimes.\tEven though\tthe\talgorithm\thas\tnested\tloops,\tthe\tcomplexity\tis\tO(n)\tas\tthe\tinner\tloop\tis\texecuting\tonly\tn times\tduring\tthe\tcourse\tof\tthe\talgorithm\t(trace\tout\tan\texample\tand\tsee\thow\tmany\ttimes\tthe\tinner loop\tbecomes\tsuccessful).\tSpace\tComplexity:\tO(n)\t[for\tstack]. Problem-24\u2003\u2003Largest\trectangle\tunder\thistogram:\tA\thistogram\tis\ta\tpolygon\tcomposed\tof\ta sequence\t of\t rectangles\t aligned\t at\t a\t common\t base\t line.\t For\t simplicity,\t assume\t that\t the rectangles\thave\tequal\twidths\tbut\tmay\thave\tdifferent\theights.\tFor\texample,\tthe\tfigure\ton\tthe left\tshows\ta\thistogram\tthat\tconsists\tof\trectangles\twith\tthe\theights\t3,2,5,6,1,4,4,\tmeasured in\tunits\twhere\t1\tis\tthe\twidth\tof\tthe\trectangles.\tHere\tour\tproblem\tis:\tgiven\tan\tarray\twith heights\tof\trectangles\t(assuming\twidth\tis\t1),\twe\tneed\tto\tfind\tthe\tlargest\trectangle\tpossible. For\tthe\tgiven\texample,\tthe\tlargest\trectangle\tis\tthe\tshared\tpart. Solution:\tA\tstraightforward\tanswer\tis\tto\tgo\tto\teach\tbar\tin\tthe\thistogram\tand\tfind\tthe\tmaximum possible\tarea\tin\tthe\thistogram\tfor\tit.\tFinally,\tfind\tthe\tmaximum\tof\tthese\tvalues.\tThis\twill\trequire O(n2). Problem-25\u2003\u2003For\tProblem-24,\tcan\twe\timprove\tthe\ttime\tcomplexity? Solution:\tLinear\tsearch\tusing\ta\tstack\tof\tincomplete\tsub\tproblems:\tThere\tare\tmany\tways\tof solving\tthis\tproblem.\tJudge\thas\tgiven\ta\tnice\talgorithm\tfor\tthis\tproblem\twhich\tis\tbased\ton\tstack. Process\tthe\telements\tin\tleft-to-right\torder\tand\tmaintain\ta\tstack\tof\tinformation\tabout\tstarted\tbut\tyet unfinished\tsub\thistograms. If\tthe\tstack\tis\tempty,\topen\ta\tnew\tsub\tproblem\tby\tpushing\tthe\telement\tonto\tthe\tstack.\tOtherwise compare\tit\tto\tthe\telement\ton\ttop\tof\tthe\tstack.\tIf\tthe\tnew\tone\tis\tgreater\twe\tagain\tpush\tit.\tIf\tthe\tnew one\tis\tequal\twe\tskip\tit.\tIn\tall\tthese\tcases,\twe\tcontinue\twith\tthe\tnext\tnew\telement.\tIf\tthe\tnew\tone is\t less,\t we\t finish\t the\t topmost\t sub\t problem\t by\t updating\t the\t maximum\t area\t with\t respect\t to\t the element\tat\tthe\ttop\tof\tthe\tstack.\tThen,\twe\tdiscard\tthe\telement\tat\tthe\ttop,\tand\trepeat\tthe\tprocedure keeping\tthe\tcurrent\tnew\telement. This\tway,\tall\tsub\tproblems\tare\tfinished\twhen\tthe\tstack\tbecomes\tempty,\tor\tits\ttop\telement\tis\tless than\tor\tequal\tto\tthe\tnew\telement,\tleading\tto\tthe\tactions\tdescribed\tabove.\tIf\tall\telements\thave been\tprocessed,\tand\tthe\tstack\tis\tnot\tyet\tempty,\twe\tfinish\tthe\tremaining\tsub\tproblems\tby\tupdating the\tmaximum\tarea\twith\trespect\tto\tthe\telements\tat\tthe\ttop. At\t the\t first\t impression,\t this\t solution\t seems\t to\t be\t having\t O(n2)\t complexity.\t But\t if\t we\t look carefully,\tevery\telement\tis\tpushed\tand\tpopped\tat\tmost\tonce,\tand\tin\tevery\tstep\tof\tthe\tfunction\tat least\tone\telement\tis\tpushed\tor\tpopped.\tSince\tthe\tamount\tof\twork\tfor\tthe\tdecisions\tand\tthe\tupdate is\tconstant,\tthe\tcomplexity\tof\tthe\talgorithm\tis\tO(n)\t by\t amortized\t analysis.\t Space\t Complexity: O(n)\t[for\tstack]. Problem-26\u2003\u2003On\ta\tgiven\tmachine,\thow\tdo\tyou\tcheck\twhether\tthe\tstack\tgrows\tup\tor\tdown? Solution:\tTry\tnoting\tdown\tthe\taddress\tof\ta\tlocal\tvariable.\tCall\tanother\tfunction\twith\ta\tlocal variable\tdeclared\tin\tit\tand\tcheck\tthe\taddress\tof\tthat\tlocal\tvariable\tand\tcompare. Time\tComplexity:\tO(1).\tSpace\tComplexity:\tO(1). Problem-27\u2003\u2003Given\ta\tstack\tof\tintegers,\thow\tdo\tyou\tcheck\twhether\teach\tsuccessive\tpair\tof numbers\tin\tthe\tstack\tis\tconsecutive\tor\tnot.\tThe\tpairs\tcan\tbe\tincreasing\tor\tdecreasing,\tand if\tthe\tstack\thas\tan\todd\tnumber\tof\telements,\tthe\telement\tat\tthe\ttop\tis\tleft\tout\tof\ta\tpair.\tFor example,\tif\tthe\tstack\tof\telements\tare\t[4,\t5,\t-2,\t-3,\t11,\t10,\t5,\t6,\t20],\tthen\tthe\toutput\tshould be\t true\t because\t each\t of\t the\t pairs\t (4,\t 5),\t (-2,\t -3),\t (11,\t 10),\t and\t (5,\t 6)\t consists\t of consecutive\tnumbers. Solution:\tRefer\tto\tQueues\tchapter. Problem-28\u2003\u2003Recursively\t remove\t all\t adjacent\t duplicates:\t Given\t a\t string\t of\t characters, recursively\tremove\tadjacent\tduplicate\tcharacters\tfrom\tstring.\tThe\toutput\tstring\tshould\tnot have\tany\tadjacent\tduplicates. Input:\tcareermonk Output:\tcamonk Input:\tmississippi Output:\tm Solution:\tThis\tsolution\truns\twith\tthe\tconcept\tof\tin-place\tstack.\tWhen\telement\ton\tstack\tdoesn\u2019t match\tthe\tcurrent\tcharacter,\twe\tadd\tit\tto\tstack.\tWhen\tit\tmatches\tto\tstack\ttop,\twe\tskip\tcharacters until\tthe\telement\tmatches\tthe\ttop\tof\tstack\tand\tremove\tthe\telement\tfrom\tstack. Time\tComplexity:\tO(n).\tSpace\tComplexity:\tO(1)\tas\tthe\tstack\tsimulation\tis\tdone\tinplace. Problem-29\u2003\u2003Given\tan\tarray\tof\telements,\treplace\tevery\telement\twith\tnearest\tgreater\telement on\tthe\tright\tof\tthat\telement. Solution:\tOne\tsimple\tapproach\twould\tinvolve\tscanning\tthe\tarray\telements\tand\tfor\teach\tof\tthe elements,\tscan\tthe\tremaining\telements\tand\tfind\tthe\tnearest\tgreater\telement. Time\tComplexity:\tO(n2).\tSpace\tComplexity:\tO(1). Problem-30\u2003\u2003For\tProblem-29,\tcan\twe\timprove\tthe\tcomplexity? Solution:\tThe\tapproach\tis\tpretty\tmuch\tsimilar\tto\tProblem-22.\tCreate\ta\tstack\tand\tpush\tthe\tfirst element.\tFor\tthe\trest\tof\tthe\telements,\tmark\tthe\tcurrent\telement\tas\tnextNearestGreater.\tIf\tstack\tis not\t empty,\t then\t pop\t an\t element\t from\t stack\t and\t compare\t it\t with\t nextNearestGreater.\t If nextNearestGreater\t is\t greater\t than\t the\t popped\t element,\t then\t nextNearestGreater\t is\t the\t next greater\telement\tfor\tthe\tpopped\telement.\tKeep\tpopping\tfrom\tthe\tstack\twhile\tthe\tpopped\telement\tis smaller\tthan\tnextNearestGreater.\tnextNearestGreater\tbecomes\tthe\tnext\tgreater\t element\t for\t all such\tpopped\telements.\tIf\tnextNearestGreater\tis\tsmaller\tthan\tthe\tpopped\telement,\tthen\tpush\tthe popped\telement\tback. Time\tComplexity:\tO(n).\tSpace\tComplexity:\tO(n). Problem-31\u2003\u2003How\tto\timplement\ta\tstack\twhich\twill\tsupport\tfollowing\toperations\tin\tO(1)\ttime complexity? \u2022 Push\twhich\tadds\tan\telement\tto\tthe\ttop\tof\tstack. \u2022 Pop\twhich\tremoves\tan\telement\tfrom\ttop\tof\tstack. \u2022 Find\tMiddle\twhich\twill\treturn\tmiddle\telement\tof\tthe\tstack. \u2022 Delete\tMiddle\twhich\twill\tdelete\tthe\tmiddle\telement. Solution:\tWe\tcan\tuse\ta\tLinkedList\tdata\tstructure\twith\tan\textra\tpointer\tto\tthe\tmiddle\telement. Also,\twe\tneed\tanother\tvariable\tto\tstore\twhether\tthe\tLinkedList\thas\tan\teven\tor\todd\tnumber\tof elements. \u2022 Push:\t Add\t the\t element\t to\t the\t head\t of\t the\t LinkedList.\t Update\t the\t pointer\t to\t the middle\telement\taccording\tto\tvariable. \u2022 Pop:\tRemove\tthe\thead\tof\tthe\tLinkedList.\tUpdate\tthe\tpointer\tto\tthe\tmiddle\telement according\tto\tvariable. \u2022 Find\tMiddle:\tFind\tMiddle\twhich\twill\treturn\tmiddle\telement\tof\tthe\tstack. \u2022 Delete\tMiddle:\tDelete\tMiddle\twhich\twill\tdelete\tthe\tmiddle\telement\tuse\tthe\tlogic\tof Problem-43\tfrom\tLinked\tLists\tchapter."
            },
            {
                "subchapter_title": "5.1\tWhat\tis\ta\tQueue?",
                "content": "A\tqueue\tis\ta\tdata\tstructure\tused\tfor\tstoring\tdata\t(similar\tto\tLinked\tLists\tand\tStacks).\tIn\tqueue,\tthe order\tin\twhich\tdata\tarrives\tis\timportant.\tIn\tgeneral,\ta\tqueue\tis\ta\tline\tof\tpeople\tor\tthings\twaiting to\tbe\tserved\tin\tsequential\torder\tstarting\tat\tthe\tbeginning\tof\tthe\tline\tor\tsequence. Definition:\t A\t queue\t is\t an\t ordered\t list\t in\t which\t insertions\t are\t done\t at\t one\t end\t (rear)\t and deletions\t are\t done\t at\t other\t end\t (front).\t The\t first\t element\t to\t be\t inserted\t is\t the\t first\t one\t to\t be deleted.\tHence,\tit\tis\tcalled\tFirst\tin\tFirst\tout\t(FIFO)\tor\tLast\tin\tLast\tout\t(LILO)\tlist. Similar\tto\tStacks,\tspecial\tnames\tare\tgiven\tto\tthe\ttwo\tchanges\tthat\tcan\tbe\tmade\tto\ta\tqueue.\tWhen an\t element\t is\t inserted\t in\t a\t queue,\t the\t concept\t is\t called\t EnQueue,\t and\t when\t an\t element\t is removed\tfrom\tthe\tqueue,\tthe\tconcept\tis\tcalled\tDeQueue. DeQueueing\tan\tempty\tqueue\tis\tcalled\tunderflow\tand\tEnQueuing\tan\telement\tin\ta\tfull\tqueue\tis called\toverflow.\tGenerally,\twe\ttreat\tthem\tas\texceptions.\tAs\tan\texample,\tconsider\tthe\tsnapshot\tof the\tqueue."
            },
            {
                "subchapter_title": "5.2\tHow\tare\tQueues\tUsed?",
                "content": "The\tconcept\tof\ta\tqueue\tcan\tbe\texplained\tby\tobserving\ta\tline\tat\ta\treservation\tcounter.\tWhen\twe enter\tthe\tline\twe\tstand\tat\tthe\tend\tof\tthe\tline\tand\tthe\tperson\twho\tis\tat\tthe\tfront\tof\tthe\tline\tis\tthe\tone who\twill\tbe\tserved\tnext.\tHe\twill\texit\tthe\tqueue\tand\tbe\tserved. As\tthis\thappens,\tthe\tnext\tperson\twill\tcome\tat\tthe\thead\tof\tthe\tline,\twill\texit\tthe\tqueue\tand\twill\tbe served.\tAs\teach\tperson\tat\tthe\thead\tof\tthe\tline\tkeeps\texiting\tthe\tqueue,\twe\tmove\ttowards\tthe\thead of\tthe\tline.\tFinally\twe\twill\treach\tthe\thead\tof\tthe\tline\tand\twe\twill\texit\tthe\tqueue\tand\tbe\tserved. This\tbehavior\tis\tvery\tuseful\tin\tcases\twhere\tthere\tis\ta\tneed\tto\tmaintain\tthe\torder\tof\tarrival."
            },
            {
                "subchapter_title": "5.3\tQueue\tADT",
                "content": "The\t following\t operations\t make\t a\t queue\t an\t ADT.\t Insertions\t and\t deletions\t in\t the\t queue\t must follow\tthe\tFIFO\tscheme.\tFor\tsimplicity\twe\tassume\tthe\telements\tare\tintegers. Main\tQueue\tOperations \u2022 EnQueue(int\tdata):\tInserts\tan\telement\tat\tthe\tend\tof\tthe\tqueue \u2022 int\tDeQueue():\tRemoves\tand\treturns\tthe\telement\tat\tthe\tfront\tof\tthe\tqueue Auxiliary\tQueue\tOperations \u2022 int\tFront():\tReturns\tthe\telement\tat\tthe\tfront\twithout\tremoving\tit \u2022 int\tQueueSize():\tReturns\tthe\tnumber\tof\telements\tstored\tin\tthe\tqueue \u2022 int\tIsEmptyQueueQ:\tIndicates\twhether\tno\telements\tare\tstored\tin\tthe\tqueue\tor\tnot"
            },
            {
                "subchapter_title": "5.4\tExceptions",
                "content": "Similar\t to\t other\t ADTs,\t executing\t DeQueue\t on\t an\t empty\t queue\t throws\t an\t \u201cEmpty\t Queue Exception\u201d\tand\texecuting\tEnQueue\ton\ta\tfull\tqueue\tthrows\t\u201cFull\tQueue\tException\u201d."
            },
            {
                "subchapter_title": "5.5\tApplications",
                "content": "Following\tare\tsome\tof\tthe\tapplications\tthat\tuse\tqueues. Direct\tApplications \u2022 Operating\tsystems\tschedule\tjobs\t(with\tequal\tpriority)\tin\tthe\torder\tof\tarrival\t(e.g.,\ta print\tqueue). \u2022 Simulation\tof\treal-world\tqueues\tsuch\tas\tlines\tat\ta\tticket\tcounter\tor\tany\tother\tfirst- come\tfirst-served\tscenario\trequires\ta\tqueue. \u2022 Multiprogramming. \u2022 Asynchronous\tdata\ttransfer\t(file\tIO,\tpipes,\tsockets). \u2022 Waiting\ttimes\tof\tcustomers\tat\tcall\tcenter. \u2022 Determining\tnumber\tof\tcashiers\tto\thave\tat\ta\tsupermarket. Indirect\tApplications \u2022 Auxiliary\tdata\tstructure\tfor\talgorithms \u2022 Component\tof\tother\tdata\tstructures"
            },
            {
                "subchapter_title": "5.6\tImplementation",
                "content": "There\t are\t many\t ways\t (similar\t to\t Stacks)\t of\t implementing\t queue\t operations\t and\t some\t of\t the commonly\tused\tmethods\tare\tlisted\tbelow. \u2022 Simple\tcircular\tarray\tbased\timplementation \u2022 Dynamic\tcircular\tarray\tbased\timplementation \u2022 Linked\tlist\timplementation Why\tCircular\tArrays? First,\tlet\tus\tsee\twhether\twe\tcan\tuse\tsimple\tarrays\tfor\timplementing\tqueues\tas\twe\thave\tdone\tfor stacks.\t We\t know\t that,\t in\t queues,\t the\t insertions\t are\t performed\t at\t one\t end\t and\t deletions\t are performed\tat\tthe\tother\tend.\tAfter\tperforming\tsome\tinsertions\tand\tdeletions\tthe\tprocess\tbecomes easy\tto\tunderstand. In\tthe\texample\tshown\tbelow,\tit\tcan\tbe\tseen\tclearly\tthat\tthe\tinitial\tslots\tof\tthe\tarray\tare\tgetting wasted.\tSo,\tsimple\tarray\timplementation\tfor\tqueue\tis\tnot\tefficient.\tTo\tsolve\tthis\tproblem\twe assume\tthe\tarrays\tas\tcircular\tarrays.\tThat\tmeans,\twe\ttreat\tthe\tlast\telement\tand\tthe\tfirst\tarray elements\tas\tcontiguous.\tWith\tthis\trepresentation,\tif\tthere\tare\tany\tfree\tslots\tat\tthe\tbeginning,\tthe rear\tpointer\tcan\teasily\tgo\tto\tits\tnext\tfree\tslot. Note:\tThe\tsimple\tcircular\tarray\tand\tdynamic\tcircular\tarray\timplementations\tare\tvery\tsimilar\tto stack\tarray\timplementations.\tRefer\tto\tStacks\tchapter\tfor\tanalysis\tof\tthese\timplementations. Simple\tCircular\tArray\tImplementation This\tsimple\timplementation\tof\tQueue\tADT\tuses\tan\tarray.\tIn\tthe\tarray,\twe\tadd\telements\tcircularly and\tuse\ttwo\tvariables\tto\tkeep\ttrack\tof\tthe\tstart\telement\tand\tend\telement.\tGenerally,\tfront\tis\tused to\tindicate\tthe\tstart\telement\tand\trear\tis\tused\tto\tindicate\tthe\tend\telement\tin\tthe\tqueue.\tThe\tarray storing\tthe\tqueue\telements\tmay\tbecome\tfull.\tAn\tEnQueue\toperation\twill\tthen\tthrow\ta\tfull\tqueue exception.\t Similarly,\t if\t we\t try\t deleting\t an\t element\t from\t an\t empty\t queue\t it\t will\t throw\t empty queue\texception. Note:\tInitially,\tboth\tfront\tand\trear\tpoints\tto\t-1\twhich\tindicates\tthat\tthe\tqueue\tis\tempty. Performance\tand\tLimitations Performance:\tLet\tn\tbe\tthe\tnumber\tof\telements\tin\tthe\tqueue: Space\tComplexity\t(for\tn\tEnQueue\toperations) O(n) Time\tComplexity\tof\tEnQueue() O(1) Time\tComplexity\tof\tDeQueue() O(1) Time\tComplexity\tof\tIsEmptyQueue() O(1) Time\tComplexity\tof\tIsFullQueue() O(1) Time\tComplexity\tof\tQueueSize() O(1) Time\tComplexity\tof\tDeleteQueue() O(1) Limitations:\tThe\tmaximum\tsize\tof\tthe\tqueue\tmust\tbe\tdefined\tas\tprior\tand\tcannot\tbe\tchanged. Trying\tto\tEnQueue\ta\tnew\telement\tinto\ta\tfull\tqueue\tcauses\tan\timplementation-specific\texception. Dynamic\tCircular\tArray\tImplementation Performance Let\tn\tbe\tthe\tnumber\tof\telements\tin\tthe\tqueue. Space\tComplexity\t(for\tn\tEnQueue\toperations) O(n) Time\tComplexity\tof\tEnQueue() O(1)\t(Average) Time\tComplexity\tof\tDeQueue() O(1) Time\tComplexity\tof\tQueueSize() O(1) Time\tComplexity\tof\tIsEmptyQueue() O(1) Time\tComplexity\tof\tIsFullQueue() O(1) Time\tComplexity\tof\tQueueSize() O(1) Time\tComplexity\tof\tDeleteQueue() O(1) Linked\tList\tImplementation Another\tway\tof\timplementing\tqueues\tis\tby\tusing\tLinked\tlists.\tEnQueue\toperation\tis\timplemented by\tinserting\tan\telement\tat\tthe\tend\tof\tthe\tlist.\tDeQueue\toperation\tis\timplemented\tby\tdeleting\tan element\tfrom\tthe\tbeginning\tof\tthe\tlist. Performance Let\tn\tbe\tthe\tnumber\tof\telements\tin\tthe\tqueue,\tthen Space\tComplexity\t(for\tn\tEnQueue\toperations) O(n) Time\tComplexity\tof\tEnQueue() O(1)\t(Average) Time\tComplexity\tof\tDeQueue() O(1) Time\tComplexity\tof\tIsEmptyQueue() O(1) Time\tComplexity\tof\tDeleteQueue() O(1) Comparison\tof\tImplementations Note:\tComparison\tis\tvery\tsimilar\tto\tstack\timplementations\tand\tStacks\tchapter."
            },
            {
                "subchapter_title": "5.7\tQueues:\tProblems\t&\tSolutions",
                "content": "Problem-1\u2003\u2003Give\tan\talgorithm\tfor\treversing\ta\tqueue\tQ.\t To\t access\t the\t queue,\t we\t are\t only allowed\tto\tuse\tthe\tmethods\tof\tqueue\tADT. Solution: Time\tComplexity:\tO(n). Problem-2\u2003\u2003How\tcan\tyou\timplement\ta\tqueue\tusing\ttwo\tstacks? Solution:\tLet\tSI\tand\tS2\tbe\tthe\ttwo\tstacks\tto\tbe\tused\tin\tthe\timplementation\tof\tqueue.\tAll\twe\thave to\tdo\tis\tto\tdefine\tthe\tEnQueue\tand\tDeQueue\toperations\tfor\tthe\tqueue. EnQueue\tAlgorithm \u2022 Just\tpush\ton\tto\tstack\tS1 Time\tComplexity:\tO(1). DeQueue\tAlgorithm \u2022 If\tstack\tS2\tis\tnot\tempty\tthen\tpop\tfrom\tS2\tand\treturn\tthat\telement. \u2022 If\tstack\tis\tempty,\tthen\ttransfer\tall\telements\tfrom\tSI\tto\tS2\tand\tpop\tthe\ttop\telement from\t S2\t and\t return\t that\t popped\t element\t [we\t can\t optimize\t the\t code\t a\t little\t by transferring\tonly\tn\t\u2013\t1\telements\tfrom\tSI\tto\tS2\tand\tpop\tthe\tnth\telement\tfrom\tSI\tand return\tthat\tpopped\telement]. \u2022 If\tstack\tS1\tis\talso\tempty\tthen\tthrow\terror. Time\tComplexity:\tFrom\tthe\talgorithm,\tif\tthe\tstack\tS2\tis\tnot\tempty\tthen\tthe\tcomplexity\tis\tO(1).\tIf the\tstack\tS2\tis\tempty,\tthen\twe\tneed\tto\ttransfer\tthe\telements\tfrom\tSI\tto\tS2.\tBut\tif\twe\tcarefully observe,\t the\t number\t of\t transferred\t elements\t and\t the\t number\t of\t popped\t elements\t from\t S2\t are equal.\tDue\tto\tthis\tthe\taverage\tcomplexity\tof\tpop\toperation\tin\tthis\tcase\tis\tO(1).The\tamortized complexity\tof\tpop\toperation\tis\tO(1). Problem-3\u2003\u2003Show\thow\tyou\tcan\tefficiently\timplement\tone\tstack\tusing\ttwo\tqueues.\tAnalyze\tthe running\ttime\tof\tthe\tstack\toperations. Solution:\tYes,\tit\tis\tpossible\tto\timplement\tthe\tStack\tADT\tusing\t2\timplementations\tof\tthe\tQueue ADT.\tOne\tof\tthe\tqueues\twill\tbe\tused\tto\tstore\tthe\telements\tand\tthe\tother\tto\thold\tthem\ttemporarily during\tthe\tpop\t and\t top\t methods.\t The\t push\tmethod\t would\tenqueue\t the\t given\t element\t onto\t the storage\tqueue.\tThe\ttop\tmethod\twould\ttransfer\tall\tbut\tthe\tlast\telement\tfrom\tthe\tstorage\tqueue\tonto the\ttemporary\tqueue,\tsave\tthe\tfront\telement\tof\tthe\tstorage\tqueue\tto\tbe\treturned,\ttransfer\tthe\tlast element\tto\tthe\ttemporary\tqueue,\tthen\ttransfer\tall\telements\tback\tto\tthe\tstorage\tqueue.\tThe\tpop method\t would\t do\t the\t same\t as\t top,\t except\t instead\t of\t transferring\t the\t last\t element\t onto\t the temporary\tqueue\tafter\tsaving\tit\tfor\treturn,\tthat\tlast\telement\twould\tbe\tdiscarded.\tLet\tQ1\tand\tQ2\tbe the\ttwo\tqueues\tto\tbe\tused\tin\tthe\timplementation\tof\tstack.\tAll\twe\thave\tto\tdo\tis\tto\tdefine\tthe\tpush and\tpop\toperations\tfor\tthe\tstack. In\tthe\talgorithms\tbelow,\twe\tmake\tsure\tthat\tone\tqueue\tis\talways\tempty. Push\tOperation\tAlgorithm:\tInsert\tthe\telement\tin\twhichever\tqueue\tis\tnot\tempty. \u2022 Check\twhether\tqueue\tQ1\tis\tempty\tor\tnot.\tIf\tQ1\tis\tempty\tthen\tEnqueue\tthe\telement into\tQ2. \u2022 Otherwise\tEnQueue\tthe\telement\tinto\tQ1. Time\tComplexity:\tO(1). Pop\tOperation\tAlgorithm:\tTransfer\tn\t\u2013\t1\telements\tto\tthe\tother\tqueue\tand\tdelete\tlast\tfrom\tqueue for\tperforming\tpop\toperation. \u2022 If\t queue\t Q1\t is\t not\t empty\t then\t transfer\t n\t \u2013\t 1\t elements\t from\t Q1\t to\t Q2\t and\t then, DeQueue\tthe\tlast\telement\tof\tQ1\tand\treturn\tit. \u2022 If\t queue\t Q2\t is\t not\t empty\t then\t transfer\t n\t \u2013\t 1\t elements\t from\t Q2\t to\t Q1\t and\t then, DeQueue\tthe\tlast\telement\tof\tQ2\tand\treturn\tit. Time\t Complexity:\t Running\t time\t of\t pop\t operation\t is\t O(n)\t as\t each\t time\t pop\t is\t called,\t we\t are transferring\tall\tthe\telements\tfrom\tone\tqueue\tto\tthe\tother. Problem-4\u2003\u2003Maximum\tsum\tin\tsliding\twindow:\tGiven\tarray\tA[]\twith\tsliding\twindow\tof\tsize w\twhich\tis\tmoving\tfrom\tthe\tvery\tleft\tof\tthe\tarray\tto\tthe\tvery\tright.\tAssume\tthat\twe\tcan only\tsee\tthe\tw\tnumbers\tin\tthe\twindow.\tEach\ttime\tthe\tsliding\twindow\tmoves\trightwards\tby one\tposition.\tFor\texample:\tThe\tarray\tis\t[1\t3\t-1\t-3\t5\t3\t6\t7],\tand\tw\tis\t3. Window\tposition Max [1\t3\t-1]\t-3\t5\t3\t6\t7 3 1\t[3\t-1\t-3]\t5\t3\t6\t7 3 1\t3\t[-1\t-3\t5]\t3\t6\t7 5 1\t3\t-1\t[-3\t5\t3]\t6\t7 5 1\t3\t-1\t-3\t[5\t3\t6]\t7 6 1\t3\t-1\t-3\t5\t[3\t6\t7] 7 Input:\t A\t long\t array\t A[],\t and\t a\t window\t width\t w.\t Output:\t An\t array\t B[],\t B[i]\t is\t the maximum\tvalue\tfrom\tA[i]\tto\tA[i+w-1].\tRequirement:\tFind\ta\tgood\toptimal\tway\tto\tget B[i] Solution:\tThis\tproblem\tcan\tbe\tsolved\twith\tdoubly\tended\tqueue\t(which\tsupports\tinsertion\tand deletion\tat\tboth\tends).\tRefer\tPriority\tQueues\tchapter\tfor\talgorithms. Problem-5\u2003\u2003Given\t a\t queue\t Q\t containing\t n\t elements,\t transfer\t these\t items\t on\t to\t a\t stack\t S (initially\tempty)\tso\tthat\tfront\telement\tof\tQ\tappears\tat\tthe\ttop\tof\tthe\tstack\tand\tthe\torder\tof all\tother\titems\tis\tpreserved.\tUsing\tenqueue\tand\tdequeue\toperations\tfor\tthe\tqueue,\tand\tpush and\t pop\t operations\t for\t the\t stack,\t outline\t an\t efficient\t O(n)\t algorithm\t to\t accomplish\t the above\ttask,\tusing\tonly\ta\tconstant\tamount\tof\tadditional\tstorage. Solution:\tAssume\tthe\telements\tof\tqueue\tQ\tare\ta1:a2\t...an.\tDequeuing\tall\telements\tand\tpushing them\tonto\tthe\tstack\twill\tresult\tin\ta\tstack\twith\tan\tat\tthe\ttop\tand\ta1\tat\tthe\tbottom.\tThis\tis\tdone\tin O(n)\ttime\tas\tdequeue\tand\teach\tpush\trequire\tconstant\ttime\tper\toperation.\tThe\tqueue\tis\tnow\tempty. By\tpopping\tall\telements\tand\tpushing\tthem\ton\tthe\tqueue\twe\twill\tget\ta1\tat\tthe\ttop\tof\tthe\tstack.\tThis is\tdone\tagain\tin\tO(n)\ttime. As\tin\tbig-oh\tarithmetic\twe\tcan\tignore\tconstant\tfactors.\tThe\tprocess\tis\tcarried\tout\tin\tO(n)\ttime. The\tamount\tof\tadditional\tstorage\tneeded\there\thas\tto\tbe\tbig\tenough\tto\ttemporarily\thold\tone\titem. Problem-6\u2003\u2003A\tqueue\tis\tset\tup\tin\ta\tcircular\tarray\tA[O..n\t-\t1]\twith\tfront\tand\trear\tdefined\tas usual.\tAssume\tthat\tn\t\u2013\t1\tlocations\tin\tthe\tarray\tare\tavailable\tfor\tstoring\tthe\telements\t(with the\tother\telement\tbeing\tused\tto\tdetect\tfull/empty\tcondition).\tGive\ta\tformula\tfor\tthe\tnumber of\telements\tin\tthe\tqueue\tin\tterms\tof\trear,\tfront,\tand\tn. Solution:\tConsider\tthe\tfollowing\tfigure\tto\tget\ta\tclear\tidea\tof\tthe\tqueue. \u2022 Rear\tof\tthe\tqueue\tis\tsomewhere\tclockwise\tfrom\tthe\tfront. \u2022 To\tenqueue\tan\telement,\twe\tmove\trear\tone\tposition\tclockwise\tand\twrite\tthe\telement in\tthat\tposition. \u2022 To\tdequeue,\twe\tsimply\tmove\tfront\tone\tposition\tclockwise. \u2022 Queue\tmigrates\tin\ta\tclockwise\tdirection\tas\twe\tenqueue\tand\tdequeue. \u2022 Emptiness\tand\tfullness\tto\tbe\tchecked\tcarefully. \u2022 Analyze\tthe\tpossible\tsituations\t(make\tsome\tdrawings\tto\tsee\twhere\tfront\tand\trear are\twhen\tthe\tqueue\tis\tempty,\tand\tpartially\tand\ttotally\tfilled).\tWe\twill\tget\tthis: Problem-7\u2003\u2003What\tis\tthe\tmost\tappropriate\tdata\tstructure\tto\tprint\telements\tof\tqueue\tin\treverse order? Solution:\tStack. Problem-8\u2003\u2003Implement\t doubly\t ended\t queues.\t A\t double-ended\t queue\t is\t an\t abstract\t data structure\tthat\timplements\ta\tqueue\tfor\twhich\telements\tcan\tonly\tbe\tadded\tto\tor\tremoved from\tthe\tfront\t(head)\tor\tback\t(tail).\tIt\tis\talso\toften\tcalled\ta\thead-tail\tlinked\tlist. Solution: Problem-9\u2003\u2003Given\t a\t stack\t of\t integers,\t how\t do\t you\t check\t whether\t each\t successive\t pair\t of numbers\tin\tthe\tstack\tis\tconsecutive\tor\tnot.\tThe\tpairs\tcan\tbe\tincreasing\tor\tdecreasing,\tand if\tthe\tstack\thas\tan\todd\tnumber\tof\telements,\tthe\telement\tat\tthe\ttop\tis\tleft\tout\tof\ta\tpair.\tFor example,\tif\tthe\tstack\tof\telements\tare\t[4,\t5,\t-2,\t-3,\t11,\t10,\t5,\t6,\t20],\tthen\tthe\toutput\tshould be\t true\t because\t each\t of\t the\t pairs\t (4,\t 5),\t (-2,\t -3),\t (11,\t 10),\t and\t (5,\t 6)\t consists\t of consecutive\tnumbers. Solution: Time\tComplexity:\tO(n).\tSpace\tComplexity:\tO(n). Problem-10\u2003\u2003Given\ta\tqueue\tof\tintegers,\trearrange\tthe\telements\tby\tinterleaving\tthe\tfirst\thalf\tof the\tlist\twith\tthe\tsecond\thalf\tof\tthe\tlist.\tFor\texample,\tsuppose\ta\tqueue\tstores\tthe\tfollowing sequence\tof\tvalues:\t[11,\t12,\t13,\t14,\t15,\t16,\t17,\t18,\t19,\t20].\tConsider\tthe\ttwo\thalves\tof this\t list:\t first\t half:\t [11,\t 12,\t 13,\t 14,\t 15]\t second\t half:\t [16,\t 17,\t 18,\t 19,\t 20].\t These\t are combined\tin\tan\talternating\tfashion\tto\tform\ta\tsequence\tof\tinterleave\tpairs:\tthe\tfirst\tvalues from\teach\thalf\t(11\tand\t16),\tthen\tthe\tsecond\tvalues\tfrom\teach\thalf\t(12\tand\t17),\tthen\tthe third\tvalues\tfrom\teach\thalf\t(13\tand\t18),\tand\tso\ton.\tIn\teach\tpair,\tthe\tvalue\tfrom\tthe\tfirst half\tappears\tbefore\tthe\tvalue\tfrom\tthe\tsecond\thalf.\tThus,\tafter\tthe\tcall,\tthe\tqueue\tstores\tthe following\tvalues:\t[11,\t16,\t12,\t17,\t13,\t18,\t14,\t19,\t15,\t20]. Solution: Time\tComplexity:\tO(n).\tSpace\tComplexity:\tO(n). Problem-11\u2003\u2003Given\tan\tinteger\tk\tand\ta\tqueue\tof\tintegers,\thow\tdo\tyou\treverse\tthe\torder\tof\tthe first\tk\telements\tof\tthe\tqueue,\tleaving\tthe\tother\telements\tin\tthe\tsame\trelative\torder?\tFor example,\tif\tk=4\tand\tqueue\thas\tthe\telements\t[10,\t20,\t30,\t40,\t50,\t60,\t70,\t80,\t90];\tthe\toutput should\tbe\t[40,\t30,\t20,\t10,\t50,\t60,\t70,\t80,\t90]. Solution: Time\tComplexity:\tO(n).\tSpace\tComplexity:\tO(n)."
            },
            {
                "subchapter_title": "6.1\tWhat\tis\ta\tTree?",
                "content": "A\ttree\tis\ta\tdata\tstructure\tsimilar\tto\ta\tlinked\tlist\tbut\tinstead\tof\teach\tnode\tpointing\tsimply\tto\tthe next\tnode\tin\ta\tlinear\tfashion,\teach\tnode\tpoints\tto\ta\tnumber\tof\tnodes.\tTree\tis\tan\texample\tof\ta\tnon- linear\tdata\tstructure.\tA\ttree\tstructure\tis\ta\tway\tof\trepresenting\tthe\thierarchical\tnature\tof\ta\tstructure in\ta\tgraphical\tform. In\ttrees\tADT\t(Abstract\tData\tType),\tthe\torder\tof\tthe\telements\tis\tnot\timportant.\tIf\twe\tneed\tordering information,\tlinear\tdata\tstructures\tlike\tlinked\tlists,\tstacks,\tqueues,\tetc.\tcan\tbe\tused."
            },
            {
                "subchapter_title": "6.2\tGlossary",
                "content": "\u2022 The\troot\tof\ta\ttree\tis\tthe\tnode\twith\tno\tparents.\tThere\tcan\tbe\tat\tmost\tone\troot\tnode\tin a\ttree\t(node\tA\tin\tthe\tabove\texample). \u2022 An\tedge\trefers\tto\tthe\tlink\tfrom\tparent\tto\tchild\t(all\tlinks\tin\tthe\tfigure). \u2022 A\tnode\twith\tno\tchildren\tis\tcalled\tleaf\tnode\t(E,J,K,H\tand\tI). \u2022 Children\tof\tsame\tparent\tare\tcalled\tsiblings\t(B,C,D\tare\tsiblings\tof\tA,\tand\tE,F\tare\tthe siblings\tof\tB). \u2022 A\tnode\tp\tis\tan\tancestor\tof\tnode\tq\tif\tthere\texists\ta\tpath\tfrom\troot\tto\tq\tand\tp\tappears on\tthe\tpath.\tThe\tnode\tq\tis\tcalled\ta\tdescendant\tof\tp.\tFor\texample,\tA,C\tand\tG\tare\tthe ancestors\tof\tif. \u2022 The\tset\tof\tall\tnodes\tat\ta\tgiven\tdepth\tis\tcalled\tthe\tlevel\tof\tthe\ttree\t(B,\tC\tand\tD\tare the\tsame\tlevel).\tThe\troot\tnode\tis\tat\tlevel\tzero. \u2022 The\tdepth\tof\ta\tnode\tis\tthe\tlength\tof\tthe\tpath\tfrom\tthe\troot\tto\tthe\tnode\t(depth\tof\tG\tis 2,\tA\t\u2013\tC\t\u2013\tG). \u2022 The\theight\tof\ta\tnode\tis\tthe\tlength\tof\tthe\tpath\tfrom\tthat\tnode\tto\tthe\tdeepest\tnode.\tThe height\tof\ta\ttree\tis\tthe\tlength\tof\tthe\tpath\tfrom\tthe\troot\tto\tthe\tdeepest\tnode\tin\tthe\ttree. A\t(rooted)\ttree\twith\tonly\tone\tnode\t(the\troot)\thas\ta\theight\tof\tzero.\tIn\tthe\tprevious example,\tthe\theight\tof\tB\tis\t2\t(B\t\u2013\tF\t\u2013\tJ). \u2022 Height\tof\tthe\ttree\tis\tthe\tmaximum\theight\tamong\tall\tthe\tnodes\tin\tthe\ttree\tand\tdepth\tof the\ttree\tis\tthe\tmaximum\tdepth\tamong\tall\tthe\tnodes\tin\tthe\ttree.\tFor\ta\tgiven\ttree, depth\t and\t height\t returns\t the\t same\t value.\t But\t for\t individual\t nodes\t we\t may\t get different\tresults. \u2022 The\tsize\tof\ta\tnode\tis\tthe\tnumber\tof\tdescendants\tit\thas\tincluding\titself\t(the\tsize\tof\tthe subtree\tC\tis\t3). \u2022 If\tevery\tnode\tin\ta\ttree\thas\tonly\tone\tchild\t(except\tleaf\tnodes)\tthen\twe\tcall\tsuch\ttrees skew\t trees.\t If\t every\t node\t has\t only\t left\t child\t then\t we\t call\t them\t left\t skew\t trees. Similarly,\tif\tevery\tnode\thas\tonly\tright\tchild\tthen\twe\tcall\tthem\tright\tskew\ttrees."
            },
            {
                "subchapter_title": "6.3\tBinary\tTrees",
                "content": "A\ttree\tis\tcalled\tbinary\ttree\tif\teach\tnode\thas\tzero\tchild,\tone\tchild\tor\ttwo\tchildren.\tEmpty\ttree\tis also\ta\tvalid\tbinary\ttree.\tWe\tcan\tvisualize\ta\tbinary\ttree\tas\tconsisting\tof\ta\troot\tand\ttwo\tdisjoint binary\ttrees,\tcalled\tthe\tleft\tand\tright\tsubtrees\tof\tthe\troot. Generic\tBinary\tTree"
            },
            {
                "subchapter_title": "6.4\tTypes\tof\tBinary\tTrees",
                "content": "Strict\t Binary\t Tree:\t A\t binary\t tree\t is\t called\t strict\t binary\t tree\t if\t each\t node\t has\t exactly\t two children\tor\tno\tchildren. Full\tBinary\tTree:\tA\tbinary\ttree\tis\tcalled\tfull\tbinary\ttree\tif\teach\tnode\thas\texactly\ttwo\tchildren and\tall\tleaf\tnodes\tare\tat\tthe\tsame\tlevel. Complete\tBinary\tTree:\tBefore\tdefining\tthe\tcomplete\tbinary\ttree,\tlet\tus\tassume\tthat\tthe\theight\tof the\tbinary\ttree\tis\th.\tIn\tcomplete\tbinary\ttrees,\tif\twe\tgive\tnumbering\tfor\tthe\tnodes\tby\tstarting\tat\tthe root\t(let\tus\tsay\tthe\troot\tnode\thas\t1)\tthen\twe\tget\ta\tcomplete\tsequence\tfrom\t1\tto\tthe\tnumber\tof nodes\tin\tthe\ttree.\tWhile\ttraversing\twe\tshould\tgive\tnumbering\tfor\tNULL\tpointers\talso.\tA\tbinary tree\tis\tcalled\tcomplete\tbinary\ttree\tif\tall\tleaf\tnodes\tare\tat\theight\th\tor\th\t\u2013\t1\tand\talso\twithout\tany missing\tnumber\tin\tthe\tsequence."
            },
            {
                "subchapter_title": "6.5\tProperties\tof\tBinary\tTrees",
                "content": "For\tthe\tfollowing\tproperties,\tlet\tus\tassume\tthat\tthe\theight\tof\tthe\ttree\tis\th.\tAlso,\tassume\tthat\troot node\tis\tat\theight\tzero. From\tthe\tdiagram\twe\tcan\tinfer\tthe\tfollowing\tproperties: \u2022 The\tnumber\tof\tnodes\tn\tin\ta\tfull\tbinary\ttree\tis\t2h+1\t\u2013\t1.\tSince,\tthere\tare\th\tlevels\twe need\tto\tadd\tall\tnodes\tat\teach\tlevel\t[20\t+\t21+\t22\t+\t\u00b7\u00b7\u00b7\t+\t2h\t=\t2h+1\t\u2013\t1]. \u2022 The\tnumber\tof\tnodes\tn\tin\ta\tcomplete\tbinary\ttree\tis\tbetween\t2h\t(minimum)\tand\t2h+1 \u2013\t1\t(maximum).\tFor\tmore\tinformation\ton\tthis,\trefer\tto\tPriority\tQueues\tchapter. \u2022 The\tnumber\tof\tleaf\tnodes\tin\ta\tfull\tbinary\ttree\tis\t2h. \u2022 The\tnumber\tof\tNULL\tlinks\t(wasted\tpointers)\tin\ta\tcomplete\tbinary\ttree\tof\tn\tnodes\tis n\t+\t1. Structure\tof\tBinary\tTrees Now\tlet\tus\tdefine\tstructure\tof\tthe\tbinary\ttree.\tFor\tsimplicity,\tassume\tthat\tthe\tdata\tof\tthe\tnodes\tare integers.\tOne\tway\tto\trepresent\ta\tnode\t(which\tcontains\tdata)\tis\tto\thave\ttwo\tlinks\twhich\tpoint\tto left\tand\tright\tchildren\talong\twith\tdata\tfields\tas\tshown\tbelow: Note:\tIn\ttrees,\tthe\tdefault\tflow\tis\tfrom\tparent\tto\tchildren\tand\tit\tis\tnot\tmandatory\tto\tshow\tdirected branches.\tFor\tour\tdiscussion,\twe\tassume\tboth\tthe\trepresentations\tshown\tbelow\tare\tthe\tsame. Operations\ton\tBinary\tTrees Basic\tOperations \u2022 Inserting\tan\telement\tinto\ta\ttree \u2022 Deleting\tan\telement\tfrom\ta\ttree \u2022 Searching\tfor\tan\telement \u2022 Traversing\tthe\ttree Auxiliary\tOperations \u2022 Finding\tthe\tsize\tof\tthe\ttree \u2022 Finding\tthe\theight\tof\tthe\ttree \u2022 Finding\tthe\tlevel\twhich\thas\tmaximum\tsum \u2022 Finding\tthe\tleast\tcommon\tancestor\t(LCA)\tfor\ta\tgiven\tpair\tof\tnodes,\tand\tmany\tmore. Applications\tof\tBinary\tTrees Following\tare\tthe\tsome\tof\tthe\tapplications\twhere\tbinary\ttrees\tplay\tan\timportant\trole: \u2022 Expression\ttrees\tare\tused\tin\tcompilers. \u2022 Huffman\tcoding\ttrees\tthat\tare\tused\tin\tdata\tcompression\talgorithms. \u2022 Binary\t Search\t Tree\t (BST),\t which\t supports\t search,\t insertion\t and\t deletion\t on\t a collection\tof\titems\tin\tO(logn)\t(average). \u2022 Priority\tQueue\t(PQ),\twhich\tsupports\tsearch\tand\tdeletion\tof\tminimum\t(or\tmaximum) on\ta\tcollection\tof\titems\tin\tlogarithmic\ttime\t(in\tworst\tcase)."
            },
            {
                "subchapter_title": "6.6\tBinary\tTree\tTraversals",
                "content": "In\torder\tto\tprocess\ttrees,\twe\tneed\ta\tmechanism\tfor\ttraversing\tthem,\tand\tthat\tforms\tthe\tsubject\tof this\tsection.\tThe\tprocess\tof\tvisiting\tall\tnodes\tof\ta\ttree\tis\tcalled\ttree\ttraversal.\t Each\t node\t is processed\tonly\tonce\tbut\tit\tmay\tbe\tvisited\tmore\tthan\tonce.\tAs\twe\thave\talready\tseen\tin\tlinear\tdata structures\t(like\tlinked\tlists,\tstacks,\tqueues,\tetc.),\tthe\telements\tare\tvisited\tin\tsequential\torder.\tBut, in\ttree\tstructures\tthere\tare\tmany\tdifferent\tways. Tree\ttraversal\tis\tlike\tsearching\tthe\ttree,\texcept\tthat\tin\ttraversal\tthe\tgoal\tis\tto\tmove\tthrough\tthe tree\t in\t a\t particular\t order.\t In\t addition,\t all\t nodes\t are\tprocessed\t in\t the\t traversal\t but\t searching stops\twhen\tthe\trequired\tnode\tis\tfound. Traversal\tPossibilities Starting\tat\tthe\troot\tof\ta\tbinary\ttree,\tthere\tare\tthree\tmain\tsteps\tthat\tcan\tbe\tperformed\tand\tthe\torder in\twhich\tthey\tare\tperformed\tdefines\tthe\ttraversal\ttype.\tThese\tsteps\tare:\tperforming\tan\taction\ton the\tcurrent\tnode\t(referred\tto\tas\t\u201cvisiting\u201d\tthe\tnode\tand\tdenoted\twith\t\u201cD\u201d),\ttraversing\tto\tthe\tleft child\tnode\t(denoted\twith\t\u201cL\u201d),\tand\ttraversing\tto\tthe\tright\tchild\tnode\t(denoted\twith\t\u201cR\u201d).\t This process\t can\t be\t easily\t described\t through\t recursion.\t Based\t on\t the\t above\t definition\t there\t are\t 6 possibilities:"
            }
        ]
    },
    {
        "chapter_title": "1.",
        "subchapters": [
            {
                "subchapter_title": "LDR:\t Process\t left\t subtree,\t process\t the\t current\t node\t data\t and\t then\t process\t right",
                "content": "subtree"
            }
        ]
    },
    {
        "chapter_title": "2.",
        "subchapters": [
            {
                "subchapter_title": "LRD:\tProcess\tleft\tsubtree,\tprocess\tright\tsubtree\tand\tthen\tprocess\tthe\tcurrent\tnode",
                "content": "data"
            }
        ]
    },
    {
        "chapter_title": "3.",
        "subchapters": [
            {
                "subchapter_title": "DLR:\t Process\t the\t current\t node\t data,\t process\t left\t subtree\t and\t then\t process\t right",
                "content": "subtree"
            }
        ]
    },
    {
        "chapter_title": "4.",
        "subchapters": [
            {
                "subchapter_title": "DRL:\t Process\t the\t current\t node\t data,\t process\t right\t subtree\t and\t then\t process\t left",
                "content": "subtree"
            }
        ]
    },
    {
        "chapter_title": "5.",
        "subchapters": [
            {
                "subchapter_title": "RDL:\t Process\t right\t subtree,\t process\t the\t current\t node\t data\t and\t then\t process\t left",
                "content": "subtree"
            }
        ]
    },
    {
        "chapter_title": "6.",
        "subchapters": [
            {
                "subchapter_title": "RLD:\tProcess\tright\tsubtree,\tprocess\tleft\tsubtree\tand\tthen\tprocess\tthe\tcurrent\tnode",
                "content": "data Classifying\tthe\tTraversals The\tsequence\tin\twhich\tthese\tentities\t(nodes)\tare\tprocessed\tdefines\ta\tparticular\ttraversal\tmethod. The\tclassification\tis\tbased\ton\tthe\torder\tin\twhich\tcurrent\tnode\tis\tprocessed.\tThat\tmeans,\tif\twe\tare classifying\t based\t on\t current\t node\t (D)\t and\t if\t D\t comes\t in\t the\t middle\t then\t it\t does\t not\t matter whether\tL\tis\ton\tleft\tside\tof\tD\tor\tR\tis\ton\tleft\tside\tof\tD. Similarly,\tit\tdoes\tnot\tmatter\twhether\tL\tis\ton\tright\tside\tof\tD\tor\tR\tis\ton\tright\tside\tof\tD.\tDue\tto\tthis, the\ttotal\t6\tpossibilities\tare\treduced\tto\t3\tand\tthese\tare: \u2022 Preorder\t(DLR)\tTraversal \u2022 Inorder\t(LDR)\tTraversal \u2022 Postorder\t(LRD)\tTraversal There\tis\tanother\ttraversal\tmethod\twhich\tdoes\tnot\tdepend\ton\tthe\tabove\torders\tand\tit\tis: \u2022 Level\tOrder\tTraversal:\tThis\tmethod\tis\tinspired\tfrom\tBreadth\tFirst\tTraversal\t(BFS of\tGraph\talgorithms). Let\tus\tuse\tthe\tdiagram\tbelow\tfor\tthe\tremaining\tdiscussion. PreOrder\tTraversal In\t preorder\t traversal,\t each\t node\t is\t processed\t before\t (pre)\t either\t of\t its\t subtrees.\t This\t is\t the simplest\t traversal\t to\t understand.\t However,\t even\t though\t each\t node\t is\t processed\t before\t the subtrees,\tit\tstill\trequires\tthat\tsome\tinformation\tmust\tbe\tmaintained\twhile\tmoving\tdown\tthe\ttree. In\tthe\texample\tabove,\t1\tis\tprocessed\tfirst,\tthen\tthe\tleft\tsubtree,\tand\tthis\tis\tfollowed\tby\tthe\tright subtree. Therefore,\t processing\t must\t return\t to\t the\t right\t subtree\t after\t finishing\t the\t processing\t of\t the\t left subtree.\tTo\tmove\tto\tthe\tright\tsubtree\tafter\tprocessing\tthe\tleft\tsubtree,\twe\tmust\tmaintain\tthe\troot information.\tThe\tobvious\tADT\tfor\tsuch\tinformation\tis\ta\tstack.\tBecause\tof\tits\tLIFO\tstructure,\tit\tis possible\tto\tget\tthe\tinformation\tabout\tthe\tright\tsubtrees\tback\tin\tthe\treverse\torder. Preorder\ttraversal\tis\tdefined\tas\tfollows: \u2022 Visit\tthe\troot. \u2022 Traverse\tthe\tleft\tsubtree\tin\tPreorder. \u2022 Traverse\tthe\tright\tsubtree\tin\tPreorder. The\tnodes\tof\ttree\twould\tbe\tvisited\tin\tthe\torder:\t1\t2\t4\t5\t3\t6\t7 Time\tComplexity:\tO(n).\tSpace\tComplexity:\tO(n). Non-Recursive\tPreorder\tTraversal In\tthe\trecursive\tversion,\ta\tstack\tis\trequired\tas\twe\tneed\tto\tremember\tthe\tcurrent\tnode\tso\tthat\tafter completing\tthe\tleft\tsubtree\twe\tcan\tgo\tto\tthe\tright\tsubtree.\tTo\tsimulate\tthe\tsame,\tfirst\twe\tprocess the\tcurrent\tnode\tand\tbefore\tgoing\tto\tthe\tleft\tsubtree,\twe\tstore\tthe\tcurrent\tnode\ton\tstack.\tAfter completing\tthe\tleft\tsubtree\tprocessing,\tpop\tthe\telement\tand\tgo\tto\tits\tright\tsubtree.\tContinue\tthis process\tuntil\tstack\tis\tnonempty. Time\tComplexity:\tO(n).\tSpace\tComplexity:\tO(n). InOrder\tTraversal In\t Inorder\t Traversal\t the\t root\t is\t visited\t between\t the\t subtrees.\t Inorder\t traversal\t is\t defined\t as follows: \u2022 Traverse\tthe\tleft\tsubtree\tin\tInorder. \u2022 Visit\tthe\troot. \u2022 Traverse\tthe\tright\tsubtree\tin\tInorder. The\tnodes\tof\ttree\twould\tbe\tvisited\tin\tthe\torder:\t4\t2\t5\t1\t6\t3\t7 Time\tComplexity:\tO(n).\tSpace\tComplexity:\tO(n). Non-Recursive\tInorder\tTraversal The\tNon-recursive\tversion\tof\tInorder\ttraversal\tis\tsimilar\tto\tPreorder.\tThe\tonly\tchange\tis,\tinstead of\tprocessing\tthe\tnode\tbefore\tgoing\tto\tleft\tsubtree,\tprocess\tit\tafter\tpopping\t(which\tis\tindicated after\tcompletion\tof\tleft\tsubtree\tprocessing). Time\tComplexity:\tO(n).\tSpace\tComplexity:\tO(n). PostOrder\tTraversal In\tpostorder\ttraversal,\tthe\troot\tis\tvisited\tafter\tboth\tsubtrees.\tPostorder\ttraversal\tis\tdefined\tas follows: \u2022 Traverse\tthe\tleft\tsubtree\tin\tPostorder. \u2022 Traverse\tthe\tright\tsubtree\tin\tPostorder. \u2022 Visit\tthe\troot. The\tnodes\tof\tthe\ttree\twould\tbe\tvisited\tin\tthe\torder:\t4\t5\t2\t6\t7\t3\t1 Time\tComplexity:\tO(n).\tSpace\tComplexity:\tO(n). Non-Recursive\tPostorder\tTraversal In\tpreorder\tand\tinorder\ttraversals,\tafter\tpopping\tthe\tstack\telement\twe\tdo\tnot\tneed\tto\tvisit\tthe same\t vertex\t again.\t But\t in\t postorder\t traversal,\t each\t node\t is\t visited\t twice.\t That\t means,\t after processing\tthe\tleft\tsubtree\twe\twill\tvisit\tthe\tcurrent\tnode\tand\tafter\tprocessing\tthe\tright\tsubtree\twe will\tvisit\tthe\tsame\tcurrent\tnode.\tBut\twe\tshould\tbe\tprocessing\tthe\tnode\tduring\tthe\tsecond\tvisit. Here\tthe\tproblem\tis\thow\tto\tdifferentiate\twhether\twe\tare\treturning\tfrom\tthe\tleft\tsubtree\tor\tthe right\tsubtree. We\tuse\ta\tprevious\tvariable\tto\tkeep\ttrack\tof\tthe\tearlier\ttraversed\tnode.\tLet\u2019s\tassume\tcurrent\tis\tthe current\t node\t that\t is\t on\t top\t of\t the\t stack.\t When\t previous\t is\tcurrent\u2019s\t parent,\t we\t are\t traversing down\tthe\ttree.\tIn\tthis\tcase,\twe\ttry\tto\ttraverse\tto\tcurrent\u2019s\tleft\tchild\tif\tavailable\t(i.e.,\tpush\tleft child\tto\tthe\tstack).\tIf\tit\tis\tnot\tavailable,\twe\tlook\tat\tcurrent\u2019s\tright\tchild.\tIf\tboth\tleft\tand\tright\tchild do\tnot\texist\t(ie,\tcurrent\tis\ta\tleaf\tnode),\twe\tprint\tcurrent\u2019s\tvalue\tand\tpop\tit\toff\tthe\tstack. If\tprev\tis\tcurrent\u2019s\tleft\tchild,\twe\tare\ttraversing\tup\tthe\ttree\tfrom\tthe\tleft.\tWe\tlook\tat\tcurrent\u2019s\tright child.\tIf\tit\tis\tavailable,\tthen\ttraverse\tdown\tthe\tright\tchild\t(i.e.,\tpush\tright\tchild\tto\tthe\tstack); otherwise\tprint\tcurrent\u2019s\tvalue\tand\tpop\tit\toff\tthe\tstack.\tIf\tprevious\tis\tcurrent\u2019s\tright\tchild,\twe\tare traversing\tup\tthe\ttree\tfrom\tthe\tright.\tIn\tthis\tcase,\twe\tprint\tcurrent\u2019s\tvalue\tand\tpop\tit\toff\tthe\tstack. Time\tComplexity:\tO(n).\tSpace\tComplexity:\tO(n). Level\tOrder\tTraversal Level\torder\ttraversal\tis\tdefined\tas\tfollows: \u2022 Visit\tthe\troot. \u2022 While\ttraversing\tlevel\t(,\tkeep\tall\tthe\telements\tat\tlevel\t(\t+\t1\tin\tqueue. \u2022 Go\tto\tthe\tnext\tlevel\tand\tvisit\tall\tthe\tnodes\tat\tthat\tlevel. \u2022 Repeat\tthis\tuntil\tall\tlevels\tare\tcompleted. The\tnodes\tof\tthe\ttree\tare\tvisited\tin\tthe\torder:\t1\t2\t3\t4\t5\t6\t7 Time\tComplexity:\tO(n).\tSpace\tComplexity:\tO(n).\tSince,\tin\tthe\tworst\tcase,\tall\tthe\tnodes\ton\tthe entire\tlast\tlevel\tcould\tbe\tin\tthe\tqueue\tsimultaneously. Binary\tTrees:\tProblems\t&\tSolutions Problem-1\u2003\u2003Give\tan\talgorithm\tfor\tfinding\tmaximum\telement\tin\tbinary\ttree. Solution:\tOne\tsimple\tway\tof\tsolving\tthis\tproblem\tis:\tfind\tthe\tmaximum\telement\tin\tleft\tsubtree, find\tthe\tmaximum\telement\tin\tright\tsub\ttree,\tcompare\tthem\twith\troot\tdata\tand\tselect\tthe\tone\twhich is\tgiving\tthe\tmaximum\tvalue.\tThis\tapproach\tcan\tbe\teasily\timplemented\twith\trecursion. Time\tComplexity:\tO(n).\tSpace\tComplexity:\tO(n). Problem-2\u2003\u2003Give\t an\t algorithm\t for\t finding\t the\t maximum\t element\t in\t binary\t tree\t without recursion. Solution:\tUsing\tlevel\torder\ttraversal:\tjust\tobserve\tthe\telement\u2019s\tdata\twhile\tdeleting. Time\tComplexity:\tO(n).\tSpace\tComplexity:\tO(n). Problem-3\u2003\u2003Give\tan\talgorithm\tfor\tsearching\tan\telement\tin\tbinary\ttree. Solution:\tGiven\ta\tbinary\ttree,\treturn\ttrue\tif\ta\tnode\twith\tdata\tis\tfound\tin\tthe\ttree.\tRecurse\tdown the\ttree,\tchoose\tthe\tleft\tor\tright\tbranch\tby\tcomparing\tdata\twith\teach\tnode\u2019s\tdata. Time\tComplexity:\tO(n).\tSpace\tComplexity:\tO(n). Problem-4\u2003\u2003Give\tan\talgorithm\tfor\tsearching\tan\telement\tin\tbinary\ttree\twithout\trecursion. Solution:\tWe\tcan\tuse\tlevel\torder\ttraversal\tfor\tsolving\tthis\tproblem.\tThe\tonly\tchange\trequired\tin level\torder\ttraversal\tis,\tinstead\tof\tprinting\tthe\tdata,\twe\tjust\tneed\tto\tcheck\twhether\tthe\troot\tdata\tis equal\tto\tthe\telement\twe\twant\tto\tsearch. Time\tComplexity:\tO(n).\tSpace\tComplexity:\tO(n). Problem-5\u2003\u2003Give\tan\talgorithm\tfor\tinserting\tan\telement\tinto\tbinary\ttree. Solution:\tSince\tthe\tgiven\ttree\tis\ta\tbinary\ttree,\twe\tcan\tinsert\tthe\telement\twherever\twe\twant.\tTo insert\tan\telement,\twe\tcan\tuse\tthe\tlevel\torder\ttraversal\tand\tinsert\tthe\telement\twherever\twe\tfind the\tnode\twhose\tleft\tor\tright\tchild\tis\tNULL. Time\tComplexity:\tO(n).\tSpace\tComplexity:\tO(n). Problem-6\u2003\u2003Give\tan\talgorithm\tfor\tfinding\tthe\tsize\tof\tbinary\ttree. Solution:\tCalculate\tthe\tsize\tof\tleft\tand\tright\tsubtrees\trecursively,\tadd\t1\t(current\tnode)\tand\treturn to\tits\tparent. Time\tComplexity:\tO(n).\tSpace\tComplexity:\tO(n). Problem-7\u2003\u2003Can\twe\tsolve\tProblem-6\twithout\trecursion? Solution:\tYes,\tusing\tlevel\torder\ttraversal. Time\tComplexity:\tO(n).\tSpace\tComplexity:\tO(n). Problem-8\u2003\u2003Give\tan\talgorithm\tfor\tprinting\tthe\tlevel\torder\tdata\tin\treverse\torder.\tFor\texample, the\toutput\tfor\tthe\tbelow\ttree\tshould\tbe:\t4\t5\t6\t7\t2\t3\t1 Solution: Time\tComplexity:\tO(n).\tSpace\tComplexity:\tO(n). Problem-9\u2003\u2003Give\tan\talgorithm\tfor\tdeleting\tthe\ttree. Solution: To\tdelete\ta\ttree,\twe\tmust\ttraverse\tall\tthe\tnodes\tof\tthe\ttree\tand\tdelete\tthem\tone\tby\tone.\tSo\twhich traversal\tshould\twe\tuse:\tInorder,\tPreorder,\tPostorder\tor\tLevel\torder\tTraversal? Before\tdeleting\tthe\tparent\tnode\twe\tshould\tdelete\tits\tchildren\tnodes\tfirst.\tWe\tcan\tuse\tpostorder traversal\tas\tit\tdoes\tthe\twork\twithout\tstoring\tanything.\tWe\tcan\tdelete\ttree\twith\tother\ttraversals also\twith\textra\tspace\tcomplexity.\tFor\tthe\tfollowing,\ttree\tnodes\tare\tdeleted\tin\torder\t\u2013\t4,5,2,3,1. Time\tComplexity:\tO(n).\tSpace\tComplexity:\tO(n). Problem-10\u2003\u2003Give\tan\talgorithm\tfor\tfinding\tthe\theight\t(or\tdepth)\tof\tthe\tbinary\ttree. Solution:\tRecursively\tcalculate\theight\tof\tleft\tand\tright\tsubtrees\tof\ta\tnode\tand\tassign\theight\tto\tthe node\tas\tmax\tof\tthe\theights\tof\ttwo\tchildren\tplus\t1.\tThis\tis\tsimilar\tto\tPreOrder\ttree\ttraversal\t(and DFS\tof\tGraph\talgorithms). Time\tComplexity:\tO(n).\tSpace\tComplexity:\tO(n). Problem-11\u2003\u2003Can\twe\tsolve\tProblem-10\twithout\trecursion? Solution:\tYes,\tusing\tlevel\torder\ttraversal.\tThis\tis\tsimilar\tto\tBFS\tof\tGraph\talgorithms.\tEnd\tof level\tis\tidentified\twith\tNULL. Time\tComplexity:\tO(n).\tSpace\tComplexity:\tO(n). Problem-12\u2003\u2003Give\tan\talgorithm\tfor\tfinding\tthe\tdeepest\tnode\tof\tthe\tbinary\ttree. Solution: Time\tComplexity:\tO(n).\tSpace\tComplexity:\tO(n). Problem-13\u2003\u2003Give\tan\talgorithm\tfor\tdeleting\tan\telement\t(assuming\tdata\tis\tgiven)\tfrom\tbinary tree. Solution:\tThe\tdeletion\tof\ta\tnode\tin\tbinary\ttree\tcan\tbe\timplemented\tas \u2022 Starting\tat\troot,\tfind\tthe\tnode\twhich\twe\twant\tto\tdelete. \u2022 Find\tthe\tdeepest\tnode\tin\tthe\ttree. \u2022 Replace\tthe\tdeepest\tnode\u2019s\tdata\twith\tnode\tto\tbe\tdeleted. \u2022 Then\tdelete\tthe\tdeepest\tnode. Problem-14\u2003\u2003Give\tan\talgorithm\tfor\tfinding\tthe\tnumber\tof\tleaves\tin\tthe\tbinary\ttree\twithout using\trecursion. Solution:\tThe\tset\tof\tnodes\twhose\tboth\tleft\tand\tright\tchildren\tare\tNULL\tare\tcalled\tleaf\tnodes. Time\tComplexity:\tO(n).\tSpace\tComplexity:\tO(n). Problem-15\u2003\u2003Give\tan\talgorithm\tfor\tfinding\tthe\tnumber\tof\tfull\tnodes\tin\tthe\tbinary\ttree\twithout using\trecursion. Solution:\tThe\tset\tof\tall\tnodes\twith\tboth\tleft\tand\tright\tchildren\tare\tcalled\tfull\tnodes. Time\tComplexity:\tO(n).\tSpace\tComplexity:\tO(n). Problem-16\u2003\u2003Give\tan\talgorithm\tfor\tfinding\tthe\tnumber\tof\thalf\tnodes\t(nodes\t with\t only\t one child)\tin\tthe\tbinary\ttree\twithout\tusing\trecursion. Solution:\tThe\tset\tof\tall\tnodes\twith\teither\tleft\tor\tright\tchild\t(but\tnot\tboth)\tare\tcalled\thalf\tnodes. Time\tComplexity:\tO(n).\tSpace\tComplexity:\tO(n). Problem-17\u2003\u2003Given\ttwo\tbinary\ttrees,\treturn\ttrue\tif\tthey\tare\tstructurally\tidentical. Solution: Algorithm: \u2022 If\tboth\ttrees\tare\tNULL\tthen\treturn\ttrue. \u2022 If\tboth\ttrees\tare\tnot\tNULL,\tthen\tcompare\tdata\tand\trecursively\tcheck\tleft\tand\tright subtree\tstructures. Time\tComplexity:\tO(n).\tSpace\tComplexity:\tO(n),\tfor\trecursive\tstack. Problem-18\u2003\u2003Give\tan\talgorithm\tfor\tfinding\tthe\tdiameter\tof\tthe\tbinary\ttree.\tThe\tdiameter\tof\ta tree\t(sometimes\tcalled\tthe\twidth)\tis\tthe\tnumber\tof\tnodes\ton\tthe\tlongest\tpath\tbetween\ttwo leaves\tin\tthe\ttree. Solution:\t To\t find\t the\t diameter\t of\t a\t tree,\t first\t calculate\t the\t diameter\t of\t left\t subtree\t and\t right subtrees\t recursively.\t Among\t these\t two\t values,\t we\t need\t to\t send\t maximum\t value\t along\t with current\tlevel\t(+1). There\tis\tanother\tsolution\tand\tthe\tcomplexity\tis\tO(n).\tThe\tmain\tidea\tof\tthis\tapproach\tis\tthat\tthe node\tstores\tits\tleft\tchild\u2019s\tand\tright\tchild\u2019s\tmaximum\tdiameter\tif\tthe\tnode\u2019s\tchild\tis\tthe\t\u201croot\u201d, therefore,\tthere\tis\tno\tneed\tto\trecursively\tcall\tthe\theight\tmethod.\tThe\tdrawback\tis\twe\tneed\tto\tadd two\textra\tvariables\tin\tthe\tnode\tstructure. Time\tComplexity:\tO(n).\tSpace\tComplexity:\tO(n). Problem-19\u2003\u2003Give\tan\talgorithm\tfor\tfinding\tthe\tlevel\tthat\thas\tthe\tmaximum\tsum\tin\tthe\tbinary tree. Solution:\tThe\tlogic\tis\tvery\tmuch\tsimilar\tto\tfinding\tthe\tnumber\tof\tlevels.\tThe\tonly\tchange\tis,\twe need\tto\tkeep\ttrack\tof\tthe\tsums\tas\twell. Time\tComplexity:\tO(n).\tSpace\tComplexity:\tO(n). Problem-20\u2003\u2003Given\ta\tbinary\ttree,\tprint\tout\tall\tits\troot-to-leaf\tpaths. Solution:\tRefer\tto\tcomments\tin\tfunctions. Time\tComplexity:\tO(n).\tSpace\tComplexity:\tO(n),\tfor\trecursive\tstack. Problem-21\u2003\u2003Give\t an\t algorithm\t for\t checking\t the\t existence\t of\t path\t with\t given\t sum.\t That means,\tgiven\ta\tsum,\tcheck\twhether\tthere\texists\ta\tpath\tfrom\troot\tto\tany\tof\tthe\tnodes. Solution:\tFor\tthis\tproblem,\tthe\tstrategy\tis:\tsubtract\tthe\tnode\tvalue\tfrom\tthe\tsum\tbefore\tcalling\tits children\trecursively,\tand\tcheck\tto\tsee\tif\tthe\tsum\tis\t0\twhen\twe\trun\tout\tof\ttree. Time\tComplexity:\tO(n).\tSpace\tComplexity:\tO(n). Problem-22\u2003\u2003Give\tan\talgorithm\tfor\tfinding\tthe\tsum\tof\tall\telements\tin\tbinary\ttree. Solution:\tRecursively,\tcall\tleft\tsubtree\tsum,\tright\tsubtree\tsum\tand\tadd\ttheir\tvalues\tto\tcurrent nodes\tdata. Time\tComplexity:\tO(n).\tSpace\tComplexity:\tO(n). Problem-23\u2003\u2003Can\twe\tsolve\tProblem-22\twithout\trecursion? Solution:\t We\t can\t use\t level\t order\t traversal\t with\t simple\t change.\t Every\t time\t after\t deleting\t an element\tfrom\tqueue,\tadd\tthe\tnodes\tdata\tvalue\tto\tsum\tvariable. Time\tComplexity:\tO(n).\tSpace\tComplexity:\tO(n). Problem-24\u2003\u2003Give\tan\talgorithm\tfor\tconverting\ta\ttree\tto\tits\tmirror.\tMirror\tof\ta\ttree\tis\tanother tree\twith\tleft\tand\tright\tchildren\tof\tall\tnon-leaf\tnodes\tinterchanged.\tThe\ttrees\tbelow\tare mirrors\tto\teach\tother. Solution: Time\tComplexity:\tO(n).\tSpace\tComplexity:\tO(n). Problem-25\u2003\u2003Given\t two\t trees,\t give\t an\t algorithm\t for\t checking\t whether\t they\t are\t mirrors\t of each\tother. Solution: Time\tComplexity:\tO(n).\tSpace\tComplexity:\tO(n). Problem-26\u2003\u2003Give\tan\talgorithm\tfor\tfinding\tLCA\t(Least\tCommon\tAncestor)\tof\ttwo\tnodes\tin\ta Binary\tTree. Solution: Time\tComplexity:\tO(n).\tSpace\tComplexity:\tO(n)\tfor\trecursion. Problem-27\u2003\u2003Give\tan\talgorithm\tfor\tconstructing\tbinary\ttree\tfrom\tgiven\tInorder\tand\tPreorder traversals. Solution:\tLet\tus\tconsider\tthe\ttraversals\tbelow: Inorder\tsequence:\tD\tB\tE\tA\tF\tC Preorder\tsequence:\tA\tB\tD\tE\tC\tF In\ta\tPreorder\tsequence,\tleftmost\telement\tdenotes\tthe\troot\tof\tthe\ttree.\tSo\twe\tknow\t\u2018A\u2019\tis\tthe\troot for\tgiven\tsequences.\tBy\tsearching\t\u2018A\u2019\tin\tInorder\tsequence\twe\tcan\tfind\tout\tall\telements\ton\tthe\tleft side\tof\t\u2018A\u2019,\twhich\tcome\tunder\tthe\tleft\tsubtree,\tand\telements\ton\tthe\tright\tside\tof\t\u2018A\u2019,\twhich\tcome under\tthe\tright\tsubtree.\tSo\twe\tget\tthe\tstructure\tas\tseen\tbelow. We\trecursively\tfollow\tthe\tabove\tsteps\tand\tget\tthe\tfollowing\ttree. Algorithm:\tBuildTree() 1 Select\t an\t element\t from\t Preorder.\t Increment\t a\t Preorder\t index\t variable (preOrderIndex\tin\tcode\tbelow)\tto\tpick\tnext\telement\tin\tnext\trecursive\tcall. 2 Create\ta\tnew\ttree\tnode\t(newNode)\tfrom\theap\twith\tthe\tdata\tas\tselected\telement. 3 Find\tthe\tselected\telement\u2019s\tindex\tin\tInorder.\tLet\tthe\tindex\tbe\tinOrderIndex. 4 Call\tBuildBinaryTree\tfor\telements\tbefore\tinOrderIndex\tand\tmake\tthe\tbuilt\ttree\tas\tleft subtree\tof\tnewNode. 5 Call\tBuildBinaryTree\tfor\telements\tafter\tinOrderIndex\tand\tmake\tthe\tbuilt\ttree\tas\tright subtree\tof\tnewNode. 6 return\tnewNode. Time\tComplexity:\tO(n).\tSpace\tComplexity:\tO(n). Problem-28\u2003\u2003If\t we\t are\t given\t two\t traversal\t sequences,\t can\t we\t construct\t the\t binary\t tree uniquely? Solution:\tIt\tdepends\ton\twhat\ttraversals\tare\tgiven.\tIf\tone\tof\tthe\ttraversal\tmethods\tis\tInorder\tthen the\ttree\tcan\tbe\tconstructed\tuniquely,\totherwise\tnot. Therefore,\tthe\tfollowing\tcombinations\tcan\tuniquely\tidentify\ta\ttree: \u2022 Inorder\tand\tPreorder \u2022 Inorder\tand\tPostorder \u2022 Inorder\tand\tLevel-order The\tfollowing\tcombinations\tdo\tnot\tuniquely\tidentify\ta\ttree. \u2022 Postorder\tand\tPreorder \u2022 Preorder\tand\tLevel-order \u2022 Postorder\tand\tLevel-order For\texample,\tPreorder,\tLevel-order\tand\tPostorder\ttraversals\tare\tthe\tsame\tfor\tthe\tabove\ttrees: So,\teven\tif\tthree\tof\tthem\t(PreOrder,\tLevel-Order\tand\tPostOrder)\tare\tgiven,\tthe\ttree\tcannot\tbe constructed\tuniquely. Problem-29\u2003\u2003Give\tan\talgorithm\tfor\tprinting\tall\tthe\tancestors\tof\ta\tnode\tin\ta\tBinary\ttree.\tFor the\ttree\tbelow,\tfor\t7\tthe\tancestors\tare\t1\t3\t7. Solution:\tApart\tfrom\tthe\tDepth\tFirst\tSearch\tof\tthis\ttree,\twe\tcan\tuse\tthe\tfollowing\trecursive\tway to\tprint\tthe\tancestors. Time\tComplexity:\tO(n).\tSpace\tComplexity:\tO(n)\tfor\trecursion. Problem-30\u2003\u2003Zigzag\tTree\tTraversal:\tGive\tan\talgorithm\tto\ttraverse\ta\tbinary\ttree\tin\tZigzag order.\tFor\texample,\tthe\toutput\tfor\tthe\ttree\tbelow\tshould\tbe:\t1\t3\t2\t4\t5\t6\t7 Solution:\t This\t problem\t can\t be\t solved\t easily\t using\t two\t stacks.\t Assume\t the\t two\t stacks\t are: currentLevel\tand\tnextLevel.\tWe\twould\talso\tneed\ta\tvariable\tto\tkeep\ttrack\tof\tthe\tcurrent\tlevel order\t(whether\tit\tis\tleft\tto\tright\tor\tright\tto\tleft). We\tpop\tfrom\tcurrentLevel\tstack\tand\tprint\tthe\tnode\u2019s\tvalue.\tWhenever\tthe\tcurrent\tlevel\torder\tis from\tleft\tto\tright,\tpush\tthe\tnode\u2019s\tleft\tchild,\tthen\tits\tright\tchild,\tto\tstack\tnextLevel.\tSince\ta\tstack is\ta\tLast\tIn\tFirst\tOut\t(LIFO)\tstructure,\tthe\tnext\ttime\tthat\tnodes\tare\tpopped\toff\tnextLevel,\tit\twill be\tin\tthe\treverse\torder. On\tthe\tother\thand,\twhen\tthe\tcurrent\tlevel\torder\tis\tfrom\tright\tto\tleft,\twe\twould\tpush\tthe\tnode\u2019s right\tchild\tfirst,\tthen\tits\tleft\tchild.\tFinally,\tdon\u2019t\tforget\tto\tswap\tthose\ttwo\tstacks\tat\tthe\tend\tof\teach level\t(i.\te.,\twhen\tcurrentLevel\tis\tempty). Time\tComplexity:\tO(n).\tSpace\tComplexity:\tSpace\tfor\ttwo\tstacks\t=\tO(n)\t+\tO(n)\t=\tO(n). Problem-31\u2003\u2003Give\tan\talgorithm\tfor\tfinding\tthe\tvertical\tsum\tof\ta\tbinary\ttree.\tFor\texample,\tThe tree\thas\t5\tvertical\tlines Vertical-1:\tnodes-4\t=>\tvertical\tsum\tis\t4 Vertical-2:\tnodes-2\t=>\tvertical\tsum\tis\t2 Vertical-3:\tnodes-1,5,6\t=>\tvertical\tsum\tis\t1\t+\t5\t+\t6\t=\t12 Vertical-4:\tnodes-3\t=>\tvertical\tsum\tis\t3 Vertical-5:\tnodes-7\t=>\tvertical\tsum\tis\t7 We\tneed\tto\toutput:\t4\t2\t12\t3\t7 Solution:\t We\t can\t do\t an\t inorder\t traversal\t and\t hash\t the\t column.\t We\t call VerticalSumlnBinaryTreefroot,\t0)\twhich\tmeans\tthe\troot\tis\tat\tcolumn\t0.\tWhile\tdoing\tthe\ttraversal, hash\tthe\tcolumn\tand\tincrease\tits\tvalue\tby\troot\t\u2192\tdata. Problem-32\u2003\u2003How\tmany\tdifferent\tbinary\ttrees\tare\tpossible\twith\tn\tnodes? Solution:\t For\t example,\t consider\t a\t tree\t with\t 3\t nodes\t (n\t =\t 3).\t It\t will\t have\t the\t maximum combination\tof\t5\tdifferent\t(i.e.,\t23\t-3\t=\t5)\ttrees. In\tgeneral,\tif\tthere\tare\tn\tnodes,\tthere\texist\t2n\t\u2013n\tdifferent\ttrees. Problem-33\u2003\u2003Given\ta\ttree\twith\ta\tspecial\tproperty\twhere\tleaves\tare\trepresented\twith\t\u2018L\u2019\tand internal\t node\t with\t \u2018I\u2019.\t Also,\t assume\t that\t each\t node\t has\t either\t 0\t or\t 2\t children.\t Given preorder\ttraversal\tof\tthis\ttree,\tconstruct\tthe\ttree. Example:\tGiven\tpreorder\tstring\t=>\tILILL Solution:\t First,\t we\t should\t see\t how\tpreorder\t traversal\t is\t arranged.\t Pre-order\t traversal\t means first\tput\troot\tnode,\tthen\tpre-order\ttraversal\tof\tleft\tsubtree\tand\tthen\tpre-order\ttraversal\tof\tright subtree.\tIn\ta\tnormal\tscenario,\tit\u2019s\tnot\tpossible\tto\tdetect\twhere\tleft\tsubtree\tends\tand\tright\tsubtree starts\tusing\tonly\tpre-order\ttraversal.\tSince\tevery\tnode\thas\teither\t2\tchildren\tor\tno\tchild,\twe\tcan surely\tsay\tthat\tif\ta\tnode\texists\tthen\tits\tsibling\talso\texists.\tSo\tevery\ttime\twhen\twe\tare\tcomputing\ta subtree,\twe\tneed\tto\tcompute\tits\tsibling\tsubtree\tas\twell. Secondly,\twhenever\twe\tget\t\u2018L\u2019\tin\tthe\tinput\tstring,\tthat\tis\ta\tleaf\tand\twe\tcan\tstop\tfor\ta\tparticular subtree\tat\tthat\tpoint.\tAfter\tthis\t\u2018L\u2019\tnode\t(left\tchild\tof\tits\tparent\t\u2018L\u2019),\tits\tsibling\tstarts.\tIf\t\u2018L\u2019\tnode\tis right\tchild\tof\tits\tparent,\tthen\twe\tneed\tto\tgo\tup\tin\tthe\thierarchy\tto\tfind\tthe\tnext\tsubtree\tto\tcompute. Keeping\tthe\tabove\tinvariant\tin\tmind,\twe\tcan\teasily\tdetermine\twhen\ta\tsubtree\tends\tand\tthe\tnext one\tstarts.\tIt\tmeans\tthat\twe\tcan\tgive\tany\tstart\tnode\tto\tour\tmethod\tand\tit\tcan\teasily\tcomplete\tthe subtree\tit\tgenerates\tgoing\toutside\tof\tits\tnodes.\tWe\tjust\tneed\tto\ttake\tcare\tof\tpassing\tthe\tcorrect start\tnodes\tto\tdifferent\tsub-trees. Time\tComplexity:\tO(n). Problem-34\u2003\u2003Given\t a\t binary\t tree\t with\t three\t pointers\t (left,\t right\t and\t nextSibling),\t give\t an algorithm\tfor\tfilling\tthe\tnextSibling\tpointers\tassuming\tthey\tare\tNULL\tinitially. Solution:\tWe\tcan\tuse\tsimple\tqueue\t(similar\tto\tthe\tsolution\tof\tProblem-11).\tLet\tus\tassume\tthat\tthe structure\tof\tbinary\ttree\tis: Time\tComplexity:\tO(n).\tSpace\tComplexity:\tO(n). Problem-35\u2003\u2003Is\tthere\tany\tother\tway\tof\tsolving\tProblem-34? Solution:\tThe\ttrick\tis\tto\tre-use\tthe\tpopulated\tnextSibling\tpointers.\tAs\tmentioned\tearlier,\twe\tjust need\tone\tmore\tstep\tfor\tit\tto\twork.\tBefore\twe\tpass\tthe\tleft\tand\tright\tto\tthe\trecursion\tfunction itself,\twe\tconnect\tthe\tright\tchild\u2019s\tnextSibling\tto\tthe\tcurrent\tnode\u2019s\tnextSibling\tleft\tchild.\tIn\torder for\tthis\tto\twork,\tthe\tcurrent\tnode\tnextSibling\tpointer\tmust\tbe\tpopulated,\twhich\tis\ttrue\tin\tthis case. Time\tComplexity:\tO(n)."
            },
            {
                "subchapter_title": "6.7\tGeneric\tTrees\t(N-ary\tTrees)",
                "content": "In\tthe\tprevious\tsection\twe\tdiscussed\tbinary\ttrees\twhere\teach\tnode\tcan\thave\ta\tmaximum\tof\ttwo children\tand\tthese\tare\trepresented\teasily\twith\ttwo\tpointers.\tBut\tsuppose\tif\twe\thave\ta\ttree\twith many\tchildren\tat\tevery\tnode\tand\talso\tif\twe\tdo\tnot\tknow\thow\tmany\tchildren\ta\tnode\tcan\thave,\thow do\twe\trepresent\tthem? For\texample,\tconsider\tthe\ttree\tshown\tbelow. How\tdo\twe\trepresent\tthe\ttree? In\tthe\tabove\ttree,\tthere\tare\tnodes\twith\t6\tchildren,\twith\t3\tchildren,\twith\t2\tchildren,\twith\t1\tchild, and\t with\t zero\t children\t (leaves).\t To\t present\t this\t tree\t we\t have\t to\t consider\t the\t worst\t case\t (6 children)\t and\t allocate\t that\t many\t child\t pointers\t for\t each\t node.\t Based\t on\t this,\t the\t node representation\tcan\tbe\tgiven\tas: Since\twe\tare\tnot\tusing\tall\tthe\tpointers\tin\tall\tthe\tcases,\tthere\tis\ta\tlot\tof\tmemory\twastage.\tAnother problem\tis\tthat\twe\tdo\tnot\tknow\tthe\tnumber\tof\tchildren\tfor\teach\tnode\tin\tadvance.\tIn\torder\tto solve\tthis\tproblem\twe\tneed\ta\trepresentation\tthat\tminimizes\tthe\twastage\tand\talso\taccepts\tnodes with\tany\tnumber\tof\tchildren. Representation\tof\tGeneric\tTrees Since\tour\tobjective\tis\tto\treach\tall\tnodes\tof\tthe\ttree,\ta\tpossible\tsolution\tto\tthis\tis\tas\tfollows: \u2022 At\teach\tnode\tlink\tchildren\tof\tsame\tparent\t(siblings)\tfrom\tleft\tto\tright. \u2022 Remove\tthe\tlinks\tfrom\tparent\tto\tall\tchildren\texcept\tthe\tfirst\tchild. What\tthese\tabove\tstatements\tsay\tis\tif\twe\thave\ta\tlink\tbetween\tchildren\tthen\twe\tdo\tnot\tneed\textra links\tfrom\tparent\tto\tall\tchildren.\tThis\tis\tbecause\twe\tcan\ttraverse\tall\tthe\telements\tby\tstarting\tat the\tfirst\tchild\tof\tthe\tparent.\tSo\tif\twe\thave\ta\tlink\tbetween\tparent\tand\tfirst\tchild\tand\talso\tlinks between\tall\tchildren\tof\tsame\tparent\tthen\tit\tsolves\tour\tproblem. This\t representation\t is\t sometimes\t called\t first\t child/next\t sibling\t representation.\t First\t child/next sibling\trepresentation\tof\tthe\tgeneric\ttree\tis\tshown\tabove.\tThe\tactual\trepresentation\tfor\tthis\ttree is: Based\ton\tthis\tdiscussion,\tthe\ttree\tnode\tdeclaration\tfor\tgeneral\ttree\tcan\tbe\tgiven\tas: Note:\tSince\twe\tare\table\tto\tconvert\tany\tgeneric\ttree\tto\tbinary\trepresentation;\tin\tpractice\twe\tuse binary\ttrees.\tWe\tcan\ttreat\tall\tgeneric\ttrees\twith\ta\tfirst\tchild/next\tsibling\trepresentation\tas\tbinary trees. Generic\tTrees:\tProblems\t&\tSolutions Problem-36\u2003\u2003Given\ta\ttree,\tgive\tan\talgorithm\tfor\tfinding\tthe\tsum\tof\tall\tthe\telements\tof\tthe\ttree. Solution:\t The\t solution\t is\t similar\t to\t what\t we\t have\t done\t for\t simple\t binary\t trees.\t That\t means, traverse\tthe\tcomplete\tlist\tand\tkeep\ton\tadding\tthe\tvalues.\tWe\tcan\teither\tuse\tlevel\torder\ttraversal or\tsimple\trecursion. Time\tComplexity:\tO(n).\tSpace\tComplexity:\tO(1)\t(if\twe\tdo\tnot\tconsider\tstack\tspace),\totherwise O(n). Note:\tAll\tproblems\twhich\twe\thave\tdiscussed\tfor\tbinary\ttrees\tare\tapplicable\tfor\tgeneric\ttrees also.\tInstead\tof\tleft\tand\tright\tpointers\twe\tjust\tneed\tto\tuse\tfirstChild\tand\tnextSibling. Problem-37\u2003\u2003For\ta\t4-ary\ttree\t(each\tnode\tcan\tcontain\tmaximum\tof\t4\tchildren),\twhat\tis\tthe maximum\tpossible\theight\twith\t100\tnodes?\tAssume\theight\tof\ta\tsingle\tnode\tis\t0. Solution:\tIn\t4-ary\ttree\teach\tnode\tcan\tcontain\t0\tto\t4\tchildren,\tand\tto\tget\tmaximum\theight,\twe\tneed to\tkeep\tonly\tone\tchild\tfor\teach\tparent.\tWith\t100\tnodes,\tthe\tmaximum\tpossible\theight\twe\tcan\tget is\t99. If\t we\t have\t a\t restriction\t that\t at\t least\t one\t node\t has\t 4\t children,\t then\t we\t keep\t one\t node\t with\t 4 children\tand\tthe\tremaining\tnodes\twith\t1\tchild.\tIn\tthis\tcase,\tthe\tmaximum\tpossible\theight\tis\t96. Similarly,\twith\tn\tnodes\tthe\tmaximum\tpossible\theight\tis\tn\t\u2013\t4. Problem-38\u2003\u2003For\ta\t4-ary\ttree\t(each\tnode\tcan\tcontain\tmaximum\tof\t4\tchildren),\twhat\tis\tthe minimum\tpossible\theight\twith\tn\tnodes? Solution:\tSimilar\tto\tthe\tabove\tdiscussion,\tif\twe\twant\tto\tget\tminimum\theight,\tthen\twe\tneed\tto\tfill all\t nodes\t with\t maximum\t children\t (in\t this\t case\t 4).\t Now\t let\u2019s\t see\t the\t following\t table,\t which indicates\tthe\tmaximum\tnumber\tof\tnodes\tfor\ta\tgiven\theight. For\t a\t given\t height\t h\t the\t maximum\t possible\t nodes\t are:\t .\t To\t get\t minimum\t height,\t take logarithm\ton\tboth\tsides: Problem-39\u2003\u2003Given\ta\tparent\tarray\tP,\twhere\tP[i]\tindicates\tthe\tparent\tof\tith\tnode\tin\tthe\ttree (assume\tparent\tof\troot\tnode\tis\tindicated\twith\t\u20131).\tGive\tan\talgorithm\tfor\tfinding\tthe\theight or\tdepth\tof\tthe\ttree. Solution: For\texample:\tif\tthe\tP\tis Its\tcorresponding\ttree\tis: From\tthe\tproblem\tdefinition,\tthe\tgiven\tarray\trepresents\tthe\tparent\tarray.\tThat\tmeans,\twe\tneed\tto consider\tthe\ttree\tfor\tthat\tarray\tand\tfind\tthe\tdepth\tof\tthe\ttree.\tThe\tdepth\tof\tthis\tgiven\ttree\tis\t4.\tIf we\tcarefully\tobserve,\twe\tjust\tneed\tto\tstart\tat\tevery\tnode\tand\tkeep\tgoing\tto\tits\tparent\tuntil\twe reach\t\u20131\tand\talso\tkeep\ttrack\tof\tthe\tmaximum\tdepth\tamong\tall\tnodes. Time\t Complexity:\t O(n2).\t For\t skew\t trees\t we\t will\t be\t re-calculating\t the\t same\t values.\t Space Complexity:\tO(1). Note:\tWe\tcan\toptimize\tthe\tcode\tby\tstoring\tthe\tprevious\tcalculated\tnodes\u2019\tdepth\tin\tsome\thash table\tor\tother\tarray.\tThis\treduces\tthe\ttime\tcomplexity\tbut\tuses\textra\tspace. Problem-40\u2003\u2003Given\ta\tnode\tin\tthe\tgeneric\ttree,\tgive\tan\talgorithm\tfor\tcounting\tthe\tnumber\tof siblings\tfor\tthat\tnode. Solution:\tSince\ttree\tis\trepresented\twith\tthe\tfirst\tchild/next\tsibling\tmethod,\tthe\ttree\tstructure\tcan be\tgiven\tas: For\ta\tgiven\tnode\tin\tthe\ttree,\twe\tjust\tneed\tto\ttraverse\tall\tits\tnext\tsiblings. Time\tComplexity:\tO(n).\tSpace\tComplexity:\tO(1). Problem-41\u2003\u2003Given\ta\tnode\tin\tthe\tgeneric\ttree,\tgive\tan\talgorithm\tfor\tcounting\tthe\tnumber\tof children\tfor\tthat\tnode. Solution:\tSince\tthe\ttree\tis\trepresented\tas\tfirst\tchild/next\tsibling\tmethod,\tthe\ttree\tstructure\tcan\tbe given\tas: For\ta\tgiven\tnode\tin\tthe\ttree,\twe\tjust\tneed\tto\tpoint\tto\tits\tfirst\tchild\tand\tkeep\ttraversing\tall\tits\tnext siblings. Time\tComplexity:\tO(n).\tSpace\tComplexity:\tO(1). Problem-42\u2003\u2003Given\t two\t trees\t how\t do\t we\t check\t whether\t the\t trees\t are\t isomorphic\t to\t each other\tor\tnot? Solution: Two\tbinary\ttrees\troot1\tand\troot2\tare\tisomorphic\tif\tthey\thave\tthe\tsame\tstructure.\tThe\tvalues\tof the\tnodes\tdoes\tnot\taffect\twhether\ttwo\ttrees\tare\tisomorphic\tor\tnot.\tIn\tthe\tdiagram\tbelow,\tthe\ttree in\tthe\tmiddle\tis\tnot\tisomorphic\tto\tthe\tother\ttrees,\tbut\tthe\ttree\ton\tthe\tright\tis\tisomorphic\tto\tthe\ttree on\tthe\tleft. Time\tComplexity:\tO(n).\tSpace\tComplexity:\tO(n). Problem-43\u2003\u2003Given\ttwo\ttrees\thow\tdo\twe\tcheck\twhether\tthey\tare\tquasi-isomorphic\tto\teach other\tor\tnot? Solution: Two\t trees\t root1\t and\t root2\t are\t quasi-isomorphic\t if\t root1\t can\t be\t transformed\t into\t root2\t by swapping\tthe\tleft\tand\tright\tchildren\tof\tsome\tof\tthe\tnodes\tof\troot1.\t Data\t in\t the\t nodes\t are\t not important\tin\tdetermining\tquasi-isomorphism;\tonly\tthe\tshape\tis\timportant.\tThe\ttrees\tbelow\tare quasi-isomorphic\tbecause\tif\tthe\tchildren\tof\tthe\tnodes\ton\tthe\tleft\tare\tswapped,\tthe\ttree\ton\tthe\tright is\tobtained. Time\tComplexity:\tO(n).\tSpace\tComplexity:\tO(n). Problem-44\u2003\u2003A\tfull\tk\t\u2013ary\ttree\tis\ta\ttree\twhere\teach\tnode\thas\teither\t0\tor\tk\tchildren.\tGiven\tan array\t which\t contains\t the\t preorder\t traversal\t of\t full\t k\t \u2013ary\t tree,\t give\t an\t algorithm\t for constructing\tthe\tfull\tk\t\u2013ary\ttree. Solution:\tIn\tk\t\u2013ary\ttree,\tfor\ta\tnode\tat\tith\tposition\tits\tchildren\twill\tbe\tat\tk\t*\ti\t+\t1\tto\tk\t*\ti\t+\tk.\tFor example,\tthe\texample\tbelow\tis\tfor\tfull\t3-ary\ttree. As\twe\thave\tseen,\tin\tpreorder\ttraversal\tfirst\tleft\tsubtree\tis\tprocessed\tthen\tfollowed\tby\troot\tnode and\tright\tsubtree.\tBecause\tof\tthis,\tto\tconstruct\ta\tfull\tk-ary,\twe\tjust\tneed\tto\tkeep\ton\tcreating\tthe nodes\twithout\tbothering\tabout\tthe\tprevious\tconstructed\tnodes.\tWe\tcan\tuse\tthis\ttrick\tto\tbuild\tthe tree\trecursively\tby\tusing\tone\tglobal\tindex.\tThe\tdeclaration\tfor\tk-ary\ttree\tcan\tbe\tgiven\tas: Time\tComplexity:\tO(n),\twhere\tn\tis\tthe\tsize\tof\tthe\tpre-order\tarray.\tThis\tis\tbecause\twe\tare\tmoving sequentially\tand\tnot\tvisiting\tthe\talready\tconstructed\tnodes."
            },
            {
                "subchapter_title": "6.8\tThreaded\tBinary\tTree\tTraversals\t(Stack\tor\tQueue-less\tTraversals)",
                "content": "In\tearlier\tsections\twe\thave\tseen\tthat,\tpreorder,\tinorder\tand\tpostorder\tbinary\ttree\ttraversals\tused stacks\tand\tlevel\torder\ttraversals\tused\tqueues\tas\tan\tauxiliary\tdata\tstructure.\tIn\tthis\tsection\twe will\tdiscuss\tnew\ttraversal\talgorithms\twhich\tdo\tnot\tneed\tboth\tstacks\tand\tqueues.\tSuch\ttraversal algorithms\tare\tcalled\tthreaded\tbinary\ttree\ttraversals\tor\tstack/queue\t\u2013\tless\ttraversals. Issues\twith\tRegular\tBinary\tTree\tTraversals \u2022 The\tstorage\tspace\trequired\tfor\tthe\tstack\tand\tqueue\tis\tlarge. \u2022 The\tmajority\tof\tpointers\tin\tany\tbinary\ttree\tare\tNULL.\tFor\texample,\ta\tbinary\ttree with\tn\tnodes\thas\tn\t+\t1\tNULL\tpointers\tand\tthese\twere\twasted. \u2022 It\tis\tdifficult\tto\tfind\tsuccessor\tnode\t(preorder,\tinorder\tand\tpostorder\tsuccessors)\tfor a\tgiven\tnode. Motivation\tfor\tThreaded\tBinary\tTrees To\tsolve\tthese\tproblems,\tone\tidea\tis\tto\tstore\tsome\tuseful\tinformation\tin\tNULL\tpointers.\tIf\twe observe\tthe\tprevious\ttraversals\tcarefully,\tstack/\tqueue\tis\trequired\tbecause\twe\thave\tto\trecord\tthe current\tposition\tin\torder\tto\tmove\tto\tthe\tright\tsubtree\tafter\tprocessing\tthe\tleft\tsubtree.\tIf\twe\tstore the\tuseful\tinformation\tin\tNULL\tpointers,\tthen\twe\tdon\u2019t\thave\tto\tstore\tsuch\tinformation\tin\tstack/ queue. The\tbinary\ttrees\twhich\tstore\tsuch\tinformation\tin\tNULL\tpointers\tare\tcalled\tthreaded\tbinary\ttrees. From\tthe\tabove\tdiscussion,\tlet\tus\tassume\tthat\twe\twant\tto\tstore\tsome\tuseful\tinformation\tin\tNULL pointers.\tThe\tnext\tquestion\tis\twhat\tto\tstore? The\t common\t convention\t is\t to\t put\t predecessor/successor\t information.\t That\t means,\t if\t we\t are dealing\twith\tpreorder\ttraversals,\tthen\tfor\ta\tgiven\tnode,\tNULL\tleft\tpointer\twill\tcontain\tpreorder predecessor\t information\t and\t NULL\t right\t pointer\t will\t contain\t preorder\t successor\t information. These\tspecial\tpointers\tare\tcalled\tthreads. Classifying\tThreaded\tBinary\tTrees The\tclassification\tis\tbased\ton\twhether\twe\tare\tstoring\tuseful\tinformation\tin\tboth\tNULL\tpointers\tor only\tin\tone\tof\tthem. \u2022 If\twe\tstore\tpredecessor\tinformation\tin\tNULL\tleft\tpointers\tonly,\tthen\twe\tcan\tcall such\tbinary\ttrees\tleft\tthreaded\tbinary\ttrees. \u2022 If\twe\tstore\tsuccessor\tinformation\tin\tNULL\tright\tpointers\tonly,\tthen\twe\tcan\tcall\tsuch binary\ttrees\tright\tthreaded\tbinary\ttrees. \u2022 If\twe\tstore\tpredecessor\tinformation\tin\tNULL\tleft\tpointers\tand\tsuccessor\tinformation in\tNULL\tright\tpointers,\tthen\twe\tcan\tcall\tsuch\tbinary\ttrees\tfully\t threaded\t binary trees\tor\tsimply\tthreaded\tbinary\ttrees. Note:\tFor\tthe\tremaining\tdiscussion\twe\tconsider\tonly\t(fully)\tthreaded\tbinary\ttrees. Types\tof\tThreaded\tBinary\tTrees Based\ton\tabove\tdiscussion\twe\tget\tthree\trepresentations\tfor\tthreaded\tbinary\ttrees. \u2022 Preorder\t Threaded\t Binary\t Trees:\t NULL\t left\t pointer\t will\t contain\t PreOrder predecessor\tinformation\tand\tNULL\tright\tpointer\twill\tcontain\tPreOrder\tsuccessor information. \u2022 Inorder\t Threaded\t Binary\t Trees:\t NULL\t left\t pointer\t will\t contain\t InOrder predecessor\t information\t and\t NULL\t right\t pointer\t will\t contain\t InOrder\t successor information. \u2022 Postorder\t Threaded\t Binary\t Trees:\t NULL\t left\t pointer\t will\t contain\t PostOrder predecessor\tinformation\tand\tNULL\tright\tpointer\twill\tcontain\tPostOrder\tsuccessor information. Note:\t As\t the\t representations\t are\t similar,\t for\t the\t remaining\t discussion\t we\t will\t use\t InOrder threaded\tbinary\ttrees. Threaded\tBinary\tTree\tstructure Any\tprogram\texamining\tthe\ttree\tmust\tbe\table\tto\tdifferentiate\tbetween\ta\tregular\tleft/right\tpointer and\ta\tthread.\tTo\tdo\tthis,\twe\tuse\ttwo\tadditional\tfields\tin\teach\tnode,\tgiving\tus,\tfor\tthreaded\ttrees, nodes\tof\tthe\tfollowing\tform: Difference\tbetween\tBinary\tTree\tand\tThreaded\tBinary\tTree\tStructures Note:\tSimilarly,\twe\tcan\tdefine\tpreorder/postorder\tdifferences\tas\twell. As\tan\texample,\tlet\tus\ttry\trepresenting\ta\ttree\tin\tinorder\tthreaded\tbinary\ttree\tform.\tThe\ttree\tbelow shows\t what\t an\t inorder\t threaded\t binary\t tree\t will\t look\t like.\t The\t dotted\t arrows\t indicate\t the threads.\tIf\twe\tobserve,\tthe\tleft\tpointer\tof\tleft\tmost\tnode\t(2)\tand\tright\tpointer\tof\tright\tmost\tnode (31)\tare\thanging. What\tshould\tleftmost\tand\trightmost\tpointers\tpoint\tto? In\t the\t representation\t of\t a\t threaded\t binary\t tree,\t it\t is\t convenient\t to\t use\t a\t special\t node\t Dummy which\tis\talways\tpresent\teven\tfor\tan\tempty\ttree.\tNote\tthat\tright\ttag\tof\tDummy\tnode\tis\t1\tand\tits right\tchild\tpoints\tto\titself. With\tthis\tconvention\tthe\tabove\ttree\tcan\tbe\trepresented\tas: Finding\tInorder\tSuccessor\tin\tInorder\tThreaded\tBinary\tTree To\tfind\tinorder\tsuccessor\tof\ta\tgiven\tnode\twithout\tusing\ta\tstack,\tassume\tthat\tthe\tnode\tfor\twhich we\twant\tto\tfind\tthe\tinorder\tsuccessor\tis\tP. Strategy:\tIf\tP\thas\ta\tno\tright\tsubtree,\tthen\treturn\tthe\tright\tchild\tof\tP.\tIf\tP\thas\tright\tsubtree,\tthen return\tthe\tleft\tof\tthe\tnearest\tnode\twhose\tleft\tsubtree\tcontains\tP. Time\tComplexity:\tO(n).\tSpace\tComplexity:\tO(1). Inorder\tTraversal\tin\tInorder\tThreaded\tBinary\tTree We\t can\t start\t with\t dummy\t node\t and\t call\t InorderSuccessor()\t to\t visit\t each\t node\t until\t we\t reach dummy\tnode. Alternative\tcoding: Time\tComplexity:\tO(n).\tSpace\tComplexity:\tO(1). Finding\tPreOrder\tSuccessor\tin\tInOrder\tThreaded\tBinary\tTree Strategy:\tIf\tP\thas\ta\tleft\tsubtree,\tthen\treturn\tthe\tleft\tchild\tof\tP.\tIf\tP\thas\tno\tleft\tsubtree,\tthen\treturn the\tright\tchild\tof\tthe\tnearest\tnode\twhose\tright\tsubtree\tcontains\tP. Time\tComplexity:\tO(n).\tSpace\tComplexity:\tO(1). PreOrder\tTraversal\tof\tInOrder\tThreaded\tBinary\tTree As\tin\tinorder\ttraversal,\tstart\twith\tdummy\tnode\tand\tcall\tPreorderSuccessorf)\tto\tvisit\teach\tnode until\twe\tget\tdummy\tnode\tagain. Alternative\tcoding: Time\tComplexity:\tO(n).\tSpace\tComplexity:\tO(1). Note:\tFrom\tthe\tabove\tdiscussion,\tit\tshould\tbe\tclear\tthat\tinorder\tand\tpreorder\tsuccessor\tfinding is\teasy\twith\tthreaded\tbinary\ttrees.\tBut\tfinding\tpostorder\tsuccessor\tis\tvery\tdifficult\tif\twe\tdo\tnot use\tstack. Insertion\tof\tNodes\tin\tInOrder\tThreaded\tBinary\tTrees For\tsimplicity,\tlet\tus\tassume\tthat\tthere\tare\ttwo\tnodes\tP\tand\tQ\tand\twe\twant\tto\tattach\tQ\tto\tright\tof P.\tFor\tthis\twe\twill\thave\ttwo\tcases. \u2022 Node\tP\tdoes\tnot\thave\tright\tchild:\tIn\tthis\tcase\twe\tjust\tneed\tto\tattach\tQ\tto\tP\t and change\tits\tleft\tand\tright\tpointers. \u2022 Node\tP\thas\tright\tchild\t(say,\tR):\tIn\tthis\tcase\twe\tneed\tto\ttraverse\tR\u2019s\tleft\tsubtree\tand find\tthe\tleft\tmost\tnode\tand\tthen\tupdate\tthe\tleft\tand\tright\tpointer\tof\tthat\tnode\t(as shown\tbelow). Time\tComplexity:\tO(n).\tSpace\tComplexity:\tO(1). Threaded\tBinary\tTrees:\tProblems\t&\tSolutions Problem-45\u2003\u2003For\ta\tgiven\tbinary\ttree\t(not\tthreaded)\thow\tdo\twe\tfind\tthe\tpreorder\tsuccessor? Solution:\tFor\tsolving\tthis\tproblem,\twe\tneed\tto\tuse\tan\tauxiliary\tstack\tS.\tOn\tthe\tfirst\tcall,\tthe parameter\tnode\tis\ta\tpointer\tto\tthe\thead\tof\tthe\ttree,\tand\tthereafter\tits\tvalue\tis\tNULL.\tSince\twe\tare simply\tasking\tfor\tthe\tsuccessor\tof\tthe\tnode\twe\tgot\tthe\tlast\ttime\twe\tcalled\tthe\tfunction. It\tis\tnecessary\tthat\tthe\tcontents\tof\tthe\tstack\tS\tand\tthe\tpointer\tP\tto\tthe\tlast\tnode\t\u201cvisited\u201d\tare preserved\tfrom\tone\tcall\tof\tthe\tfunction\tto\tthe\tnext;\tthey\tare\tdefined\tas\tstatic\tvariables. Problem-46\u2003\u2003For\ta\tgiven\tbinary\ttree\t(not\tthreaded)\thow\tdo\twe\tfind\tthe\tinorder\tsuccessor? Solution:\tSimilar\tto\tthe\tabove\tdiscussion,\twe\tcan\tfind\tthe\tinorder\tsuccessor\tof\ta\tnode\tas:"
            },
            {
                "subchapter_title": "6.9\tExpression\tTrees",
                "content": "A\ttree\trepresenting\tan\texpression\tis\tcalled\tan\texpression\ttree.\tIn\texpression\ttrees,\tleaf\tnodes\tare operands\tand\tnon-leaf\tnodes\tare\toperators.\tThat\tmeans,\tan\texpression\ttree\tis\ta\tbinary\ttree\twhere internal\t nodes\t are\t operators\t and\t leaves\t are\t operands.\t An\t expression\t tree\t consists\t of\t binary expression.\t But\t for\t a\t u-nary\t operator,\t one\t subtree\t will\t be\t empty.\t The\t figure\t below\t shows\t a simple\texpression\ttree\tfor\t(A\t+\tB\t*\tC)\t/\tD. Algorithm\tfor\tBuilding\tExpression\tTree\tfrom\tPostfix\tExpression Example:\tAssume\tthat\tone\tsymbol\tis\tread\tat\ta\ttime.\tIf\tthe\tsymbol\tis\tan\toperand,\twe\tcreate\ta\ttree node\tand\tpush\ta\tpointer\tto\tit\tonto\ta\tstack.\tIf\tthe\tsymbol\tis\tan\toperator,\tpop\tpointers\tto\ttwo\ttrees T1\tand\tT2\tfrom\tthe\tstack\t(T1\tis\tpopped\tfirst)\tand\tform\ta\tnew\ttree\twhose\troot\tis\tthe\toperator\tand whose\tleft\tand\tright\tchildren\tpoint\tto\tT2\tand\tT1\trespectively.\tA\tpointer\tto\tthis\tnew\ttree\tis\tthen pushed\tonto\tthe\tstack. As\tan\texample,\tassume\tthe\tinput\tis\tA\tB\tC\t*\t+\tD\t/.\tThe\tfirst\tthree\tsymbols\tare\toperands,\tso\tcreate tree\tnodes\tand\tpush\tpointers\tto\tthem\tonto\ta\tstack\tas\tshown\tbelow. Next,\tan\toperator\t\u2018*\u2019\tis\tread,\tso\ttwo\tpointers\tto\ttrees\tare\tpopped,\ta\tnew\ttree\tis\tformed\tand\ta pointer\tto\tit\tis\tpushed\tonto\tthe\tstack. Next,\tan\toperator\t\u2018+\u2019\tis\tread,\tso\ttwo\tpointers\tto\ttrees\tare\tpopped,\ta\tnew\ttree\tis\tformed\tand\ta pointer\tto\tit\tis\tpushed\tonto\tthe\tstack. Next,\tan\toperand\t\u2018D\u2019\tis\tread,\ta\tone-node\ttree\tis\tcreated\tand\ta\tpointer\tto\tthe\tcorresponding\ttree\tis pushed\tonto\tthe\tstack. Finally,\tthe\tlast\tsymbol\t(\u2018/\u2019)\tis\tread,\ttwo\ttrees\tare\tmerged\tand\ta\tpointer\tto\tthe\tfinal\ttree\tis\tleft\ton the\tstack."
            },
            {
                "subchapter_title": "6.10\tXOR\tTrees",
                "content": "This\tconcept\tis\tsimilar\tto\tmemory\tefficient\tdoubly\tlinked\tlists\tof\tLinked\tLists\tchapter.\tAlso,\tlike threaded\tbinary\ttrees\tthis\trepresentation\tdoes\tnot\tneed\tstacks\tor\tqueues\tfor\ttraversing\tthe\ttrees. This\t representation\t is\t used\t for\t traversing\t back\t (to\t parent)\t and\t forth\t (to\t children)\t using\t \u2295 operation.\t To\t represent\t the\t same\t in\t XOR\t trees,\t for\t each\t node\t below\t are\t the\t rules\t used\t for representation: \u2022 Each\tnodes\tleft\twill\thave\tthe\t\u2295\tof\tits\tparent\tand\tits\tleft\tchildren. \u2022 Each\tnodes\tright\twill\thave\tthe\t\u2295\tof\tits\tparent\tand\tits\tright\tchildren. \u2022 The\troot\tnodes\tparent\tis\tNULL\tand\talso\tleaf\tnodes\tchildren\tare\tNULL\tnodes. Based\ton\tthe\tabove\trules\tand\tdiscussion,\tthe\ttree\tcan\tbe\trepresented\tas: The\tmajor\tobjective\tof\tthis\tpresentation\tis\tthe\tability\tto\tmove\tto\tparent\tas\twell\tto\tchildren.\tNow, let\tus\tsee\thow\tto\tuse\tthis\trepresentation\tfor\ttraversing\tthe\ttree.\tFor\texample,\tif\twe\tare\tat\tnode\tB and\twant\tto\tmove\tto\tits\tparent\tnode\tA,\tthen\twe\tjust\tneed\tto\tperform\t\u2295\ton\tits\tleft\tcontent\twith\tits left\tchild\taddress\t(we\tcan\tuse\tright\tchild\talso\tfor\tgoing\tto\tparent\tnode). Similarly,\tif\twe\twant\tto\tmove\tto\tits\tchild\t(say,\tleft\tchild\tD)\tthen\twe\thave\tto\tperform\t\u2295\ton\tits\tleft content\twith\tits\tparent\tnode\taddress.\tOne\timportant\tpoint\tthat\twe\tneed\tto\tunderstand\tabout\tthis representation\tis:\tWhen\twe\tare\tat\tnode\tB,\thow\tdo\twe\tknow\tthe\taddress\tof\tits\tchildren\tD?\tSince the\ttraversal\tstarts\tat\tnode\troot\tnode,\twe\tcan\tapply\t\u2295\ton\troot\u2019s\tleft\tcontent\twith\tNULL.\tAs\ta result\twe\tget\tits\tleft\tchild,\tB.\tWhen\twe\tare\tat\tB,\twe\tcan\tapply\t\u2295\ton\tits\tleft\tcontent\twith\tA address."
            },
            {
                "subchapter_title": "6.11\tBinary\tSearch\tTrees\t(BSTs)",
                "content": "Why\tBinary\tSearch\tTrees? In\tprevious\tsections\twe\thave\tdiscussed\tdifferent\ttree\trepresentations\tand\tin\tall\tof\tthem\twe\tdid not\timpose\tany\trestriction\ton\tthe\tnodes\tdata.\tAs\ta\tresult,\tto\tsearch\tfor\tan\telement\twe\tneed\tto check\tboth\tin\tleft\tsubtree\tand\tin\tright\tsubtree.\tDue\tto\tthis,\tthe\tworst\tcase\tcomplexity\tof\tsearch operation\tis\tO(n). In\tthis\tsection,\twe\twill\tdiscuss\tanother\tvariant\tof\tbinary\ttrees:\tBinary\tSearch\tTrees\t(BSTs).\tAs the\tname\tsuggests,\tthe\tmain\tuse\tof\tthis\trepresentation\tis\tfor\tsearching.\tIn\tthis\trepresentation\twe impose\trestriction\ton\tthe\tkind\tof\tdata\ta\tnode\tcan\tcontain.\tAs\ta\tresult,\tit\treduces\tthe\tworst\tcase average\tsearch\toperation\tto\tO(logn). Binary\tSearch\tTree\tProperty In\tbinary\tsearch\ttrees,\tall\tthe\tleft\tsubtree\telements\tshould\tbe\tless\tthan\troot\tdata\tand\tall\tthe\tright subtree\telements\tshould\tbe\tgreater\tthan\troot\tdata.\tThis\tis\tcalled\tbinary\tsearch\ttree\tproperty.\tNote that,\tthis\tproperty\tshould\tbe\tsatisfied\tat\tevery\tnode\tin\tthe\ttree. \u2022 The\tleft\tsubtree\tof\ta\tnode\tcontains\tonly\tnodes\twith\tkeys\tless\tthan\tthe\tnodes\tkey. \u2022 The\tright\tsubtree\tof\ta\tnode\tcontains\tonly\tnodes\twith\tkeys\tgreater\tthan\tthe\tnodes\tkey. \u2022 Both\tthe\tleft\tand\tright\tsubtrees\tmust\talso\tbe\tbinary\tsearch\ttrees. Example:\tThe\tleft\ttree\tis\ta\tbinary\tsearch\ttree\tand\tthe\tright\ttree\tis\tnot\ta\tbinary\tsearch\ttree\t(at node\t6\tit\u2019s\tnot\tsatisfying\tthe\tbinary\tsearch\ttree\tproperty). Binary\tSearch\tTree\tDeclaration There\tis\tno\tdifference\tbetween\tregular\tbinary\ttree\tdeclaration\tand\tbinary\tsearch\ttree\tdeclaration. The\tdifference\tis\tonly\tin\tdata\tbut\tnot\tin\tstructure.\tBut\tfor\tour\tconvenience\twe\tchange\tthe\tstructure name\tas: Operations\ton\tBinary\tSearch\tTrees Main\toperations:\tFollowing\tare\tthe\tmain\toperations\tthat\tare\tsupported\tby\tbinary\tsearch\ttrees: \u2022 Find/\tFind\tMinimum\t/\tFind\tMaximum\telement\tin\tbinary\tsearch\ttrees \u2022 Inserting\tan\telement\tin\tbinary\tsearch\ttrees \u2022 Deleting\tan\telement\tfrom\tbinary\tsearch\ttrees Auxiliary\toperations:\tChecking\twhether\tthe\tgiven\ttree\tis\ta\tbinary\tsearch\ttree\tor\tnot \u2022 Finding\tkth-smallest\telement\tin\ttree \u2022 Sorting\tthe\telements\tof\tbinary\tsearch\ttree\tand\tmany\tmore Important\tNotes\ton\tBinary\tSearch\tTrees \u2022 Since\t root\t data\t is\t always\t between\t left\t subtree\t data\t and\t right\t subtree\t data, performing\tinorder\ttraversal\ton\tbinary\tsearch\ttree\tproduces\ta\tsorted\tlist. \u2022 While\tsolving\tproblems\ton\tbinary\tsearch\ttrees,\tfirst\twe\tprocess\tleft\tsubtree,\tthen root\t data,\t and\t finally\t we\t process\t right\t subtree.\t This\t means,\t depending\t on\t the problem,\tonly\tthe\tintermediate\tstep\t(processing\troot\tdata)\tchanges\tand\twe\tdo\tnot touch\tthe\tfirst\tand\tthird\tsteps. \u2022 If\twe\tare\tsearching\tfor\tan\telement\tand\tif\tthe\tleft\tsubtree\troot\tdata\tis\tless\tthan\tthe element\twe\twant\tto\tsearch,\tthen\tskip\tit.\tThe\tsame\tis\tthe\tcase\twith\tthe\tright\tsubtree.. Because\tof\tthis,\tbinary\tsearch\ttrees\ttake\tless\ttime\tfor\tsearching\tan\telement\tthan regular\tbinary\ttrees.\tIn\tother\twords,\tthe\tbinary\tsearch\ttrees\tconsider\teither\tleft\tor right\tsubtrees\tfor\tsearching\tan\telement\tbut\tnot\tboth. \u2022 The\t basic\t operations\t that\t can\t be\t performed\t on\t binary\t search\t tree\t (BST)\t are insertion\t of\t element,\t deletion\t of\t element,\t and\t searching\t for\t an\t element.\t While performing\tthese\toperations\ton\tBST\tthe\theight\tof\tthe\ttree\tgets\tchanged\teach\ttime. Hence\tthere\texists\tvariations\tin\ttime\tcomplexities\tof\tbest\tcase,\taverage\tcase,\tand worst\tcase. \u2022 The\tbasic\toperations\ton\ta\tbinary\tsearch\ttree\ttake\ttime\tproportional\tto\tthe\theight\tof the\ttree.\tFor\ta\tcomplete\tbinary\ttree\twith\tnode\tn,\tsuch\toperations\truns\tin\tO(lgn) worst-case\ttime.\tIf\tthe\ttree\tis\ta\tlinear\tchain\tof\tn\tnodes\t(skew-tree),\thowever,\tthe same\toperations\ttakes\tO(n)\tworst-case\ttime. Finding\tan\tElement\tin\tBinary\tSearch\tTrees Find\toperation\tis\tstraightforward\tin\ta\tBST.\tStart\twith\tthe\troot\tand\tkeep\tmoving\tleft\tor\tright\tusing the\tBST\tproperty.\tIf\tthe\tdata\twe\tare\tsearching\tis\tsame\tas\tnodes\tdata\tthen\twe\treturn\tcurrent\tnode. If\t the\t data\t we\t are\t searching\t is\t less\t than\t nodes\t data\t then\t search\t left\t subtree\t of\t current\t node; otherwise\tsearch\tright\tsubtree\tof\tcurrent\tnode.\tIf\tthe\tdata\tis\tnot\tpresent,\twe\tend\tup\tin\ta\tNULL link. Time\tComplexity:\tO(n),\tin\tworst\tcase\t(when\tBST\tis\ta\tskew\ttree).\tSpace\tComplexity:\tO(n),\tfor recursive\tstack. Non\trecursive\tversion\tof\tthe\tabove\talgorithm\tcan\tbe\tgiven\tas: Time\tComplexity:\tO(n).\tSpace\tComplexity:\tO(1). Finding\tMinimum\tElement\tin\tBinary\tSearch\tTrees In\tBSTs,\tthe\tminimum\telement\tis\tthe\tleft-most\tnode,\twhich\tdoes\tnot\thas\tleft\tchild.\tIn\tthe\tBST below,\tthe\tminimum\telement\tis\t4. Time\tComplexity:\tO(n),\tin\tworst\tcase\t(when\tBST\tis\ta\tleft\tskew\ttree). Space\tComplexity:\tO(n),\tfor\trecursive\tstack. Non\trecursive\tversion\tof\tthe\tabove\talgorithm\tcan\tbe\tgiven\tas: Time\tComplexity:\tO(n).\tSpace\tComplexity:\tO(1). Finding\tMaximum\tElement\tin\tBinary\tSearch\tTrees In\tBSTs,\tthe\tmaximum\telement\tis\tthe\tright-most\tnode,\twhich\tdoes\tnot\thave\tright\tchild.\tIn\tthe\tBST below,\tthe\tmaximum\telement\tis\t16. Time\tComplexity:\tO(n),\tin\tworst\tcase\t(when\tBST\tis\ta\tright\tskew\ttree). Space\tComplexity:\tO(n),\tfor\trecursive\tstack. Non\trecursive\tversion\tof\tthe\tabove\talgorithm\tcan\tbe\tgiven\tas: Time\tComplexity:\tO(n).\tSpace\tComplexity:\tO(1). Where\tis\tInorder\tPredecessor\tand\tSuccessor? Where\tis\tthe\tinorder\tpredecessor\tand\tsuccessor\tof\tnode\tX\tin\ta\tbinary\tsearch\ttree\tassuming\tall keys\tare\tdistinct? If\tX\thas\ttwo\tchildren\tthen\tits\tinorder\tpredecessor\tis\tthe\tmaximum\tvalue\tin\tits\tleft\tsubtree\tand\tits inorder\tsuccessor\tthe\tminimum\tvalue\tin\tits\tright\tsubtree. If\tit\tdoes\tnot\thave\ta\tleft\tchild,\tthen\ta\tnode\u2019s\tinorder\tpredecessor\tis\tits\tfirst\tleft\tancestor. Inserting\tan\tElement\tfrom\tBinary\tSearch\tTree To\tinsert\tdata\tinto\tbinary\tsearch\ttree,\tfirst\twe\tneed\tto\tfind\tthe\tlocation\tfor\tthat\telement.\tWe\tcan find\tthe\tlocation\tof\tinsertion\tby\tfollowing\tthe\tsame\tmechanism\tas\tthat\tof\tfind\toperation.\tWhile finding\t the\t location,\t if\t the\t data\t is\t already\t there\t then\t we\t can\t simply\t neglect\t and\t come\t out. Otherwise,\tinsert\tdata\tat\tthe\tlast\tlocation\ton\tthe\tpath\ttraversed. As\tan\texample\tlet\tus\tconsider\tthe\tfollowing\ttree.\tThe\tdotted\tnode\tindicates\tthe\telement\t(5)\tto\tbe inserted.\tTo\tinsert\t5,\ttraverse\tthe\ttree\tusing\tfind\tfunction.\tAt\tnode\twith\tkey\t4,\twe\tneed\tto\tgo\tright, but\tthere\tis\tno\tsubtree,\tso\t5\tis\tnot\tin\tthe\ttree,\tand\tthis\tis\tthe\tcorrect\tlocation\tfor\tinsertion. Note:\tIn\tthe\tabove\tcode,\tafter\tinserting\tan\telement\tin\tsubtrees,\tthe\ttree\tis\treturned\tto\tits\tparent. As\ta\tresult,\tthe\tcomplete\ttree\twill\tget\tupdated. Time\tComplexity:O(n). Space\tComplexity:O(n),\tfor\trecursive\tstack.\tFor\titerative\tversion,\tspace\tcomplexity\tis\tO(1). Deleting\tan\tElement\tfrom\tBinary\tSearch\tTree The\tdelete\toperation\tis\tmore\tcomplicated\tthan\tother\toperations.\tThis\tis\tbecause\tthe\telement\tto\tbe deleted\tmay\tnot\tbe\tthe\tleaf\tnode.\tIn\tthis\toperation\talso,\tfirst\twe\tneed\tto\tfind\tthe\tlocation\tof\tthe element\twhich\twe\twant\tto\tdelete. Once\twe\thave\tfound\tthe\tnode\tto\tbe\tdeleted,\tconsider\tthe\tfollowing\tcases: \u2022 If\tthe\telement\tto\tbe\tdeleted\tis\ta\tleaf\tnode:\treturn\tNULL\tto\tits\tparent.\tThat\tmeans make\tthe\tcorresponding\tchild\tpointer\tNULL.\tIn\tthe\ttree\tbelow\tto\tdelete\t5,\tset\tNULL to\tits\tparent\tnode\t2. \u2022 If\t the\t element\t to\t be\t deleted\t has\t one\t child:\t In\t this\t case\t we\t just\t need\t to\t send\t the current\tnode\u2019s\tchild\tto\tits\tparent.\tIn\tthe\ttree\tbelow,\tto\tdelete\t4,\t4\tleft\tsubtree\tis\tset to\tits\tparent\tnode\t2. \u2022 If\tthe\telement\tto\tbe\tdeleted\thas\tboth\tchildren:\tThe\tgeneral\tstrategy\tis\tto\treplace\tthe key\tof\tthis\tnode\twith\tthe\tlargest\telement\tof\tthe\tleft\tsubtree\tand\trecursively\tdelete that\tnode\t(which\tis\tnow\tempty).\tThe\tlargest\tnode\tin\tthe\tleft\tsubtree\tcannot\thave\ta right\tchild,\tso\tthe\tsecond\tdelete\tis\tan\teasy\tone.\tAs\tan\texample,\tlet\tus\tconsider\tthe following\ttree.\tIn\tthe\ttree\tbelow,\tto\tdelete\t8,\tit\tis\tthe\tright\tchild\tof\tthe\troot.\tThe\tkey value\tis\t8.\tIt\tis\treplaced\twith\tthe\tlargest\tkey\tin\tits\tleft\tsubtree\t(7),\tand\tthen\tthat node\tis\tdeleted\tas\tbefore\t(second\tcase). Note:\tWe\tcan\treplace\twith\tminimum\telement\tin\tright\tsubtree\talso. Time\tComplexity:\tO(n).\tSpace\tComplexity:\tO(n)\tfor\trecursive\tstack.\tFor\titerative\tversion,\tspace complexity\tis\tO(1). Binary\tSearch\tTrees:\tProblems\t&\tSolutions Note:\tFor\tordering\trelated\tproblems\twith\tbinary\tsearch\ttrees\tand\tbalanced\tbinary\tsearch\ttrees, Inorder\ttraversal\thas\tadvantages\tover\tothers\tas\tit\tgives\tthe\tsorted\torder. Problem-47\u2003\u2003Given\tpointers\tto\ttwo\tnodes\tin\ta\tbinary\tsearch\ttree,\tfind\tthe\tlowest\tcommon ancestor\t(LCA).\tAssume\tthat\tboth\tvalues\talready\texist\tin\tthe\ttree. Solution: The\tmain\tidea\tof\tthe\tsolution\tis:\twhile\ttraversing\tBST\tfrom\troot\tto\tbottom,\tthe\tfirst\tnode\twe encounter\t with\t value\t between\t \u03b1\t and\t \u03b2,\t i.e.,\t \u03b1\t <\t node\t \u2192\t data\t <\t \u03b2,\t is\t the\t Least\t Common Ancestor(LCA)\tof\t\u03b1\tand\t\u03b2\t(where\t\u03b1\t<\t\u03b2).\tSo\tjust\ttraverse\tthe\tBST\tin\tpre-order,\tand\tif\twe\tfind\ta node\twith\tvalue\tin\tbetween\t\u03b1\tand\t\u03b2,\tthen\tthat\tnode\tis\tthe\tLCA.\tIf\tits\tvalue\tis\tgreater\tthan\tboth\t\u03b1 and\t\u03b2,\tthen\tthe\tLCA\tlies\ton\tthe\tleft\tside\tof\tthe\tnode,\tand\tif\tits\tvalue\tis\tsmaller\tthan\tboth\t\u03b1\tand\t\u03b2, then\tthe\tLCA\tlies\ton\tthe\tright\tside. Time\tComplexity:\tO(n).\tSpace\tComplexity:\tO(n),\tfor\tskew\ttrees. Problem-48\u2003\u2003Give\tan\talgorithm\tfor\tfinding\tthe\tshortest\tpath\tbetween\ttwo\tnodes\tin\ta\tBST. Solution:\tIt\u2019s\tnothing\tbut\tfinding\tthe\tLCA\tof\ttwo\tnodes\tin\tBST. Problem-49\u2003\u2003Give\tan\talgorithm\tfor\tcounting\tthe\tnumber\tof\tBSTs\tpossible\twith\tn\tnodes. Solution:\tThis\tis\ta\tDP\tproblem.\tRefer\tto\tchapter\ton\tDynamic\tProgramming\tfor\tthe\talgorithm. Problem-50\u2003\u2003Give\tan\talgorithm\tto\tcheck\twhether\tthe\tgiven\tbinary\ttree\tis\ta\tBST\tor\tnot. Solution: Consider\tthe\tfollowing\tsimple\tprogram.\tFor\teach\tnode,\tcheck\tif\tthe\tnode\ton\tits\tleft\tis\tsmaller\tand check\tif\tthe\tnode\ton\tits\tright\tis\tgreater.\tThis\tapproach\tis\twrong\tas\tthis\twill\treturn\ttrue\tfor\tbinary tree\tbelow.\tChecking\tonly\tat\tcurrent\tnode\tis\tnot\tenough. Problem-51\u2003\u2003Can\twe\tthink\tof\tgetting\tthe\tcorrect\talgorithm? Solution:\tFor\teach\tnode,\tcheck\tif\tmax\tvalue\tin\tleft\tsubtree\tis\tsmaller\tthan\tthe\tcurrent\tnode\tdata and\t min\t value\t in\t right\t subtree\t greater\t than\t the\t node\t data.\t It\t is\t assumed\t that\t we\t have\t helper functions\tFindMin()\tand\tFindMax()\tthat\treturn\tthe\tmin\tor\tmax\tinteger\tvalue\tfrom\ta\tnon-empty tree. Time\tComplexity:\tO(n2).\tSpace\tComplexity:\tO(n). Problem-52\u2003\u2003Can\twe\timprove\tthe\tcomplexity\tof\tProblem-51? Solution:\tYes.\tA\tbetter\tsolution\tis\tto\tlook\tat\teach\tnode\tonly\tonce.\tThe\ttrick\tis\tto\twrite\ta\tutility helper\tfunction\tIsBSTUtil(struct\tBinaryTreeNode*\troot,\tint\tmin,\tint\tmax)\tthat\ttraverses\tdown\tthe tree\tkeeping\ttrack\tof\tthe\tnarrowing\tmin\tand\tmax\tallowed\tvalues\tas\tit\tgoes,\tlooking\tat\teach\tnode only\tonce.\tThe\tinitial\tvalues\tfor\tmin\tand\tmax\tshould\tbe\tINT_MIN\tand\tINT_MAX\t\u2013\tthey\tnarrow from\tthere. Time\tComplexity:\tO(n).\tSpace\tComplexity:\tO(n),\tfor\tstack\tspace. Problem-53\u2003\u2003Can\twe\tfurther\timprove\tthe\tcomplexity\tof\tProblem-51? Solution:\tYes,\tby\tusing\tinorder\ttraversal.\tThe\tidea\tbehind\tthis\tsolution\tis\tthat\tinorder\ttraversal\tof BST\tproduces\tsorted\tlists.\tWhile\ttraversing\tthe\tBST\tin\tinorder,\tat\teach\tnode\tcheck\tthe\tcondition that\tits\tkey\tvalue\tshould\tbe\tgreater\tthan\tthe\tkey\tvalue\tof\tits\tprevious\tvisited\tnode.\tAlso,\twe\tneed to\tinitialize\tthe\tprev\twith\tpossible\tminimum\tinteger\tvalue\t(say,\tINT_MIN). Time\tComplexity:\tO(n).\tSpace\tComplexity:\tO(n),\tfor\tstack\tspace. Problem-54\u2003\u2003Give\tan\talgorithm\tfor\tconverting\tBST\tto\tcircular\tDLL\twith\tspace\tcomplexity O(1). Solution:\tConvert\tleft\tand\tright\tsubtrees\tto\tDLLs\tand\tmaintain\tend\tof\tthose\tlists.\tThen,\tadjust\tthe pointers. Time\tComplexity:\tO(n). Problem-55\u2003\u2003For\tProblem-54,\tis\tthere\tany\tother\tway\tof\tsolving\tit? Solution:\tYes.\tThere\tis\tan\talternative\tsolution\tbased\ton\tthe\tdivide\tand\tconquer\tmethod\twhich\tis quite\tneat. Time\tComplexity:\tO(n). Problem-56\u2003\u2003Given\t a\t sorted\t doubly\t linked\t list,\t give\t an\t algorithm\t for\t converting\t it\t into balanced\tbinary\tsearch\ttree. Solution:\tFind\tthe\tmiddle\tnode\tand\tadjust\tthe\tpointers. Time\tComplexity:\t2T(n/2)\t+\tO(n)\t[for\tfinding\tthe\tmiddle\tnode]\t=\tO(nlogn). Note:\tFor\tFindMiddleNode\tfunction\trefer\tLinked\tLists\tchapter. Problem-57\u2003\u2003Given\ta\tsorted\tarray,\tgive\tan\talgorithm\tfor\tconverting\tthe\tarray\tto\tBST. Solution:\tIf\twe\thave\tto\tchoose\tan\tarray\telement\tto\tbe\tthe\troot\tof\ta\tbalanced\tBST,\twhich\telement should\twe\tpick?\tThe\troot\tof\ta\tbalanced\tBST\tshould\tbe\tthe\tmiddle\telement\tfrom\tthe\tsorted\tarray. We\twould\tpick\tthe\tmiddle\telement\tfrom\tthe\tsorted\tarray\tin\teach\titeration.\tWe\tthen\tcreate\ta\tnode in\t the\t tree\t initialized\t with\t this\t element.\t After\t the\t element\t is\t chosen,\t what\t is\t left?\t Could\t you identify\tthe\tsub-problems\twithin\tthe\tproblem? There\tare\ttwo\tarrays\tleft\t\u2013\tthe\tone\ton\tits\tleft\tand\tthe\tone\ton\tits\tright.\tThese\ttwo\tarrays\tare\tthe sub-problems\t of\t the\t original\t problem,\t since\t both\t of\t them\t are\t sorted.\t Furthermore,\t they\t are subtrees\tof\tthe\tcurrent\tnode\u2019s\tleft\tand\tright\tchild. The\tcode\tbelow\tcreates\ta\tbalanced\tBST\tfrom\tthe\tsorted\tarray\tin\tO(n)\ttime\t(n\tis\tthe\tnumber\tof elements\tin\tthe\tarray).\tCompare\thow\tsimilar\tthe\tcode\tis\tto\ta\tbinary\tsearch\talgorithm.\tBoth\tare using\tthe\tdivide\tand\tconquer\tmethodology. Time\tComplexity:\tO(n).\tSpace\tComplexity:\tO(n),\tfor\tstack\tspace. Problem-58\u2003\u2003Given\ta\tsingly\tlinked\tlist\twhere\telements\tare\tsorted\tin\tascending\torder,\tconvert it\tto\ta\theight\tbalanced\tBST. Solution:\tA\tnaive\tway\tis\tto\tapply\tthe\tProblem-56\tsolution\tdirectly.\tIn\teach\trecursive\tcall,\twe would\thave\tto\ttraverse\thalf\tof\tthe\tlist\u2019s\tlength\tto\tfind\tthe\tmiddle\telement.\tThe\trun\ttime\tcomplexity is\tclearly\tO(nlogn),\twhere\tn\tis\tthe\ttotal\tnumber\tof\telements\tin\tthe\tlist.\tThis\tis\tbecause\teach\tlevel of\trecursive\tcall\trequires\ta\ttotal\tof\tn/2\ttraversal\tsteps\tin\tthe\tlist,\tand\tthere\tare\ta\ttotal\tof\tlogn number\tof\tlevels\t(ie,\tthe\theight\tof\tthe\tbalanced\ttree). Problem-59\u2003\u2003For\tProblem-58,\tcan\twe\timprove\tthe\tcomplexity? Solution:\tHint:\tHow\tabout\tinserting\tnodes\tfollowing\tthe\tlist\torder?\tIf\twe\tcan\tachieve\tthis,\twe\tno longer\tneed\tto\tfind\tthe\tmiddle\telement\tas\twe\tare\table\tto\ttraverse\tthe\tlist\twhile\tinserting\tnodes\tto the\ttree. Best\tSolution:\tAs\tusual,\tthe\tbest\tsolution\trequires\tus\tto\tthink\tfrom\tanother\tperspective.\tIn\tother words,\twe\tno\tlonger\tcreate\tnodes\tin\tthe\ttree\tusing\tthe\ttop-down\tapproach.\tCreate\tnodes\tbottom- up,\tand\tassign\tthem\tto\ttheir\tparents.\tThe\tbottom-up\tapproach\tenables\tus\tto\taccess\tthe\tlist\tin\tits order\twhile\tcreating\tnodes\t[42]. Isn\u2019t\tthe\tbottom-up\tapproach\tprecise?\tAny\ttime\twe\tare\tstuck\twith\tthe\ttop-down\tapproach,\twe\tcan give\tbottom-up\ta\ttry.\tAlthough\tthe\tbottom-up\tapproach\tis\tnot\tthe\tmost\tnatural\tway\twe\tthink,\tit\tis helpful\t in\t some\t cases.\t However,\t we\t should\t prefer\t top-down\t instead\t of\t bottom-up\t in\t general, since\tthe\tlatter\tis\tmore\tdifficult\tto\tverify. Below\t is\t the\t code\t for\t converting\t a\t singly\t linked\t list\t to\t a\t balanced\t BST.\t Please\t note\t that\t the algorithm\trequires\tthe\tlist\tlength\tto\tbe\tpassed\tin\tas\tthe\tfunction\tparameters.\tThe\tlist\tlength\tcan\tbe found\tin\tO(n)\ttime\tby\ttraversing\tthe\tentire\tlist\tonce.\tThe\trecursive\tcalls\ttraverse\tthe\tlist\tand create\ttree\tnodes\tby\tthe\tlist\torder,\twhich\talso\ttakes\tO(n)\ttime.\tTherefore,\tthe\toverall\trun\ttime complexity\tis\tstill\tO(n). Problem-60\u2003\u2003Give\tan\talgorithm\tfor\tfinding\tthe\tkth\tsmallest\telement\tin\tBST. Solution:\tThe\tidea\tbehind\tthis\tsolution\tis\tthat,\tinorder\ttraversal\tof\tBST\tproduces\tsorted\tlists. While\ttraversing\tthe\tBST\tin\tinorder,\tkeep\ttrack\tof\tthe\tnumber\tof\telements\tvisited. Time\tComplexity:\tO(n).\tSpace\tComplexity:\tO(1). Problem-61\u2003\u2003Floor\tand\tceiling:\tIf\ta\tgiven\tkey\tis\tless\tthan\tthe\tkey\tat\tthe\troot\tof\ta\tBST\tthen\tthe floor\tof\tthe\tkey\t(the\tlargest\tkey\tin\tthe\tBST\tless\tthan\tor\tequal\tto\tthe\tkey)\tmust\tbe\tin\tthe\tleft subtree.\tIf\tthe\tkey\tis\tgreater\tthan\tthe\tkey\tat\tthe\troot,\tthen\tthe\tfloor\tof\tthe\tkey\tcould\tbe\tin\tthe right\tsubtree,\tbut\tonly\tif\tthere\tis\ta\tkey\tsmaller\tthan\tor\tequal\tto\tthe\tkey\tin\tthe\tright\tsubtree; if\tnot\t(or\tif\tthe\tkey\tis\tequal\tto\tthe\tthe\tkey\tat\tthe\troot)\tthen\tthe\tkey\tat\tthe\troot\tis\tthe\tfloor\tof the\tkey.\tFinding\tthe\tceiling\tis\tsimilar,\twith\tinterchanging\tright\tand\tleft.\tFor\texample,\tif\tthe sorted\twith\tinput\tarray\tis\t{1,\t2,\t8,\t10,\t10,\t12,\t19},\tthen For\tx\t=\t0:\tfloor\tdoesn\u2019t\texist\tin\tarray,\tceil\t=\t1,\tFor\tx\t=\t1:\tfloor\t=\t1,\tceil\t=\t1 For\tx\t=\t5:\tfloor\t=2,\tceil\t=\t8,\tFor\tx\t=\t20:\tfloor\t=\t19,\tceil\tdoesn\u2019t\texist\tin\tarray Solution:\tThe\tidea\tbehind\tthis\tsolution\tis\tthat,\tinorder\ttraversal\tof\tBST\tproduces\tsorted\tlists. While\ttraversing\tthe\tBST\tin\tinorder,\tkeep\ttrack\tof\tthe\tvalues\tbeing\tvisited.\tIf\tthe\troots\tdata\tis greater\t than\t the\t given\t value\t then\t return\t the\t previous\t value\t which\t we\t have\t maintained\t during traversal.\tIf\tthe\troots\tdata\tis\tequal\tto\tthe\tgiven\tdata\tthen\treturn\troot\tdata. Time\tComplexity:\tO(n).\tSpace\tComplexity:\tO(n),\tfor\tstack\tspace. For\tceiling,\twe\tjust\tneed\tto\tcall\tthe\tright\tsubtree\tfirst,\tfollowed\tby\tleft\tsubtree. Time\tComplexity:\tO(n).\tSpace\tComplexity:\tO(n),\tfor\tstack\tspace. Problem-62\u2003\u2003Give\tan\talgorithm\tfor\tfinding\tthe\tunion\tand\tintersection\tof\tBSTs.\tAssume\tparent pointers\tare\tavailable\t(say\tthreaded\tbinary\ttrees).\tAlso,\tassume\tthe\tlengths\tof\ttwo\tBSTs are\tm\tand\tn\trespectively. Solution:\tIf\tparent\tpointers\tare\tavailable\tthen\tthe\tproblem\tis\tsame\tas\tmerging\tof\ttwo\tsorted\tlists. This\tis\tbecause\tif\twe\tcall\tinorder\tsuccessor\teach\ttime\twe\tget\tthe\tnext\thighest\telement.\tIt\u2019s\tjust\ta matter\tof\twhich\tInorderSuccessor\tto\tcall. Time\tComplexity:\tO(m\t+\tn).\tSpace\tcomplexity:\tO(1). Problem-63\u2003\u2003For\tProblem-62,\twhat\tif\tparent\tpointers\tare\tnot\tavailable? Solution:\tIf\tparent\tpointers\tare\tnot\tavailable,\tthe\tBSTs\tcan\tbe\tconverted\tto\tlinked\tlists\tand\tthen merged. 1 Convert\tboth\tthe\tBSTs\tinto\tsorted\tdoubly\tlinked\tlists\tin\tO(n\t+\tm)\ttime.\tThis\tproduces 2\tsorted\tlists. 2 Merge\t the\t two\t double\t linked\t lists\t into\t one\t and\t also\t maintain\t the\t count\t of\t total elements\tin\tO(n\t+\tm)\ttime. 3 Convert\tthe\tsorted\tdoubly\tlinked\tlist\tinto\theight\tbalanced\ttree\tin\tO(n\t+\tm)\ttime. Problem-64\u2003\u2003For\tProblem-62,\tis\tthere\tany\talternative\tway\tof\tsolving\tthe\tproblem? Solution:\tYes,\tby\tusing\tinorder\ttraversal. \u2022 Perform\tinorder\ttraversal\ton\tone\tof\tthe\tBSTs. \u2022 While\tperforming\tthe\ttraversal\tstore\tthem\tin\ttable\t(hash\ttable). \u2022 After\t completion\t of\t the\t traversal\t of\t first\t BST,\t start\t traversal\t of\t second\t BST\t and compare\tthem\twith\thash\ttable\tcontents. Time\tComplexity:\tO(m\t+\tn).\tSpace\tComplexity:\tO(Max(m,n)). Problem-65\u2003\u2003Given\ta\tBST\tand\ttwo\tnumbers\tK1\tand\tK2,\tgive\tan\talgorithm\tfor\tprinting\tall\tthe elements\tof\tBST\tin\tthe\trange\tK1\tand\tK2. Solution: Time\tComplexity:\tO(n).\tSpace\tComplexity:\tO(n),\tfor\tstack\tspace. Problem-66\u2003\u2003For\tProblem-65,\tis\tthere\tany\talternative\tway\tof\tsolving\tthe\tproblem? Solution:\tWe\tcan\tuse\tlevel\torder\ttraversal:\twhile\tadding\tthe\telements\tto\tqueue\tcheck\tfor\tthe range. Time\tComplexity:\tO(n).\tSpace\tComplexity:\tO(n),\tfor\tqueue. Problem-67\u2003\u2003For\tProblem-65,\tcan\twe\tstill\tthink\tof\tan\talternative\tway\tto\tsolve\tthe\tproblem? Solution:\tFirst\tlocate\tK1\twith\tnormal\tbinary\tsearch\tand\tafter\tthat\tuse\tInOrder\tsuccessor\tuntil\twe encounter\tK2.\tFor\talgorithm,\trefer\tto\tproblems\tsection\tof\tthreaded\tbinary\ttrees. Problem-68\u2003\u2003Given\troot\tof\ta\tBinary\tSearch\ttree,\ttrim\tthe\ttree,\tso\tthat\tall\telements\treturned\tin the\tnew\ttree\tare\tbetween\tthe\tinputs\tA\tand\tB. Solution:\tIt\u2019s\tjust\tanother\tway\tof\tasking\tProblem-65. Problem-69\u2003\u2003Given\ttwo\tBSTs,\tcheck\twhether\tthe\telements\tof\tthem\tare\tthe\tsame\tor\tnot.\tFor example:\ttwo\tBSTs\twith\tdata\t10\t5\t20\t15\t30\tand\t10\t20\t15\t30\t5\tshould\treturn\ttrue\tand\tthe dataset\twith\t10\t5\t20\t15\t30\tand\t10\t15\t30\t20\t5\tshould\treturn\tfalse.\tNote:\tBSTs\tdata\tcan\tbe in\tany\torder. Solution:\tOne\tsimple\tway\tis\tperforming\tan\tinorder\ttraversal\ton\tfirst\ttree\tand\tstoring\tits\tdata\tin hash\ttable.\tAs\ta\tsecond\tstep,\tperform\tinorder\ttraversal\ton\tsecond\ttree\tand\tcheck\twhether\tthat data\tis\talready\tthere\tin\thash\ttable\tor\tnot\t(if\tit\texists\tin\thash\ttable\tthen\tmark\tit\twith\t-1\tor\tsome unique\tvalue). During\tthe\ttraversal\tof\tsecond\ttree\tif\twe\tfind\tany\tmismatch\treturn\tfalse.\tAfter\ttraversal\tof\tsecond tree\tcheck\twhether\tit\thas\tall\t-1s\tin\tthe\thash\ttable\tor\tnot\t(this\tensures\textra\tdata\tavailable\tin second\ttree). Time\tComplexity:\tO(max(m,\tn)),\twhere\tm\tand\tn\tare\tthe\tnumber\tof\telements\tin\tfirst\tand\tsecond BST.\tSpace\tComplexity:\tO(max(m,n)).\tThis\tdepends\ton\tthe\tsize\tof\tthe\tfirst\ttree. Problem-70\u2003\u2003For\tProblem-69,\tcan\twe\treduce\tthe\ttime\tcomplexity? Solution:\t Instead\t of\t performing\t the\t traversals\t one\t after\t the\t other,\t we\t can\t perform\t in\t \u2013\t order traversal\tof\tboth\tthe\ttrees\tin\tparallel.\tSince\tthe\tin\t\u2013\torder\ttraversal\tgives\tthe\tsorted\tlist,\twe\tcan check\twhether\tboth\tthe\ttrees\tare\tgenerating\tthe\tsame\tsequence\tor\tnot. Time\tComplexity:\tO(max(m,n)).\tSpace\tComplexity:\tO(1).\tThis\tdepends\ton\tthe\tsize\tof\tthe\tfirst tree. Problem-71\u2003\u2003For\tthe\tkey\tvalues\t1...\tn,\thow\tmany\tstructurally\tunique\tBSTs\tare\tpossible\tthat store\tthose\tkeys. Solution:\tStrategy:\tconsider\tthat\teach\tvalue\tcould\tbe\tthe\troot.\tRecursively\tfind\tthe\tsize\tof\tthe\tleft and\tright\tsubtrees. Problem-72\u2003\u2003Given\ta\tBST\tof\tsize\tn,\tin\twhich\teach\tnode\tr\thas\tan\tadditional\tfield\tr\t\u2192\tsize, the\tnumber\tof\tthe\tkeys\tin\tthe\tsub-tree\trooted\tat\tr\t(including\tthe\troot\tnode\tr).\tGive\tan\tO(h) algorithm\tGreaterthanConstant(r,k)\tto\tfind\tthe\tnumber\tof\tkeys\tthat\tare\tstrictly\tgreater\tthan k\t(h\tis\tthe\theight\tof\tthe\tbinary\tsearch\ttree). Solution: The\tsuggested\talgorithm\tworks\twell\tif\tthe\tkey\tis\ta\tunique\tvalue\tfor\teach\tnode.\tOtherwise\twhen reaching\tk=r\u2192data,\twe\tshould\tstart\ta\tprocess\tof\tmoving\tto\tthe\tright\tuntil\treaching\ta\tnode\ty\twith a\tkey\tthat\tis\tbigger\tthen\tk,\tand\tthen\twe\tshould\treturn\tkeysCount\t+\ty\u2192size.\tTime\tComplexity: O(h)\twhere\th=O(n)\tin\tthe\tworst\tcase\tand\tO(logn)\tin\tthe\taverage\tcase."
            },
            {
                "subchapter_title": "6.12\tBalanced\tBinary\tSearch\tTrees",
                "content": "In\tearlier\tsections\twe\thave\tseen\tdifferent\ttrees\twhose\tworst\tcase\tcomplexity\tis\tO(n),\twhere\tn\tis the\tnumber\tof\tnodes\tin\tthe\ttree.\tThis\thappens\twhen\tthe\ttrees\tare\tskew\ttrees.\tIn\tthis\tsection\twe will\ttry\tto\treduce\tthis\tworst\tcase\tcomplexity\tto\tO(logn)\tby\timposing\trestrictions\ton\tthe\theights. In\t general,\t the\t height\t balanced\t trees\t are\t represented\t with\t HB(k),\t where\t k\t is\t the\t difference between\tleft\tsubtree\theight\tand\tright\tsubtree\theight.\tSometimes\tk\tis\tcalled\tbalance\tfactor. Full\tBalanced\tBinary\tSearch\tTrees In\t HB(k),\t if\t k\t =\t 0\t (if\t balance\t factor\t is\t zero),\t then\t we\t call\t such\t binary\t search\t trees\t as\t full balanced\tbinary\tsearch\ttrees.\tThat\tmeans,\tin\tHB(0)\tbinary\tsearch\ttree,\tthe\tdifference\tbetween\tleft subtree\theight\tand\tright\tsubtree\theight\tshould\tbe\tat\tmost\tzero.\tThis\tensures\tthat\tthe\ttree\tis\ta\tfull binary\ttree.\tFor\texample, Note:\tFor\tconstructing\tHB(0)\ttree\trefer\tto\tProblems\tsection."
            },
            {
                "subchapter_title": "6.13\tAVL\t(Adelson-Velskii\tand\tLandis)\tTrees",
                "content": "In\tHB(k),\tif\tk\t=\t1\t(if\tbalance\tfactor\tis\tone),\tsuch\ta\tbinary\tsearch\ttree\tis\tcalled\tan\tAVL\ttree.\tThat means\tan\tAVL\ttree\tis\ta\tbinary\tsearch\ttree\twith\ta\tbalance\tcondition:\tthe\tdifference\tbetween\tleft subtree\theight\tand\tright\tsubtree\theight\tis\tat\tmost\t1. Properties\tof\tAVL\tTrees A\tbinary\ttree\tis\tsaid\tto\tbe\tan\tAVL\ttree,\tif: \u2022 It\tis\ta\tbinary\tsearch\ttree,\tand \u2022 For\tany\tnode\tX,\tthe\theight\tof\tleft\tsubtree\tof\tX\tand\theight\tof\tright\tsubtree\tof\tX\tdiffer by\tat\tmost\t1. As\tan\texample,\tamong\tthe\tabove\tbinary\tsearch\ttrees,\tthe\tleft\tone\tis\tnot\tan\tAVL\ttree,\twhereas\tthe right\tbinary\tsearch\ttree\tis\tan\tAVL\ttree. Minimum/Maximum\tNumber\tof\tNodes\tin\tAVL\tTree For\tsimplicity\tlet\tus\tassume\tthat\tthe\theight\tof\tan\tAVL\ttree\tis\th\tand\tN(K)\tindicates\tthe\tnumber\tof nodes\tin\tAVL\ttree\twith\theight\th.\tTo\tget\tthe\tminimum\tnumber\tof\tnodes\twith\theight\th,\twe\tshould fill\tthe\ttree\twith\tthe\tminimum\tnumber\tof\tnodes\tpossible.\tThat\tmeans\tif\twe\tfill\tthe\tleft\tsubtree with\theight\th\t\u2013\t1\tthen\twe\tshould\tfill\tthe\tright\tsubtree\twith\theight\th\t\u2013\t2.\tAs\ta\tresult,\tthe\tminimum number\tof\tnodes\twith\theight\th\tis: N(h)\t=\tN(h\t\u2013\t1)\t+\tN(h\t\u2013\t2)\t+\t1 In\tthe\tabove\tequation: \u2022 N(h\t\u2013\t1)\tindicates\tthe\tminimum\tnumber\tof\tnodes\twith\theight\th\t\u2013\t1. \u2022 N(h\t\u2013\t2)\tindicates\tthe\tminimum\tnumber\tof\tnodes\twith\theight\th\t\u2013\t2. \u2022 In\tthe\tabove\texpression,\t\u201c1\u201d\tindicates\tthe\tcurrent\tnode. We\tcan\tgive\tN(h\t\u2013\t1)\teither\tfor\tleft\tsubtree\tor\tright\tsubtree.\tSolving\tthe\tabove\trecurrence\tgives: N(h)\t=\tO(1.618h)\t\u21d2\th\t=\t1.44logn\t\u2248\tO(logn) Where\tn\tis\tthe\tnumber\tof\tnodes\tin\tAVL\ttree.\tAlso,\tthe\tabove\tderivation\tsays\tthat\tthe\tmaximum height\tin\tAVL\ttrees\tis\tO(logn).\tSimilarly,\tto\tget\tmaximum\tnumber\tof\tnodes,\twe\tneed\tto\tfill\tboth left\tand\tright\tsubtrees\twith\theight\th\t\u2013\t1.\tAs\ta\tresult,\twe\tget: N(h)\t=\tN(h\t\u2013\t1)\t+\tN(h\t\u2013\t1)\t+\t1\t=\t2N(h\t\u2013\t1)\t+\t1 The\tabove\texpression\tdefines\tthe\tcase\tof\tfull\tbinary\ttree.\tSolving\tthe\trecurrence\twe\tget: N(h)\t=\tO(2h)\t\u21d2\th\t=\tlogn\t\u2248\tO(logn) \u2234\tIn\tboth\tthe\tcases,\tAVL\ttree\tproperty\tis\tensuring\tthat\tthe\theight\tof\tan\tAVL\ttree\twith\tn\tnodes\tis O(logn). AVL\tTree\tDeclaration Since\tAVL\ttree\tis\ta\tBST,\tthe\tdeclaration\tof\tAVL\tis\tsimilar\tto\tthat\tof\tBST.\tBut\tjust\tto\tsimplify\tthe operations,\twe\talso\tinclude\tthe\theight\tas\tpart\tof\tthe\tdeclaration. Finding\tthe\tHeight\tof\tan\tAVL\ttree Time\tComplexity:\tO(1). Rotations When\tthe\ttree\tstructure\tchanges\t(e.g.,\twith\tinsertion\tor\tdeletion),\twe\tneed\tto\tmodify\tthe\ttree\tto restore\tthe\tAVL\ttree\tproperty.\tThis\tcan\tbe\tdone\tusing\tsingle\trotations\tor\tdouble\trotations.\tSince an\tinsertion/deletion\tinvolves\tadding/deleting\ta\tsingle\tnode,\tthis\tcan\tonly\tincrease/decrease\tthe height\tof\ta\tsubtree\tby\t1. So,\t if\t the\t AVL\t tree\t property\t is\t violated\t at\t a\t node\t X,\t it\t means\t that\t the\t heights\t of\t left(X)\t and right(X)\tdiffer\tby\texactly\t2.\tThis\tis\tbecause,\tif\twe\tbalance\tthe\tAVL\ttree\tevery\ttime,\tthen\tat\tany point,\t the\t difference\t in\t heights\t of\t left(X)\t and\t right(X)\t differ\t by\t exactly\t 2.\t Rotations\t is\t the technique\tused\tfor\trestoring\tthe\tAVL\ttree\tproperty.\tThis\tmeans,\twe\tneed\tto\tapply\tthe\trotations\tfor the\tnode\tX. Observation:\tOne\timportant\tobservation\tis\tthat,\tafter\tan\tinsertion,\tonly\tnodes\tthat\tare\ton\tthe\tpath from\tthe\tinsertion\tpoint\tto\tthe\troot\tmight\thave\ttheir\tbalances\taltered,\tbecause\tonly\tthose\tnodes have\ttheir\tsubtrees\taltered.\tTo\trestore\tthe\tAVL\ttree\tproperty,\twe\tstart\tat\tthe\tinsertion\tpoint\tand keep\tgoing\tto\tthe\troot\tof\tthe\ttree. While\t moving\t to\t the\t root,\t we\t need\t to\t consider\t the\t first\t node\t that\t is\t not\t satisfying\t the\t AVL property.\tFrom\tthat\tnode\tonwards,\tevery\tnode\ton\tthe\tpath\tto\tthe\troot\twill\thave\tthe\tissue. Also,\t if\t we\t fix\t the\t issue\t for\t that\t first\t node,\t then\t all\t other\t nodes\t on\t the\t path\t to\t the\t root\t will automatically\tsatisfy\tthe\tAVL\ttree\tproperty.\tThat\tmeans\twe\talways\tneed\tto\tcare\tfor\tthe\tfirst\tnode that\tis\tnot\tsatisfying\tthe\tAVL\tproperty\ton\tthe\tpath\tfrom\tthe\tinsertion\tpoint\tto\tthe\troot\tand\tfix\tit. Types\tof\tViolations Let\tus\tassume\tthe\tnode\tthat\tmust\tbe\trebalanced\tis\tX.\tSince\tany\tnode\thas\tat\tmost\ttwo\tchildren,\tand a\theight\timbalance\trequires\tthat\tX\u2019s\t two\t subtree\t heights\t differ\t by\t two,\t we\t can\t observe\t that\t a violation\tmight\toccur\tin\tfour\tcases:"
            }
        ]
    },
    {
        "chapter_title": "1.",
        "subchapters": [
            {
                "subchapter_title": "An\tinsertion\tinto\tthe\tleft\tsubtree\tof\tthe\tleft\tchild\tof\tX.",
                "content": ""
            }
        ]
    },
    {
        "chapter_title": "2.",
        "subchapters": [
            {
                "subchapter_title": "An\tinsertion\tinto\tthe\tright\tsubtree\tof\tthe\tleft\tchild\tof\tX.",
                "content": ""
            }
        ]
    },
    {
        "chapter_title": "3.",
        "subchapters": [
            {
                "subchapter_title": "An\tinsertion\tinto\tthe\tleft\tsubtree\tof\tthe\tright\tchild\tof\tX.",
                "content": ""
            }
        ]
    },
    {
        "chapter_title": "4.",
        "subchapters": [
            {
                "subchapter_title": "An\tinsertion\tinto\tthe\tright\tsubtree\tof\tthe\tright\tchild\tof\tX.",
                "content": "Cases\t1\tand\t4\tare\tsymmetric\tand\teasily\tsolved\twith\tsingle\trotations.\tSimilarly,\tcases\t2\tand\t3\tare also\tsymmetric\tand\tcan\tbe\tsolved\twith\tdouble\trotations\t(needs\ttwo\tsingle\trotations). Single\tRotations Left\tLeft\tRotation\t(LL\tRotation)\t[Case-1]:\tIn\tthe\tcase\tbelow,\tnode\tX\tis\tnot\tsatisfying\tthe\tAVL tree\tproperty.\tAs\tdiscussed\tearlier,\tthe\trotation\tdoes\tnot\thave\tto\tbe\tdone\tat\tthe\troot\tof\ta\ttree.\tIn general,\twe\tstart\tat\tthe\tnode\tinserted\tand\ttravel\tup\tthe\ttree,\tupdating\tthe\tbalance\tinformation\tat every\tnode\ton\tthe\tpath. For\texample,\tin\tthe\tfigure\tabove,\tafter\tthe\tinsertion\tof\t7\tin\tthe\toriginal\tAVL\ttree\ton\tthe\tleft,\tnode 9\tbecomes\tunbalanced.\tSo,\twe\tdo\ta\tsingle\tleft-left\trotation\tat\t9.\tAs\ta\tresult\twe\tget\tthe\ttree\ton\tthe right. Time\tComplexity:\tO(1).\tSpace\tComplexity:\tO(1). Right\tRight\tRotation\t(RR\tRotation)\t[Case-4]:\tIn\tthis\tcase,\tnode\tX\tis\tnot\tsatisfying\tthe\tAVL tree\tproperty. For\texample,\tin\tthe\tfigure,\tafter\tthe\tinsertion\tof\t29\tin\tthe\toriginal\tAVL\ttree\ton\tthe\tleft,\tnode\t15 becomes\tunbalanced.\tSo,\twe\tdo\ta\tsingle\tright-right\trotation\tat\t15.\tAs\ta\tresult\twe\tget\tthe\ttree\ton the\tright. Time\tComplexity:\tO(1).\tSpace\tComplexity:\tO(1). Double\tRotations Left\tRight\tRotation\t(LR\tRotation)\t[Case-2]:\tFor\tcase-2\tand\tcase-3\tsingle\trotation\tdoes\tnot\tfix the\tproblem.\tWe\tneed\tto\tperform\ttwo\trotations. As\t an\t example,\t let\t us\t consider\t the\t following\t tree:\t The\t insertion\t of\t 7\t is\t creating\t the\t case-2 scenario\tand\tthe\tright\tside\ttree\tis\tthe\tone\tafter\tthe\tdouble\trotation. Code\tfor\tleft-right\tdouble\trotation\tcan\tbe\tgiven\tas: Right\t Left\t Rotation\t (RL\t Rotation)\t [Case-3]:\t Similar\t to\t case-2,\t we\t need\t to\t perform\t two rotations\tto\tfix\tthis\tscenario. As\t an\t example,\t let\t us\t consider\t the\t following\t tree:\t The\t insertion\t of\t 6\t is\t creating\t the\t case-3 scenario\tand\tthe\tright\tside\ttree\tis\tthe\tone\tafter\tthe\tdouble\trotation. Insertion\tinto\tan\tAVL\ttree Insertion\tinto\tan\tAVL\ttree\tis\tsimilar\tto\ta\tBST\tinsertion.\tAfter\tinserting\tthe\telement,\twe\tjust\tneed to\t check\t whether\t there\t is\t any\t height\t imbalance.\t If\t there\t is\t an\t imbalance,\t call\t the\t appropriate rotation\tfunctions. Time\tComplexity:\tO(logn).\tSpace\tComplexity:\tO(logn). AVL\tTrees:\tProblems\t&\tSolutions Problem-73\u2003\u2003Given\ta\theight\th,\tgive\tan\talgorithm\tfor\tgenerating\tthe\tHB(0). Solution:\tAs\twe\thave\tdiscussed,\tHB(0)\tis\tnothing\tbut\tgenerating\tfull\tbinary\ttree.\tIn\tfull\tbinary tree\tthe\tnumber\tof\tnodes\twith\theight\th\tis:\t2h+1\t\u2013\t1\t(let\tus\tassume\tthat\tthe\theight\tof\ta\ttree\twith\tone node\tis\t0).\tAs\ta\tresult\tthe\tnodes\tcan\tbe\tnumbered\tas:\t1\tto\t2h+1\t\u2013\t1. Time\tComplexity:\tO(n). Space\t Complexity:\t O(logn),\t where\t logn\t indicates\t the\t maximum\t stack\t size\t which\t is\t equal\t to height\tof\ttree. Problem-74\u2003\u2003Is\tthere\tany\talternative\tway\tof\tsolving\tProblem-73? Solution:\tYes,\twe\tcan\tsolve\tit\tfollowing\tMergesort\tlogic.\tThat\tmeans,\tinstead\tof\tworking\twith height,\t we\t can\t take\t the\t range.\t With\t this\t approach\t we\t do\t not\t need\t any\t global\t counter\t to\t be maintained. The\tinitial\tcall\tto\tthe\tBuildHBO\tfunction\tcould\tbe:\tBuildHB0(1,\t1\t\u226a\th).\t1\t\u226a\th\tdoes\tthe\tshift operation\tfor\tcalculating\tthe\t2h+1\t\u2013\t1. Time\tComplexity:\tO(n).\tSpace\tComplexity:\tO(login).\tWhere\tlogn\tindicates\tmaximum\tstack\tsize which\tis\tequal\tto\tthe\theight\tof\tthe\ttree. Problem-75\u2003\u2003Construct\tminimal\tAVL\ttrees\tof\theight\t0,1,2,3,4,\tand\t5.\tWhat\tis\tthe\tnumber\tof nodes\tin\ta\tminimal\tAVL\ttree\tof\theight\t6? Solution\tLet\tN(h)\tbe\tthe\tnumber\tof\tnodes\tin\ta\tminimal\tAVL\ttree\twith\theight\th. Problem-76\u2003\u2003For\tProblem-73,\thow\tmany\tdifferent\tshapes\tcan\tthere\tbe\tof\ta\tminimal\tAVL\ttree of\theight\th? Solution:\tLet\tNS(h)\tbe\tthe\tnumber\tof\tdifferent\tshapes\tof\ta\tminimal\tAVL\ttree\tof\theight\th. Problem-77\u2003\u2003Given\ta\tbinary\tsearch\ttree,\tcheck\twhether\tit\tis\tan\tAVL\ttree\tor\tnot? Solution:\tLet\tus\tassume\tthat\tIsAVL\tis\tthe\tfunction\twhich\tchecks\twhether\tthe\tgiven\tbinary\tsearch tree\tis\tan\tAVL\ttree\tor\tnot.\tIsAVL\treturns\t\u20131\tif\tthe\ttree\tis\tnot\tan\tAVL\ttree.\tDuring\tthe\tchecks\teach node\tsends\tits\theight\tto\tits\tparent. Time\tComplexity:\tO(n).\tSpace\tComplexity:\tO(n). Problem-78\u2003\u2003Given\t a\t height\t h,\t give\t an\t algorithm\t to\t generate\t an\t AVL\t tree\t with\t minimum number\tof\tnodes. Solution:\tTo\tget\tminimum\tnumber\tof\tnodes,\tfill\tone\tlevel\twith\th\t\u2013\t1\tand\tthe\tother\twith\th\t\u2013\t2. Problem-79\u2003\u2003Given\tan\tAVL\ttree\twith\tn\tinteger\titems\tand\ttwo\tintegers\ta\tand\tb,\twhere\ta\tand\tb can\tbe\tany\tintegers\twith\ta\t<=\tb.\tImplement\tan\talgorithm\tto\tcount\tthe\tnumber\tof\tnodes\tin the\trange\t[a,b]. Solution: The\tidea\tis\tto\tmake\tuse\tof\tthe\trecursive\tproperty\tof\tbinary\tsearch\ttrees.\tThere\tare\tthree\tcases\tto consider:\twhether\tthe\tcurrent\tnode\tis\tin\tthe\trange\t[a,\tb],\ton\tthe\tleft\tside\tof\tthe\trange\t[a,\tb],\tor\ton the\tright\tside\tof\tthe\trange\t[a,b].\tOnly\tsubtrees\tthat\tpossibly\tcontain\tthe\tnodes\twill\tbe\tprocessed under\teach\tof\tthe\tthree\tcases. The\tcomplexity\tis\tsimilar\tto\tin\t\u2013\torder\ttraversal\tof\tthe\ttree\tbut\tskipping\tleft\tor\tright\tsub-trees when\tthey\tdo\tnot\tcontain\tany\tanswers.\tSo\tin\tthe\tworst\tcase,\tif\tthe\trange\tcovers\tall\tthe\tnodes\tin the\ttree,\twe\tneed\tto\ttraverse\tall\tthe\tn\tnodes\tto\tget\tthe\tanswer.\tThe\tworst\ttime\tcomplexity\tis therefore\tO(n). If\tthe\trange\tis\tsmall,\twhich\tonly\tcovers\ta\tfew\telements\tin\ta\tsmall\tsubtree\tat\tthe\tbottom\tof\tthe\ttree, the\ttime\tcomplexity\twill\tbe\tO(h)\t=\tO(logn),\twhere\th\tis\tthe\theight\tof\tthe\ttree.\tThis\tis\tbecause\tonly a\tsingle\tpath\tis\ttraversed\tto\treach\tthe\tsmall\tsubtree\tat\tthe\tbottom\tand\tmany\thigher\tlevel\tsubtrees have\tbeen\tpruned\talong\tthe\tway. Note:\tRefer\tsimilar\tproblem\tin\tBST. Problem-80\u2003\u2003Given\ta\tBST\t(applicable\tto\tAVL\ttrees\tas\twell)\twhere\teach\tnode\tcontains\ttwo data\t elements\t (its\t data\t and\t also\t the\t number\t of\t nodes\t in\t its\t subtrees)\t as\t shown\t below. Convert\tthe\ttree\tto\tanother\tBST\tby\treplacing\tthe\tsecond\tdata\telement\t(number\tof\tnodes\tin its\tsubtrees)\twith\tprevious\tnode\tdata\tin\tinorder\ttraversal.\tNote\tthat\teach\tnode\tis\tmerged with\tinorder\tprevious\tnode\tdata.\tAlso\tmake\tsure\tthat\tconversion\thappens\tin-place. Solution:\tThe\tsimplest\tway\tis\tto\tuse\tlevel\torder\ttraversal.\tIf\tthe\tnumber\tof\telements\tin\tthe\tleft subtree\tis\tgreater\tthan\tthe\tnumber\tof\telements\tin\tthe\tright\tsubtree,\tfind\tthe\tmaximum\telement\tin the\tleft\tsubtree\tand\treplace\tthe\tcurrent\tnode\tsecond\tdata\telement\twith\tit.\tSimilarly,\tif\tthe\tnumber of\telements\tin\tthe\tleft\tsubtree\tis\tless\tthan\tthe\tnumber\tof\telements\tin\tthe\tright\tsubtree,\tfind\tthe minimum\telement\tin\tthe\tright\tsubtree\tand\treplace\tthe\tcurrent\tnode\tsecond\tdata\telement\twith\tit. Time\tComplexity:\tO(nlogn)\ton\taverage\tsince\tBST\ttakes\tO(logn)\ton\taverage\tto\tfind\tthe\tmaximum or\tminimum\telement.\tSpace\tComplexity:\tO(n).\tSince,\tin\tthe\tworst\tcase,\tall\tthe\tnodes\ton\tthe\tentire last\tlevel\tcould\tbe\tin\tthe\tqueue\tsimultaneously. Problem-81\u2003\u2003Can\twe\treduce\ttime\tcomplexity\tfor\tthe\tprevious\tproblem? Solution:\tLet\tus\ttry\tusing\tan\tapproach\tthat\tis\tsimilar\tto\twhat\twe\tfollowed\tin\tProblem-60.\tThe idea\tbehind\tthis\tsolution\tis\tthat\tinorder\ttraversal\tof\tBST\tproduces\tsorted\tlists.\tWhile\ttraversing the\tBST\tin\tinorder,\tkeep\ttrack\tof\tthe\telements\tvisited\tand\tmerge\tthem. Time\tComplexity:\tO(n). Space\t Complexity:\t O(1).\t Note\t that,\t we\t are\t still\t having\t recursive\t stack\t space\t for\t inorder traversal. Problem-82\u2003\u2003Given\ta\tBST\tand\ta\tkey,\tfind\tthe\telement\tin\tthe\tBST\twhich\tis\tclosest\tto\tthe\tgiven key. Solution:\tAs\ta\tsimple\tsolution,\twe\tcan\tuse\tlevel-order\ttraversal\tand\tfor\tevery\telement\tcompute the\tdifference\tbetween\tthe\tgiven\tkey\tand\tthe\telement\u2019s\tvalue.\tIf\tthat\tdifference\tis\tless\tthan\tthe previous\tmaintained\tdifference,\tthen\tupdate\tthe\tdifference\twith\tthis\tnew\tminimum\tvalue.\tWith this\tapproach,\tat\tthe\tend\tof\tthe\ttraversal\twe\twill\tget\tthe\telement\twhich\tis\tclosest\tto\tthe\tgiven\tkey. Time\tComplexity:\tO(n).\tSpace\tComplexity:\tO(n). Problem-83\u2003\u2003For\tProblem-82,\tcan\twe\tsolve\tit\tusing\tthe\trecursive\tapproach? Solution:\tThe\tapproach\tis\tsimilar\tto\tProblem-18.\tFollowing\tis\ta\tsimple\talgorithm\tfor\tfinding\tthe closest\tValue\tin\tBST."
            }
        ]
    },
    {
        "chapter_title": "1.",
        "subchapters": [
            {
                "subchapter_title": "If\tthe\troot\tis\tNULL,\tthen\tthe\tclosest\tvalue\tis\tzero\t(or\tNULL).",
                "content": ""
            }
        ]
    },
    {
        "chapter_title": "2.",
        "subchapters": [
            {
                "subchapter_title": "If\tthe\troot\u2019s\tdata\tmatches\tthe\tgiven\tkey,\tthen\tthe\tclosest\tis\tthe\troot.",
                "content": ""
            }
        ]
    },
    {
        "chapter_title": "3.",
        "subchapters": [
            {
                "subchapter_title": "Else,\tconsider\tthe\troot\tas\tthe\tclosest\tand\tdo\tthe\tfollowing:",
                "content": "a. If\tthe\tkey\tis\tsmaller\tthan\tthe\troot\tdata,\tfind\tthe\tclosest\ton\tthe\tleft\tside tree\tof\tthe\troot\trecursively\tand\tcall\tit\ttemp. b. If\tthe\tkey\tis\tlarger\tthan\tthe\troot\tdata,\tfind\tthe\tclosest\ton\tthe\tright\tside tree\tof\tthe\troot\trecursively\tand\tcall\tit\ttemp."
            }
        ]
    },
    {
        "chapter_title": "4.",
        "subchapters": [
            {
                "subchapter_title": "Return\tthe\troot\tor\ttemp\tdepending\ton\twhichever\tis\tnearer\tto\tthe\tgiven\tkey.",
                "content": "Time\tComplexity:\tO(n)\tin\tworst\tcase,\tand\tin\taverage\tcase\tit\tis\tO(logn). Space\tComplexity:\tO(n)\tin\tworst\tcase,\tand\tin\taverage\tcase\tit\tis\tO(logn). Problem-84\u2003\u2003Median\tin\tan\tinfinite\tseries\tof\tintegers Solution:\tMedian\tis\tthe\tmiddle\tnumber\tin\ta\tsorted\tlist\tof\tnumbers\t(if\twe\thave\todd\tnumber\tof elements).\tIf\twe\thave\teven\tnumber\tof\telements,\tmedian\tis\tthe\taverage\tof\ttwo\tmiddle\tnumbers\tin\ta sorted\tlist\tof\tnumbers. For\tsolving\tthis\tproblem\twe\tcan\tuse\ta\tbinary\tsearch\ttree\twith\tadditional\tinformation\tat\teach node,\tand\tthe\tnumber\tof\tchildren\ton\tthe\tleft\tand\tright\tsubtrees.\tWe\talso\tkeep\tthe\tnumber\tof\ttotal nodes\tin\tthe\ttree.\tUsing\tthis\tadditional\tinformation\twe\tcan\tfind\tthe\tmedian\tin\tO(logn)\ttime,\ttaking the\tappropriate\tbranch\tin\tthe\ttree\tbased\ton\tthe\tnumber\tof\tchildren\ton\tthe\tleft\tand\tright\tof\tthe current\t node.\t But,\t the\t insertion\t complexity\t is\t O(n)\t because\t a\t standard\t binary\t search\t tree\t can degenerate\tinto\ta\tlinked\tlist\tif\twe\thappen\tto\treceive\tthe\tnumbers\tin\tsorted\torder. So,\tlet\u2019s\tuse\ta\tbalanced\tbinary\tsearch\ttree\tto\tavoid\tworst\tcase\tbehavior\tof\tstandard\tbinary\tsearch trees.\tFor\tthis\tproblem,\tthe\tbalance\tfactor\tis\tthe\tnumber\tof\tnodes\tin\tthe\tleft\tsubtree\tminus\tthe number\tof\tnodes\tin\tthe\tright\tsubtree.\tAnd\tonly\tthe\tnodes\twith\ta\tbalance\tfactor\tof+\t1\tor\t0\tare considered\tto\tbe\tbalanced. So,\tthe\tnumber\tof\tnodes\ton\tthe\tleft\tsubtree\tis\teither\tequal\tto\tor\t1\tmore\tthan\tthe\tnumber\tof\tnodes on\tthe\tright\tsubtree,\tbut\tnot\tless. If\twe\tensure\tthis\tbalance\tfactor\ton\tevery\tnode\tin\tthe\ttree,\tthen\tthe\troot\tof\tthe\ttree\tis\tthe\tmedian,\tif the\tnumber\tof\telements\tis\todd.\tIn\tthe\tnumber\tof\telements\tis\teven,\tthe\tmedian\tis\tthe\taverage\tof\tthe root\tand\tits\tinorder\tsuccessor,\twhich\tis\tthe\tleftmost\tdescendent\tof\tits\tright\tsubtree. So,\tthe\tcomplexity\tof\tinsertion\tmaintaining\ta\tbalanced\tcondition\tis\tO(logn)\tand\tfinding\ta\tmedian operation\tis\tO(1)\tassuming\twe\tcalculate\tthe\tinorder\tsuccessor\tof\tthe\troot\tat\tevery\tinsertion\tif\tthe number\tof\tnodes\tis\teven. Insertion\tand\tbalancing\tis\tvery\tsimilar\tto\tAVL\ttrees.\tInstead\tof\tupdating\tthe\theights,\twe\tupdate\tthe number\tof\tnodes\tinformation.\tBalanced\tbinary\tsearch\ttrees\tseem\tto\tbe\tthe\tmost\toptimal\tsolution, insertion\tis\tO(logn)\tand\tfind\tmedian\tis\tO(1). Note:\tFor\tan\tefficient\talgorithm\trefer\tto\tthe\tPriority\tQueues\tand\tHeaps\tchapter. Problem-85\u2003\u2003Given\ta\tbinary\ttree,\thow\tdo\tyou\tremove\tall\tthe\thalf\tnodes\t(which\thave\tonly\tone child)?\tNote\tthat\twe\tshould\tnot\ttouch\tleaves. Solution:\tBy\tusing\tpost-order\ttraversal\twe\tcan\tsolve\tthis\tproblem\tefficiently.\tWe\tfirst\tprocess the\t left\t children,\t then\t the\t right\t children,\t and\t finally\t the\t node\t itself.\t So\t we\t form\t the\t new\t tree bottom\tup,\tstarting\tfrom\tthe\tleaves\ttowards\tthe\troot.\tBy\tthe\ttime\twe\tprocess\tthe\tcurrent\tnode, both\tits\tleft\tand\tright\tsubtrees\thave\talready\tbeen\tprocessed. Time\tComplexity:\tO(n). Problem-86\u2003\u2003Given\ta\tbinary\ttree,\thow\tdo\tyou\tremove\tits\tleaves? Solution:\tBy\tusing\tpost-order\ttraversal\twe\tcan\tsolve\tthis\tproblem\t(other\ttraversals\twould\talso work). Time\tComplexity:\tO(n). Problem-87\u2003\u2003Given\ta\tBST\tand\ttwo\tintegers\t(minimum\tand\tmaximum\tintegers)\tas\tparameters, how\tdo\tyou\tremove\t(prune)\telements\tthat\tare\tnot\twithin\tthat\trange? Solution:\t Observation:\t Since\t we\t need\t to\t check\t each\t and\t every\t element\t in\t the\t tree,\t and\t the subtree\tchanges\tshould\tbe\treflected\tin\tthe\tparent,\twe\tcan\tthink\tabout\tusing\tpost\torder\ttraversal. So\twe\tprocess\tthe\tnodes\tstarting\tfrom\tthe\tleaves\ttowards\tthe\troot.\tAs\ta\tresult,\twhile\tprocessing the\tnode\titself,\tboth\tits\tleft\tand\tright\tsubtrees\tare\tvalid\tpruned\tBSTs.\tAt\teach\tnode\twe\twill\treturn a\tpointer\tbased\ton\tits\tvalue,\twhich\twill\tthen\tbe\tassigned\tto\tits\tparent\u2019s\tleft\tor\tright\tchild\tpointer, depending\ton\twhether\tthe\tcurrent\tnode\tis\tthe\tleft\tor\tright\tchild\tof\tthe\tparent.\tIf\tthe\tcurrent\tnode\u2019s value\tis\tbetween\tA\tand\tB\t(A\t<=\tnode\u2019s\tdata\t<=\tB)\tthen\tno\taction\tneeds\tto\tbe\ttaken,\tso\twe\treturn the\treference\tto\tthe\tnode\titself. If\tthe\tcurrent\tnode\u2019s\tvalue\tis\tless\tthan\tA,\tthen\twe\treturn\tthe\treference\tto\tits\tright\tsubtree\tand discard\t the\t left\t subtree.\t Because\t if\t a\t node\u2019s\t value\t is\t less\t than\t A,\t then\t its\t left\t children\t are definitely\tless\tthan\tA\tsince\tthis\tis\ta\tbinary\tsearch\ttree.\tBut\tits\tright\tchildren\tmay\tor\tmay\tnot\tbe less\tthan\tA;\twe\tcan\u2019t\tbe\tsure,\tso\twe\treturn\tthe\treference\tto\tit.\tSince\twe\u2019re\tperforming\tbottom-up post-order\t traversal,\t its\t right\t subtree\t is\t already\t a\t trimmed\t valid\t binary\t search\t tree\t (possibly NULL),\tand\tits\tleft\tsubtree\tis\tdefinitely\tNULL\tbecause\tthose\tnodes\twere\tsurely\tless\tthan\tA\tand they\twere\teliminated\tduring\tthe\tpost-order\ttraversal. A\tsimilar\tsituation\toccurs\twhen\tthe\tnode\u2019s\tvalue\tis\tgreater\tthan\tB,\tso\twe\tnow\treturn\tthe\treference to\tits\tleft\tsubtree.\tBecause\tif\ta\tnode\u2019s\tvalue\tis\tgreater\tthan\tB,\tthen\tits\tright\tchildren\tare\tdefinitely greater\tthan\tB.\tBut\tits\tleft\tchildren\tmay\tor\tmay\tnot\tbe\tgreater\tthan\tB;\tSo\twe\tdiscard\tthe\tright subtree\tand\treturn\tthe\treference\tto\tthe\talready\tvalid\tleft\tsubtree. Time\tComplexity:\tO(n)\tin\tworst\tcase\tand\tin\taverage\tcase\tit\tis\tO(logn). Note:\tIf\tthe\tgiven\tBST\tis\tan\tAVL\ttree\tthen\tO(n)\tis\tthe\taverage\ttime\tcomplexity. Problem-88\u2003\u2003Given\t a\t binary\t tree,\t how\t do\t you\t connect\t all\t the\t adjacent\t nodes\t at\t the\t same level?\tAssume\tthat\tgiven\tbinary\ttree\thas\tnext\tpointer\talong\twith\tleft\tand\tright\tpointers\tas shown\tbelow. Solution:\t One\t simple\t approach\t is\t to\t use\t level-order\t traversal\t and\t keep\t updating\t the\t next pointers.\tWhile\ttraversing,\twe\twill\tlink\tthe\tnodes\ton\tthe\tnext\tlevel.\tIf\tthe\tnode\thas\tleft\tand\tright node,\twe\twill\tlink\tleft\tto\tright.\tIf\tnode\thas\tnext\tnode,\tthen\tlink\trightmost\tchild\tof\tcurrent\tnode\tto leftmost\tchild\tof\tnext\tnode. Time\tComplexity:\tO(n).\tSpace\tComplexity:\tO(n). Problem-89\u2003\u2003Can\twe\timprove\tspace\tcomplexity\tfor\tProblem-88? Solution:\tWe\tcan\tprocess\tthe\ttree\tlevel\tby\tlevel,\tbut\twithout\ta\tqueue.\tThe\tlogical\tpart\tis\tthat when\twe\tprocess\tthe\tnodes\tof\tthe\tnext\tlevel,\twe\tmake\tsure\tthat\tthe\tcurrent\tlevel\thas\talready\tbeen linked. Time\tComplexity:\tO(n).\tSpace\tComplexity:\tO(depth\tof\ttree)\tfor\tstack\tspace. Problem-90\u2003\u2003Assume\tthat\ta\tset\tS\tof\tn\tnumbers\tare\tstored\tin\tsome\tform\tof\tbalanced\tbinary search\t tree;\t i.e.\t the\t depth\t of\t the\t tree\t is\t O(logn).\t In\t addition\t to\t the\t key\t value\t and\t the pointers\tto\tchildren,\tassume\tthat\tevery\tnode\tcontains\tthe\tnumber\tof\tnodes\tin\tits\tsubtree. Specify\ta\treason(s)\twhy\ta\tbalanced\tbinary\ttree\tcan\tbe\ta\tbetter\toption\tthan\ta\tcomplete binary\ttree\tfor\tstoring\tthe\tset\tS. Solution:\tImplementation\tof\ta\tbalanced\tbinary\ttree\trequires\tless\tRAM\tspace\tas\twe\tdo\tnot\tneed to\tkeep\tthe\tcomplete\ttree\tin\tRAM\t(since\tthey\tuse\tpointers). Problem-91\u2003\u2003For\tthe\tProblem-90,\tspecify\ta\treason\t(s)\twhy\ta\tcomplete\tbinary\ttree\tcan\tbe\ta better\toption\tthan\ta\tbalanced\tbinary\ttree\tfor\tstoring\tthe\tset\tS. Solution:\tA\tcomplete\tbinary\ttree\tis\tmore\tspace\tefficient\tas\twe\tdo\tnot\tneed\tany\textra\tflags.\tA balanced\tbinary\ttree\tusually\ttakes\tmore\tspace\tsince\twe\tneed\tto\tstore\tsome\tflags.\tFor\texample,\tin a\tRed-Black\ttree\twe\tneed\tto\tstore\ta\tbit\tfor\tthe\tcolor.\tAlso,\ta\tcomplete\tbinary\ttree\tcan\tbe\tstored in\ta\tRAM\tas\tan\tarray\twithout\tusing\tpointers. Problem-92\u2003\u2003Given\ta\tbinary\ttree,\tfind\tthe\tmaximum\tpath\tsum.\tThe\tpath\tmay\tstart\tand\tend\tat any\tnode\tin\tthe\ttree. Solution: Problem-93\u2003\u2003Let\tT\tbe\ta\tproper\tbinary\ttree\twith\troot\tr.\tConsider\tthe\tfollowing\talgorithm. What\tdoes\tthe\talgorithm\tdo? A.\tIt\talways\treturns\tthe\tvalue\t1. B.\tIt\tcomputes\tthe\tnumber\tof\tnodes\tin\tthe\ttree. C.\tIt\tcomputes\tthe\tdepth\tof\tthe\tnodes. D.\tIt\tcomputes\tthe\theight\tof\tthe\ttree. E.\tIt\tcomputes\tthe\tnumber\tof\tleaves\tin\tthe\ttree. Solution:\tE."
            },
            {
                "subchapter_title": "6.14\tOther\tVariations\ton\tTrees",
                "content": "In\tthis\tsection,\tlet\tus\tenumerate\tthe\tother\tpossible\trepresentations\tof\ttrees.\tIn\tthe\tearlier\tsections, we\thave\tlooked\tat\tAVL\ttrees,\twhich\tis\ta\tbinary\tsearch\ttree\t(BST)\twith\tbalancing\tproperty.\tNow, let\tus\tlook\tat\ta\tfew\tmore\tbalanced\tbinary\tsearch\ttrees:\tRed-black\tTrees\tand\tSplay\tTrees. 6.14.1\tRed-Black\tTrees In\tRed-black\ttrees\teach\tnode\tis\tassociated\twith\tan\textra\tattribute:\tthe\tcolor,\twhich\tis\teither\tred or\tblack.\tTo\tget\tlogarithmic\tcomplexity\twe\timpose\tthe\tfollowing\trestrictions. Definition:\tA\tRed-black\ttree\tis\ta\tbinary\tsearch\ttree\tthat\tsatisfies\tthe\tfollowing\tproperties: \u2022 Root\tProperty:\tthe\troot\tis\tblack \u2022 External\tProperty:\tevery\tleaf\tis\tblack \u2022 Internal\tProperty:\tthe\tchildren\tof\ta\tred\tnode\tare\tblack \u2022 Depth\tProperty:\tall\tthe\tleaves\thave\tthe\tsame\tblack Similar\tto\tAVL\ttrees,\tif\tthe\tRed-black\ttree\tbecomes\timbalanced,\tthen\twe\tperform\trotations\tto reinforce\tthe\tbalancing\tproperty.\tWith\tRed-black\ttrees,\twe\tcan\tperform\tthe\tfollowing\toperations in\tO(logn)\tin\tworst\tcase,\twhere\tn\tis\tthe\tnumber\tof\tnodes\tin\tthe\ttrees. \u2022 Insertion,\tDeletion \u2022 Finding\tpredecessor,\tsuccessor \u2022 Finding\tminimum,\tmaximum 6.14.2\tSplay\tTrees Splay-trees\tare\tBSTs\twith\ta\tself-adjusting\tproperty.\tAnother\tinteresting\tproperty\tof\tsplay-trees is:\tstarting\twith\tan\tempty\ttree,\tany\tsequence\tof\tK\toperations\twith\tmaximum\t of\tn\t nodes\t takes O(Klogn)\ttime\tcomplexity\tin\tworst\tcase.\tSplay\ttrees\tare\teasier\tto\tprogram\tand\talso\tensure\tfaster access\tto\trecently\taccessed\titems.\tSimilar\tto\tAVL\tand\tRed-Black\ttrees,\tat\tany\tpoint\tthat\tthe\tsplay tree\tbecomes\timbalanced,\twe\tcan\tperform\trotations\tto\treinforce\tthe\tbalancing\tproperty. Splay-trees\t cannot\t guarantee\t the\t O(logn)\t complexity\t in\t worst\t case.\t But\t it\t gives\t amortized O(logn)\t complexity.\t Even\t though\t individual\t operations\t can\t be\t expensive,\t any\t sequence\t of operations\t gets\t the\t complexity\t of\t logarithmic\t behavior.\t One\t operation\t may\t take\t more\t time\t (a single\t operation\t may\t take\t O(n)\t time)\t but\t the\t subsequent\t operations\t may\t not\t take\t worst\t case complexity\tand\ton\tthe\taverage\tper\toperation\tcomplexity\tis\tO{logn). 6.14.3\tB-Trees B-Tree\tis\tlike\tother\tself-balancing\ttrees\tsuch\tas\tAVL\tand\tRed-black\ttree\tsuch\tthat\tit\tmaintains\tits balance\tof\tnodes\twhile\topertions\tare\tperformed\tagainst\tit.\tB-Tree\thas\tthe\tfollowing\tproperties: \u2022 Minimum\tdegree\t\u201c\u00a3\u201d\twhere,\texcept\troot\tnode,\tall\tother\tnodes\tmust\thave\tno\tless\tthan t\t\u2013\t1\tkeys \u2022 Each\tnode\twith\tn\tkeys\thas\tn\t+\t1\tchildren \u2022 Keys\tin\teach\tnode\tare\tlined\tup\twhere\tk1\t<\tk2\t<\t..\tkn \u2022 Each\tnode\tcannot\thave\tmore\tthan\t2t-l\tkeys,\tthus\t2t\tchildren \u2022 Root\tnode\tat\tleast\tmust\tcontain\tone\tkey.\tThere\tis\tno\troot\tnode\tif\tthe\ttree\tis\tempty. \u2022 Tree\tgrows\tin\tdepth\tonly\twhen\troot\tnode\tis\tsplit. Unlike\ta\tbinary-tree,\teach\tnode\tof\ta\tb-tree\tmay\thave\ta\tvariable\tnumber\tof\tkeys\tand\tchildren.\tThe keys\tare\tstored\tin\tnon-decreasing\torder.\tEach\tkey\thas\tan\tassociated\tchild\tthat\tis\tthe\troot\tof\ta subtree\tcontaining\tall\tnodes\twith\tkeys\tless\tthan\tor\tequal\tto\tthe\tkey\tbut\tgreater\tthan\tthe\tpreceeding key.\tA\tnode\talso\thas\tan\tadditional\trightmost\tchild\tthat\tis\tthe\troot\tfor\ta\tsubtree\tcontaining\tall\tkeys greater\tthan\tany\tkeys\tin\tthe\tnode. A\tb-tree\thas\ta\tminumum\tnumber\tof\tallowable\tchildren\tfor\teach\tnode\tknown\tas\tthe\tminimization factor.\tIf\tt\tis\tthis\tminimization\tfactor,\tevery\tnode\tmust\thave\tat\tleast\tt\t\u2013\t1\tkeys.\tUnder\tcertain circumstances,\tthe\troot\tnode\tis\tallowed\tto\tviolate\tthis\tproperty\tby\thaving\tfewer\tthan\tt\t\u2013\t1\tkeys. Every\tnode\tmay\thave\tat\tmost\t2t\t\u2013\t1\tkeys\tor,\tequivalently,\t2t\tchildren. Since\teach\tnode\ttends\tto\thave\ta\tlarge\tbranching\tfactor\t(a\tlarge\tnumber\tof\tchildren),\tit\tis\ttypically neccessary\tto\ttraverse\trelatively\tfew\tnodes\tbefore\tlocating\tthe\tdesired\tkey.\tIf\taccess\tto\teach\tnode requires\ta\tdisk\taccess,\tthen\ta\tB-tree\twill\tminimize\tthe\tnumber\tof\tdisk\taccesses\trequired.\tThe minimzation\tfactor\tis\tusually\tchosen\tso\tthat\tthe\ttotal\tsize\tof\teach\tnode\tcorresponds\tto\ta\tmultiple of\t the\t block\t size\t of\t the\t underlying\t storage\t device.\t This\t choice\t simplifies\t and\t optimizes\t disk access.\t Consequently,\t a\t B-tree\t is\t an\t ideal\t data\t structure\t for\t situations\t where\t all\t data\t cannot reside\tin\tprimary\tstorage\tand\taccesses\tto\tsecondary\tstorage\tare\tcomparatively\texpensive\t(or\ttime consuming). To\tsearch\tthe\ttree,\tit\tis\tsimilar\tto\tbinary\ttree\texcept\tthat\tthe\tkey\tis\tcompared\tmultiple\ttimes\tin\ta given\tnode\tbecause\tthe\tnode\tcontains\tmore\tthan\t1\tkey.\tIf\tthe\tkey\tis\tfound\tin\tthe\tnode,\tthe\tsearch terminates.\tOtherwise,\tit\tmoves\tdown\twhere\tat\tchild\tpointed\tby\tci\twhere\tkey\tk\t<\tki. Key\tinsertions\tof\ta\tB-tree\thappens\tfrom\tthe\tbottom\tfasion.\tThis\tmeans\tthat\tit\twalk\tdown\tthe\ttree from\troot\tto\tthe\ttarget\tchild\tnode\tfirst.\tIf\tthe\tchild\tis\tnot\tfull,\tthe\tkey\tis\tsimply\tinserted.\tIf\tit\tis full,\tthe\tchild\tnode\tis\tsplit\tin\tthe\tmiddle,\tthe\tmedian\tkey\tmoves\tup\tto\tthe\tparent,\tthen\tthe\tnew\tkey is\tinserted.\tWhen\tinserting\tand\twalking\tdown\tthe\ttree,\tif\tthe\troot\tnode\tis\tfound\tto\tbe\tfull,\tit\u2019s\tsplit first\tand\twe\thave\ta\tnew\troot\tnode.\tThen\tthe\tnormal\tinsertion\toperation\tis\tperformed. Key\tdeletion\tis\tmore\tcomplicated\tas\tit\tneeds\tto\tmaintain\tthe\tnumber\tof\tkeys\tin\teach\tnode\tto\tmeet the\tconstraint.\tIf\ta\tkey\tis\tfound\tin\tleaf\tnode\tand\tdeleting\tit\tstill\tkeeps\tthe\tnumber\tof\tkeys\tin\tthe nodes\tnot\ttoo\tlow,\tit\u2019s\tsimply\tdone\tright\taway.\tIf\tit\u2019s\tdone\tto\tthe\tinner\tnode,\tthe\tpredecessor\tof the\tkey\tin\tthe\tcorresonding\tchild\tnode\tis\tmoved\tto\treplace\tthe\tkey\tin\tthe\tinner\tnode.\tIf\tmoving\tthe predecessor\twill\tcause\tthe\tchild\tnode\tto\tviolate\tthe\tnode\tcount\tconstraint,\tthe\tsibling\tchild\tnodes are\tcombined\tand\tthe\tkey\tin\tthe\tinner\tnode\tis\tdeleted. 6.14.4\tAugmented\tTrees In\tearlier\tsections,\twe\thave\tseen\tvarious\tproblems\tlike\tfinding\tthe\tKth\t\u2013\tsmallest\t-\telement\tin\tthe tree\tand\tother\tsimilar\tones.\tOf\tall\tthe\tproblems\tthe\tworst\tcomplexity\tis\tO(n),\t where\t n\t is\t the number\tof\tnodes\tin\tthe\ttree.\tTo\tperform\tsuch\toperations\tin\tO(logn),\taugmented\ttrees\tare\tuseful.\tIn these\ttrees,\textra\tinformation\tis\tadded\tto\teach\tnode\tand\tthat\textra\tdata\tdepends\ton\tthe\tproblem we\tare\ttrying\tto\tsolve. For\texample,\tto\tfind\tthe\tKth\telement\tin\ta\tbinary\tsearch\ttree,\tlet\tus\tsee\thow\taugmented\ttrees\tsolve the\tproblem.\tLet\tus\tassume\tthat\twe\tare\tusing\tRed-Black\ttrees\tas\tbalanced\tBST\t(or\tany\tbalanced BST)\tand\taugmenting\tthe\tsize\tinformation\tin\tthe\tnodes\tdata.\tFor\ta\tgiven\tnode\tX\tin\tRed-Black\ttree with\ta\tfield\tsize(X)\tequal\tto\tthe\tnumber\tof\tnodes\tin\tthe\tsubtree\tand\tcan\tbe\tcalculated\tas: size(X)\t=\tsize(X\t\u2192\tleft)\t+\tsize(X\t\u2192\tright))\t+\t1 Kth\t-\tsmallest\t-\toperation\tcan\tbe\tdefined\tas: Time\tComplexity:\tO(logn).\tSpace\tComplexity:\tO(logn). Example:\tWith\tthe\textra\tsize\tinformation,\tthe\taugmented\ttree\twill\tlook\tlike: 6.14.5\tInterval\tTrees\t[Segment\tTrees] We\toften\tface\tquestions\tthat\tinvolve\tqueries\tmade\tin\tan\tarray\tbased\ton\trange.\tFor\texample,\tfor\ta given\tarray\tof\tintegers,\twhat\tis\tthe\tmaximum\tnumber\tin\tthe\trange\t\u03b1\tto\t\u03b2,\twhere\t\u03b1\tand\t\u03b2\tare\tof course\t within\t array\t limits.\t To\t iterate\t over\t those\t entries\t with\t intervals\t containing\t a\t particular value,\t we\t can\t use\t a\t simple\t array.\t But\t if\t we\t need\t more\t efficient\t access,\t we\t need\t a\t more sophisticated\tdata\tstructure. An\tarray-based\tstorage\tscheme\tand\ta\tbrute-force\tsearch\tthrough\tthe\tentire\tarray\tis\tacceptable only\tif\ta\tsingle\tsearch\tis\tto\tbe\tperformed,\tor\tif\tthe\tnumber\tof\telements\tis\tsmall.\tFor\texample,\tif you\tknow\tall\tthe\tarray\tvalues\tof\tinterest\tin\tadvance,\tyou\tneed\tto\tmake\tonly\tone\tpass\tthrough\tthe array.\tHowever,\tif\tyou\tcan\tinteractively\tspecify\tdifferent\tsearch\toperations\tat\tdifferent\ttimes,\tthe brute-force\t search\t becomes\t impractical\t because\t every\t element\t in\t the\t array\t must\t be\t examined during\teach\tsearch\toperation. If\t you\t sort\t the\t array\t in\t ascending\t order\t of\t the\t array\t values,\t you\t can\t terminate\t the\t sequential search\twhen\tyou\treach\tthe\tobject\twhose\tlow\tvalue\tis\tgreater\tthan\tthe\telement\twe\tare\tsearching. Unfortunately,\t this\t technique\t becomes\t increasingly\t ineffective\t as\t the\t low\t value\t increases, because\tfewer\tsearch\toperations\tare\teliminated.\tThat\tmeans,\twhat\tif\twe\thave\tto\tanswer\ta\tlarge number\tof\tqueries\tlike\tthis?\t\u2013\tis\tbrute\tforce\tstill\ta\tgood\toption? Another\texample\tis\twhen\twe\tneed\tto\treturn\ta\tsum\tin\ta\tgiven\trange.\tWe\tcan\tbrute\tforce\tthis\ttoo, but\tthe\tproblem\tfor\ta\tlarge\tnumber\tof\tqueries\tstill\tremains.\tSo,\twhat\tcan\twe\tdo?\tWith\ta\tbit\tof thinking\twe\tcan\tcome\tup\twith\tan\tapproach\tlike\tmaintaining\ta\tseparate\tarray\tof\tn\telements,\twhere n\tis\tthe\tsize\tof\tthe\toriginal\tarray,\twhere\teach\tindex\tstores\tthe\tsum\tof\tall\telements\tfrom\t0\tto\tthat index.\tSo\tessentially\twe\thave\twith\ta\tbit\tof\tpreprocessing\tbrought\tdown\tthe\tquery\ttime\tfrom\ta worst\tcase\tO(n)\tto\tO(1).\tNow\tthis\tis\tgreat\tas\tfar\tas\tstatic\tarrays\tare\tconcerned,\tbut,\twhat\tif\twe are\trequired\tto\tperform\tupdates\ton\tthe\tarray\ttoo? The\tfirst\tapproach\tgives\tus\tan\tO(n)\tquery\ttime,\tbut\tan\tO(1)\tupdate\ttime.\tThe\tsecond\tapproach,\ton the\tother\thand,\tgives\tus\tO(1)\tquery\ttime,\tbut\tan\tO(n)\tupdate\ttime.\tSo,\twhich\tone\tdo\twe\tchoose? Interval\ttrees\tare\talso\tbinary\tsearch\ttrees\tand\tthey\tstore\tinterval\tinformation\tin\tthe\tnode\tstructure. That\tmeans,\twe\tmaintain\ta\tset\tof\tn\tintervals\t[i1,\ti2]\tsuch\tthat\tone\tof\tthe\tintervals\tcontaining\ta query\t point\t Q\t (if\t any)\t can\t be\t found\t efficiently.\t Interval\t trees\t are\t used\t for\t performing\t range queries\tefficiently. A\tsegment\ttree\tis\ta\theap-like\tdata\tstructure\tthat\tcan\tbe\tused\tfor\tmaking\tupdate/query\toperations upon\tarray\tintervals\tin\tlogarithmical\ttime.\tWe\tdefine\tthe\tsegment\ttree\tfor\tthe\tinterval\t[i,j]\tin\tthe following\trecursive\tmanner: \u2022 The\troot\t(first\tnode\tin\tthe\tarray)\tnode\twill\thold\tthe\tinformation\tfor\tthe\tinterval\t[i,j] \u2022 If\ti\t<\ty\tthe\tleft\tand\tright\tchildren\twill\thold\tthe\tinformation\tfor\tthe\tintervals\t and\t Segment\ttrees\t(also\tcalled\tsegtrees\tand\tinterval\ttrees)\tis\ta\tcool\tdata\tstructure,\tprimarily\tused\tfor range\tqueries.\tIt\tis\ta\theight\tbalanced\tbinary\ttree\twith\ta\tstatic\tstructure.\tThe\tnodes\tof\ta\tsegment tree\t correspond\t to\t various\t intervals,\t and\t can\t be\t augmented\t with\t appropriate\t information pertaining\tto\tthose\tintervals.\tIt\tis\tsomewhat\tless\tpowerful\tthan\ta\tbalanced\tbinary\ttree\tbecause\tof its\tstatic\tstructure,\tbut\tdue\tto\tthe\trecursive\tnature\tof\toperations\ton\tthe\tsegtree,\tit\tis\tincredibly easy\tto\tthink\tabout\tand\tcode. We\tcan\tuse\tsegment\ttrees\tto\tsolve\trange\tminimum/maximum\tquery\tproblems.\tThe\ttime\tcomplexity is\tT(nlogn)\twhere\tO(n)\tis\tthe\ttime\trequired\tto\tbuild\tthe\ttree\tand\teach\tquery\ttakes\tO(logn)\ttime. Example:\tGiven\ta\tset\tof\tintervals:\tS=\t{[2-5],\t[6-7],\t[6-10],\t[8-9],\t[12-15],\t[15-23],\t[25-30]}.\tA query\twith\tQ\t=\t9\treturns\t[6,10]\tor\t[8,9]\t(assume\tthese\tare\tthe\tintervals\twhich\tcontain\t9\tamong all\tthe\tintervals).\tA\tquery\twith\tQ\t=\t23\treturns\t[15,\t23]. Construction\tof\tInterval\tTrees:\tLet\tus\tassume\tthat\twe\tare\tgiven\ta\tset\tS\tof\tn\tintervals\t(called segments).\t These\t n\t intervals\t will\t have\t 2n\t endpoints.\t Now,\t let\t us\t see\t how\t to\t construct\t the interval\ttree. Algorithm: Recursively\tbuild\ttree\ton\tinterval\tset\t5\tas\tfollows: \u2022 Sort\tthe\t2n\tendpoints \u2022 Let\tXmid\tbe\tthe\tmedian\tpoint Time\t Complexity\t for\t building\t interval\t trees:\t O(nlogn).\t Since\t we\t are\t choosing\t the\t median, Interval\tTrees\twill\tbe\tapproximately\tbalanced.\tThis\tensures\tthat,\twe\tsplit\tthe\tset\tof\tend\tpoints\tup in\thalf\teach\ttime.\tThe\tdepth\tof\tthe\ttree\tis\tO(logn).\tTo\tsimplify\tthe\tsearch\tprocess,\tgenerally\tXmid is\tstored\twith\teach\tnode. 6.14.6\tScapegoat\tTrees Scapegoat\ttree\tis\ta\tself-balancing\tbinary\tsearch\ttree,\tdiscovered\tby\tArne\tAndersson.\tIt\tprovides worst-case\tO(logn)\tsearch\ttime,\tand\tO(logn)\tamortized\t(average)\tinsertion\tand\tdeletion\ttime. AVL\t trees\t rebalance\t whenever\t the\t height\t of\t two\t sibling\t subtrees\t differ\t by\t more\t than\t one; scapegoat\ttrees\trebalance\twhenever\tthe\tsize\tof\ta\tchild\texceeds\ta\tcertain\tratio\tof\tits\tparents,\ta ratio\t known\t as\t a.\t After\t inserting\t the\t element,\t we\t traverse\t back\t up\t the\t tree.\t If\t we\t find\t an imbalance\twhere\ta\tchild\u2019s\tsize\texceeds\tthe\tparent\u2019s\tsize\ttimes\talpha,\twe\tmust\trebuild\tthe\tsubtree at\tthe\tparent,\tthe\tscapegoat. There\tmight\tbe\tmore\tthan\tone\tpossible\tscapegoat,\tbut\twe\tonly\thave\tto\tpick\tone.\tThe\tmost\toptimal scapegoat\tis\tactually\tdetermined\tby\theight\tbalance.\tWhen\tremoving\tit,\twe\tsee\tif\tthe\ttotal\tsize\tof the\ttree\tis\tless\tthan\talpha\tof\tthe\tlargest\tsize\tsince\tthe\tlast\trebuilding\tof\tthe\ttree.\tIf\tso,\twe\trebuild the\tentire\ttree.\tThe\talpha\tfor\ta\tscapegoat\ttree\tcan\tbe\tany\tnumber\tbetween\t0.5\tand\t1.0.\tThe\tvalue"
            },
            {
                "subchapter_title": "0.5\t will\t force\t perfect\t balance,\t while\t 1.0\t will\t cause\t rebalancing\t to\t never\t occur,\t effectively",
                "content": "turning\tit\tinto\ta\tBST."
            },
            {
                "subchapter_title": "7.1\tWhat\tis\ta\tPriority\tQueue?",
                "content": "In\tsome\tsituations\twe\tmay\tneed\tto\tfind\tthe\tminimum/maximum\telement\tamong\ta\tcollection\tof elements.\tWe\tcan\tdo\tthis\twith\tthe\thelp\tof\tPriority\tQueue\tADT.\tA\tpriority\tqueue\tADT\tis\ta\tdata structure\t that\t supports\t the\t operations\t Insert\t and\t DeleteMin\t (which\t returns\t and\t removes\t the minimum\telement)\tor\tDeleteMax\t(which\treturns\tand\tremoves\tthe\tmaximum\telement). These\toperations\tare\tequivalent\tto\tEnQueue\tand\tDeQueue\toperations\tof\ta\tqueue.\tThe\tdifference is\tthat,\tin\tpriority\tqueues,\tthe\torder\tin\twhich\tthe\telements\tenter\tthe\tqueue\tmay\tnot\tbe\tthe\tsame\tin which\tthey\twere\tprocessed.\tAn\texample\tapplication\tof\ta\tpriority\tqueue\tis\tjob\tscheduling,\twhich is\tprioritized\tinstead\tof\tserving\tin\tfirst\tcome\tfirst\tserve. A\tpriority\tqueue\tis\tcalled\tan\tascending\t\u2013\tpriority\tqueue,\tif\tthe\titem\twith\tthe\tsmallest\tkey\thas\tthe highest\tpriority\t(that\tmeans,\tdelete\tthe\tsmallest\telement\talways).\tSimilarly,\ta\tpriority\tqueue\tis said\tto\tbe\ta\tdescending\t\u2013priority\tqueue\tif\tthe\titem\twith\tthe\tlargest\tkey\thas\tthe\thighest\tpriority (delete\t the\t maximum\t element\t always).\t Since\t these\t two\t types\t are\t symmetric\t we\t will\t be concentrating\ton\tone\tof\tthem:\tascending-priority\tqueue."
            },
            {
                "subchapter_title": "7.2\tPriority\tQueue\tADT",
                "content": "The\tfollowing\toperations\tmake\tpriority\tqueues\tan\tADT. Main\tPriority\tQueues\tOperations A\tpriority\tqueue\tis\ta\tcontainer\tof\telements,\teach\thaving\tan\tassociated\tkey. \u2022 Insert\t(key,\tdata):\tInserts\tdata\twith\tkey\tto\tthe\tpriority\tqueue.\tElements\tare\tordered based\ton\tkey. \u2022 DeleteMin/DeleteMax:\tRemove\tand\treturn\tthe\telement\twith\tthe\tsmallest/largest\tkey. \u2022 GetMinimum/GetMaximum:\tReturn\tthe\telement\twith\tthe\tsmallest/largest\tkey\twithout deleting\tit. Auxiliary\tPriority\tQueues\tOperations \u2022 kth\t -\t Smallest/kth\t \u2013\t Largest:\t Returns\t the\t kth\t -Smallest/kth\t \u2013Largest\t key\t in\t priority queue. \u2022 Size:\tReturns\tnumber\tof\telements\tin\tpriority\tqueue. \u2022 Heap\tSort:\tSorts\tthe\telements\tin\tthe\tpriority\tqueue\tbased\ton\tpriority\t(key)."
            },
            {
                "subchapter_title": "7.3\tPriority\tQueue\tApplications",
                "content": "Priority\tqueues\thave\tmany\tapplications\t-\ta\tfew\tof\tthem\tare\tlisted\tbelow: \u2022 Data\tcompression:\tHuffman\tCoding\talgorithm \u2022 Shortest\tpath\talgorithms:\tDijkstra\u2019s\talgorithm \u2022 Minimum\tspanning\ttree\talgorithms:\tPrim\u2019s\talgorithm \u2022 Event-driven\tsimulation:\tcustomers\tin\ta\tline \u2022 Selection\tproblem:\tFinding\tkth-\tsmallest\telement"
            },
            {
                "subchapter_title": "7.4\tPriority\tQueue\tImplementations",
                "content": "Before\tdiscussing\tthe\tactual\timplementation,\tlet\tus\tenumerate\tthe\tpossible\toptions. Unordered\tArray\tImplementation Elements\tare\tinserted\tinto\tthe\tarray\twithout\tbothering\tabout\tthe\torder.\tDeletions\t(DeleteMax)\tare performed\tby\tsearching\tthe\tkey\tand\tthen\tdeleting. Insertions\tcomplexity:\tO(1).\tDeleteMin\tcomplexity:\tO(n). Unordered\tList\tImplementation It\tis\tvery\tsimilar\tto\tarray\timplementation,\tbut\tinstead\tof\tusing\tarrays,\tlinked\tlists\tare\tused. Insertions\tcomplexity:\tO(1).\tDeleteMin\tcomplexity:\tO(n). Ordered\tArray\tImplementation Elements\tare\tinserted\tinto\tthe\tarray\tin\tsorted\torder\tbased\ton\tkey\tfield.\tDeletions\tare\tperformed\tat only\tone\tend. Insertions\tcomplexity:\tO(n).\tDeleteMin\tcomplexity:\tO(1). Ordered\tList\tImplementation Elements\tare\tinserted\tinto\tthe\tlist\tin\tsorted\torder\tbased\ton\tkey\tfield.\tDeletions\tare\tperformed\tat only\tone\tend,\thence\tpreserving\tthe\tstatus\tof\tthe\tpriority\tqueue.\tAll\tother\tfunctionalities\tassociated with\ta\tlinked\tlist\tADT\tare\tperformed\twithout\tmodification. Insertions\tcomplexity:\tO(n).\tDeleteMin\tcomplexity:\tO(1). Binary\tSearch\tTrees\tImplementation Both\tinsertions\tand\tdeletions\ttake\tO(logn)\ton\taverage\tif\tinsertions\tare\trandom\t(refer\tto\tTrees chapter). Balanced\tBinary\tSearch\tTrees\tImplementation Both\tinsertions\tand\tdeletion\ttake\tO(logn)\tin\tthe\tworst\tcase\t(refer\tto\tTrees\tchapter). Binary\tHeap\tImplementation In\t subsequent\t sections\t we\t will\t discuss\t this\t in\t full\t detail.\t For\t now,\t assume\t that\t binary\t heap implementation\t gives\t O(logn)\t complexity\t for\t search,\t insertions\t and\t deletions\t and\t O(1)\t for finding\tthe\tmaximum\tor\tminimum\telement. Comparing\tImplementations"
            },
            {
                "subchapter_title": "7.5\tHeaps\tand\tBinary\tHeaps",
                "content": "What\tis\ta\tHeap? A\theap\tis\ta\ttree\twith\tsome\tspecial\tproperties.\tThe\tbasic\trequirement\tof\ta\theap\tis\tthat\tthe\tvalue\tof a\tnode\tmust\tbe\t\u2265\t(or\t\u2264)\tthan\tthe\tvalues\tof\tits\tchildren.\tThis\tis\tcalled\theap\tproperty.\tA\theap\talso has\tthe\tadditional\tproperty\tthat\tall\tleaves\tshould\tbe\tat\th\tor\th\t\u2013\t1\tlevels\t(where\th\tis\tthe\theight\tof the\ttree)\tfor\tsome\th\t>\t0\t(complete\tbinary\ttrees).\tThat\tmeans\theap\tshould\tform\ta\tcomplete\tbinary tree\t(as\tshown\tbelow). In\tthe\texamples\tbelow,\tthe\tleft\ttree\tis\ta\theap\t(each\telement\tis\tgreater\tthan\tits\tchildren)\tand\tthe right\ttree\tis\tnot\ta\theap\t(since\t11\tis\tgreater\tthan\t2). Types\tof\tHeaps? Based\ton\tthe\tproperty\tof\ta\theap\twe\tcan\tclassify\theaps\tinto\ttwo\ttypes: \u2022 Min\t heap:\t The\t value\t of\t a\t node\t must\t be\t less\t than\t or\t equal\t to\t the\t values\t of\t its children \u2022 Max\theap:\tThe\tvalue\tof\ta\tnode\tmust\tbe\tgreater\tthan\tor\tequal\tto\tthe\tvalues\tof\tits children"
            },
            {
                "subchapter_title": "7.6\tBinary\tHeaps",
                "content": "In\tbinary\theap\teach\tnode\tmay\thave\tup\tto\ttwo\tchildren.\tIn\tpractice,\tbinary\theaps\tare\tenough\tand we\tconcentrate\ton\tbinary\tmin\theaps\tand\tbinary\tmax\theaps\tfor\tthe\tremaining\tdiscussion. Representing\t Heaps:\t Before\t looking\t at\t heap\t operations,\t let\t us\t see\t how\t heaps\t can\t be represented.\tOne\tpossibility\tis\tusing\tarrays.\tSince\theaps\tare\tforming\tcomplete\tbinary\ttrees,\tthere will\tnot\tbe\tany\twastage\tof\tlocations.\tFor\tthe\tdiscussion\tbelow\tlet\tus\tassume\tthat\telements\tare stored\tin\tarrays,\twhich\tstarts\tat\tindex\t0.\tThe\tprevious\tmax\theap\tcan\tbe\trepresented\tas: Note:\tFor\tthe\tremaining\tdiscussion\tlet\tus\tassume\tthat\twe\tare\tdoing\tmanipulations\tin\tmax\theap. Declaration\tof\tHeap Creating\tHeap Time\tComplexity:\tO(1). Parent\tof\ta\tNode For\ta\tnode\tat\tith\tlocation,\tits\tparent\tis\tat\t \tlocation.\tIn\tthe\tprevious\texample,\tthe\telement\t6\tis\tat second\tlocation\tand\tits\tparent\tis\tat\t0th\tlocation. Time\tComplexity:\tO(1). Children\tof\ta\tNode Similar\tto\tthe\tabove\tdiscussion,\tfor\ta\tnode\tat\tith\tlocation,\tits\tchildren\tare\tat\t2\t*\ti\t+\t1\tand\t2\t*\ti\t+ 2\tlocations.\tFor\texample,\tin\tthe\tabove\ttree\tthe\telement\t6\tis\tat\tsecond\tlocation\tand\tits\tchildren\t2 and\t5\tare\tat\t5\t(2\t*\ti\t+\t1\t=\t2\t*\t2\t+\t1)\tand\t6(2\t*\ti\t+\t2\t=\t2\t*\t2)\tlocations. Getting\tthe\tMaximum\tElement Since\tthe\tmaximum\telement\tin\tmax\theap\tis\talways\tat\troot,\tit\twill\tbe\tstored\tat\th\u2192array[O]. Time\tComplexity:\tO(1). Heapifying\tan\tElement After\tinserting\tan\telement\tinto\theap,\tit\tmay\tnot\tsatisfy\tthe\theap\tproperty.\tIn\tthat\tcase\twe\tneed\tto adjust\tthe\tlocations\tof\tthe\theap\tto\tmake\tit\theap\tagain.\tThis\tprocess\tis\tcalled\theapifying.\tIn\tmax- heap,\tto\theapify\tan\telement,\twe\thave\tto\tfind\tthe\tmaximum\tof\tits\tchildren\tand\tswap\tit\twith\tthe current\telement\tand\tcontinue\tthis\tprocess\tuntil\tthe\theap\tproperty\tis\tsatisfied\tat\tevery\tnode. Observation:\t One\t important\t property\t of\t heap\t is\t that,\t if\t an\t element\t is\t not\t satisfying\t the\t heap property,\tthen\tall\tthe\telements\tfrom\tthat\telement\tto\tthe\troot\twill\thave\tthe\tsame\tproblem.\tIn\tthe example\tbelow,\telement\t1\tis\tnot\tsatisfying\tthe\theap\tproperty\tand\tits\tparent\t31\tis\talso\thaving\tthe issue.\tSimilarly,\tif\twe\theapify\tan\telement,\tthen\tall\tthe\telements\tfrom\tthat\telement\tto\tthe\troot\twill also\tsatisfy\tthe\theap\tproperty\tautomatically.\tLet\tus\tgo\tthrough\tan\texample.\tIn\tthe\tabove\theap,\tthe element\t1\tis\tnot\tsatisfying\tthe\theap\tproperty.\tLet\tus\ttry\theapifying\tthis\telement. To\theapify\t1,\tfind\tthe\tmaximum\tof\tits\tchildren\tand\tswap\twith\tthat. We\tneed\tto\tcontinue\tthis\tprocess\tuntil\tthe\telement\tsatisfies\tthe\theap\tproperties.\tNow,\tswap\t1\twith"
            }
        ]
    },
    {
        "chapter_title": "8.",
        "subchapters": [
            {
                "subchapter_title": "Now\t the\t tree\t is\t satisfying\t the\t heap\t property.\t In\t the\t above\t heapifying\t process,\t since\t we\t are",
                "content": "moving\tfrom\ttop\tto\tbottom,\tthis\tprocess\tis\tsometimes\tcalled\tpercolate\tdown.\tSimilarly,\tif\twe start\theapifying\t from\t any\t other\t node\t to\t root,\t we\t can\t that\tprocess\t percolate\t up\t as\t move\t from bottom\tto\ttop. Time\tComplexity:\tO(logn).\tHeap\tis\ta\tcomplete\tbinary\ttree\tand\tin\tthe\tworst\tcase\twe\tstart\tat\tthe root\tand\tcome\tdown\tto\tthe\tleaf.\tThis\tis\tequal\tto\tthe\theight\tof\tthe\tcomplete\tbinary\ttree.\tSpace Complexity:\tO(1). Deleting\tan\tElement To\tdelete\tan\telement\tfrom\theap,\twe\tjust\tneed\tto\tdelete\tthe\telement\tfrom\tthe\troot.\tThis\tis\tthe\tonly operation\t(maximum\telement)\tsupported\tby\tstandard\theap.\tAfter\tdeleting\tthe\troot\telement,\tcopy the\tlast\telement\tof\tthe\theap\t(tree)\tand\tdelete\tthat\tlast\telement. After\treplacing\tthe\tlast\telement,\tthe\ttree\tmay\tnot\tsatisfy\tthe\theap\tproperty.\tTo\tmake\tit\theap\tagain, call\tthe\tPercolateDown\tfunction. \u2022 Copy\tthe\tfirst\telement\tinto\tsome\tvariable \u2022 Copy\tthe\tlast\telement\tinto\tfirst\telement\tlocation \u2022 PercolateDown\tthe\tfirst\telement Note:\t Deleting\t an\t element\t uses\t PercolateDown,\t and\t inserting\t an\t element\t uses\t PercolateUp. Time\tComplexity:\tsame\tas\tHeapify\tfunction\tand\tit\tis\tO(logn). Inserting\tan\tElement Insertion\tof\tan\telement\tis\tsimilar\tto\tthe\theapify\tand\tdeletion\tprocess. \u2022 Increase\tthe\theap\tsize \u2022 Keep\tthe\tnew\telement\tat\tthe\tend\tof\tthe\theap\t(tree) \u2022 Heapify\tthe\telement\tfrom\tbottom\tto\ttop\t(root) Before\tgoing\tthrough\tcode,\tlet\tus\tlook\tat\tan\texample.\tWe\thave\tinserted\tthe\telement\t19\tat\tthe\tend of\tthe\theap\tand\tthis\tis\tnot\tsatisfying\tthe\theap\tproperty. In\t order\t to\t heapify\t this\t element\t (19),\t we\t need\t to\t compare\t it\t with\t its\t parent\t and\t adjust\t them. Swapping\t19\tand\t14\tgives: Again,\tswap\t19\tandl6: Now\tthe\ttree\tis\tsatisfying\tthe\theap\tproperty.\tSince\twe\tare\tfollowing\tthe\tbottom-up\tapproach\twe sometimes\tcall\tthis\tprocess\tpercolate\tup. Time\tComplexity:\tO(logn).\tThe\texplanation\tis\tthe\tsame\tas\tthat\tof\tthe\tHeapify\tfunction. Destroying\tHeap Heapifying\tthe\tArray One\tsimple\tapproach\tfor\tbuilding\tthe\theap\tis,\ttake\tn\tinput\titems\tand\tplace\tthem\tinto\tan\tempty heap.\tThis\tcan\tbe\tdone\twith\tn\tsuccessive\tinserts\tand\ttakes\tO(nlogn)\tin\tthe\tworst\tcase.\tThis\tis due\tto\tthe\tfact\tthat\teach\tinsert\toperation\ttakes\tO(logn). To\tfinish\tour\tdiscussion\tof\tbinary\theaps,\twe\twill\tlook\tat\ta\tmethod\tto\tbuild\tan\tentire\theap\tfrom\ta list\tof\tkeys.\tThe\tfirst\tmethod\tyou\tmight\tthink\tof\tmay\tbe\tlike\tthe\tfollowing.\tGiven\ta\tlist\tof\tkeys, you\tcould\teasily\tbuild\ta\theap\tby\tinserting\teach\tkey\tone\tat\ta\ttime.\tSince\tyou\tare\tstarting\twith\ta\tlist of\tone\titem,\tthe\tlist\tis\tsorted\tand\tyou\tcould\tuse\tbinary\tsearch\tto\tfind\tthe\tright\tposition\tto\tinsert\tthe next\tkey\tat\ta\tcost\tof\tapproximately\tO(logn)\toperations. However,\tremember\tthat\tinserting\tan\titem\tin\tthe\tmiddle\tof\tthe\tlist\tmay\trequire\tO(n)\toperations\tto shift\tthe\trest\tof\tthe\tlist\tover\tto\tmake\troom\tfor\tthe\tnew\tkey.\tTherefore,\tto\tinsert\tn\tkeys\tinto\tthe heap\twould\trequire\ta\ttotal\tof\tO(nlogn)\toperations.\tHowever,\tif\twe\tstart\twith\tan\tentire\tlist\tthen we\tcan\tbuild\tthe\twhole\theap\tin\tO(n)\toperations. Observation:\tLeaf\tnodes\talways\tsatisfy\tthe\theap\tproperty\tand\tdo\tnot\tneed\tto\tcare\tfor\tthem.\tThe leaf\t elements\t are\t always\t at\t the\t end\t and\t to\t heapify\t the\t given\t array\t it\t should\t be\t enough\t if\t we heapify\tthe\tnon-leaf\tnodes.\tNow\tlet\tus\tconcentrate\ton\tfinding\tthe\tfirst\tnon-leaf\tnode.\tThe\tlast element\tof\tthe\theap\tis\tat\tlocation\th\t\u2192\tcount\t\u2013\t1,\tand\tto\tfind\tthe\tfirst\tnon-leaf\tnode\tit\tis\tenough\tto find\tthe\tparent\tof\tthe\tlast\telement. Time\tComplexity:\tThe\tlinear\ttime\tbound\tof\tbuilding\theap\tcan\tbe\tshown\tby\tcomputing\tthe\tsum\tof the\theights\tof\tall\tthe\tnodes.\tFor\ta\tcomplete\tbinary\ttree\tof\theight\th\tcontaining\tn\t=\t2h+1-\t1\tnodes, the\tsum\tof\tthe\theights\tof\tthe\tnodes\tis\tn\t\u2013\th\t-\t1\t=\tn\t \u2013\t logn\t \u2013\t 1\t (for\t proof\t refer\t to\t Problems Section).\tThat\tmeans,\tbuilding\tthe\theap\toperation\tcan\tbe\tdone\tin\tlinear\ttime\t(O(n))\tby\tapplying\ta PercolateDown\tfunction\tto\tthe\tnodes\tin\treverse\tlevel\torder."
            },
            {
                "subchapter_title": "7.7\tHeapsort",
                "content": "One\t main\t application\t of\t heap\t ADT\t is\t sorting\t (heap\t sort).\t The\t heap\t sort\t algorithm\t inserts\t all elements\t(from\tan\tunsorted\tarray)\tinto\ta\theap,\tthen\tremoves\tthem\tfrom\tthe\troot\tof\ta\theap\tuntil\tthe heap\tis\tempty.\tNote\tthat\theap\tsort\tcan\tbe\tdone\tin\tplace\twith\tthe\tarray\tto\tbe\tsorted.\tInstead\tof deleting\tan\telement,\texchange\tthe\tfirst\telement\t(maximum)\twith\tthe\tlast\telement\tand\treduce\tthe heap\tsize\t(array\tsize).\tThen,\twe\theapify\tthe\tfirst\telement.\tContinue\tthis\tprocess\tuntil\tthe\tnumber of\tremaining\telements\tis\tone. Time\tcomplexity:\tAs\twe\tremove\tthe\telements\tfrom\tthe\theap,\tthe\tvalues\tbecome\tsorted\t(since maximum\t elements\t are\t always\t root\t only).\t Since\t the\t time\t complexity\t of\t both\t the\t insertion algorithm\tand\tdeletion\talgorithm\tis\tO(logn)\t(where\tn\tis\tthe\tnumber\tof\titems\tin\tthe\theap),\tthe\ttime complexity\tof\tthe\theap\tsort\talgorithm\tis\tO(nlogn)."
            },
            {
                "subchapter_title": "7.8\tPriority\tQueues\t[Heaps]:\tProblems\t&\tSolutions",
                "content": "Problem-1\u2003\u2003What\tare\tthe\tminimum\tand\tmaximum\tnumber\tof\telements\tin\ta\theap\tof\theight\th? Solution:\tSince\theap\tis\ta\tcomplete\tbinary\ttree\t(all\tlevels\tcontain\tfull\tnodes\texcept\tpossibly\tthe lowest\tlevel),\tit\thas\tat\tmost\t2h+1\t\u2013\t1\telements\t(if\tit\tis\tcomplete).\tThis\tis\tbecause,\tto\tget\tmaximum nodes,\twe\tneed\tto\tfill\tall\tthe\th\tlevels\tcompletely\tand\tthe\tmaximum\tnumber\tof\tnodes\tis\tnothing\tbut the\tsum\tof\tall\tnodes\tat\tall\th\tlevels. To\t get\t minimum\t nodes,\t we\t should\t fill\t the\t h\t \u2013\t 1\t levels\t fully\t and\t the\t last\t level\t with\t only\t one element.\tAs\ta\tresult,\tthe\tminimum\tnumber\tof\tnodes\tis\tnothing\tbut\tthe\tsum\tof\tall\tnodes\tfrom\th\t\u2013\t1 levels\tplus\t1\t(for\tthe\tlast\tlevel)\tand\twe\tget\t2h\t\u2013\t1\t+\t1\t=\t2h\telements\t(if\tthe\tlowest\tlevel\thas\tjust\t1 element\tand\tall\tthe\tother\tlevels\tare\tcomplete). Problem-2\u2003\u2003Is\tthere\ta\tmin-heap\twith\tseven\tdistinct\telements\tso\tthat\tthe\tpreorder\ttraversal\tof it\tgives\tthe\telements\tin\tsorted\torde? Solution:\tYes.\tFor\tthe\ttree\tbelow,\tpreorder\ttraversal\tproduces\tascending\torder. Problem-3\u2003\u2003Is\tthere\ta\tmax-heap\twith\tseven\tdistinct\telements\tso\tthat\tthe\tpreorder\ttraversal\tof it\tgives\tthe\telements\tin\tsorted\torder? Solution:\tYes.\tFor\tthe\ttree\tbelow,\tpreorder\ttraversal\tproduces\tdescending\torder. Problem-4\u2003\u2003Is\t there\t a\t min-heap/max-heap\t with\t seven\t distinct\t elements\t so\t that\t the\t inorder traversal\tof\tit\tgives\tthe\telements\tin\tsorted\torder? Solution:\t No.\t Since\t a\t heap\t must\t be\t either\t a\t min-heap\t or\t a\t max-heap,\t the\t root\t will\t hold\t the smallest\telement\tor\tthe\tlargest.\tAn\tinorder\ttraversal\twill\tvisit\tthe\troot\tof\tthe\ttree\tas\tits\tsecond step,\twhich\tis\tnot\tthe\tappropriate\tplace\tif\tthe\ttree\u2019s\troot\tcontains\tthe\tsmallest\tor\tlargest\telement. Problem-5\u2003\u2003Is\tthere\ta\tmin-heap/max-heap\twith\tseven\tdistinct\telements\tso\tthat\tthe\tpostorder traversal\tof\tit\tgives\tthe\telements\tin\tsorted\torder? Solution: Yes,\tif\tthe\ttree\tis\ta\tmax-heap\tand\twe\twant\tdescending\torder\t(below\tleft),\tor\tif\tthe\ttree\tis\ta\tmin- heap\tand\twe\twant\tascending\torder\t(below\tright). Problem-6\u2003\u2003Show\tthat\tthe\theight\tof\ta\theap\twith\tn\telements\tis\tlogn? Solution:\tA\theap\tis\ta\tcomplete\tbinary\ttree.\tAll\tthe\tlevels,\texcept\tthe\tlowest,\tare\tcompletely\tfull. A\theap\thas\tat\tleast\t2h\telements\tand\tat\tmost\telements\t2h\t\u2264\tn\t\u2264\t2h+1\t\u2013\t1.\tThis\timplies,\th\t\u2264\tlogn\t\u2264\th +\t1.\tSince\th\tis\tan\tinteger,\th\t=\tlogn. Problem-7\u2003\u2003Given\ta\tmin-heap,\tgive\tan\talgorithm\tfor\tfinding\tthe\tmaximum\telement. Solution:\tFor\ta\tgiven\tmin\theap,\tthe\tmaximum\telement\twill\talways\tbe\tat\tleaf\tonly.\tNow,\tthe\tnext question\tis\thow\tto\tfind\tthe\tleaf\tnodes\tin\tthe\ttree. If\twe\tcarefully\tobserve,\tthe\tnext\tnode\tof\tthe\tlast\telement\u2019s\tparent\tis\tthe\tfirst\tleaf\tnode.\tSince\tthe last\t element\t is\t always\t at\t the\t h\t \u2192\t count\t \u2013\t 1th\t location,\t the\t next\t node\t of\t its\t parent\t (parent\t at location\t \tcan\tbe\tcalculated\tas: Now,\tthe\tonly\tstep\tremaining\tis\tscanning\tthe\tleaf\tnodes\tand\tfinding\tthe\tmaximum\tamong\tthem. Time\tComplexity:\t . Problem-8\u2003\u2003Give\tan\talgorithm\tfor\tdeleting\tan\tarbitrary\telement\tfrom\tmin\theap. Solution:\tTo\tdelete\tan\telement,\tfirst\twe\tneed\tto\tsearch\tfor\tan\telement.\tLet\tus\tassume\tthat\twe\tare using\tlevel\torder\ttraversal\tfor\tfinding\tthe\telement.\tAfter\tfinding\tthe\telement\twe\tneed\tto\tfollow the\tDeleteMin\tprocess. Time\tComplexity\t=\tTime\tfor\tfinding\tthe\telement\t+\tTime\tfor\tdeleting\tan\telement =\t O(n)\t +\t O\t (logn)\t \u2248\t O(n).\t //Time\t for\t searching\t is dominated. Problem-9\u2003\u2003Give\tan\talgorithm\tfor\tdeleting\tthe\tith\tindexed\telement\tin\ta\tgiven\tmin-heap. Solution: Time\tComplexity\t=\tO(logn). Problem-10\u2003\u2003Prove\tthat,\tfor\ta\tcomplete\tbinary\ttree\tof\theight\th\tthe\tsum\tof\tthe\theight\tof\tall nodes\tis\tO(n\t\u2013\th). Solution:\tA\tcomplete\tbinary\ttree\thas\t2i\tnodes\ton\tlevel\t(.Also,\ta\tnode\ton\tlevel\ti\thas\tdepth\ti\tand height\th\t\u2013\ti.\tLet\tus\tassume\tthat\tS\tdenotes\tthe\tsum\tof\tthe\theights\tof\tall\tthese\tnodes\tand\tS\tcan\tbe calculated\tas: Multiplying\twith\t2\ton\tboth\tsides\tgives:\t2S\t=\t2h\t+\t4(h\t\u2013\t1)\t+\t8(h\t\u2013\t2)\t+\t\u00b7\u00b7\u00b7+\t2h\t\u2013\t1(1) Now,\tsubtract\tS\tfrom\t2S:\t2S\t\u2013\tS\t=\t\u2013\th\t+\t2\t+\t4\t+\t\u00b7\u00b7\u00b7\t+\t2h\t\u21d2\tS\t=\t(2h+1\t\u2013\t1)\t\u2013\t(h\t\u2013\t1) But,\twe\talready\tknow\tthat\tthe\ttotal\tnumber\tof\tnodes\tn\tin\ta\tcomplete\tbinary\ttree\twith\theight\th\tis\tn =\t2h+1\t\u2013\t1.\tThis\tgives\tus:\th\t=\tlog(n\t+\t1). Finally,\treplacing\t2h+1\t\u2013\t1\twith\tn,\tgives:\tS\t=\tn\t\u2013\t(h\t\u2013\t1)\t=\tO(n\t\u2013\tlogn)\t=\tO(n\t-\th). Problem-11\u2003\u2003Give\tan\talgorithm\tto\tfind\tall\telements\tless\tthan\tsome\tvalue\tof\tk\tin\ta\tbinary\theap. Solution:\tStart\tfrom\tthe\troot\tof\tthe\theap.\tIf\tthe\tvalue\tof\tthe\troot\tis\tsmaller\tthan\tk\tthen\tprint\tits value\tand\tcall\trecursively\tonce\tfor\tits\tleft\tchild\tand\tonce\tfor\tits\tright\tchild.\tIf\tthe\tvalue\tof\ta\tnode is\tgreater\tor\tequal\tthan\tk\tthen\tthe\tfunction\tstops\twithout\tprinting\tthat\tvalue. The\tcomplexity\tof\tthis\talgorithm\tis\tO(n),\twhere\tn\tis\tthe\ttotal\tnumber\tof\tnodes\tin\tthe\theap.\tThis bound\ttakes\tplace\tin\tthe\tworst\tcase,\twhere\tthe\tvalue\tof\tevery\tnode\tin\tthe\theap\twill\tbe\tsmaller than\tk,\tso\tthe\tfunction\thas\tto\tcall\teach\tnode\tof\tthe\theap. Problem-12\u2003\u2003Give\tan\talgorithm\tfor\tmerging\ttwo\tbinary\tmax-heaps.\tLet\tus\tassume\tthat\tthe\tsize of\tthe\tfirst\theap\tis\tm\t+\tn\tand\tthe\tsize\tof\tthe\tsecond\theap\tis\tn. Solution:\tOne\tsimple\tway\tof\tsolving\tthis\tproblem\tis: \u2022 Assume\tthat\tthe\telements\tof\tthe\tfirst\tarray\t(with\tsize\tm\t+\tn)\tare\tat\tthe\tbeginning. That\tmeans,\tfirst\tm\tcells\tare\tfilled\tand\tremaining\tn\tcells\tare\tempty. \u2022 Without\tchanging\tthe\tfirst\theap,\tjust\tappend\tthe\tsecond\theap\tand\theapify\tthe\tarray. \u2022 Since\tthe\ttotal\tnumber\tof\telements\tin\tthe\tnew\tarray\tis\tm\t+\tn,\teach\theapify\toperation takes\tO(log(m\t+\tn)). The\tcomplexity\tof\tthis\talgorithm\tis\t:\tO((m\t+\tn)log(m\t+\tn)). Problem-13\u2003\u2003Can\twe\timprove\tthe\tcomplexity\tof\tProblem-12? Solution:\tInstead\tof\theapifying\tall\tthe\telements\tof\tthe\tm\t+\tn\tarray,\twe\tcan\tuse\tthe\ttechnique\tof \u201cbuilding\theap\twith\tan\tarray\tof\telements\t(heapifying\tarray)\u201d.\tWe\tcan\tstart\twith\tnon-leaf\tnodes and\theapify\tthem.\tThe\talgorithm\tcan\tbe\tgiven\tas: \u2022 Assume\tthat\tthe\telements\tof\tthe\tfirst\tarray\t(with\tsize\tm\t+\tn)\tare\tat\tthe\tbeginning. That\tmeans,\tthe\tfirst\tm\tcells\tare\tfilled\tand\tthe\tremaining\tn\tcells\tare\tempty. \u2022 Without\tchanging\tthe\tfirst\theap,\tjust\tappend\tthe\tsecond\theap. \u2022 Now,\tfind\tthe\tfirst\tnon-leaf\tnode\tand\tstart\theapifying\tfrom\tthat\telement. In\t the\t theory\t section,\t we\t have\t already\t seen\t that\t building\t a\t heap\t with\t n\t elements\t takes\t O(n) complexity.\tThe\tcomplexity\tof\tmerging\twith\tthis\ttechnique\tis:\tO(m\t+\tn). Problem-14\u2003\u2003Is\tthere\tan\tefficient\talgorithm\tfor\tmerging\t2\tmax-heaps\t(stored\tas\tan\tarray)? Assume\tboth\tarrays\thave\tn\telements. Solution:\tThe\talternative\tsolution\tfor\tthis\tproblem\tdepends\ton\twhat\ttype\tof\theap\tit\tis.\tIf\tit\u2019s\ta standard\theap\twhere\tevery\tnode\thas\tup\tto\ttwo\tchildren\tand\twhich\tgets\tfilled\tup\tso\tthat\tthe\tleaves are\ton\ta\tmaximum\tof\ttwo\tdifferent\trows,\twe\tcannot\tget\tbetter\tthan\tO(n)\tfor\tthe\tmerge. There\tis\tan\tO(logm\t\u00d7\tlogn)\talgorithm\tfor\tmerging\ttwo\tbinary\theaps\twith\tsizes\tm\tand\tn.\tFor\tm\t= n,\tthis\talgorithm\ttakes\tO(log2n)\ttime\tcomplexity.\tWe\twill\tbe\tskipping\tit\tdue\tto\tits\tdifficulty\tand scope. For\tbetter\tmerging\tperformance,\twe\tcan\tuse\tanother\tvariant\tof\tbinary\theap\tlike\ta\tFibonacci- Heap\twhich\tcan\tmerge\tin\tO(1)\ton\taverage\t(amortized). Problem-15\u2003\u2003Give\tan\talgorithm\tfor\tfinding\tthe\tkth\tsmallest\telement\tin\tmin-heap. Solution:\tOne\tsimple\tsolution\tto\tthis\tproblem\tis:\tperform\tdeletion\tk\ttimes\tfrom\tmin-heap. Time\t Complexity:\t O(klogn).\t Since\t we\t are\t performing\t deletion\t operation\t k\t times\t and\t each deletion\ttakes\tO(logn). Problem-16\u2003\u2003For\tProblem-15,\tcan\twe\timprove\tthe\ttime\tcomplexity? Solution:\tAssume\tthat\tthe\toriginal\tmin-heap\tis\tcalled\tHOrig\tand\tthe\tauxiliary\tmin-heap\tis\tnamed HAux.\tInitially,\tthe\telement\tat\tthe\ttop\tof\tHOrig,\tthe\tminimum\tone,\tis\tinserted\tinto\tHAux.\tHere\twe don\u2019t\tdo\tthe\toperation\tof\tDeleteMin\twith\tHOrig. Every\t while-loop\t iteration\t gives\t the\t kth\t smallest\t element\t and\t we\t need\t k\t loops\t to\t get\t the\t kth smallest\telements.\tBecause\tthe\tsize\tof\tthe\tauxiliary\theap\tis\talways\tless\tthan\tk,\tevery\twhile-loop iteration\t the\t size\t of\t the\t auxiliary\t heap\t increases\t by\t one,\t and\t the\t original\t heap\t HOrig\t has\t no operation\tduring\tthe\tfinding,\tthe\trunning\ttime\tis\tO(klogk). Note:\tThe\tabove\talgorithm\tis\tuseful\tif\tthe\tk\tvalue\tis\ttoo\tsmall\tcompared\tto\tn.\tIf\tthe\tk\tvalue\tis approximately\tequal\tto\tn,\tthen\twe\tcan\tsimply\tsort\tthe\tarray\t(let\u2019s\tsay,\tusing\tcouting\tsort\tor\tany other\tlinear\tsorting\talgorithm)\tand\treturn\tkth\tsmallest\telement\tfrom\tthe\tsorted\tarray.\tThis\tgives O(n)\tsolution. Problem-17\u2003\u2003Find\tk\tmax\telements\tfrom\tmax\theap. Solution:\tOne\tsimple\tsolution\tto\tthis\tproblem\tis:\tbuild\tmax-heap\tand\tperform\tdeletion\tk\ttimes. T(n)\t=\tDeleteMin\tfrom\theap\tk\ttimes\t=\t\u0398(klogn). Problem-18\u2003\u2003For\tProblem-17,\tis\tthere\tany\talternative\tsolution? Solution:\t We\t can\t use\t the\t Problem-16\t solution.\t At\t the\t end,\t the\t auxiliary\t heap\t contains\t the\t k- largest\telements.\tWithout\tdeleting\tthe\telements\twe\tshould\tkeep\ton\tadding\telements\tto\tHAux. Problem-19\u2003\u2003How\tdo\twe\timplement\tstack\tusing\theap? Solution:\tTo\timplement\ta\tstack\tusing\ta\tpriority\tqueue\tPQ\t(using\tmin\theap),\tlet\tus\tassume\tthat\twe are\tusing\tone\textra\tinteger\tvariable\tc.\tAlso,\tassume\tthat\tc\tis\tinitialized\tequal\tto\tany\tknown\tvalue (e.g.,\t0).\tThe\timplementation\tof\tthe\tstack\tADT\tis\tgiven\tbelow.\tHere\tc\tis\tused\tas\tthe\tpriority while\tinserting/deleting\tthe\telements\tfrom\tPQ. We\tcould\talso\tincrement\tc\tback\twhen\tpopping. Observation:\t We\t could\t use\t the\t negative\t of\t the\t current\t system\t time\t instead\t of\t c\t (to\t avoid overflow).\tThe\timplementation\tbased\ton\tthis\tcan\tbe\tgiven\tas: Problem-20\u2003\u2003How\tdo\twe\timplement\tQueue\tusing\theap? Solution:\tTo\timplement\ta\tqueue\tusing\ta\tpriority\tqueue\tPQ\t(using\tmin\theap),\tas\tsimilar\tto\tstacks simulation,\tlet\tus\tassume\tthat\twe\tare\tusing\tone\textra\tinteger\tvariable,\tc.\tAlso,\tassume\tthat\tc\tis initialized\tequal\tto\tany\tknown\tvalue\t(e.g.,\t0).\tThe\timplementation\tof\tthe\tqueue\tADT\tis\tgiven below.\tHere\tthe\tc\tis\tused\tas\tthe\tpriority\twhile\tinserting/deleting\tthe\telements\tfrom\tPQ. Note:\tWe\tcould\talso\tdecrement\tc\twhen\tpopping. Observation:\tWe\tcould\tuse\tjust\tthe\tnegative\tof\tthe\tcurrent\tsystem\ttime\tinstead\tof\tc\t(to\tavoid overflow).\tThe\timplementation\tbased\ton\tthis\tcan\tbe\tgiven\tas: Note:\tThe\tonly\tchange\tis\tthat\twe\tneed\tto\ttake\ta\tpositive\tc\tvalue\tinstead\tof\tnegative. Problem-21\u2003\u2003Given\t a\t big\t file\t containing\t billions\t of\t numbers,\t how\t can\t you\t find\t the\t 10 maximum\tnumbers\tfrom\tthat\tfile? Solution:\tAlways\tremember\tthat\twhen\tyou\tneed\tto\tfind\tmax\tn\telements,\tthe\tbest\tdata\tstructure\tto use\tis\tpriority\tqueues. One\tsolution\tfor\tthis\tproblem\tis\tto\tdivide\tthe\tdata\tin\tsets\tof\t1000\telements\t(let\u2019s\tsay\t1000)\tand make\ta\theap\tof\tthem,\tand\tthen\ttake\t10\telements\tfrom\teach\theap\tone\tby\tone.\tFinally\theap\tsort\tall the\tsets\tof\t10\telements\tand\ttake\tthe\ttop\t10\tamong\tthose.\tBut\tthe\tproblem\tin\tthis\tapproach\tis where\tto\tstore\t10\telements\tfrom\teach\theap.\tThat\tmay\trequire\ta\tlarge\tamount\tof\tmemory\tas\twe have\tbillions\tof\tnumbers. Reusing\t the\t top\t 10\t elements\t (from\t the\t earlier\t heap)\t in\t subsequent\t elements\t can\t solve\t this problem.\tThat\tmeans\ttake\tthe\tfirst\tblock\tof\t1000\telements\tand\tsubsequent\tblocks\tof\t990\telements each.\tInitially,\tHeapsort\tthe\tfirst\tset\tof\t1000\tnumbers,\ttake\tmax\t10\telements,\tand\tmix\tthem\twith 990\telements\tof\tthe\t2nd\tset.\tAgain,\tHeapsort\tthese\t1000\tnumbers\t(10\tfrom\tthe\tfirst\tset\tand\t990 from\tthe\t2nd\tset),\ttake\t10\tmax\telements,\tand\tmix\tthem\twith\t990\telements\tof\tthe\t3rd\tset.\tRepeat\ttill the\tlast\tset\tof\t990\t(or\tless)\telements\tand\ttake\tmax\t10\telements\tfrom\tthe\tfinal\theap.\tThese\t10 elements\twill\tbe\tyour\tanswer. Time\tComplexity:\tO(n)\t=\tn/1000\t\u00d7(complexity\tof\tHeapsort\t1000\telements)\tSince\tcomplexity\tof heap\tsorting\t1000\telements\twill\tbe\ta\tconstant\tso\tthe\tO(n)\t=\tn\ti.e.\tlinear\tcomplexity. Problem-22\u2003\u2003Merge\tk\tsorted\tlists\twith\ttotal\tof\tn\telements:\tWe\tare\tgiven\tk\tsorted\tlists\twith total\tn\tinputs\tin\tall\tthe\tlists.\tGive\tan\talgorithm\tto\tmerge\tthem\tinto\tone\tsingle\tsorted\tlist. Solution:\tSince\tthere\tare\tk\tequal\tsize\tlists\twith\ta\ttotal\tof\tn\telements,\tthe\tsize\tof\teach\tlist\tis\t \tOne simple\tway\tof\tsolving\tthis\tproblem\tis: \u2022 Take\tthe\tfirst\tlist\tand\tmerge\tit\twith\tthe\tsecond\tlist.\tSince\tthe\tsize\tof\teach\tlist\tis\t , this\tstep\tproduces\ta\tsorted\tlist\twith\tsize\t .\tThis\tis\tsimilar\tto\tmerge\tsort\tlogic.\tThe time\tcomplexity\tof\tthis\tstep\tis:\t .\tThis\tis\tbecause\twe\tneed\tto\tscan\tall\tthe\telements of\tboth\tthe\tlists. \u2022 Then,\tmerge\tthe\tsecond\tlist\toutput\twith\tthe\tthird\tlist.\tAs\ta\tresult,\tthis\tstep\tproduces\ta sorted\tlist\twith\tsize\t .\tThe\ttime\tcomplexity\tof\tthis\tstep\tis:\t .\tThis\tis\tbecause\twe need\tto\tscan\tall\tthe\telements\tof\tboth\tlists\t(one\twith\tsize\t \tand\tthe\tother\twith\tsize\t ). \u2022 Continue\tthis\tprocess\tuntil\tall\tthe\tlists\tare\tmerged\tto\tone\tlist. Total\t time\t complexity:\t Space\tComplexity:\tO(1). Problem-23\u2003\u2003For\tProblem-22,\tcan\twe\timprove\tthe\ttime\tcomplexity? Solution: 1 Divide\tthe\tlists\tinto\tpairs\tand\tmerge\tthem.\tThat\tmeans,\tfirst\ttake\ttwo\tlists\tat\ta\ttime and\tmerge\tthem\tso\tthat\tthe\ttotal\telements\tparsed\tfor\tall\tlists\tis\tO(n).\tThis\toperation gives\tk/2\tlists. 2 Repeat\tstep-1\tuntil\tthe\tnumber\tof\tlists\tbecomes\tone. Time\tcomplexity:\tStep-1\texecutes\tlogk\ttimes\tand\teach\toperation\tparses\tall\tn\telements\tin\tall\tthe lists\tfor\tmaking\tk/2\tlists.\tFor\texample,\tif\twe\thave\t8\tlists,\tthen\tthe\tfirst\tpass\twould\tmake\t4\tlists\tby parsing\tall\tn\telements.\tThe\tsecond\tpass\twould\tmake\t2\tlists\tby\tagain\tparsing\tn\telements\tand\tthe third\tpass\twould\tgive\t1\tlist\tby\tagain\tparsing\tn\telements.\tAs\ta\tresult\tthe\ttotal\ttime\tcomplexity\tis O(nlogn). Space\tComplexity:\tO(n). Problem-24\u2003\u2003For\tProblem-23,\tcan\twe\timprove\tthe\tspace\tcomplexity? Solution:\tLet\tus\tuse\theaps\tfor\treducing\tthe\tspace\tcomplexity."
            }
        ]
    },
    {
        "chapter_title": "1.",
        "subchapters": [
            {
                "subchapter_title": "Build\tthe\tmax-heap\twith\tall\tthe\tfirst\telements\tfrom\teach\tlist\tin\tO(k).",
                "content": ""
            }
        ]
    },
    {
        "chapter_title": "2.",
        "subchapters": [
            {
                "subchapter_title": "In\teach\tstep,\textract\tthe\tmaximum\telement\tof\tthe\theap\tand\tadd\tit\tat\tthe\tend\tof\tthe",
                "content": "output."
            }
        ]
    },
    {
        "chapter_title": "3.",
        "subchapters": [
            {
                "subchapter_title": "Add\tthe\tnext\telement\tfrom\tthe\tlist\tof\tthe\tone\textracted.\tThat\tmeans\twe\tneed\tto\tselect",
                "content": "the\t next\t element\t of\t the\t list\t which\t contains\t the\t extracted\t element\t of\t the\t previous step."
            }
        ]
    },
    {
        "chapter_title": "4.",
        "subchapters": [
            {
                "subchapter_title": "Repeat\tstep-2\tand\tstep-3\tuntil\tall\tthe\telements\tare\tcompleted\tfrom\tall\tthe\tlists.",
                "content": "Time\tComplexity\t=\tO(nlogk\t).\tAt\ta\ttime\twe\thave\tk\telements\tmax-heap\tand\tfor\tall\tn\telements\twe have\tto\tread\tjust\tthe\theap\tin\tlogk\ttime,\tso\ttotal\ttime\t=\tO(nlogk). Space\tComplexity:\tO(k)\t[for\tMax-heap]. Problem-25\u2003\u2003Given\t2\tarrays\tA\t and\t B\t each\t with\t n\t elements.\t Give\tan\t algorithm\t for\t finding largest\tn\tpairs\t(A[i],B[j]). Solution: Algorithm: \u2022 Heapify\tA\tand\tB.\tThis\tstep\ttakes\tO(2n)\t\u2248\tO(n). \u2022 Then\tkeep\ton\tdeleting\tthe\telements\tfrom\tboth\tthe\theaps.\tEach\tstep\ttakes\tO(2logn)\t\u2248 O(logn). Total\tTime\tcomplexity:\tO(nlogn). Problem-26\u2003\u2003Min-Max\t heap:\t Give\t an\t algorithm\t that\t supports\t min\t and\t max\t in\t O(1)\t time, insert,\tdelete\tmin,\tand\tdelete\tmax\tin\tO(logn)\ttime.\tThat\tmeans,\tdesign\ta\tdata\tstructure which\tsupports\tthe\tfollowing\toperations: Operation Complexity Init O(n) Insert O(logn) FindMin O(1) FindMax O(1) Delete\tMin O(logn) Delete\tMax O(logri) Solution:\tThis\tproblem\tcan\tbe\tsolved\tusing\ttwo\theaps.\tLet\tus\tsay\ttwo\theaps\tare:\tMinimum-Heap Hmin\t and\t Maximum-Heap\t Hmax.\t Also,\t assume\t that\t elements\t in\t both\t the\t arrays\t have\t mutual pointers.\tThat\tmeans,\tan\telement\tin\tHmin\twill\thave\ta\tpointer\tto\tthe\tsame\telement\tin\tHmax\tand\tan element\tin\tHmax\twill\thave\ta\tpointer\tto\tthe\tsame\telement\tin\tHmin. Init Build\tHmin\tin\tO(n)\tand\tHmax\tin\tO(n) Insert(x) Insert\tx\tto\tHmin\tin\tO(logn).\tInsert\tx\tto\tHmax\tin\tO(logn).\tUpdate\tthe pointers\tin\tO(1) FindMin() Return\troot(Hmin)\tin\tO(1) FindMax Return\troot(Hmax)\tin\tO(1) Delete Min Delete\tthe\tminimum\tfrom\tHmin\tin\tO(logn).\tDelete\tthe\tsame\telement\tfrom Hmax\tby\tusing\tthe\tmutual\tpointer\tin\tO(logn) DeleteMax Delete\tthe\tmaximum\tfrom\tHmax\tin\tO(logn).\tDelete\tthe\tsame\telement\tfrom Hmin\tby\tusing\tthe\tmutual\tpointer\tin\tO(logn) Problem-27\u2003\u2003Dynamic\tmedian\tfinding.\tDesign\ta\theap\tdata\tstructure\tthat\tsupports\tfinding\tthe median. Solution:\tIn\ta\tset\tof\tn\telements,\tmedian\tis\tthe\tmiddle\telement,\tsuch\tthat\tthe\tnumber\tof\telements lesser\tthan\tthe\tmedian\tis\tequal\tto\tthe\tnumber\tof\telements\tlarger\tthan\tthe\tmedian.\tIf\tn\tis\todd,\twe can\tfind\tthe\tmedian\tby\tsorting\tthe\tset\tand\ttaking\tthe\tmiddle\telement.\tIf\tn\tis\teven,\tthe\tmedian\tis usually\tdefined\tas\tthe\taverage\tof\tthe\ttwo\tmiddle\telements.\tThis\talgorithm\tworks\teven\twhen\tsome of\tthe\telements\tin\tthe\tlist\tare\tequal.\tFor\texample,\tthe\tmedian\tof\tthe\tmultiset\t{1,\t1,\t2,\t3,\t5}\tis\t2, and\tthe\tmedian\tof\tthe\tmultiset\t{1,\t1,\t2,\t3,\t5,\t8}\tis\t2.5. \u201cMedian\theaps\u201d\tare\tthe\tvariant\tof\theaps\tthat\tgive\taccess\tto\tthe\tmedian\telement.\tA\tmedian\theap can\t be\t implemented\t using\t two\t heaps,\t each\t containing\t half\t the\t elements.\t One\t is\t a\t max-heap, containing\tthe\tsmallest\telements;\tthe\tother\tis\ta\tmin-heap,\tcontaining\tthe\tlargest\telements.\tThe\tsize of\tthe\tmax-heap\tmay\tbe\tequal\tto\tthe\tsize\tof\tthe\tmin-heap,\tif\tthe\ttotal\tnumber\tof\telements\tis\teven. In\tthis\tcase,\tthe\tmedian\tis\tthe\taverage\tof\tthe\tmaximum\telement\tof\tthe\tmax-heap\tand\tthe\tminimum element\tof\tthe\tmin-heap.\tIf\tthere\tis\tan\todd\tnumber\tof\telements,\tthe\tmax-heap\twill\tcontain\tone more\telement\tthan\tthe\tmin-heap.\tThe\tmedian\tin\tthis\tcase\tis\tsimply\tthe\tmaximum\telement\tof\tthe max-heap. Problem-28\u2003\u2003Maximum\tsum\tin\tsliding\twindow:\tGiven\tarray\tA[]\twith\tsliding\twindow\tof\tsize w\twhich\tis\tmoving\tfrom\tthe\tvery\tleft\tof\tthe\tarray\tto\tthe\tvery\tright.\tAssume\tthat\twe\tcan only\tsee\tthe\tw\tnumbers\tin\tthe\twindow.\tEach\ttime\tthe\tsliding\twindow\tmoves\trightwards\tby one\tposition.\tFor\texample:\tThe\tarray\tis\t[1\t3\t-1\t-3\t5\t3\t6\t7],\tand\tw\tis\t3. Window\tposition Max [1\t3\t-1]\t-3\t5\t3\t6\t7 3 1\t[3\t-1\t-3]\t5\t3\t6\t7 3 1\t3\t[-1\t-3\t5]\t3\t6\t7 5 1\t3\t-1\t[-3\t5\t3]\t6\t7 5 1\t3\t-1\t-3\t[5\t3\t6]\t7 6 1\t3\t-1\t-3\t5\t[3\t6\t7] 7 Input:\t A\t long\t array\t A[],\t and\t a\t window\t width\t w.\t Output:\t An\t array\t B[],\t B[i]\t is\t the maximum\tvalue\tof\tfrom\tA[i]\tto\tA[i+w-1] Requirement:\tFind\ta\tgood\toptimal\tway\tto\tget\tB[i] Solution:\tBrute\tforce\tsolution\tis,\tevery\ttime\tthe\twindow\tis\tmoved\twe\tcan\tsearch\tfor\ta\ttotal\tof\tw elements\tin\tthe\twindow. Time\tcomplexity:\tO(nw). Problem-29\u2003\u2003For\tProblem-28,\tcan\twe\treduce\tthe\tcomplexity? Solution:\tYes,\twe\tcan\tuse\theap\tdata\tstructure.\tThis\treduces\tthe\ttime\tcomplexity\tto\tO(nlogw). Insert\t operation\t takes\t O(logw)\t time,\t where\t w\t is\t the\t size\t of\t the\t heap.\t However,\t getting\t the maximum\tvalue\tis\tcheap;\tit\tmerely\ttakes\tconstant\ttime\tas\tthe\tmaximum\tvalue\tis\talways\tkept\tin\tthe root\t(head)\tof\tthe\theap.\tAs\tthe\twindow\tslides\tto\tthe\tright,\tsome\telements\tin\tthe\theap\tmight\tnot\tbe valid\tanymore\t(range\tis\toutside\tof\tthe\tcurrent\twindow).\tHow\tshould\twe\tremove\tthem?\tWe\twould need\tto\tbe\tsomewhat\tcareful\there.\tSince\twe\tonly\tremove\telements\tthat\tare\tout\tof\tthe\twindow\u2019s range,\twe\twould\tneed\tto\tkeep\ttrack\tof\tthe\telements\u2019\tindices\ttoo. Problem-30\u2003\u2003For\tProblem-28,\tcan\twe\tfurther\treduce\tthe\tcomplexity? Solution:\tYes,\tThe\tdouble-ended\tqueue\tis\tthe\tperfect\tdata\tstructure\tfor\tthis\tproblem.\tIt\tsupports insertion/deletion\tfrom\tthe\tfront\tand\tback.\tThe\ttrick\tis\tto\tfind\ta\tway\tsuch\tthat\tthe\tlargest\telement in\t the\t window\t would\t always\t appear\t in\t the\t front\t of\t the\t queue.\t How\t would\t you\t maintain\t this requirement\tas\tyou\tpush\tand\tpop\telements\tin\tand\tout\tof\tthe\tqueue? Besides,\tyou\twill\tnotice\tthat\tthere\tare\tsome\tredundant\telements\tin\tthe\tqueue\tthat\twe\tshouldn\u2019t even\tconsider.\tFor\texample,\tif\tthe\tcurrent\tqueue\thas\tthe\telements:\t[10\t5\t3],\tand\ta\tnew\telement\tin the\t window\t has\t the\t element\t 11.\t Now,\t we\t could\t have\t emptied\t the\t queue\t without\t considering elements\t10,\t5,\tand\t3,\tand\tinsert\tonly\telement\t11\tinto\tthe\tqueue. Typically,\tmost\tpeople\ttry\tto\tmaintain\tthe\tqueue\tsize\tthe\tsame\tas\tthe\twindow\u2019s\tsize.\tTry\tto\tbreak away\tfrom\tthis\tthought\tand\tthink\tout\tof\tthe\tbox.\tRemoving\tredundant\telements\tand\tstoring\tonly elements\tthat\tneed\tto\tbe\tconsidered\tin\tthe\tqueue\tis\tthe\tkey\tto\tachieving\tthe\tefficient\tO(n)\tsolution below.\t This\t is\t because\t each\t element\t in\t the\t list\t is\t being\t inserted\t and\t removed\t at\t most\t once. Therefore,\tthe\ttotal\tnumber\tof\tinsert\t+\tdelete\toperations\tis\t2n. Problem-31\u2003\u2003A\tpriority\tqueue\tis\ta\tlist\tof\titems\tin\twhich\teach\titem\thas\tassociated\twith\tit\ta priority.\tItems\tare\twithdrawn\tfrom\ta\tpriority\tqueue\tin\torder\tof\ttheir\tpriorities\tstarting\twith the\t highest\t priority\t item\t first.\t If\t the\t maximum\t priority\t item\t is\t required,\t then\t a\t heap\t is constructed\tsuch\tthan\tpriority\tof\tevery\tnode\tis\tgreater\tthan\tthe\tpriority\tof\tits\tchildren. Design\tsuch\ta\theap\twhere\tthe\titem\twith\tthe\tmiddle\tpriority\tis\twithdrawn\tfirst.\tIf\tthere\tare n\t items\t in\t the\t heap,\t then\t the\t number\t of\t items\t with\t the\t priority\t smaller\t than\tthe\t middle priority\tis\t \tif\tn\tis\todd,\telse\t \t\u2213\t1. Explain\thow\twithdraw\tand\tinsert\toperations\twork,\tcalculate\ttheir\tcomplexity,\tand\thow\tthe data\tstructure\tis\tconstructed. Solution:\tWe\tcan\tuse\tone\tmin\theap\tand\tone\tmax\theap\tsuch\tthat\troot\tof\tthe\tmin\theap\tis\tlarger\tthan the\troot\tof\tthe\tmax\theap.\tThe\tsize\tof\tthe\tmin\theap\tshould\tbe\tequal\tor\tone\tless\tthan\tthe\tsize\tof\tthe max\theap.\tSo\tthe\tmiddle\telement\tis\talways\tthe\troot\tof\tthe\tmax\theap. For\tthe\tinsert\toperation,\tif\tthe\tnew\titem\tis\tless\tthan\tthe\troot\tof\tmax\theap,\tthen\tinsert\tit\tinto\tthe max\theap;\telse\tinsert\tit\tinto\tthe\tmin\theap.\tAfter\tthe\twithdraw\tor\tinsert\toperation,\tif\tthe\tsize\tof heaps\tare\tnot\tas\tspecified\tabove\tthan\ttransfer\tthe\troot\telement\tof\tthe\tmax\theap\tto\tmin\theap\tor vice-versa. With\tthis\timplementation,\tinsert\tand\twithdraw\toperation\twill\tbe\tin\tO(logn)\ttime. Problem-32\u2003\u2003Given\ttwo\theaps,\thow\tdo\tyou\tmerge\t(union)\tthem? Solution:\tBinary\theap\tsupports\tvarious\toperations\tquickly:\tFind-min,\tinsert,\tdecrease-key.\tIf\twe have\ttwo\tmin-heaps,\tH1\tand\tH2,\tthere\tis\tno\tefficient\tway\tto\tcombine\tthem\tinto\ta\tsingle\tmin-heap. For\t solving\t this\t problem\t efficiently,\t we\t can\t use\t mergeable\t heaps.\t Mergeable\t heaps\t support efficient\tunion\toperation.\tIt\tis\ta\tdata\tstructure\tthat\tsupports\tthe\tfollowing\toperations: \u2022 Create-Heap():\tcreates\tan\tempty\theap \u2022 Insert(H,X,K)\t:\tinsert\tan\titem\tx\twith\tkey\tK\tinto\ta\theap\tH \u2022 Find-Min(H)\t:\treturn\titem\twith\tmin\tkey \u2022 Delete-Min(H)\t:\treturn\tand\tremove \u2022 Union(H1,\tH2)\t:\tmerge\theaps\tH1\tand\tH2 Examples\tof\tmergeable\theaps\tare: \u2022 Binomial\tHeaps \u2022 Fibonacci\tHeaps Both\theaps\talso\tsupport: \u2022 Decrease-Key(H,X,K):\tassign\titem\tY\twith\ta\tsmaller\tkey\tK \u2022 Delete(H,X)\t:\tremove\titem\tX Binomial\tHeaps:\tUnlike\tbinary\theap\twhich\tconsists\tof\ta\tsingle\ttree,\ta\tbinomial\theap\tconsists\tof a\tsmall\tset\tof\tcomponent\ttrees\tand\tno\tneed\tto\trebuild\teverything\twhen\tunion\tis\tperformed.\tEach component\ttree\tis\tin\ta\tspecial\tformat,\tcalled\ta\tbinomial\ttree. A\tbinomial\ttree\tof\torder\tk,\tdenoted\tby\tBk\tis\tdefined\trecursively\tas\tfollows: \u2022 B0\tis\ta\ttree\twith\ta\tsingle\tnode \u2022 For\tk\t\u2265\t1,\tBk\tis\tformed\tby\tjoining\ttwo\tBk\u20131,\tsuch\tthat\tthe\troot\tof\tone\ttree\tbecomes the\tleftmost\tchild\tof\tthe\troot\tof\tthe\tother. Example: Fibonacci\tHeaps:\tFibonacci\theap\tis\tanother\texample\tof\tmergeable\theap.\tIt\thas\tno\tgood\tworst- case\tguarantee\tfor\tany\toperation\t(except\tInsert/Create-Heap).\tFibonacci\tHeaps\thave\texcellent amortized\tcost\tto\tperform\teach\toperation.\tLike\tbinomial\theap,\tfibonacci\theap\tconsists\tof\ta\tset\tof min-heap\tordered\tcomponent\ttrees.\tHowever,\tunlike\tbinomial\theap,\tit\thas \u2022 No\tlimit\ton\tnumber\tof\ttrees\t(up\tto\tO(n)),\tand \u2022 No\tlimit\ton\theight\tof\ta\ttree\t(up\tto\tO(n)) Also,\t Find-Min,\t Delete-Min,\t Union,\t Decrease-Key,\t Delete\t all\t have\t worst-case\t O(n)\t running time.\tHowever,\tin\tthe\tamortized\tsense,\teach\toperation\tperforms\tvery\tquickly. Problem-33\u2003\u2003Median\tin\tan\tinfinite\tseries\tof\tintegers Solution:\tMedian\tis\tthe\tmiddle\tnumber\tin\ta\tsorted\tlist\tof\tnumbers\t(if\twe\thave\todd\tnumber\tof elements).\tIf\twe\thave\teven\tnumber\tof\telements,\tmedian\tis\tthe\taverage\tof\ttwo\tmiddle\tnumbers\tin\ta sorted\tlist\tof\tnumbers. We\tcan\tsolve\tthis\tproblem\tefficiently\tby\tusing\t2\theaps:\tOne\tMaxHeap\tand\tone\tMinHeap."
            }
        ]
    },
    {
        "chapter_title": "1.",
        "subchapters": [
            {
                "subchapter_title": "MaxHeap\tcontains\tthe\tsmallest\thalf\tof\tthe\treceived\tintegers",
                "content": ""
            }
        ]
    },
    {
        "chapter_title": "2.",
        "subchapters": [
            {
                "subchapter_title": "MinHeap\tcontains\tthe\tlargest\thalf\tof\tthe\treceived\tintegers",
                "content": "The\tintegers\tin\tMaxHeap\tare\talways\tless\tthan\tor\tequal\tto\tthe\tintegers\tin\tMinHeap.\tAlso,\tthe number\tof\telements\tin\tMaxHeap\tis\teither\tequal\tto\tor\t1\tmore\tthan\tthe\tnumber\tof\telements\tin\tthe MinHeap. In\t the\t stream\t if\t we\t get\t 2n\t elements\t (at\t any\t point\t of\t time),\t MaxHeap\t and\t MinHeap\t will\t both contain\tequal\tnumber\tof\telements\t(in\tthis\tcase,\tn\telements\tin\teach\theap).\tOtherwise,\tif\twe\thave received\t2n\t+\t1\telements,\tMaxHeap\twill\tcontain\tn\t+\t1\tand\tMinHeap\tn. Let\tus\tfind\tthe\tMedian:\tIf\twe\thave\t2n\t+\t1\telements\t(odd),\tthe\tMedian\tof\treceived\telements\twill be\tthe\tlargest\telement\tin\tthe\tMaxHeap\t(nothing\tbut\tthe\troot\tof\tMaxHeap).\tOtherwise,\tthe\tMedian of\treceived\telements\twill\tbe\tthe\taverage\tof\tlargest\telement\tin\tthe\tMaxHeap\t(nothing\tbut\tthe\troot of\tMaxHeap)\tand\tsmallest\telement\tin\tthe\tMinHeap\t(nothing\tbut\tthe\troot\tof\tMinHeap).\tThis\tcan\tbe calculated\tin\tO(1). Inserting\t an\t element\t into\t heap\t can\t be\t done\t in\t O(logn).\t Note\t that,\t any\t heap\t containing\t n\t +\t 1 elements\tmight\tneed\tone\tdelete\toperation\t(and\tinsertion\tto\tother\theap)\tas\twell. Example: Insert\t1:\tInsert\tto\tMaxHeap. MaxHeap:\t{1},\tMinHeap:{} Insert\t9:\tInsert\tto\tMinHeap.\tSince\t9\tis\tgreater\tthan\t1\tand\tMinHeap\tmaintains\tthe\tmaximum elements. MaxHeap:\t{1},\tMinHeap:{9} Insert\t2:\tInsert\tMinHeap.\tSince\t2\tis\tless\tthan\tall\telements\tof\tMinHeap. MaxHeap:\t{1,2},\tMinHeap:{9} Insert\t0:\tSince\tMaxHeap\talready\thas\tmore\tthan\thalf;\twe\thave\tto\tdrop\tthe\tmax\telement from\t MaxHeap\t and\t insert\t it\t to\t MinHeap.\t So,\t we\t have\t to\t remove\t 2\t and\t insert\t into MinHeap.\tWith\tthat\tit\tbecomes: MaxHeap:\t{1},\tMinHeap:{2,9} Now,\tinsert\t0\tto\tMaxHeap. Total\tTime\tComplexity:\tO(logn). Problem-34\u2003\u2003Suppose\tthe\telements\t7,\t2,\t10\tand\t4\tare\tinserted,\tin\tthat\torder,\tinto\tthe\tvalid\t3- ary\tmax\theap\tfound\tin\tthe\tabove\tquestion,\tWhich\tone\tof\tthe\tfollowing\tis\tthe\tsequence\tof items\tin\tthe\tarray\trepresenting\tthe\tresultant\theap? (A) 10,\t7,\t9,\t8,\t3,\t1,\t5,\t2,\t6,\t4 (B) 10,\t9,\t8,\t7,\t6,\t5,\t4,\t3,\t2,\t1 (C) 10,\t9,\t4,\t5,\t7,\t6,\t8,\t2,\t1,\t3 (D) 10,\t8,\t6,\t9,\t7,\t2,\t3,\t4,\t1,\t5 Solution:\tThe\t3-ary\tmax\theap\twith\telements\t9,\t5,\t6,\t8,\t3,\t1\tis: After\tInsertion\tof\t7: After\tInsertion\tof\t2: After\tInsertion\tof\t10: After\tInsertion\tof\t4: Problem-35\u2003\u2003A\t complete\t binary\t min-heap\t is\t made\t by\t including\t each\t integer\t in\t [1,1023] exactly\tonce.\tThe\tdepth\tof\ta\tnode\tin\tthe\theap\tis\tthe\tlength\tof\tthe\tpath\tfrom\tthe\troot\tof\tthe heap\tto\tthat\tnode.\tThus,\tthe\troot\tis\tat\tdepth\t0.\tThe\tmaximum\tdepth\tat\twhich\tinteger\t9\tcan appear\tis. Solution:\tAs\tshown\tin\tthe\tfigure\tbelow,\tfor\ta\tgiven\tnumber\ti,\twe\tcan\tfix\tthe\telement\ti\tat\tith\tlevel and\t arrange\t the\t numbers\t 1\t to\t i\t \u2013\t 1\t to\t the\t levels\t above.\t Since\t the\t root\t is\t at\t depth\t zero,\t the maximum\tdepth\tof\tthe\tith\telement\tin\ta\tmin-heap\tis\ti\t\u2013\t1.\tHence,\tthe\tmaximum\tdepth\tat\twhich integer\t9\tcan\tappear\tis\t8. Problem-36\u2003\u2003A\t d-ary\t heap\t is\t like\t a\t binary\t heap,\t but\t instead\t of\t 2\t children,\t nodes\t have\t d children.\tHow\twould\tyou\trepresent\ta\td-ary\theap\twith\tn\telements\tin\tan\tarray?\tWhat\tare\tthe expressions\tfor\tdetermining\tthe\tparent\tof\ta\tgiven\telement,\tParent(i),\tand\ta\tjth\tchild\tof\ta given\telement,\tChild(i,j),\twhere\t1\t\u2264\tj\t\u2264\td? Solution:\tThe\tfollowing\texpressions\tdetermine\tthe\tparent\tand\tjth\tchild\tof\telement\ti\t(where\t1\t\u2264\tj \u2264\td):"
            },
            {
                "subchapter_title": "8.1\tIntroduction",
                "content": "In\tthis\tchapter,\twe\twill\trepresent\tan\timportant\tmathematics\tconcept:\tsets.\t This\t means\t how\t to represent\ta\tgroup\tof\telements\twhich\tdo\tnot\tneed\tany\torder.\tThe\tdisjoint\tsets\tADT\tis\tthe\tone\tused for\tthis\tpurpose.\tIt\tis\tused\tfor\tsolving\tthe\tequivalence\tproblem.\tIt\tis\tvery\tsimple\tto\timplement.\tA simple\tarray\tcan\tbe\tused\tfor\tthe\timplementation\tand\teach\tfunction\ttakes\tonly\ta\tfew\tlines\tof\tcode. Disjoint\t sets\t ADT\t acts\t as\t an\t auxiliary\t data\t structure\t for\t many\t other\t algorithms\t (for\t example, Kruskal\u2019s\talgorithm\tin\tgraph\ttheory).\tBefore\tstarting\tour\tdiscussion\ton\tdisjoint\tsets\tADT,\tlet\tus look\tat\tsome\tbasic\tproperties\tof\tsets."
            },
            {
                "subchapter_title": "8.2\tEquivalence\tRelations\tand\tEquivalence\tClasses",
                "content": "For\tthe\tdiscussion\tbelow\tlet\tus\tassume\tthat\t5\tis\ta\tset\tcontaining\tthe\telements\tand\ta\trelation\tR\tis defined\ton\tit.\tThat\tmeans\tfor\tevery\tpair\tof\telements\tin\ta,b\t\u2208\t5,\ta\tR\tb\tis\teither\ttrue\tor\tfalse.\tIf\ta\tR b\tis\ttrue,\tthen\twe\tsay\ta\tis\trelated\tto\tb,\totherwise\ta\tis\tnot\trelated\tto\tb.\tA\trelation\tR\tis\tcalled\tan equivalence\trelation\tif\tit\tsatisfies\tthe\tfollowing\tproperties: \u2022 Reflexive:\tFor\tevery\telement\ta\t\u2208\tS.aR\ta\tis\ttrue. \u2022 Symmetric:\tFor\tany\ttwo\telements\ta,\tb\t\u2208\tS,\tif\ta\tR\tb\tis\ttrue\tthen\tb\tR\ta\tis\ttrue. \u2022 Transitive:\tFor\tany\tthree\telements\ta,\tb,\tc\t\u2208\tS,\tif\ta\tR\tb\tand\tb\tR\tc\tare\ttrue\tthen\ta\tR\tc is\ttrue. As\tan\texample,\trelations\t\u2264\t(less\tthan\tor\tequal\tto)\tand\t\u2265\t(greater\tthan\tor\tequal\tto)\ton\ta\tset\tof integers\tare\tnot\tequivalence\trelations.\tThey\tare\treflexive\t(since\ta\t\u2264\ta)\tand\ttransitive\t(a\t\u2264\tb\tand\tb \u2264\tc\timplies\ta\t\u2264\tc)\tbut\tnot\tsymmetric\t(a\t\u2264\tb\tdoes\tnot\timply\tb\t\u2264\ta). Similarly,\t rail\t connectivity\t is\t an\t equivalence\t relation.\t This\t relation\t is\t reflexive\t because\t any location\tis\tconnected\tto\titself.\tIf\tthere\tis\tconnectivity\tfrom\tcity\ta\tto\tcity\tb,\tthen\tcity\tb\talso\thas connectivity\tto\tcity\ta,\tso\tthe\trelation\tis\tsymmetric.\tFinally,\tif\tcity\ta\tis\tconnected\tto\tcity\tb\tand\tcity b\tis\tconnected\tto\tcity\tc,\tthen\tcity\ta\tis\talso\tconnected\tto\tcity\tc. The\tequivalence\tclass\tof\tan\telement\ta\t\u2208\tS\tis\ta\tsubset\tof\tS\tthat\tcontains\tall\tthe\telements\tthat\tare related\tto\ta.\tEquivalence\tclasses\tcreate\ta\tpartition\tof\tS.\tEvery\tmember\tof\tS\tappears\tin\texactly one\tequivalence\tclass.\tTo\tdecide\tif\ta\tR\tb,\twe\tjust\tneed\tto\tcheck\twhether\ta\tand\tb\tare\tin\tthe\tsame equivalence\tclass\t(group)\tor\tnot. In\tthe\tabove\texample,\ttwo\tcities\twill\tbe\tin\tsame\tequivalence\tclass\tif\tthey\thave\trail\tconnectivity. If\tthey\tdo\tnot\thave\tconnectivity\tthen\tthey\twill\tbe\tpart\tof\tdifferent\tequivalence\tclasses. Since\tthe\tintersection\tof\tany\ttwo\tequivalence\tclasses\tis\tempty\t(\u03d5),\tthe\tequivalence\tclasses\tare sometimes\tcalled\tdisjoint\tsets.\tIn\tthe\tsubsequent\tsections,\twe\twill\ttry\tto\tsee\tthe\toperations\tthat can\tbe\tperformed\ton\tequivalence\tclasses.\tThe\tpossible\toperations\tare: \u2022 Creating\tan\tequivalence\tclass\t(making\ta\tset) \u2022 Finding\tthe\tequivalence\tclass\tname\t(Find) \u2022 Combining\tthe\tequivalence\tclasses\t(Union)"
            },
            {
                "subchapter_title": "8.3\tDisjoint\tSets\tADT",
                "content": "To\t manipulate\t the\t set\t elements\t we\t need\t basic\t operations\t defined\t on\t sets.\t In\t this\t chapter,\t we concentrate\ton\tthe\tfollowing\tset\toperations: \u2022 MAKESET(X):\tCreates\ta\tnew\tset\tcontaining\ta\tsingle\telement\tX. \u2022 UNION(X,\tY):\tCreates\ta\tnew\tset\tcontaining\tthe\telements\tX\tand\tY\tin\ttheir\tunion\tand deletes\tthe\tsets\tcontaining\tthe\telements\tX\tand\tY. \u2022 FIND(X):\tReturns\tthe\tname\tof\tthe\tset\tcontaining\tthe\telement\tX."
            },
            {
                "subchapter_title": "8.4\tApplications",
                "content": "Disjoint\tsets\tADT\thave\tmany\tapplications\tand\ta\tfew\tof\tthem\tare: \u2022 To\trepresent\tnetwork\tconnectivity \u2022 Image\tprocessing \u2022 To\tfind\tleast\tcommon\tancestor \u2022 To\tdefine\tequivalence\tof\tfinite\tstate\tautomata \u2022 Kruskal\u2019s\tminimum\tspanning\ttree\talgorithm\t(graph\ttheory) \u2022 In\tgame\talgorithms"
            },
            {
                "subchapter_title": "8.5\tTradeoffs\tin\tImplementing\tDisjoint\tSets\tADT",
                "content": "Let\tus\tsee\tthe\tpossibilities\tfor\timplementing\tdisjoint\tset\toperations.\tInitially,\tassume\tthe\tinput elements\t are\t a\t collection\t of\t n\t sets,\t each\t with\t one\t element.\t That\t means,\t initial\t representation assumes\tall\trelations\t(except\treflexive\trelations)\tare\tfalse.\tEach\tset\thas\ta\tdifferent\telement,\tso that\tSi\t\u2229\tSj=\t\u0444.\tThis\tmakes\tthe\tsets\tdisjoint. To\tadd\tthe\trelation\ta\tR\tb\t(UNION),\twe\tfirst\tneed\tto\tcheck\twhether\ta\tand\tb\tare\talready\trelated\tor not.\tThis\tcan\tbe\tverified\tby\tperforming\tFINDs\ton\tboth\ta\tand\tb\tand\tchecking\twhether\tthey\tare\tin the\tsame\tequivalence\tclass\t(set)\tor\tnot. If\t they\t are\t not,\t then\t we\t apply\t UNION.\t This\t operation\t merges\t the\t two\t equivalence\t classes containing\ta\tand\tb\tinto\ta\tnew\tequivalence\tclass\tby\tcreating\ta\tnew\tset\tSk\t=\tSi\t\u222a\tSj\tand\tdeletes\tSi and\tSj.\tBasically\tthere\tare\ttwo\tways\tto\timplement\tthe\tabove\tFIND/UNION\toperations: \u2022 Fast\tFIND\timplementation\t(also\tcalled\tQuick\tFIND) \u2022 Fast\tUNION\toperation\timplementation\t(also\tcalled\tQuick\tUNION)"
            },
            {
                "subchapter_title": "8.6\tFast\tFIND\tImplementation\t(Quick\tFIND)",
                "content": "In\tthis\tmethod,\twe\tuse\tan\tarray.\tAs\tan\texample,\tin\tthe\trepresentation\tbelow\tthe\tarray\tcontains\tthe set\t name\t for\t each\t element.\t For\t simplicity,\t let\t us\t assume\t that\t all\t the\t elements\t are\t numbered sequentially\tfrom\t0\tto\tn\t\u2013\t1. In\tthe\texample\tbelow,\telement\t0\thas\tthe\tset\tname\t3,\telement\t1\thas\tthe\tset\tname\t5,\tand\tso\ton.\tWith this\t representation\t FIND\t takes\t only\t O(1)\t since\t for\t any\t element\t we\t can\t find\t the\t set\t name\t by accessing\tits\tarray\tlocation\tin\tconstant\ttime. In\tthis\trepresentation,\tto\tperform\tUNION(a,\tb)\t[assuming\tthat\ta\tis\tin\tset\ti\tand\tb\tis\tin\tset\tj]\twe need\tto\tscan\tthe\tcomplete\tarray\tand\tchange\tall\ti\u2019s\tto\tj.\tThis\ttakes\tO(n). A\tsequence\tof\tn\t\u2013\t1\tunions\ttake\tO(n2)\ttime\tin\tthe\tworst\tcase.\tIf\tthere\tare\tO(n2)\tFIND\toperations, this\t performance\t is\t fine,\t as\t the\t average\t time\t complexity\t is\t O(1)\t for\t each\t UNION\t or\t FIND operation.\tIf\tthere\tare\tfewer\tFINDs,\tthis\tcomplexity\tis\tnot\tacceptable."
            },
            {
                "subchapter_title": "8.7\tFast\tUNION\tImplementation\t(Quick\tUNION)",
                "content": "In\t this\t and\t subsequent\t sections,\t we\t will\t discuss\t the\t faster\t UNION\t implementations\t and\t its variants.\tThere\tare\tdifferent\tways\tof\timplementing\tthis\tapproach\tand\tthe\tfollowing\tis\ta\tlist\tof\ta few\tof\tthem. \u2022 Fast\tUNION\timplementations\t(Slow\tFIND) \u2022 Fast\tUNION\timplementations\t(Quick\tFIND) \u2022 Fast\tUNION\timplementations\twith\tpath\tcompression"
            },
            {
                "subchapter_title": "8.8\tFast\tUNION\tImplementation\t(Slow\tFIND)",
                "content": "As\twe\thave\tdiscussed,\tFIND\toperation\treturns\tthe\tsame\tanswer\t(set\tname)\tif\tand\tonly\tif\tthey\tare in\tthe\tsame\tset.\tIn\trepresenting\tdisjoint\tsets,\tour\tmain\tobjective\tis\tto\tgive\ta\tdifferent\tset\tname\tfor each\tgroup.\tIn\tgeneral\twe\tdo\tnot\tcare\tabout\tthe\tname\tof\tthe\tset.\tOne\tpossibility\tfor\timplementing the\tset\tis\ttree\tas\teach\telement\thas\tonly\tone\troot\tand\twe\tcan\tuse\tit\tas\tthe\tset\tname. How\tare\tthese\trepresented?\tOne\tpossibility\tis\tusing\tan\tarray:\tfor\teach\telement\tkeep\tthe\troot\tas its\tset\tname.\tBut\twith\tthis\trepresentation,\twe\twill\thave\tthe\tsame\tproblem\tas\tthat\tof\tFIND\tarray implementation.\tTo\tsolve\tthis\tproblem,\tinstead\tof\tstoring\tthe\troot\twe\tcan\tkeep\tthe\tparent\tof\tthe element.\tTherefore,\tusing\tan\tarray\twhich\tstores\tthe\tparent\tof\teach\telement\tsolves\tour\tproblem. To\tdifferentiate\tthe\troot\tnode,\tlet\tus\tassume\tits\tparent\tis\tthe\tsame\tas\tthat\tof\tthe\telement\tin\tthe array.\tBased\ton\tthis\trepresentation,\tMAKESET,\tFIND,\tUNION\toperations\tcan\tbe\tdefined\tas: \u2022 (X):\t Creates\t a\t new\t set\t containing\t a\t single\t element\t X\t and\t in\t the\t array\t update\t the parent\tof\tX\tas\tX.\tThat\tmeans\troot\t(set\tname)\tof\tX\tis\tX. \u2022 UNION(X,\tY):\tReplaces\tthe\ttwo\tsets\tcontaining\tX\tand\tY\tby\ttheir\tunion\tand\tin\tthe array\tupdates\tthe\tparent\tof\tX\tas\tY. \u2022 FIND(X):\t Returns\t the\t name\t of\t the\t set\t containing\t the\t element\t X.\t We\t keep\t on searching\tfor\tX\u2019s\tset\tname\tuntil\twe\tcome\tto\tthe\troot\tof\tthe\ttree. For\tthe\telements\t0\tto\tn\t\u2013\t1\tthe\tinitial\trepresentation\tis: To\tperform\ta\tUNION\ton\ttwo\tsets,\twe\tmerge\tthe\ttwo\ttrees\tby\tmaking\tthe\troot\tof\tone\ttree\tpoint\tto the\troot\tof\tthe\tother. Initial\tConfiguration\tfor\tthe\telements\t0\tto\t6 After\tUNION(5,6) After\tUNION(\t1,2) After\tUNION(0,2) One\timportant\tthing\tto\tobserve\there\tis,\tUNION\toperation\tis\tchanging\tthe\troot\u2019s\tparent\tonly,\tbut not\tfor\tall\tthe\telements\tin\tthe\tsets.\tDue\tto\tthis,\tthe\ttime\tcomplexity\tof\tUNION\toperation\tis\tO(1). A\tFIND(X)\ton\telement\tX\tis\tperformed\tby\treturning\tthe\troot\tof\tthe\ttree\tcontaining\tX.\tThe\ttime\tto perform\tthis\toperation\tis\tproportional\tto\tthe\tdepth\tof\tthe\tnode\trepresenting\tX. Using\tthis\tmethod,\tit\tis\tpossible\tto\tcreate\ta\ttree\tof\tdepth\tn\t-\t1\t(Skew\tTrees).\tThe\tworst-case running\ttime\tof\ta\tFIND\tis\tO(n)\tand\tm\tconsecutive\tFIND\toperations\ttake\tO(mn)\ttime\tin\tthe\tworst case. MAKESET FIND UNION"
            },
            {
                "subchapter_title": "8.9\tFast\tUNION\tImplementations\t(Quick\tFIND)",
                "content": "The\tmain\tproblem\twith\tthe\tprevious\tapproach\tis\tthat,\tin\tthe\tworst\tcase\twe\tare\tgetting\tthe\tskew trees\tand\tas\ta\tresult\tthe\tFIND\toperation\tis\ttaking\tO(n)\ttime\tcomplexity.\tThere\tare\ttwo\tways\tto improve\tit: \u2022 UNION\tby\tSize\t(also\tcalled\tUNION\tby\tWeight):\tMake\tthe\tsmaller\ttree\ta\tsubtree\tof the\tlarger\ttree \u2022 UNION\tby\tHeight\t(also\tcalled\tUNION\tby\tRank):\tMake\tthe\ttree\twith\tless\theight\ta subtree\tof\tthe\ttree\twith\tmore\theight UNION\tby\tSize In\tthe\tearlier\trepresentation,\tfor\teach\telement\ti\twe\thave\tstored\ti\t(in\tthe\tparent\tarray)\tfor\tthe\troot element\t and\t for\t other\t elements\t we\t have\t stored\t the\t parent\t of\t i.\t But\t in\t this\t approach\t we\t store negative\tof\tthe\tsize\tof\tthe\ttree\t(that\tmeans,\tif\tthe\tsize\tof\tthe\ttree\tis\t3\tthen\tstore\t\u20133\tin\tthe\tparent array\tfor\tthe\troot\telement).\tFor\tthe\tprevious\texample\t(after\tUNION(0,2)),\tthe\tnew\trepresentation will\tlook\tlike: Assume\tthat\tthe\tsize\tof\tone\telement\tset\tis\t1\tand\tstore\t\u2013\t1.\tOther\tthan\tthis\tthere\tis\tno\tchange. MAKESET FIND UNION\tby\tSize Note:\tThere\tis\tno\tchange\tin\tFIND\toperation\timplementation. UNION\tby\tHeight\t(UNION\tby\tRank) As\tin\tUNION\tby\tsize,\tin\tthis\tmethod\twe\tstore\tnegative\tof\theight\tof\tthe\ttree\t(that\tmeans,\tif\tthe height\tof\tthe\ttree\tis\t3\tthen\twe\tstore\t\u20133\tin\tthe\tparent\tarray\tfor\tthe\troot\telement).\tWe\tassume\tthe height\tof\ta\ttree\twith\tone\telement\tset\tis\t1.\tFor\tthe\tprevious\texample\t(after\tUNION(0,2)),\tthe\tnew representation\twill\tlook\tlike: UNION\tby\tHeight Note:\tFor\tFIND\toperation\tthere\tis\tno\tchange\tin\tthe\timplementation. Comparing\tUNION\tby\tSize\tand\tUNION\tby\tHeight With\tUNION\tby\tsize,\tthe\tdepth\tof\tany\tnode\tis\tnever\tmore\tthan\tlogn.\tThis\tis\tbecause\ta\tnode\tis initially\tat\tdepth\t0.\tWhen\tits\tdepth\tincreases\tas\ta\tresult\tof\ta\tUNION,\tit\tis\tplaced\tin\ta\ttree\tthat\tis at\tleast\ttwice\tas\tlarge\tas\tbefore.\tThat\tmeans\tits\tdepth\tcan\tbe\tincreased\tat\tmost\tlogn\ttimes.\tThis means\tthat\tthe\trunning\ttime\tfor\ta\tFIND\toperation\tis\tO(logn),\tand\ta\tsequence\tof\tm\t operations takes\tO(m\tlogn). Similarly\twith\tUNION\tby\theight,\tif\twe\ttake\tthe\tUNION\tof\ttwo\ttrees\tof\tthe\tsame\theight,\tthe\theight of\tthe\tUNION\tis\tone\tlarger\tthan\tthe\tcommon\theight,\tand\totherwise\tequal\tto\tthe\tmax\tof\tthe\ttwo heights.\tThis\twill\tkeep\tthe\theight\tof\ttree\tof\tn\tnodes\tfrom\tgrowing\tpast\tO(logn).\tA\tsequence\tof\tm UNIONs\tand\tFINDs\tcan\tthen\tstill\tcost\tO(m\tlogn). Path\tCompression FIND\t operation\t traverses\t a\t list\t of\t nodes\t on\t the\t way\t to\t the\t root.\t We\t can\t make\t later\t FIND operations\tefficient\tby\tmaking\teach\tof\tthese\tvertices\tpoint\tdirectly\tto\tthe\troot.\tThis\tprocess\tis called\tpath\tcompression.\tFor\texample,\tin\tthe\tFIND(X)\toperation,\twe\ttravel\tfrom\tX\tto\tthe\troot\tof the\ttree.\tThe\teffect\tof\tpath\tcompression\tis\tthat\tevery\tnode\ton\tthe\tpath\tfrom\tX\tto\tthe\troot\thas\tits parent\tchanged\tto\tthe\troot. With\tpath\tcompression\tthe\tonly\tchange\tto\tthe\tFIND\tfunction\tis\tthat\tS[X]\tis\tmade\tequal\tto\tthe value\treturned\tby\tFIND.\tThat\tmeans,\tafter\tthe\troot\tof\tthe\tset\tis\tfound\trecursively,\tX\tis\tmade\tto point\tdirectly\tto\tit.\tThis\thappen\trecursively\tto\tevery\tnode\ton\tthe\tpath\tto\tthe\troot. FIND\twith\tpath\tcompression Note:\tPath\tcompression\tis\tcompatible\twith\tUNION\tby\tsize\tbut\tnot\twith\tUNION\tby\theight\tas there\tis\tno\tefficient\tway\tto\tchange\tthe\theight\tof\tthe\ttree."
            },
            {
                "subchapter_title": "8.10\tSummary",
                "content": "Performing\tm\tunion-find\toperations\ton\ta\tset\tof\tn\tobjects. Algorithm Worst-case\ttime Quick-Find mn Quick-Union mn Quick-Union\tby\tSize/Height n\t+\tm\tlogn Path\tcompression n\t+\tm\tlogn Quick-Union\tby\tSize/Height\t+\tPath\tCompression (m\t+\tn)\tlogn"
            },
            {
                "subchapter_title": "8.11\tDisjoint\tSets:\tProblems\t&\tSolutions",
                "content": "Problem-1\u2003\u2003Consider\ta\tlist\tof\tcities\tc1;\tc2,...,cn.\tAssume\tthat\twe\thave\ta\trelation\tR\tsuch\tthat, for\tany\ti,j,\tR(ci,cj)\tis\t1\tif\tcities\tci\tand\tcj\tare\tin\tthe\tsame\tstate,\tand\t0\totherwise.\tIf\tR\t is stored\tas\ta\ttable,\thow\tmuch\tspace\tdoes\tit\trequire? Solution:\tR\tmust\thave\tan\tentry\tfor\tevery\tpair\tof\tcities.\tThere\tare\t\u0398(n2)\tof\tthese. Problem-2\u2003\u2003For\tProblem-1,\tusing\ta\tDisjoint\tsets\tADT,\tgive\tan\talgorithm\tthat\tputs\teach\tcity\tin a\tset\tsuch\tthat\tci\tand\tcj\tare\tin\tthe\tsame\tset\tif\tand\tonly\tif\tthey\tare\tin\tthe\tsame\tstate. Solution: Problem-3\u2003\u2003For\tProblem-1,\twhen\tthe\tcities\tare\tstored\tin\tthe\tDisjoint\tsets\tADT,\tif\twe\tare given\ttwo\tcities\tci\tand\tcj,\thow\tdo\twe\tcheck\tif\tthey\tare\tin\tthe\tsame\tstate? Solution:\tCities\tci\tand\tcj\tare\tin\tthe\tsame\tstate\tif\tand\tonly\tif\tFIND(ci)\t=\tFIND(cj). Problem-4\u2003\u2003For\t Problem-1,\t if\t we\t use\t linked-lists\t with\t UNION\t by\t size\t to\t implement\t the union-find\tADT,\thow\tmuch\tspace\tdo\twe\tuse\tto\tstore\tthe\tcities? Solution:\tThere\tis\tone\tnode\tper\tcity,\tso\tthe\tspace\tis\t\u0398(n). Problem-5\u2003\u2003For\t Problem-1,\t if\t we\t use\t trees\t with\t UNION\t by\t rank,\t what\t is\t the\t worst-case running\ttime\tof\tthe\talgorithm\tfrom\tProblem-2? Solution:\tWhenever\twe\tdo\ta\tUNION\tin\tthe\talgorithm\tfrom\tProblem-2,\tthe\tsecond\targument\tis\ta tree\tof\tsize\t1.\tTherefore,\tall\ttrees\thave\theight\t1,\tso\teach\tunion\ttakes\ttime\tO(1).\tThe\tworst-case running\ttime\tis\tthen\t\u0398(n2). Problem-6\u2003\u2003If\twe\tuse\ttrees\twithout\tunion-by-rank,\twhat\tis\tthe\tworst-case\trunning\ttime\tof\tthe algorithm\tfrom\tProblem-2?\tAre\tthere\tmore\tworst-case\tscenarios\tthan\tProblem-5? Solution:\tBecause\tof\tthe\tspecial\tcase\tof\tthe\tunions,\tunion-by-rank\tdoes\tnot\tmake\ta\tdifference\tfor our\talgorithm.\tHence,\teverything\tis\tthe\tsame\tas\tin\tProblem-5. Problem-7\u2003\u2003With\tthe\tquick-union\talgorithm\twe\tknow\tthat\ta\tsequence\tof\tn\toperations\t(unions and\tfinds)\tcan\ttake\tslightly\tmore\tthan\tlinear\ttime\tin\tthe\tworst\tcase.\tExplain\twhy\tif\tall\tthe finds\tare\tdone\tbefore\tall\tthe\tunions,\ta\tsequence\tof\tn\toperations\tis\tguaranteed\tto\ttake\tO(n) time. Solution:\tIf\tthe\tfind\toperations\tare\tperformed\tfirst,\tthen\tthe\tfind\toperations\ttake\tO(1)\ttime\teach because\tevery\titem\tis\tthe\troot\tof\tits\town\ttree.\tNo\titem\thas\ta\tparent,\tso\tfinding\tthe\tset\tan\titem\tis\tin takes\ta\tfixed\tnumber\tof\toperations.\tUnion\toperations\talways\ttake\tO(1)\ttime.\tHence,\ta\tsequence of\tn\toperations\twith\tall\tthe\tfinds\tbefore\tthe\tunions\ttakes\tO(n)\ttime. Problem-8\u2003\u2003With\treference\tto\tProblem-7,\texplain\twhy\tif\tall\tthe\tunions\tare\tdone\tbefore\tall\tthe finds,\ta\tsequence\tof\tn\toperations\tis\tguaranteed\tto\ttake\tO(n)\ttime. Solution:\tThis\tproblem\trequires\tamortized\tanalysis.\tFind\toperations\tcan\tbe\texpensive,\tbut\tthis expensive\tfind\toperation\tis\tbalanced\tout\tby\tlots\tof\tcheap\tunion\toperations. The\taccounting\tis\tas\tfollows.\tUnion\toperations\talways\ttake\tO(1)\ttime,\tso\tlet\u2019s\tsay\tthey\thave\tan actual\t cost\t of"
            }
        ]
    },
    {
        "chapter_title": "1.\t Assign\t each\t union\t operation\t an\t amortized\t cost\t of",
        "subchapters": [
            {
                "subchapter_title": "2,\t so\t every\t union",
                "content": "operation\tputs\t 1\tin\tthe\taccount.\tEach\tunion\toperation\tcreates\ta\tnew\tchild.\t(Some\tnode\tthat was\tnot\ta\tchild\tof\tany\tother\tnode\tbefore\tis\ta\tchild\tnow.)\tWhen\tall\tthe\tunion\toperations\tare\tdone, there\tis\t$1\tin\tthe\taccount\tfor\tevery\tchild,\tor\tin\tother\twords,\tfor\tevery\tnode\twith\ta\tdepth\tof\tone\tor greater.\tLet\u2019s\tsay\tthat\ta\tfind(u)\toperation\tcosts\t 1\tif\tu\tis\ta\troot.\tFor\tany\tother\tnode,\tthe\tfind operation\tcosts\tan\tadditional\t 1\tfor\teach\tparent\tpointer\tthe\tfind\toperation\ttraverses.\tSo\tthe actual\tcost\tis\t \t(1\t+\td),\twhere\td\tis\tthe\tdepth\tof\tu.\tAssign\teach\tfind\toperation\tan\tamortized\tcost of"
            }
        ]
    },
    {
        "chapter_title": "2.\tThis\tcovers\tthe\tcase\twhere\tu\tis\ta\troot\tor\ta\tchild\tof\ta\troot.\tFor\teach\tadditional\tparent",
        "subchapters": [
            {
                "subchapter_title": "pointer\ttraversed,",
                "content": "1\tis\twithdrawn\tfrom\tthe\taccount\tto\tpay\tfor\tit. Fortunately,\t path\t compression\t changes\t the\t parent\t pointers\t of\t all\t the\t nodes\t we\t pay\t 1\t to traverse,\tso\tthese\tnodes\tbecome\tchildren\tof\tthe\troot.\tAll\tof\tthe\ttraversed\tnodes\twhose\tdepths\tare 2\tor\tgreater\tmove\tup,\tso\ttheir\tdepths\tare\tnow\t1.\tWe\twill\tnever\thave\tto\tpay\tto\ttraverse\tthese nodes\tagain.\tSay\tthat\ta\tnode\tis\ta\tgrandchild\tif\tits\tdepth\tis\t2\tor\tgreater. Every\ttime\tfind(u)\tvisits\ta\tgrandchild,\t 1\tis\twithdrawn\tfrom\tthe\taccount,\tbut\tthe\tgrandchild\tis no\tlonger\ta\tgrandchild.\tSo\tthe\tmaximum\tnumber\tof\tdollars\tthat\tcan\tever\tbe\twithdrawn\tfrom\tthe account\tis\tthe\tnumber\tof\tgrandchildren.\tBut\twe\tinitially\tput\t$1\tin\tthe\tbank\tfor\tevery\tchild,\tand every\t grandchild\t is\t a\t child,\t so\t the\t bank\t balance\t will\t never\t drop\t below\t zero.\t Therefore,\t the amortization\tworks\tout.\tUnion\tand\tfind\toperations\tboth\thave\tamortized\tcosts\tof\t 2,\t so\t any sequence\tof\tn\toperations\twhere\tall\tthe\tunions\tare\tdone\tfirst\ttakes\tO(n)\ttime."
            },
            {
                "subchapter_title": "9.1\tIntroduction",
                "content": "In\tthe\treal\tworld,\tmany\tproblems\tare\trepresented\tin\tterms\tof\tobjects\tand\tconnections\tbetween them.\tFor\texample,\tin\tan\tairline\troute\tmap,\twe\tmight\tbe\tinterested\tin\tquestions\tlike:\t\u201cWhat\u2019s\tthe fastest\t way\t to\t go\t from\t Hyderabad\t to\t New\t York?\u201d\t or\t \u201cWhat\t is\t the\t cheapest\t way\t to\t go\t from Hyderabad\t to\t New\t York?\u201d\t To\t answer\t these\t questions\t we\t need\t information\t about\t connections (airline\troutes)\tbetween\tobjects\t(towns).\tGraphs\tare\tdata\tstructures\tused\tfor\tsolving\tthese\tkinds of\tproblems."
            },
            {
                "subchapter_title": "9.2\tGlossary",
                "content": "Graph:\tA\tgraph\tis\ta\tpair\t(V,\tE),\twhere\tV\tis\ta\tset\tof\tnodes,\tcalled\tvertices,\tand\t\u00a3\tis\ta\tcollection of\tpairs\tof\tvertices,\tcalled\tedges. \u2022 Vertices\tand\tedges\tare\tpositions\tand\tstore\telements \u2022 Definitions\tthat\twe\tuse: \u25cb Directed\tedge: \u25aa ordered\tpair\tof\tvertices\t(u,\tv) \u25aa first\tvertex\tu\tis\tthe\torigin \u25aa second\tvertex\tv\tis\tthe\tdestination \u25aa Example:\tone-way\troad\ttraffic \u25cb Undirected\tedge: \u25aa unordered\tpair\tof\tvertices\t(u,\tv) \u25aa Example:\trailway\tlines \u25cb Directed\tgraph: \u25aa all\tthe\tedges\tare\tdirected \u25aa Example:\troute\tnetwork \u25cb\tUndirected\tgraph: \u25aa all\tthe\tedges\tare\tundirected \u25aa Example:\tflight\tnetwork \u2022 When\tan\tedge\tconnects\ttwo\tvertices,\tthe\tvertices\tare\tsaid\tto\tbe\tadjacent\tto\teach other\tand\tthe\tedge\tis\tincident\ton\tboth\tvertices. \u2022 A\tgraph\twith\tno\tcycles\tis\tcalled\ta\ttree.\tA\ttree\tis\tan\tacyclic\tconnected\tgraph. \u2022 A\tself\tloop\tis\tan\tedge\tthat\tconnects\ta\tvertex\tto\titself. \u2022 Two\tedges\tare\tparallel\tif\tthey\tconnect\tthe\tsame\tpair\tof\tvertices. \u2022 The\tDegree\tof\ta\tvertex\tis\tthe\tnumber\tof\tedges\tincident\ton\tit. \u2022 A\t subgraph\t is\t a\t subset\t of\t a\t graph\u2019s\t edges\t (with\t associated\t vertices)\t that\t form\t a graph. \u2022 A\tpath\tin\ta\tgraph\tis\ta\tsequence\tof\tadjacent\tvertices.\tSimple\tpath\tis\ta\tpath\twith\tno repeated\tvertices.\tIn\tthe\tgraph\tbelow,\tthe\tdotted\tlines\trepresent\ta\tpath\tfrom\tG\tto\tE. \u2022 A\tcycle\tis\ta\tpath\twhere\tthe\tfirst\tand\tlast\tvertices\tare\tthe\tsame.\tA\tsimple\tcycle\tis\ta cycle\twith\tno\trepeated\tvertices\tor\tedges\t(except\tthe\tfirst\tand\tlast\tvertices). \u2022 We\tsay\tthat\tone\tvertex\tis\tconnected\tto\tanother\tif\tthere\tis\ta\tpath\tthat\tcontains\tboth\tof them. \u2022 A\tgraph\tis\tconnected\tif\tthere\tis\ta\tpath\tfrom\tevery\tvertex\tto\tevery\tother\tvertex. \u2022 If\ta\tgraph\tis\tnot\tconnected\tthen\tit\tconsists\tof\ta\tset\tof\tconnected\tcomponents. \u2022 A\tdirected\tacyclic\tgraph\t[DAG]\tis\ta\tdirected\tgraph\twith\tno\tcycles. \u2022 A\tforest\tis\ta\tdisjoint\tset\tof\ttrees. \u2022 A\tspanning\ttree\tof\ta\tconnected\tgraph\tis\ta\tsubgraph\tthat\tcontains\tall\tof\tthat\tgraph\u2019s vertices\tand\tis\ta\tsingle\ttree.\tA\tspanning\tforest\tof\ta\tgraph\tis\tthe\tunion\tof\tspanning trees\tof\tits\tconnected\tcomponents. \u2022 A\tbipartite\tgraph\tis\ta\tgraph\twhose\tvertices\tcan\tbe\tdivided\tinto\ttwo\tsets\tsuch\tthat\tall edges\tconnect\ta\tvertex\tin\tone\tset\twith\ta\tvertex\tin\tthe\tother\tset. \u2022 In\t weighted\t graphs\t integers\t (weights)\t are\t assigned\t to\t each\t edge\t to\t represent (distances\tor\tcosts). \u2022 Graphs\twith\tall\tedges\tpresent\tare\tcalled\tcomplete\tgraphs. \u2022 Graphs\t with\t relatively\t few\t edges\t (generally\t if\t it\t edges\t <\t |V|\t log\t |V|)\t are\t called sparse\tgraphs. \u2022 Graphs\twith\trelatively\tfew\tof\tthe\tpossible\tedges\tmissing\tare\tcalled\tdense. \u2022 Directed\tweighted\tgraphs\tare\tsometimes\tcalled\tnetwork. \u2022 We\twill\tdenote\tthe\tnumber\tof\tvertices\tin\ta\tgiven\tgraph\tby\t|V|,\tand\tthe\tnumber\tof edges\tby\t|E|.\tNote\tthat\tE\tcan\trange\tanywhere\tfrom\t0\tto\t|V|(|V|\t\u2013\tl)/2\t(in\tundirected graph).\tThis\tis\tbecause\teach\tnode\tcan\tconnect\tto\tevery\tother\tnode."
            },
            {
                "subchapter_title": "9.3\tApplications\tof\tGraphs",
                "content": "\u2022 Representing\trelationships\tbetween\tcomponents\tin\telectronic\tcircuits \u2022 Transportation\tnetworks:\tHighway\tnetwork,\tFlight\tnetwork \u2022 Computer\tnetworks:\tLocal\tarea\tnetwork,\tInternet,\tWeb \u2022 Databases:\t For\t representing\t ER\t (Entity\t Relationship)\t diagrams\t in\t databases,\t for representing\tdependency\tof\ttables\tin\tdatabases"
            },
            {
                "subchapter_title": "9.4\tGraph\tRepresentation",
                "content": "As\tin\tother\tADTs,\tto\tmanipulate\tgraphs\twe\tneed\tto\trepresent\tthem\tin\tsome\tuseful\tform.\tBasically, there\tare\tthree\tways\tof\tdoing\tthis: \u2022 Adjacency\tMatrix \u2022 Adjacency\tList \u2022 Adjacency\tSet Adjacency\tMatrix Graph\tDeclaration\tfor\tAdjacency\tMatrix First,\tlet\tus\tlook\tat\tthe\tcomponents\tof\tthe\tgraph\tdata\tstructure.\tTo\trepresent\tgraphs,\twe\tneed\tthe number\tof\tvertices,\tthe\tnumber\tof\tedges\tand\talso\ttheir\tinterconnections.\tSo,\tthe\tgraph\tcan\tbe declared\tas: Description In\tthis\tmethod,\twe\tuse\ta\tmatrix\twith\tsize\tV\t\u00d7\tV.\tThe\tvalues\tof\tmatrix\tare\tboolean.\tLet\tus\tassume the\tmatrix\tis\tAdj.\tThe\tvalue\tAdj[u,\tv]\tis\tset\tto\t1\tif\tthere\tis\tan\tedge\tfrom\tvertex\tu\tto\tvertex\tv\tand\t0 otherwise. In\tthe\tmatrix,\teach\tedge\tis\trepresented\tby\ttwo\tbits\tfor\tundirected\tgraphs.\tThat\tmeans,\tan\tedge from\tu\tto\tv\tis\trepresented\tby\t1\tvalue\tin\tboth\tAdj[u,v\t]\tand\tAdj[u,v].\tTo\tsave\ttime,\twe\tcan\tprocess only\thalf\tof\tthis\tsymmetric\tmatrix.\tAlso,\twe\tcan\tassume\tthat\tthere\tis\tan\t\u201cedge\u201d\tfrom\teach\tvertex to\titself.\tSo,\tAdj[u,\tu]\tis\tset\tto\t1\tfor\tall\tvertices. If\tthe\tgraph\tis\ta\tdirected\tgraph\tthen\twe\tneed\tto\tmark\tonly\tone\tentry\tin\tthe\tadjacency\tmatrix.\tAs\tan example,\tconsider\tthe\tdirected\tgraph\tbelow. The\tadjacency\tmatrix\tfor\tthis\tgraph\tcan\tbe\tgiven\tas: Now,\tlet\tus\tconcentrate\ton\tthe\timplementation.\tTo\tread\ta\tgraph,\tone\tway\tis\tto\tfirst\tread\tthe\tvertex names\tand\tthen\tread\tpairs\tof\tvertex\tnames\t(edges).\tThe\tcode\tbelow\treads\tan\tundirected\tgraph. The\tadjacency\tmatrix\trepresentation\tis\tgood\tif\tthe\tgraphs\tare\tdense.\tThe\tmatrix\trequires\tO(V2) bits\tof\tstorage\tand\tO(V2)\ttime\tfor\tinitialization.\tIf\tthe\tnumber\tof\tedges\tis\tproportional\tto\tV2,\tthen there\tis\tno\tproblem\tbecause\tV2\tsteps\tare\trequired\tto\tread\tthe\tedges.\tIf\tthe\tgraph\tis\tsparse,\tthe initialization\tof\tthe\tmatrix\tdominates\tthe\trunning\ttime\tof\tthe\talgorithm\tas\tit\ttakes\ttakes\tO(V2). Adjacency\tList Graph\tDeclaration\tfor\tAdjacency\tList In\tthis\trepresentation\tall\tthe\tvertices\tconnected\tto\ta\tvertex\tv\tare\tlisted\ton\tan\tadjacency\tlist\tfor that\tvertex\tv.\tThis\tcan\tbe\teasily\timplemented\twith\tlinked\tlists.\tThat\tmeans,\tfor\teach\tvertex\tv\twe use\ta\tlinked\tlist\tand\tlist\tnodes\trepresents\tthe\tconnections\tbetween\tv\tand\tother\tvertices\tto\twhich\tv has\tan\tedge. The\ttotal\tnumber\tof\tlinked\tlists\tis\tequal\tto\tthe\tnumber\tof\tvertices\tin\tthe\tgraph.\tThe\tgraph\tADT can\tbe\tdeclared\tas: Description Considering\tthe\tsame\texample\tas\tthat\tof\tthe\tadjacency\tmatrix,\tthe\tadjacency\tlist\trepresentation can\tbe\tgiven\tas: Since\tvertex\tA\thas\tan\tedge\tfor\tB\tand\tD,\twe\thave\tadded\tthem\tin\tthe\tadjacency\tlist\tfor\tA.\tThe same\tis\tthe\tcase\twith\tother\tvertices\tas\twell. For\t this\t representation,\t the\t order\t of\t edges\t in\t the\t input\t is\t important.\t This\t is\t because\t they determine\tthe\torder\tof\tthe\tvertices\ton\tthe\tadjacency\tlists.\tThe\tsame\tgraph\tcan\tbe\trepresented\tin many\tdifferent\tways\tin\tan\tadjacency\tlist.\tThe\torder\tin\twhich\tedges\tappear\ton\tthe\tadjacency\tlist affects\tthe\torder\tin\twhich\tedges\tare\tprocessed\tby\talgorithms. Disadvantages\tof\tAdjacency\tLists Using\t adjacency\t list\t representation\t we\t cannot\t perform\t some\t operations\t efficiently.\t As\t an example,\tconsider\tthe\tcase\tof\tdeleting\ta\tnode.\t.\tIn\tadjacency\tlist\trepresentation,\tit\tis\tnot\tenugh\tif we\tsimply\tdelete\ta\tnode\tfrom\tthe\tlist\trepresentation,\tif\twe\tdelete\ta\tnode\tfrom\tthe\tadjacency\tlist then\tthat\tis\tenough.\tFor\teach\tnode\ton\tthe\tadjacency\tlist\tof\tthat\tnode\tspecifies\tanother\tvertex.\tWe need\tto\tsearch\tother\tnodes\tlinked\tlist\talso\tfor\tdeleting\tit.\tThis\tproblem\tcan\tbe\tsolved\tby\tlinking the\t two\t list\t nodes\t that\t correspond\t to\t a\t particular\tedge\t and\t making\t the\t adjacency\t lists\t doubly linked.\tBut\tall\tthese\textra\tlinks\tare\trisky\tto\tprocess. Adjacency\tSet It\tis\tvery\tmuch\tsimilar\tto\tadjacency\tlist\tbut\tinstead\tof\tusing\tLinked\tlists,\tDisjoint\tSets\t[Union- Find]\tare\tused.\tFor\tmore\tdetails\trefer\tto\tthe\tDisjoint\tSets\tADT\tchapter. Comparison\tof\tGraph\tRepresentations Directed\tand\tundirected\tgraphs\tare\trepresented\twith\tthe\tsame\tstructures.\tFor\tdirected\tgraphs, everything\tis\tthe\tsame,\texcept\tthat\teach\tedge\tis\trepresented\tjust\tonce.\tAn\tedge\tfrom\tx\tto\ty\t is represented\tby\ta\t1\tvalue\tin\tAgj[x][y]\tin\tthe\tadjacency\tmatrix,\tor\tby\tadding\ty\ton\tx\u2019s\tadjacency\tlist. For\tweighted\tgraphs,\teverything\tis\tthe\tsame,\texcept\tfill\tthe\tadjacency\tmatrix\twith\tweights\tinstead of\tboolean\tvalues."
            },
            {
                "subchapter_title": "9.5\tGraph\tTraversals",
                "content": "To\tsolve\tproblems\ton\tgraphs,\twe\tneed\ta\tmechanism\tfor\ttraversing\tthe\tgraphs.\tGraph\ttraversal algorithms\t are\t also\t called\t graph\t search\t algorithms.\t Like\t trees\t traversal\t algorithms\t (Inorder, Preorder,\tPostorder\tand\tLevel-Order\ttraversals),\tgraph\tsearch\talgorithms\tcan\tbe\tthought\tof\tas starting\tat\tsome\tsource\tvertex\tin\ta\tgraph\tand\t\u201csearching\u201d\tthe\tgraph\tby\tgoing\tthrough\tthe\tedges\tand marking\tthe\tvertices.\tNow,\twe\twill\tdiscuss\ttwo\tsuch\talgorithms\tfor\ttraversing\tthe\tgraphs. \u2022 Depth\tFirst\tSearch\t[DFS] \u2022 Breadth\tFirst\tSearch\t[BFS] Depth\tFirst\tSearch\t[DFS] DFS\t algorithm\t works\t in\t a\t manner\t similar\t to\t preorder\t traversal\t of\t the\t trees.\t Like\t preorder traversal,\tinternally\tthis\talgorithm\talso\tuses\tstack. Let\tus\tconsider\tthe\tfollowing\texample.\tSuppose\ta\tperson\tis\ttrapped\tinside\ta\tmaze.\tTo\tcome\tout from\tthat\tmaze,\tthe\tperson\tvisits\teach\tpath\tand\teach\tintersection\t(in\tthe\tworst\tcase).\tLet\tus\tsay\tthe person\tuses\ttwo\tcolors\tof\tpaint\tto\tmark\tthe\tintersections\talready\tpassed.\tWhen\tdiscovering\ta\tnew intersection,\tit\tis\tmarked\tgrey,\tand\the\tcontinues\tto\tgo\tdeeper. After\treaching\ta\t\u201cdead\tend\u201d\tthe\tperson\tknows\tthat\tthere\tis\tno\tmore\tunexplored\tpath\tfrom\tthe\tgrey intersection,\twhich\tnow\tis\tcompleted,\tand\the\tmarks\tit\twith\tblack.\tThis\t\u201cdead\tend\u201d\tis\teither\tan intersection\twhich\thas\talready\tbeen\tmarked\tgrey\tor\tblack,\tor\tsimply\ta\tpath\tthat\tdoes\tnot\tlead\tto an\tintersection. The\t intersections\t of\t the\t maze\t are\t the\t vertices\t and\t the\t paths\t between\t the\t intersections\t are\t the edges\tof\tthe\tgraph.\tThe\tprocess\tof\treturning\tfrom\tthe\t\u201cdead\tend\u201d\tis\tcalled\tbacktracking.\tWe\tare trying\tto\tgo\taway\tfrom\tthe\tstarting\tvertex\tinto\tthe\tgraph\tas\tdeep\tas\tpossible,\tuntil\twe\thave\tto backtrack\tto\tthe\tpreceding\tgrey\tvertex.\tIn\tDFS\talgorithm,\twe\tencounter\tthe\tfollowing\ttypes\tof edges. Tree\tedge:\tencounter\tnew\tvertex Back\tedge:\tfrom\tdescendent\tto\tancestor Forward\tedge:\tfrom\tancestor\tto\tdescendent Cross\tedge:\tbetween\ta\ttree\tor\tsubtrees For\t most\t algorithms\t boolean\t classification,\t unvisited/visited\t is\t enough\t (for\t three\t color implementation\trefer\tto\tproblems\tsection).\tThat\tmeans,\tfor\tsome\tproblems\twe\tneed\tto\tuse\tthree colors,\tbut\tfor\tour\tdiscussion\ttwo\tcolors\tare\tenough. Initially\tall\tvertices\tare\tmarked\tunvisited\t(false).\tThe\tDFS\talgorithm\tstarts\tat\ta\tvertex\tu\tin\tthe graph.\tBy\tstarting\tat\tvertex\tu\tit\tconsiders\tthe\tedges\tfrom\tu\tto\tother\tvertices.\tIf\tthe\tedge\tleads\tto an\t already\t visited\t vertex,\t then\t backtrack\t to\t current\t vertex\t u.\t If\t an\t edge\t leads\t to\t an\t unvisited vertex,\tthen\tgo\tto\tthat\tvertex\tand\tstart\tprocessing\tfrom\tthat\tvertex.\tThat\tmeans\tthe\tnew\tvertex becomes\tthe\tcurrent\tvertex.\tFollow\tthis\tprocess\tuntil\twe\treach\tthe\tdead-end.\tAt\tthis\tpoint\tstart backtracking. The\tprocess\tterminates\twhen\tbacktracking\tleads\tback\tto\tthe\tstart\tvertex.\tThe\talgorithm\tbased\ton this\tmechanism\tis\tgiven\tbelow:\tassume\tVisited[]\tis\ta\tglobal\tarray. As\tan\texample,\tconsider\tthe\tfollowing\tgraph.\tWe\tcan\tsee\tthat\tsometimes\tan\tedge\tleads\tto\tan already\tdiscovered\tvertex.\tThese\tedges\tare\tcalled\tback\tedges,\tand\tthe\tother\tedges\tare\tcalled\ttree edges\tbecause\tdeleting\tthe\tback\tedges\tfrom\tthe\tgraph\tgenerates\ta\ttree. The\tfinal\tgenerated\ttree\tis\tcalled\tthe\tDFS\ttree\tand\tthe\torder\tin\twhich\tthe\tvertices\tare\tprocessed is\tcalled\tDFS\tnumbers\tof\tthe\tvertices.\tIn\tthe\tgraph\tbelow,\tthe\tgray\tcolor\tindicates\tthat\tthe\tvertex is\tvisited\t(there\tis\tno\tother\tsignificance).\tWe\tneed\tto\tsee\twhen\tthe\tVisited\ttable\tis\tupdated. From\t the\t above\t diagrams,\t it\t can\t be\t seen\t that\t the\t DFS\t traversal\t creates\t a\t tree\t (without\t back edges)\tand\twe\tcall\tsuch\ttree\ta\tDFS\ttree.\tThe\tabove\talgorithm\tworks\teven\tif\tthe\tgiven\tgraph\thas connected\tcomponents. The\ttime\tcomplexity\tof\tDFS\tis\tO(V\t+\tE),\tif\twe\tuse\tadjacency\tlists\tfor\trepresenting\tthe\tgraphs. This\tis\tbecause\twe\tare\tstarting\tat\ta\tvertex\tand\tprocessing\tthe\tadjacent\tnodes\tonly\tif\tthey\tare\tnot visited.\t Similarly,\t if\t an\t adjacency\t matrix\t is\t used\t for\t a\t graph\t representation,\t then\t all\t edges adjacent\tto\ta\tvertex\tcan\u2019t\tbe\tfound\tefficiently,\tand\tthis\tgives\tO(V2)\tcomplexity. Applications\tof\tDFS \u2022 Topological\tsorting \u2022 Finding\tconnected\tcomponents \u2022 Finding\tarticulation\tpoints\t(cut\tvertices)\tof\tthe\tgraph \u2022 Finding\tstrongly\tconnected\tcomponents \u2022 Solving\tpuzzles\tsuch\tas\tmazes For\talgorithms\trefer\tto\tProblems\tSection. Breadth\tFirst\tSearch\t[BFS] The\t BFS\t algorithm\t works\t similar\t to\t level\t \u2013\t order\t traversal\t of\t the\t trees.\t Like\t level\t \u2013\t order traversal,\t BFS\t also\t uses\t queues.\t In\t fact,\t level\t \u2013\t order\t traversal\t got\t inspired\t from\t BFS.\t BFS works\tlevel\tby\tlevel.\tInitially,\tBFS\tstarts\tat\ta\tgiven\tvertex,\twhich\tis\tat\tlevel\t0.\tIn\tthe\tfirst\tstage\tit visits\tall\tvertices\tat\tlevel\t1\t(that\tmeans,\tvertices\twhose\tdistance\tis\t1\tfrom\tthe\tstart\tvertex\tof\tthe graph).\tIn\tthe\tsecond\tstage,\tit\tvisits\tall\tvertices\tat\tthe\tsecond\tlevel.\tThese\tnew\tvertices\tare\tthe ones\twhich\tare\tadjacent\tto\tlevel\t1\tvertices. BFS\tcontinues\tthis\tprocess\tuntil\tall\tthe\tlevels\tof\tthe\tgraph\tare\tcompleted.\tGenerally\tqueue\tdata structure\tis\tused\tfor\tstoring\tthe\tvertices\tof\ta\tlevel. As\tsimilar\tto\tDFS,\tassume\tthat\tinitially\tall\tvertices\tare\tmarked\tunvisited\t(false).\tVertices\tthat have\tbeen\tprocessed\tand\tremoved\tfrom\tthe\tqueue\tare\tmarked\tvisited\t(true).\tWe\tuse\ta\tqueue\tto represent\tthe\tvisited\tset\tas\tit\twill\tkeep\tthe\tvertices\tin\tthe\torder\tof\twhen\tthey\twere\tfirst\tvisited. The\timplementation\tfor\tthe\tabove\tdiscussion\tcan\tbe\tgiven\tas: As\tan\texample,\tlet\tus\tconsider\tthe\tsame\tgraph\tas\tthat\tof\tthe\tDFS\texample.\tThe\tBFS\ttraversal\tcan be\tshown\tas: Time\tcomplexity\tof\tBFS\tis\tO(V\t+\tE),\tif\twe\tuse\tadjacency\tlists\tfor\trepresenting\tthe\tgraphs,\tand O(V2)\tfor\tadjacency\tmatrix\trepresentation. Applications\tof\tBFS \u2022 Finding\tall\tconnected\tcomponents\tin\ta\tgraph \u2022 Finding\tall\tnodes\twithin\tone\tconnected\tcomponent \u2022 Finding\tthe\tshortest\tpath\tbetween\ttwo\tnodes \u2022 Testing\ta\tgraph\tfor\tbipartiteness Comparing\tDFS\tand\tBFS Comparing\t BFS\t and\t DFS,\t the\t big\t advantage\t of\t DFS\t is\t that\t it\t has\t much\t lower\t memory requirements\tthan\tBFS\tbecause\tit\u2019s\tnot\trequired\tto\tstore\tall\tof\tthe\tchild\tpointers\tat\teach\tlevel. Depending\ton\tthe\tdata\tand\twhat\twe\tare\tlooking\tfor,\teither\tDFS\tor\tBFS\tcan\tbe\tadvantageous.\tFor example,\tin\ta\tfamily\ttree\tif\twe\tare\tlooking\tfor\tsomeone\twho\u2019s\tstill\talive\tand\tif\twe\tassume\tthat person\twould\tbe\tat\tthe\tbottom\tof\tthe\ttree,\tthen\tDFS\tis\ta\tbetter\tchoice.\tBFS\twould\ttake\ta\tvery long\ttime\tto\treach\tthat\tlast\tlevel. The\tDFS\talgorithm\tfinds\tthe\tgoal\tfaster.\tNow,\tif\twe\twere\tlooking\tfor\ta\tfamily\tmember\twho\tdied a\tvery\tlong\ttime\tago,\tthen\tthat\tperson\twould\tbe\tcloser\tto\tthe\ttop\tof\tthe\ttree.\tIn\tthis\tcase,\tBFS finds\tfaster\tthan\tDFS.\tSo,\tthe\tadvantages\tof\teither\tvary\tdepending\ton\tthe\tdata\tand\twhat\twe\tare looking\tfor. DFS\t is\t related\t to\t preorder\t traversal\t of\t a\t tree.\t Like\tpreorder\t traversal,\t DFS\t visits\t each\t node before\tits\tchildren.\tThe\tBFS\talgorithm\tworks\tsimilar\tto\tlevel\t\u2013\torder\ttraversal\tof\tthe\ttrees. If\tsomeone\tasks\twhether\tDFS\tis\tbetter\tor\tBFS\tis\tbetter,\tthe\tanswer\tdepends\ton\tthe\ttype\tof\tthe problem\tthat\twe\tare\ttrying\tto\tsolve.\tBFS\tvisits\teach\tlevel\tone\tat\ta\ttime,\tand\tif\twe\tknow\tthe solution\twe\tare\tsearching\tfor\tis\tat\ta\tlow\tdepth,\tthen\tBFS\tis\tgood.\tDFS\tis\ta\tbetter\tchoice\tif\tthe solution\tis\tat\tmaximum\tdepth.\tThe\tbelow\ttable\tshows\tthe\tdifferences\tbetween\tDFS\tand\tBFS\tin terms\tof\ttheir\tapplications."
            },
            {
                "subchapter_title": "9.6\tTopological\tSort",
                "content": "Topological\tsort\tis\tan\tordering\tof\tvertices\tin\ta\tdirected\tacyclic\tgraph\t[DAG]\tin\twhich\teach\tnode comes\t before\t all\t nodes\t to\t which\t it\t has\t outgoing\t edges.\t As\t an\t example,\t consider\t the\t course prerequisite\t structure\t at\t universities.\t A\t directed\t edge\t (v,w)\t indicates\t that\t course\t v\t must\t be completed\tbefore\tcourse\tw.\tTopological\tordering\tfor\tthis\texample\tis\tthe\tsequence\twhich\tdoes\tnot violate\tthe\tprerequisite\trequirement.\tEvery\tDAG\tmay\thave\tone\tor\tmore\ttopological\torderings. Topological\tsort\tis\tnot\tpossible\tif\tthe\tgraph\thas\ta\tcycle,\tsince\tfor\ttwo\tvertices\tv\tand\tw\ton\tthe cycle,\tv\tprecedes\tw\tand\tw\tprecedes\tv. Topological\tsort\thas\tan\tinteresting\tproperty.\tAll\tpairs\tof\tconsecutive\tvertices\tin\tthe\tsorted\torder are\tconnected\tby\tedges;\tthen\tthese\tedges\tform\ta\tdirected\tHamiltonian\tpath\t[refer\tto\tProblems Section]\t in\t the\t DAG.\t If\t a\t Hamiltonian\t path\t exists,\t the\t topological\t sort\t order\t is\t unique.\t If\t a topological\t sort\t does\t not\t form\t a\t Hamiltonian\t path,\t DAG\t can\t have\t two\t or\t more\t topological orderings.\t In\t the\t graph\t below:\t 7,\t 5,\t 3,\t 11,\t 8,\t 2,\t 9,\t 10\t and\t 3,\t 5,\t 7,\t 8,\t 11,\t 2,\t 9,\t 10\t are\t both topological\torderings. Initially,\t indegree\t is\t computed\t for\t all\t vertices,\t starting\t with\t the\t vertices\t which\t are\t having indegree\t0.\tThat\tmeans\tconsider\tthe\tvertices\twhich\tdo\tnot\thave\tany\tprerequisite.\tTo\tkeep\ttrack\tof vertices\twith\tindegree\tzero\twe\tcan\tuse\ta\tqueue. All\t vertices\t of\t indegree\t 0\t are\t placed\t on\t queue.\t While\t the\t queue\t is\t not\t empty,\t a\t vertex\t v\t is removed,\tand\tall\tedges\tadjacent\tto\tv\thave\ttheir\tindegrees\tdecremented.\tA\tvertex\tis\tput\ton\tthe queue\t as\t soon\t as\t its\t indegree\t falls\t to\t 0.\t The\t topological\t ordering\t is\t the\t order\t in\t which\t the vertices\tDeQueue. The\ttime\tcomplexity\tof\tthis\talgorithm\tis\tO(|E|\t+\t|V|)\tif\tadjacency\tlists\tare\tused. Total\trunning\ttime\tof\ttopological\tsort\tis\tO(V\t+\tE). Note:\tThe\tTopological\tsorting\tproblem\tcan\tbe\tsolved\twith\tDFS.\tRefer\tto\tthe\tProblems\tSection for\tthe\talgorithm. Applications\tof\tTopological\tSorting \u2022 Representing\tcourse\tprerequisites \u2022 Detecting\tdeadlocks \u2022 Pipeline\tof\tcomputing\tjobs \u2022 Checking\tfor\tsymbolic\tlink\tloop \u2022 Evaluating\tformulae\tin\tspreadsheet"
            },
            {
                "subchapter_title": "9.7\tShortest\tPath\tAlgorithms",
                "content": "Let\t us\t consider\t the\t other\t important\t problem\t of\t a\t graph.\t Given\t a\t graph\t G\t =\t (V,\t E)\t and\t a distinguished\tvertex\ts,\twe\tneed\tto\tfind\tthe\tshortest\tpath\tfrom\ts\tto\tevery\tother\tvertex\tin\tG.\tThere are\tvariations\tin\tthe\tshortest\tpath\talgorithms\twhich\tdepend\ton\tthe\ttype\tof\tthe\tinput\tgraph\tand\tare given\tbelow. Variations\tof\tShortest\tPath\tAlgorithms Shortest\tpath\tin\tunweighted\tgraph Shortest\tpath\tin\tweighted\tgraph Shortest\tpath\tin\tweighted\tgraph\twith\tnegative\tedges Applications\tof\tShortest\tPath\tAlgorithms \u2022 Finding\tfastest\tway\tto\tgo\tfrom\tone\tplace\tto\tanother \u2022 Finding\tcheapest\tway\tto\tfly/send\tdata\tfrom\tone\tcity\tto\tanother Shortest\tPath\tin\tUnweighted\tGraph Let\t s\t be\t the\t input\t vertex\t from\t which\t we\t want\t to\t find\t the\t shortest\t path\t to\t all\t other\t vertices. Unweighted\t graph\t is\t a\t special\t case\t of\t the\t weighted\t shortest-path\t problem,\t with\t all\t edges\t a weight\tof\t1.\tThe\talgorithm\tis\tsimilar\tto\tBFS\tand\twe\tneed\tto\tuse\tthe\tfollowing\tdata\tstructures: \u2022 A\tdistance\ttable\twith\tthree\tcolumns\t(each\trow\tcorresponds\tto\ta\tvertex): \u25cb Distance\tfrom\tsource\tvertex. \u25cb Path\t\u2013\tcontains\tthe\tname\tof\tthe\tvertex\tthrough\twhich\twe\tget\tthe\tshortest distance. \u2022 A\t queue\t is\t used\t to\t implement\t breadth-first\t search.\t It\t contains\t vertices\t whose distance\tfrom\tthe\tsource\tnode\thas\tbeen\tcomputed\tand\ttheir\tadjacent\tvertices\tare\tto be\texamined. As\tan\texample,\tconsider\tthe\tfollowing\tgraph\tand\tits\tadjacency\tlist\trepresentation. The\tadjacency\tlist\tfor\tthis\tgraph\tis: Let\ts\t=\tC.\tThe\tdistance\tfrom\tC\tto\tC\tis\t0.\tInitially,\tdistances\tto\tall\tother\tnodes\tare\tnot\tcomputed, and\twe\tinitialize\tthe\tsecond\tcolumn\tin\tthe\tdistance\ttable\tfor\tall\tvertices\t(except\tC)\twith\t-1\tas below. Algorithm Running\ttime:\tO(|E|\t+\t|V|),\tif\tadjacency\tlists\tare\tused.\tIn\tfor\tloop,\twe\tare\tchecking\tthe\toutgoing edges\tfor\ta\tgiven\tvertex\tand\tthe\tsum\tof\tall\texamined\tedges\tin\tthe\twhile\tloop\tis\tequal\tto\tthe number\tof\tedges\twhich\tgives\tO(|E|). If\twe\tuse\tmatrix\trepresentation\tthe\tcomplexity\tis\tO(|V|2),\tbecause\twe\tneed\tto\tread\tan\tentire\trow in\tthe\tmatrix\tof\tlength\t|V|\tin\torder\tto\tfind\tthe\tadjacent\tvertices\tfor\ta\tgiven\tvertex. Shortest\tpath\tin\tWeighted\tGraph\t[Dijkstra\u2019s] A\tfamous\tsolution\tfor\tthe\tshortest\tpath\tproblem\twas\tdeveloped\tby\tDijkstra.\tDijkstra\u2019s\talgorithm is\ta\tgeneralization\tof\tthe\tBFS\talgorithm.\tThe\tregular\tBFS\talgorithm\tcannot\tsolve\tthe\tshortest\tpath problem\tas\tit\tcannot\tguarantee\tthat\tthe\tvertex\tat\tthe\tfront\tof\tthe\tqueue\tis\tthe\tvertex\tclosest\tto source\ts. Before\tgoing\tto\tcode\tlet\tus\tunderstand\thow\tthe\talgorithm\tworks.\tAs\tin\tunweighted\tshortest\tpath algorithm,\t here\t too\t we\t use\t the\t distance\t table.\t The\t algorithm\t works\t by\t keeping\t the\t shortest distance\t of\t vertex\t v\t from\t the\t source\t in\t the\t Distance\t table.\t The\t value\t Distance[v]\t holds\t the distance\tfrom\ts\tto\tv.\tThe\tshortest\tdistance\tof\tthe\tsource\tto\titself\tis\tzero.\tThe\tDistance\ttable\tfor all\tother\tvertices\tis\tset\tto\t\u20131\tto\tindicate\tthat\tthose\tvertices\tare\tnot\talready\tprocessed. After\tthe\talgorithm\tfinishes,\tthe\tDistance\ttable\twill\thave\tthe\tshortest\tdistance\tfrom\tsource\ts\tto each\tother\tvertex\tv.\tTo\tsimplify\tthe\tunderstanding\tof\tDijkstra\u2019s\talgorithm,\tlet\tus\tassume\tthat\tthe given\tvertices\tare\tmaintained\tin\ttwo\tsets.\tInitially\tthe\tfirst\tset\tcontains\tonly\tthe\tsource\telement and\tthe\tsecond\tset\tcontains\tall\tthe\tremaining\telements.\tAfter\tthe\tkth\titeration,\tthe\tfirst\tset\tcontains k\t vertices\t which\t are\t closest\t to\t the\t source.\t These\t k\t vertices\t are\t the\t ones\t for\t which\t we\t have already\tcomputed\tthe\tshortest\tdistances\tfrom\tsource. Notes\ton\tDijkstra\u2019s\tAlgorithm \u2022 It\tuses\tgreedy\tmethod:\tAlways\tpick\tthe\tnext\tclosest\tvertex\tto\tthe\tsource. \u2022 It\tuses\tpriority\tqueue\tto\tstore\tunvisited\tvertices\tby\tdistance\tfrom\ts. \u2022 It\tdoes\tnot\twork\twith\tnegative\tweights. Difference\tbetween\tUnweighted\tShortest\tPath\tand\tDijkstra\u2019s\tAlgorithm 1) To\trepresent\tweights\tin\tthe\tadjacency\tlist,\teach\tvertex\tcontains\tthe\tweights\tof\tthe edges\t(in\taddition\tto\ttheir\tidentifier). 2) Instead\tof\tordinary\tqueue\twe\tuse\tpriority\tqueue\t[distances\tare\tthe\tpriorities]\tand\tthe vertex\twith\tthe\tsmallest\tdistance\tis\tselected\tfor\tprocessing. 3) The\tdistance\tto\ta\tvertex\tis\tcalculated\tby\tthe\tsum\tof\tthe\tweights\tof\tthe\tedges\ton\tthe path\tfrom\tthe\tsource\tto\tthat\tvertex. 4) We\tupdate\tthe\tdistances\tin\tcase\tthe\tnewly\tcomputed\tdistance\tis\tsmaller\tthan\tthe\told distance\twhich\twe\thave\talready\tcomputed. The\tabove\talgorithm\tcan\tbe\tbetter\tunderstood\tthrough\tan\texample,\twhich\twill\texplain\teach\tstep that\tis\ttaken\tand\thow\tDistance\tis\tcalculated.\tThe\tweighted\tgraph\tbelow\thas\t5\tvertices\tfrom\tA\t\u2013 E. The\t value\t between\t the\t two\t vertices\t is\t known\t as\t the\t edge\t cost\t between\t two\t vertices.\t For example,\tthe\tedge\tcost\tbetween\tA\tand\tC\tis\t1.\tDijkstra\u2019s\talgorithm\tcan\tbe\tused\tto\tfind\tthe\tshortest path\tfrom\tsource\tA\tto\tthe\tremaining\tvertices\tin\tthe\tgraph. Initially\tthe\tDistance\ttable\tis: After\tthe\tfirst\tstep,\tfrom\tvertex\tA,\twe\tcan\treach\tB\tand\tC.\tSo,\tin\tthe\tDistance\ttable\twe\tupdate\tthe reachability\tof\tB\tand\tC\twith\ttheir\tcosts\tand\tthe\tsame\tis\tshown\tbelow. Now,\t let\t us\t select\t the\t minimum\t distance\t among\t all.\t The\t minimum\t distance\t vertex\t is\t C.\t That means,\twe\thave\tto\treach\tother\tvertices\tfrom\tthese\ttwo\tvertices\t(A\tand\tC).\tFor\texample,\tB\tcan\tbe reached\tfrom\tA\tand\talso\tfrom\tC.\tIn\tthis\tcase\twe\thave\tto\tselect\tthe\tone\twhich\tgives\tthe\tlowest cost.\tSince\treaching\tB\tthrough\tC\tis\tgiving\tthe\tminimum\tcost\t(1\t+\t2),\twe\tupdate\tthe\tDistance\ttable for\tvertex\tB\twith\tcost\t3\tand\tthe\tvertex\tfrom\twhich\twe\tgot\tthis\tcost\tas\tC. The\tonly\tvertex\tremaining\tis\tE.\tTo\treach\tE,\twe\thave\tto\tsee\tall\tthe\tpaths\tthrough\twhich\twe\tcan reach\tE\tand\tselect\tthe\tone\twhich\tgives\tthe\tminimum\tcost.\tWe\tcan\tsee\tthat\tif\twe\tuse\tB\t as\t the intermediate\tvertex\tthrough\tC\twe\tget\tthe\tminimum\tcost. The\tfinal\tminimum\tcost\ttree\twhich\tDijkstra\u2019s\talgorithm\tgenerates\tis: Performance In\tDijkstra\u2019s\talgorithm,\tthe\tefficiency\tdepends\ton\tthe\tnumber\tof\tDeleteMins\t(V\tDeleteMins)\tand updates\tfor\tpriority\tqueues\t(E\tupdates)\tthat\tare\tused.\tIf\ta\tstandard\tbinary\theap\tis\tused\tthen\tthe complexity\tis\tO(ElogV). The\tterm\tElogV\tcomes\tfrom\tE\tupdates\t(each\tupdate\ttakes\tlogV)\tfor\tthe\tstandard\theap.\tIf\tthe\tset used\tis\tan\tarray\tthen\tthe\tcomplexity\tis\tO(E\t+\tV2). Disadvantages\tof\tDijkstra\u2019s\tAlgorithm \u2022 As\tdiscussed\tabove,\tthe\tmajor\tdisadvantage\tof\tthe\talgorithm\tis\tthat\tit\tdoes\ta\tblind search,\tthereby\twasting\ttime\tand\tnecessary\tresources. \u2022 Another\tdisadvantage\tis\tthat\tit\tcannot\thandle\tnegative\tedges.\tThis\tleads\tto\tacyclic graphs\tand\tmost\toften\tcannot\tobtain\tthe\tright\tshortest\tpath. Relatives\tof\tDijkstra\u2019s\tAlgorithm \u2022 The\tBellman-\tFord\talgorithm\tcomputes\tsingle-source\tshortest\tpaths\tin\ta\tweighted digraph.\t It\t uses\t the\t same\t concept\t as\t that\t of\t Dijkstra\u2019s\t algorithm\t but\t can\t handle negative\tedges\tas\twell.\tIt\thas\tmore\trunning\ttime\tthan\tDijkstra\u2019s\talgorithm. \u2022 Prim\u2019s\talgorithm\tfinds\ta\tminimum\tspanning\ttree\tfor\ta\tconnected\tweighted\tgraph.\tIt implies\tthat\ta\tsubset\tof\tedges\tthat\tform\ta\ttree\twhere\tthe\ttotal\tweight\tof\tall\tthe\tedges in\tthe\ttree\tis\tminimized. Bellman-Ford\tAlgorithm If\tthe\tgraph\thas\tnegative\tedge\tcosts,\tthen\tDijkstra\u2019s\talgorithm\tdoes\tnot\twork.\tThe\tproblem\tis\tthat once\ta\tvertex\tu\tis\tdeclared\tknown,\tit\tis\tpossible\tthat\tfrom\tsome\tother,\tunknown\tvertex\tv\tthere\tis\ta path\tback\tto\tu\tthat\tis\tvery\tnegative.\tIn\tsuch\ta\tcase,\ttaking\ta\tpath\tfrom\ts\tto\tv\tback\tto\tu\tis\tbetter than\tgoing\tfrom\ts\tto\tu\twithout\tusing\t v.\t A\t combination\t of\t Dijkstra\u2019s\t algorithm\t and\t unweighted algorithms\twill\tsolve\tthe\tproblem.\tInitialize\tthe\tqueue\twith\ts.\tThen,\tat\teach\tstage,\twe\tDeQueue\ta vertex\tv.\tWe\tfind\tall\tvertices\tW\tadjacent\tto\tv\tsuch\tthat, distance\tto\tv\t+\tweight\t(v,w)\t<\told\tdistance\tto\tw We\tupdate\tw\told\tdistance\tand\tpath,\tand\tplace\tw\ton\ta\tqueue\tif\tit\tis\tnot\talready\tthere.\tA\tbit\tcan\tbe set\tfor\teach\tvertex\tto\tindicate\tpresence\tin\tthe\tqueue.\tWe\trepeat\tthe\tprocess\tuntil\tthe\tqueue\tis empty. This\talgorithm\tworks\tif\tthere\tare\tno\tnegative-cost\tcycles.\tEach\tvertex\tcan\tDeQueue\tat\tmost\t|\tV| times,\tso\tthe\trunning\ttime\tis\tO(|E|.\t|V|)\tif\tadjacency\tlists\tare\tused. Overview\tof\tShortest\tPath\tAlgorithms Shortest\tpath\tin\tunweighted\tgraph\t[Modified\tBFS] O(|E|\t+\t|V|) Shortest\tpath\tin\tweighted\tgraph\t[Dijkstra\u2019s] O(|E|\tlog\t|V|) Shortest\tpath\tin\tweighted\tgraph\twith\tnegative\tedges\t[Bellman\t\u2013\tFord] O(|E|.|V|) Shortest\tpath\tin\tweighted\tacyclic\tgraph O(|E|\t+\t|V|)"
            },
            {
                "subchapter_title": "9.8\tMinimal\tSpanning\tTree",
                "content": "The\tSpanning\ttree\tof\ta\tgraph\tis\ta\tsubgraph\tthat\tcontains\tall\tthe\tvertices\tand\tis\talso\ta\ttree.\tA graph\tmay\thave\tmany\tspanning\ttrees.\tAs\tan\texample,\tconsider\ta\tgraph\twith\t4\tvertices\tas\tshown below.\tLet\tus\tassume\tthat\tthe\tcorners\tof\tthe\tgraph\tare\tvertices. For\tthis\tsimple\tgraph,\twe\tcan\thave\tmultiple\tspanning\ttrees\tas\tshown\tbelow. The\talgorithm\twe\twill\tdiscuss\tnow\tis\tminimum\tspanning\ttree\tin\tan\tundirected\tgraph.\tWe\tassume that\tthe\tgiven\tgraphs\tare\tweighted\tgraphs.\tIf\tthe\tgraphs\tare\tunweighted\tgraphs\tthen\twe\tcan\tstill use\tthe\tweighted\tgraph\talgorithms\tby\ttreating\tall\tweights\tas\tequal.\tA\tminimum\tspanning\ttree\tof an\tundirected\tgraph\tG\tis\ta\ttree\tformed\tfrom\tgraph\tedges\tthat\tconnect\tall\tthe\tvertices\tof\tG\twith minimum\t total\t cost\t (weights).\t A\t minimum\t spanning\t tree\t exists\t only\t if\t the\t graph\t is\t connected. There\tare\ttwo\tfamous\talgorithms\tfor\tthis\tproblem: \u2022 Prim\u2019s\tAlgorithm \u2022 Kruskal\u2019s\tAlgorithm Prim\u2019s\tAlgorithm Prim\u2019s\talgorithm\tis\talmost\tthe\tsame\tas\tDijkstra\u2019s\talgorithm.\tAs\tin\tDijkstra\u2019s\talgorithm,\tin\tPrim\u2019s algorithm\twe\tkeep\tthe\tvalues\tdistance\tand\tpaths\tin\tthe\tdistance\ttable.\tThe\tonly\texception\tis\tthat since\t the\t definition\t of\t distance\t is\t different,\t the\t updating\t statement\t also\t changes\t a\t little.\t The update\tstatement\tis\tsimpler\tthan\tbefore. The\t entire\t implementation\t of\t this\t algorithm\t is\t identical\t to\t that\t of\t Dijkstra\u2019s\t algorithm.\t The running\ttime\tis\tO(|V|2)\twithout\theaps\t[good\tfor\tdense\tgraphs],\tand\tO\t(ElogV)\tusing\tbinary\theaps [good\tfor\tsparse\tgraphs]. Kruskal\u2019s\tAlgorithm The\talgorithm\tstarts\twith\tV\tdifferent\ttrees\t(V\tis\tthe\tvertices\tin\tthe\tgraph).\tWhile\tconstructing\tthe minimum\tspanning\ttree,\tevery\ttime\tKruskal\u2019s\talorithm\tselects\tan\tedge\tthat\thas\tminimum\tweight and\tthen\tadds\tthat\tedge\tif\tit\tdoesn\u2019t\tcreate\ta\tcycle.\tSo,\tinitially,\tthere\tare\t|\tV\t|\tsingle-node\ttrees\tin the\tforest.\tAdding\tan\tedge\tmerges\ttwo\ttrees\tinto\tone.\tWhen\tthe\talgorithm\tis\tcompleted,\tthere\twill be\tonly\tone\ttree,\tand\tthat\tis\tthe\tminimum\tspanning\ttree.\tThere\tare\ttwo\tways\tof\timplementing Kruskal\u2019s\talgorithm: \u2022 By\tusing\tDisjoint\tSets:\tUsing\tUNION\tand\tFIND\toperations \u2022 By\tusing\tPriority\tQueues:\tMaintains\tweights\tin\tpriority\tqueue The\t appropriate\t data\t structure\t is\t the\t UNION/FIND\t algorithm\t [for\t implementing\t forests].\t Two vertices\tbelong\tto\tthe\tsame\tset\tif\tand\tonly\tif\tthey\tare\tconnected\tin\tthe\tcurrent\tspanning\tforest. Each\tvertex\tis\tinitially\tin\tits\town\tset.\tIf\tu\tand\tv\tare\tin\tthe\tsame\tset,\tthe\tedge\tis\trejected\tbecause\tit forms\t a\t cycle.\t Otherwise,\t the\t edge\t is\t accepted,\t and\t a\t UNION\t is\t performed\t on\t the\t two\t sets containing\tu\tand\tv.\tAs\tan\texample,\tconsider\tthe\tfollowing\tgraph\t(the\tedges\tshow\tthe\tweights). Now\t let\t us\t perform\t Kruskal\u2019s\t algorithm\t on\t this\t graph.\t We\t always\t select\t the\t edge\t which\t has minimum\tweight. From\tthe\tabove\tgraph,\tthe\tedges\twhich\thave\tminimum\tweight\t(cost)\tare:\tAD\tand\tBE.\tFrom\tthese\ttwo\twe\tcan select\tone\tof\tthem\tand\tlet\tus\tassume\tthat\twe\tselect\tAD\t(dotted\tline). DF\tis\tthe\tnext\tedge\tthat\thas\tthe\tlowest\tcost\t(6). BE\tnow\thas\tthe\tlowest\tcost\tand\twe\tselect\tit\t(dotted\tlines\tindicate\tselected\tedges). Next,\tAC\tand\tCE\thave\tthe\tlow\tcost\tof\t7\tand\twe\tselect\tAC. Then\twe\tselect\tCE\tas\tits\tcost\tis\t7\tand\tit\tdoes\tnot\tform\ta\tcycle. The\tnext\tlow\tcost\tedges\tare\tCB\tand\tEF.\tBut\tif\twe\tselect\tCB,\tthen\tit\tforms\ta\tcycle.\tSo\twe\tdiscard\tit.\tThis\tis\talso the\tcase\twith\tEF.\tSo\twe\tshould\tnot\tselect\tthose\ttwo.\tAnd\tthe\tnext\tlow\tcost\tis\t9\t(BD\tand\tEG).\tSelecting\tBD forms\ta\tcycle\tso\twe\tdiscard\tit.\tAdding\tEG\twill\tnot\tform\ta\tcycle\tand\ttherefore\twith\tthis\tedge\twe\tcomplete\tall vertices\tof\tthe\tgraph. Note:\t For\t implementation\t of\t UNION\t and\t FIND\t operations,\t refer\t to\t the\t Disjoint\t Sets\t ADT chapter. The\t worst-case\t running\t time\t of\t this\t algorithm\t is\t O(ElogE),\t which\t is\t dominated\t by\t the\t heap operations.\tThat\tmeans,\tsince\twe\tare\tconstructing\tthe\theap\twith\tE\tedges,\twe\tneed\tO(ElogE)\ttime to\tdo\tthat."
            },
            {
                "subchapter_title": "9.9\tGraph\tAlgorithms:\tProblems\t&\tSolutions",
                "content": "Problem-1\u2003\u2003In\tan\tundirected\tsimple\tgraph\twith\tn\tvertices,\twhat\tis\tthe\tmaximum\tnumber\tof edges?\tSelf-loops\tare\tnot\tallowed. Solution:\tSince\tevery\tnode\tcan\tconnect\tto\tall\tother\tnodes,\tthe\tfirst\tnode\tcan\tconnect\tto\tn\t\u2013\t1 nodes.\tThe\tsecond\tnode\tcan\tconnect\tto\tn\t\u2013\t2\tnodes\t[since\tone\tedge\tis\talready\tthere\tfrom\tthe\tfirst node].\tThe\ttotal\tnumber\tof\tedges\tis:\t1\t+\t2\t+\t3\t+\t\u00b7\u00b7\u00b7\t+\tn\t\u2013\t \tedges. Problem-2\u2003\u2003How\tmany\tdifferent\tadjacency\tmatrices\tdoes\ta\tgraph\twith\tn\tvertices\tand\tE\tedges have? Solution:\tIt\u2019s\tequal\tto\tthe\tnumber\tof\tpermutations\tof\tn\telements,\ti.e.,\tn!. Problem-3\u2003\u2003How\tmany\tdifferent\tadjacency\tlists\tdoes\ta\tgraph\twith\tn\tvertices\thave? Solution:\tIt\u2019s\tequal\tto\tthe\tnumber\tof\tpermutations\tof\tedges,\ti.e.,\tE!. Problem-4\u2003\u2003Which\t undirected\t graph\t representation\t is\t most\t appropriate\t for\t determining whether\tor\tnot\ta\tvertex\tis\tisolated\t(is\tnot\tconnected\tto\tany\tother\tvertex)? Solution:\tAdjacency\tList.\tIf\twe\tuse\tthe\tadjacency\tmatrix,\tthen\twe\tneed\tto\tcheck\tthe\tcomplete row\tto\tdetermine\twhether\tthat\tvertex\thas\tedges\tor\tnot.\tBy\tusing\tthe\tadjacency\tlist,\tit\tis\tvery\teasy to\tcheck,\tand\tit\tcan\tbe\tdone\tjust\tby\tchecking\twhether\tthat\tvertex\thas\tNULL\tfor\tnext\tpointer\tor\tnot [NULL\tindicates\tthat\tthe\tvertex\tis\tnot\tconnected\tto\tany\tother\tvertex]. Problem-5\u2003\u2003For\tchecking\twhether\tthere\tis\ta\tpath\tfrom\tsource\ts\tto\ttarget\tt,\twhich\tone\tis\tbest between\tdisjoint\tsets\tand\tDFS? Solution:\tThe\ttable\tbelow\tshows\tthe\tcomparison\tbetween\tdisjoint\tsets\tand\tDFS.\tThe\tentries\tin the\ttable\trepresent\tthe\tcase\tfor\tany\tpair\tof\tnodes\t(for\ts\tand\tt). Problem-6\u2003\u2003What\tis\tthe\tmaximum\tnumber\tof\tedges\ta\tdirected\tgraph\twith\tn\tvertices\tcan\thave and\tstill\tnot\tcontain\ta\tdirected\tcycle? Solution:\tThe\tnumber\tis\tV\t(V\t\u2013\t1)/2.\tAny\tdirected\tgraph\tcan\thave\tat\tmost\tn2\tedges.\tHowever, since\tthe\tgraph\thas\tno\tcycles\tit\tcannot\tcontain\ta\tself\tloop,\tand\tfor\tany\tpair\tx,y\tof\tvertices,\tat\tmost one\tedge\tfrom\t(x,y)\tand\t(y,x)\tcan\tbe\tincluded.\tTherefore\tthe\tnumber\tof\tedges\tcan\tbe\tat\tmost\t(V2\t\u2013 V)/2\tas\tdesired.\tIt\tis\tpossible\tto\tachieve\tV(V\t\u2013\t1)/2\tedges.\tLabel\tn\tnodes\t1,2...\tn\tand\tadd\tan edge\t(x,\ty)\tif\tand\tonly\tif\tx\t<\ty.\tThis\tgraph\thas\tthe\tappropriate\tnumber\tof\tedges\tand\tcannot\tcontain a\tcycle\t(any\tpath\tvisits\tan\tincreasing\tsequence\tof\tnodes). Problem-7\u2003\u2003How\t many\t simple\t directed\t graphs\t with\t no\t parallel\t edges\t and\t self-loops\t are possible\tin\tterms\tof\tV? Solution:\t(V)\t\u00d7\t(V\t\u2013\t1).\tSince,\teach\tvertex\tcan\tconnect\tto\tV\t\u2013\t1\tvertices\twithout\tself-loops. Problem-8\u2003\u2003What\tare\tthe\tdifferences\tbetween\tDFS\tand\tBFS? Solution: DFS BFS Backtracking\tis\tpossible\tfrom\ta\tdead\tend. Backtracking\tis\tnot\tpossible. Vertices\tfrom\twhich\texploration\tis incomplete\tare\tprocessed\tin\ta\tLIFO\torder The\tvertices\tto\tbe\texplored\tare\torganized as\ta\tFIFO\tqueue. The\tsearch\tis\tdone\tin\tone\tparticular direction The\tvertices\tat\tthe\tsame\tlevel\tare maintained\tin\tparallel. Problem-9\u2003\u2003Earlier\t in\t this\t chapter,\t we\t discussed\t minimum\t spanning\t tree\t algorithms.\t Now, give\tan\talgorithm\tfor\tfinding\tthe\tmaximum-weight\tspanning\ttree\tin\ta\tgraph. Solution: Using\tthe\tgiven\tgraph,\tconstruct\ta\tnew\tgraph\twith\tthe\tsame\tnodes\tand\tedges.\tBut\tinstead\tof\tusing the\tsame\tweights,\ttake\tthe\tnegative\tof\ttheir\tweights.\tThat\tmeans,\tweight\tof\tan\tedge\t=\tnegative\tof weight\t of\t the\t corresponding\t edge\t in\t the\t given\t graph.\t Now,\t we\t can\t use\t existing\t minimum spanning\t tree\t algorithms\t on\t this\t new\t graph.\t As\t a\t result,\t we\t will\t get\t the\t maximum-weight spanning\ttree\tin\tthe\toriginal\tone. Problem-10\u2003\u2003Give\tan\talgorithm\tfor\tchecking\twhether\ta\tgiven\tgraph\tG\thas\tsimple\tpath\tfrom source\ts\tto\tdestination\td.\tAssume\tthe\tgraph\tG\tis\trepresented\tusing\tthe\tadjacent\tmatrix. Solution:\tLet\tus\tassume\tthat\tthe\tstructure\tfor\tthe\tgraph\tis: For\teach\tvertex\tcall\tDFS\t and\t check\t whether\t the\t current\t vertex\t is\t the\t same\t as\t the\t destination vertex\t or\t not.\t If\t they\t are\t the\t same,\t then\t return\t 1.\t Otherwise,\t call\t the\t DFS\t on\t its\t unvisited neighbors.\tOne\timportant\tthing\tto\tnote\there\tis\tthat,\twe\tare\tcalling\tthe\tDFS\talgorithm\ton\tvertices which\tare\tnot\tyet\tvisited. Time\tComplexity:\tO(E).\tIn\tthe\tabove\talgorithm,\tfor\teach\tnode,\tsince\twe\tare\tnot\tcalling\tDFS\ton all\tof\tits\tneighbors\t(discarding\tthrough\tif\tcondition),\tSpace\tComplexity:\tO(V). Problem-11\u2003\u2003Count\t simple\t paths\t for\t a\t given\t graph\t G\t has\t simple\t path\t from\t source\t s\t to destination\td?\tAssume\tthe\tgraph\tis\trepresented\tusing\tthe\tadjacent\tmatrix. Solution:\tSimilar\tto\tthe\tdiscussion\tin\tProblem-10,\tstart\tat\tone\tnode\tand\tcall\tDFS\ton\tthat\tnode. As\ta\tresult\tof\tthis\tcall,\tit\tvisits\tall\tthe\tnodes\tthat\tit\tcan\treach\tin\tthe\tgiven\tgraph.\tThat\tmeans\tit visits\tall\tthe\tnodes\tof\tthe\tconnected\tcomponent\tof\tthat\tnode.\tIf\tthere\tare\tany\tnodes\tthat\thave\tnot been\tvisited,\tthen\tagain\tstart\tat\tone\tof\tthose\tnodes\tand\tcall\tDFS. Before\tthe\tfirst\tDFS\tin\teach\tconnected\tcomponent,\tincrement\tthe\tconnected\tcomponents\tcount. Continue\tthis\tprocess\tuntil\tall\tof\tthe\tgraph\tnodes\tare\tvisited.\tAs\ta\tresult,\tat\tthe\tend\twe\twill\tget the\t total\t number\t of\t connected\t components.\t The\t implementation\t based\t on\t this\t logic\t is\t given below: Problem-12\u2003\u2003All\t pairs\t shortest\t path\t problem:\t Find\t the\t shortest\t graph\t distances\t between every\tpair\tof\tvertices\tin\ta\tgiven\tgraph.\tLet\tus\tassume\tthat\tthe\tgiven\tgraph\tdoes\tnot\thave negative\tedges. Solution:\tThe\tproblem\tcan\tbe\tsolved\tusing\tn\tapplications\tof\tDijkstra\u2019s\talgorithm.\tThat\tmeans\twe apply\tDijkstra\u2019s\talgorithm\ton\teach\tvertex\tof\tthe\tgiven\tgraph.\tThis\talgorithm\tdoes\tnot\twork\tif\tthe graph\thas\tedges\twith\tnegative\tweights. Problem-13\u2003\u2003In\tProblem-12,\thow\tdo\twe\tsolve\tthe\tall\tpairs\tshortest\tpath\tproblem\tif\tthe\tgraph has\tedges\twith\tnegative\tweights? Solution:\t This\t can\t be\t solved\t by\t using\t the\t Floyd\t \u2013\t Warshall\t algorithm.\t This\t algorithm\t also works\tin\tthe\tcase\tof\ta\tweighted\tgraph\twhere\tthe\tedges\thave\tnegative\tweights.\tThis\talgorithm\tis an\texample\tof\tDynamic\tProgramming\t-refer\tto\tthe\tDynamic\tProgramming\tchapter. Problem-14\u2003\u2003DFS\tApplication:\tCut\tVertex\tor\tArticulation\tPoints Solution:\tIn\tan\tundirected\tgraph,\ta\tcut\tvertex\t(or\tarticulation\tpoint)\tis\ta\tvertex,\tand\tif\twe\tremove it,\tthen\tthe\tgraph\tsplits\tinto\ttwo\tdisconnected\tcomponents.\tAs\tan\texample,\tconsider\tthe\tfollowing figure.\tRemoval\tof\tthe\t\u201cD\u201d\tvertex\tdivides\tthe\tgraph\tinto\ttwo\tconnected\tcomponents\t({E,F}\tand {A,B,\tC,\tG}). Similarly,\tremoval\tof\tthe\t\u201cC\u201d\tvertex\tdivides\tthe\tgraph\tinto\t({G}\t and\t {A,\t B,D,E,F}).\t For\t this graph,\tA\tand\tC\tare\tthe\tcut\tvertices. Note:\tA\tconnected,\tundirected\tgraph\tis\tcalled\tbi\t\u2013\tconnected\tif\tthe\tgraph\tis\tstill\tconnected\tafter removing\tany\tvertex. DFS\tprovides\ta\tlinear-time\talgorithm\t(O(n))\tto\tfind\tall\tcut\tvertices\tin\ta\tconnected\tgraph.\tStarting at\tany\tvertex,\tcall\ta\tDFS\tand\tnumber\tthe\tnodes\tas\tthey\tare\tvisited.\tFor\teach\tvertex\tv,\twe\tcall\tthis DFS\t number\t dfsnum(v).\t The\t tree\t generated\t with\t DFS\t traversal\t is\t called\t DFS\t spanning\t tree. Then,\t for\t every\t vertex\t v\t in\t the\t DFS\t spanning\t tree,\t we\t compute\t the\t lowest-numbered\t vertex, which\t we\t call\t low(v),\t that\t is\t reachable\t from\t v\t by\t taking\t zero\t or\t more\t tree\t edges\t and\t then possibly\tone\tback\tedge\t(in\tthat\torder). Based\ton\tthe\tabove\tdiscussion,\twe\tneed\tthe\tfollowing\tinformation\tfor\tthis\talgorithm:\tthe\tdfsnum of\teach\tvertex\tin\tthe\tDFS\ttree\t(once\tit\tgets\tvisited),\tand\tfor\teach\tvertex\tv,\tthe\tlowest\tdepth\tof neighbors\tof\tall\tdescendants\tof\tv\tin\tthe\tDFS\ttree,\tcalled\tthe\tlow. The\t dfsnum\t can\t be\t computed\t during\t DFS.\t The\t low\t of\t v\t can\t be\t computed\t after\t visiting\t all descendants\tof\tv\t(i.e.,\tjust\tbefore\tv\tgets\tpopped\toff\tthe\tDFS\tstack)\tas\tthe\tminimum\tof\tthe\tdfsnum of\tall\tneighbors\tof\tv\t(other\tthan\tthe\tparent\tof\tv\tin\tthe\tDFS\ttree)\tand\tthe\tlow\tof\tall\tchildren\tof\tv\tin the\tDFS\ttree. The\troot\tvertex\tis\ta\tcut\tvertex\tif\tand\tonly\tif\tit\thas\tat\tleast\ttwo\tchildren.\tA\tnon-root\tvertex\tu\tis\ta cut\tvertex\tif\tand\tonly\tif\tthere\tis\ta\tson\tv\tof\tu\tsuch\tthat\tlow(v)\t\u2265\tdfsnum(u).\tThis\tproperty\tcan\tbe tested\tonce\tthe\tDFS\tis\treturned\tfrom\tevery\tchild\tof\tu\t(that\tmeans,\tjust\tbefore\tu\tgets\tpopped\toff the\tDFS\tstack),\tand\tif\ttrue,\tu\tseparates\tthe\tgraph\tinto\tdifferent\tbi-connected\tcomponents.\tThis\tcan be\t represented\t by\t computing\t one\t bi-connected\t component\t out\t of\t every\t such\t v\t (a\t component which\tcontains\tv\twill\tcontain\tthe\tsub-tree\tof\tv,\tplus\tu),\tand\tthen\terasing\tthe\tsub-tree\tof\tv\tfrom\tthe tree. For\tthe\tgiven\tgraph,\tthe\tDFS\ttree\twith\tdfsnum/low\tcan\tbe\tgiven\tas\tshown\tin\tthe\tfigure\tbelow. The\timplementation\tfor\tthe\tabove\tdiscussion\tis: Problem-15\u2003\u2003Let\tG\tbe\ta\tconnected\tgraph\tof\torder\tn.\tWhat\tis\tthe\tmaximum\tnumber\tof\tcut- vertices\tthat\tG\tcan\tcontain? Solution:\tn\t\u2013\t2.\tAs\tan\texample,\tconsider\tthe\tfollowing\tgraph.\tIn\tthe\tgraph\tbelow,\texcept\tfor\tthe vertices\t1\tand\tn,\tall\tthe\tremaining\tvertices\tare\tcut\tvertices.\tThis\tis\tbecause\tremoving\t1\tand\tn vertices\tdoes\tnot\tsplit\tthe\tgraph\tinto\ttwo.\tThis\tis\ta\tcase\twhere\twe\tcan\tget\tthe\tmaximum\tnumber of\tcut\tvertices. Problem-16\u2003\u2003DFS\tApplication:\tCut\tBridges\tor\tCut\tEdges Solution: Definition:\tLet\tG\tbe\ta\tconnected\tgraph.\tAn\tedge\tuv\tin\tG\tis\tcalled\ta\tbridge\tof\tG\tif\tG\t\u2013\tuv\t is disconnected. As\tan\texample,\tconsider\tthe\tfollowing\tgraph. In\tthe\tabove\tgraph,\tif\twe\tremove\tthe\tedge\tuv\tthen\tthe\tgraph\tsplits\tinto\ttwo\tcomponents.\tFor\tthis graph,\tuv\tis\ta\tbridge.\tThe\tdiscussion\twe\thad\tfor\tcut\tvertices\tholds\tgood\tfor\tbridges\talso.\tThe only\tchange\tis,\tinstead\tof\tprinting\tthe\tvertex,\twe\tgive\tthe\tedge.\tThe\tmain\tobservation\tis\tthat\tan edge\t(u,\tv)\tcannot\tbe\ta\tbridge\tif\tit\tis\tpart\tof\ta\tcycle.\tIf\t(u,\tv)\tis\tnot\tpart\tof\ta\tcycle,\tthen\tit\tis\ta bridge. We\tcan\tdetect\tcycles\tin\tDFS\tby\tthe\tpresence\tof\tback\tedges,\t(u,\tv)\tis\ta\tbridge\tif\tand\tonly\tif\tnone of\tv\tor\tv\u2019s\tchildren\thas\ta\tback\tedge\tto\tu\tor\tany\tof\tu\u2019s\tancestors.\tTo\tdetect\twhether\tany\tof\tv\u2019s children\thas\ta\tback\tedge\tto\tu\u2019s\tparent,\twe\tcan\tuse\ta\tsimilar\tidea\tas\tabove\tto\tsee\twhat\tis\tthe smallest\tdfsnum\treachable\tfrom\tthe\tsubtree\trooted\tat\tv. Problem-17\u2003\u2003DFS\tApplication:\tDiscuss\tEuler\tCircuits Solution:\tBefore\tdiscussing\tthis\tproblem\tlet\tus\tsee\tthe\tterminology: \u2022 Eulerian\ttour-\ta\tpath\tthat\tcontains\tall\tedges\twithout\trepetition. \u2022 Eulerian\tcircuit\t\u2013\ta\tpath\tthat\tcontains\tall\tedges\twithout\trepetition\tand\tstarts\tand ends\tin\tthe\tsame\tvertex. \u2022 Eulerian\tgraph\t\u2013\ta\tgraph\tthat\tcontains\tan\tEulerian\tcircuit. \u2022 Even\tvertex:\ta\tvertex\tthat\thas\tan\teven\tnumber\tof\tincident\tedges. \u2022 Odd\tvertex:\ta\tvertex\tthat\thas\tan\todd\tnumber\tof\tincident\tedges. Euler\tcircuit:\tFor\ta\tgiven\tgraph\twe\thave\tto\treconstruct\tthe\tcircuits\tusing\ta\tpen,\tdrawing\teach\tline exactly\tonce.\tWe\tshould\tnot\tlift\tthe\tpen\tfrom\tthe\tpaper\twhile\tdrawing.\tThat\tmeans,\twe\tmust\tfind\ta path\tin\tthe\tgraph\tthat\tvisits\tevery\tedge\texactly\tonce\tand\tthis\tproblem\tis\tcalled\tan\tEuler\t path (also\tcalled\tEuler\ttour)\tor\tEuler\tcircuit\tproblem.\tThis\tpuzzle\thas\ta\tsimple\tsolution\tbased\ton DFS. An\tEuler\tcircuit\texists\tif\tand\tonly\tif\tthe\tgraph\tis\tconnected\tand\tthe\tnumber\tof\tneighbors\tof\teach vertex\tis\teven.\tStart\twith\tany\tnode,\tselect\tany\tuntraversed\toutgoing\tedge,\tand\tfollow\tit.\tRepeat until\tthere\tare\tno\tmore\tremaining\tunselected\toutgoing\tedges.\tFor\texample,\tconsider\tthe\tfollowing graph:\tA\tlegal\tEuler\tCircuit\tof\tthis\tgraph\tis\t0\t1\t3\t4\t1\t2\t3\t5\t4\t2\t0. If\twe\tstart\tat\tvertex\t0,\twe\tcan\tselect\tthe\tedge\tto\tvertex\t1,\tthen\tselect\tthe\tedge\tto\tvertex\t2,\tthen select\tthe\tedge\tto\tvertex\t0.\tThere\tare\tnow\tno\tremaining\tunchosen\tedges\tfrom\tvertex\t0: We\tnow\thave\ta\tcircuit\t0,1,2,0\tthat\tdoes\tnot\ttraverse\tevery\tedge.\tSo,\twe\tpick\tsome\tother\tvertex that\tis\ton\tthat\tcircuit,\tsay\tvertex\t1.\tWe\tthen\tdo\tanother\tdepth\tfirst\tsearch\tof\tthe\tremaining\tedges. Say\t we\t choose\t the\t edge\t to\t node\t 3,\t then\t 4,\t then\t 1.\t Again\t we\t are\t stuck.\t There\t are\t no\t more unchosen\tedges\tfrom\tnode\t1.\tWe\tnow\tsplice\tthis\tpath\t1,3,4,1\tinto\tthe\told\tpath\t0,1,2,0\tto\tget: 0,1,3,4,1,2,0.\tThe\tunchosen\tedges\tnow\tlook\tlike\tthis: We\tcan\tpick\tyet\tanother\tvertex\tto\tstart\tanother\tDFS.\tIf\twe\tpick\tvertex\t2,\tand\tsplice\tthe\tpath 2,3,5,4,2,\tthen\twe\tget\tthe\tfinal\tcircuit\t0,1,3,4,1,2,3,5,4,2,0. A\tsimilar\tproblem\tis\tto\tfind\ta\tsimple\tcycle\tin\tan\tundirected\tgraph\tthat\tvisits\tevery\tvertex.\tThis\tis known\tas\tthe\tHamiltonian\tcycle\tproblem.\tAlthough\tit\tseems\talmost\tidentical\tto\tthe\tEuler\tcircuit problem,\tno\tefficient\talgorithm\tfor\tit\tis\tknown. Notes: \u2022 A\tconnected\tundirected\tgraph\tis\tEulerian\tif\tand\tonly\tif\tevery\tgraph\tvertex\thas\tan even\tdegree,\tor\texactly\ttwo\tvertices\twith\tan\todd\tdegree. \u2022 A\tdirected\tgraph\tis\tEulerian\tif\tit\tis\tstrongly\tconnected\tand\tevery\tvertex\thas\tan\tequal in\tand\tout\tdegree. Application:\tA\tpostman\thas\tto\tvisit\ta\tset\tof\tstreets\tin\torder\tto\tdeliver\tmails\tand\tpackages.\tHe needs\tto\tfind\ta\tpath\tthat\tstarts\tand\tends\tat\tthe\tpost-office,\tand\tthat\tpasses\tthrough\teach\tstreet (edge)\texactly\tonce.\tThis\tway\tthe\tpostman\twill\tdeliver\tmails\tand\tpackages\tto\tall\tthe\tnecessary streets,\tand\tat\tthe\tsame\ttime\twill\tspend\tminimum\ttime/effort\ton\tthe\troad. Problem-18\u2003\u2003DFS\tApplication:\tFinding\tStrongly\tConnected\tComponents. Solution:\t This\t is\t another\t application\t of\t DFS.\t In\t a\t directed\t graph,\t two\t vertices\t u\t and\t v\t are strongly\tconnected\tif\tand\tonly\tif\tthere\texists\ta\tpath\tfrom\tu\tto\tv\tand\tthere\texists\ta\tpath\tfrom\tv\tto\tu. The\tstrong\tconnectedness\tis\tan\tequivalence\trelation. \u2022 A\tvertex\tis\tstrongly\tconnected\twith\titself \u2022 If\ta\tvertex\tu\tis\tstrongly\tconnected\tto\ta\tvertex\tv,\tthen\tv\tis\tstrongly\tconnected\tto\tu \u2022 If\ta\tvertex\tu\tis\tstrongly\tconnected\tto\ta\tvertex\tv,\tand\tv\tis\tstrongly\tconnected\tto\ta vertex\tx,\tthen\tu\tis\tstrongly\tconnected\tto\tx What\tthis\tsays\tis,\tfor\ta\tgiven\tdirected\tgraph\twe\tcan\tdivide\tit\tinto\tstrongly\tconnected\tcomponents. This\tproblem\tcan\tbe\tsolved\tby\tperforming\ttwo\tdepth-first\tsearches.\tWith\ttwo\tDFS\tsearches\twe can\ttest\twhether\ta\tgiven\tdirected\tgraph\tis\tstrongly\tconnected\tor\tnot.\tWe\tcan\talso\tproduce\tthe subsets\tof\tvertices\tthat\tare\tstrongly\tconnected. Algorithm \u2022 Perform\tDFS\ton\tgiven\tgraph\tG. \u2022 Number\tvertices\tof\tgiven\tgraph\tG\taccording\tto\ta\tpost-order\ttraversal\tof\tdepth-first spanning\tforest. \u2022 Construct\tgraph\tGr\tby\treversing\tall\tedges\tin\tG. \u2022 Perform\tDFS\ton\tGr:\tAlways\tstart\ta\tnew\tDFS\t(initial\tcall\tto\tVisit)\tat\tthe\thighest- numbered\tvertex. \u2022 Each\t tree\t in\t the\t resulting\t depth-first\t spanning\t forest\t corresponds\t to\t a\t strongly- connected\tcomponent. Why\tthis\talgorithm\tworks? Let\tus\tconsider\ttwo\tvertices,\tv\tand\tw.\tIf\tthey\tare\tin\tthe\tsame\tstrongly\tconnected\tcomponent,\tthen there\tare\tpaths\tfrom\tv\tto\tW\tand\tfrom\tw\tto\tv\tin\tthe\toriginal\tgraph\tG,\tand\thence\talso\tin\tGr.\tIf\ttwo vertices\tv\tand\tw\tare\tnot\tin\tthe\tsame\tdepth-first\tspanning\ttree\tof\tGr,\tclearly\tthey\tcannot\tbe\tin\tthe same\tstrongly\tconnected\tcomponent.\tAs\tan\texample,\tconsider\tthe\tgraph\tshown\tbelow\ton\tthe\tleft. Let\tus\tassume\tthis\tgraph\tis\tG. Now,\tas\tper\tthe\talgorithm,\tperforming\tDFS\ton\tthis\tG\tgraph\tgives\tthe\tfollowing\tdiagram.\tThe dotted\tline\tfrom\tC\tto\tA\tindicates\ta\tback\tedge. Now,\tperforming\tpost\torder\ttraversal\ton\tthis\ttree\tgives:\tD,C,B\tand\tA. Vertex Post\tOrder\tNumber A 4 B 3 C 2 D 1 Now\treverse\tthe\tgiven\tgraph\tG\tand\tcall\tit\tGr\tand\tat\tthe\tsame\ttime\tassign\tpostorder\tnumbers\tto the\tvertices.\tThe\treversed\tgraph\tGr\twill\tlook\tlike: The\t last\t step\t is\t performing\t DFS\t on\t this\t reversed\t graph\t Gr.\t While\t doing\t DFS,\t we\t need\t to consider\tthe\tvertex\twhich\thas\tthe\tlargest\tDFS\tnumber.\tSo,\tfirst\twe\tstart\tat\tA\tand\twith\tDFS\twe\tgo to\tC\tand\tthen\tB.\tAt\tB,\twe\tcannot\tmove\tfurther.\tThis\tsays\tthat\t{A,\tB,\tC}\tis\ta\tstrongly\tconnected component.\t Now\t the\t only\t remaining\t element\t is\t D\t and\t we\t end\t our\t second\t DFS\t at\t D.\t So\t the connected\tcomponents\tare:\t{A,\tB,\tC}\tand\t{D}. The\timplementation\tbased\ton\tthis\tdiscussion\tcan\tbe\tshown\tas: Problem-19\u2003\u2003Count\tthe\tnumber\tof\tconnected\tcomponents\tof\tGraph\tG\twhich\tis\trepresented\tin the\tadjacent\tmatrix. Solution:\tThis\tproblem\tcan\tbe\tsolved\twith\tone\textra\tcounter\tin\tDFS. Time\tComplexity:\tSame\tas\tthat\tof\tDFS\tand\tit\tdepends\ton\timplementation.\tWith\tadjacency\tmatrix the\tcomplexity\tis\tO(|E|\t+\t|V|)\tand\twith\tadjacency\tmatrix\tthe\tcomplexity\tis\tO(|V|2). Problem-20\u2003\u2003Can\twe\tsolve\tthe\tProblem-19,\tusing\tBFS? Solution:\tYes.\tThis\tproblem\tcan\tbe\tsolved\twith\tone\textra\tcounter\tin\tBFS. Time\tComplexity:\tSame\tas\tthat\tof\tBFS\tand\tit\tdepends\ton\timplementation.\tWith\tadjacency\tmatrix the\tcomplexity\tis\tO(|E|\t+\t|V|)\tand\twith\tadjacency\tmatrix\tthe\tcomplexity\tis\tO(|V|2). Problem-21\u2003\u2003Let\tus\tassume\tthat\tG(V,E)\tis\tan\tundirected\tgraph.\tGive\tan\talgorithm\tfor\tfinding\ta spanning\t tree\t which\t takes\t O(|E|)\t time\t complexity\t (not\t necessarily\t a\t minimum\t spanning tree). Solution:\tThe\ttest\tfor\ta\tcycle\tcan\tbe\tdone\tin\tconstant\ttime,\tby\tmarking\tvertices\tthat\thave\tbeen added\tto\tthe\tset\tS.\tAn\tedge\twill\tintroduce\ta\tcycle,\tif\tboth\tits\tvertices\thave\talready\tbeen\tmarked. Algorithm: Problem-22\u2003\u2003Is\tthere\tany\tother\tway\tof\tsolving\t0? Solution:\tYes.\tWe\tcan\trun\tBFS\tand\tfind\tthe\tBFS\ttree\tfor\tthe\tgraph\t(level\torder\ttree\tof\tthe\tgraph). Then\tstart\tat\tthe\troot\telement\tand\tkeep\tmoving\tto\tthe\tnext\tlevels\tand\tat\tthe\tsame\ttime\twe\thave\tto consider\tthe\tnodes\tin\tthe\tnext\tlevel\tonly\tonce.\tThat\tmeans,\tif\twe\thave\ta\tnode\twith\tmultiple\tinput edges\tthen\twe\tshould\tconsider\tonly\tone\tof\tthem;
/*-
 * #%L
 * Code Critters
 * %%
 * Copyright (C) 2019 - 2024 Michael Gruber
 * %%
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as
 * published by the Free Software Foundation, either version 3 of the
 * License, or (at your option) any later version.
 * 
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public
 * License along with this program.  If not, see
 * <http://www.gnu.org/licenses/gpl-3.0.html>.
 * #L%
 */
\totherwise\tthey\twill\tform\ta\tcycle. Problem-23\u2003\u2003Detecting\ta\tcycle\tin\tan\tundirected\tgraph Solution:\tAn\tundirected\tgraph\tis\tacyclic\tif\tand\tonly\tif\ta\tDFS\tyields\tno\tback\tedges,\tedges\t(u,\tv) where\tv\thas\talready\tbeen\tdiscovered\tand\tis\tan\tancestor\tof\tu. \u2022 Execute\tDFS\ton\tthe\tgraph. \u2022 If\tthere\tis\ta\tback\tedge\t\u2013\tthe\tgraph\thas\ta\tcycle. If\tthe\tgraph\tdoes\tnot\tcontain\ta\tcycle,\tthen\t|E|\t<\t|V|\tand\tDFS\tcost\tO(|V|).\tIf\tthe\tgraph\tcontains\ta cycle,\tthen\ta\tback\tedge\tis\tdiscovered\tafter\t2|V|\tsteps\tat\tmost. Problem-24\u2003\u2003Detecting\ta\tcycle\tin\tDAG Solution: Cycle\tdetection\ton\ta\tgraph\tis\tdifferent\tthan\ton\ta\ttree.\tThis\tis\tbecause\tin\ta\tgraph,\ta\tnode\tcan\thave multiple\tparents.\tIn\ta\ttree,\tthe\talgorithm\tfor\tdetecting\ta\tcycle\tis\tto\tdo\ta\tdepth\tfirst\tsearch,\tmarking nodes\tas\tthey\tare\tencountered.\tIf\ta\tpreviously\tmarked\tnode\tis\tseen\tagain,\tthen\ta\tcycle\texists.\tThis won\u2019t\twork\ton\ta\tgraph.\tLet\tus\tconsider\tthe\tgraph\tshown\tin\tthe\tfigure\tbelow.\tIf\twe\tuse\ta\ttree cycle\tdetection\talgorithm,\tthen\tit\twill\treport\tthe\twrong\tresult.\tThat\tmeans\tthat\tthis\tgraph\thas\ta cycle\tin\tit.\tBut\tthe\tgiven\tgraph\tdoes\tnot\thave\ta\tcycle\tin\tit.\tThis\tis\tbecause\tnode\t3\twill\tbe\tseen twice\tin\ta\tDFS\tstarting\tat\tnode\t1. The\tcycle\tdetection\talgorithm\tfor\ttrees\tcan\teasily\tbe\tmodified\tto\twork\tfor\tgraphs.\tThe\tkey\tis\tthat in\ta\tDFS\tof\tan\tacyclic\tgraph,\ta\tnode\twhose\tdescendants\thave\tall\tbeen\tvisited\tcan\tbe\tseen\tagain without\timplying\ta\tcycle.\tBut,\tif\ta\tnode\tis\tseen\tfor\tthe\tsecond\ttime\tbefore\tall\tits\tdescendants\thave been\t visited,\t then\t there\t must\t be\t a\t cycle.\t Can\t you\t see\t why\t this\t is?\t Suppose\t there\t is\t a\t cycle containing\tnode\tA.\tThis\tmeans\tthat\tA\tmust\tbe\treachable\tfrom\tone\tof\tits\tdescendants.\tSo\twhen\tthe DFS\t is\t visiting\t that\t descendant,\t it\t will\t see\t A\t again,\t before\t it\t has\t finished\t visiting\t all\t of\t A\u2019s descendants.\tSo\tthere\tis\ta\tcycle.\tIn\torder\tto\tdetect\tcycles,\twe\tcan\tmodify\tthe\tdepth\tfirst\tsearch. Time\tComplexity:\tO(V\t+\tE). Problem-25\u2003\u2003Given\ta\tdirected\tacyclic\tgraph,\tgive\tan\talgorithm\tfor\tfinding\tits\tdepth. Solution:\tIf\tit\tis\tan\tundirected\tgraph,\twe\tcan\tuse\tthe\tsimple\tunweighted\tshortest\tpath\talgorithm (check\tShortest\tPath\tAlgorithms\tsection).\tWe\tjust\tneed\tto\treturn\tthe\thighest\tnumber\tamong\tall distances.\tFor\tdirected\tacyclic\tgraph,\twe\tcan\tsolve\tby\tfollowing\tthe\tsimilar\tapproach\twhich\twe used\t for\t finding\t the\t depth\t in\t trees.\t In\t trees,\t we\t have\t solved\t this\t problem\t using\t level\t order traversal\t(with\tone\textra\tspecial\tsymbol\tto\tindicate\tthe\tend\tof\tthe\tlevel). Total\trunning\ttime\tis\tO(V\t+\tE). Problem-26\u2003\u2003How\tmany\ttopological\tsorts\tof\tthe\tfollowing\tdag\tare\tthere? Solution:\t If\t we\t observe\t the\t above\t graph\t there\t are\t three\t stages\t with\t 2\t vertices.\t In\t the\t early discussion\tof\tthis\tchapter,\twe\tsaw\tthat\ttopological\tsort\tpicks\tthe\telements\twith\tzero\tindegree\tat any\tpoint\tof\ttime.\tAt\teach\tof\tthe\ttwo\tvertices\tstages,\twe\tcan\tfirst\tprocess\teither\tthe\ttop\tvertex\tor the\tbottom\tvertex.\tAs\ta\tresult,\tat\teach\tof\tthese\tstages\twe\thave\ttwo\tpossibilities.\tSo\tthe\ttotal number\tof\tpossibilities\tis\tthe\tmultiplication\tof\tpossibilities\tat\teach\tstage\tand\tthat\tis,\t2\t\u00d7\t2\t\u00d7\t2\t="
            }
        ]
    },
    {
        "chapter_title": "8.",
        "subchapters": [
            {
                "subchapter_title": "Problem-27\u2003\u2003Unique\t topological\t ordering:\t Design\t an\t algorithm\t to\t determine\t whether\t a",
                "content": "directed\tgraph\thas\ta\tunique\ttopological\tordering. Solution:\tA\tdirected\tgraph\thas\ta\tunique\ttopological\tordering\tif\tand\tonly\tif\tthere\tis\ta\tdirected edge\tbetween\teach\tpair\tof\tconsecutive\tvertices\tin\tthe\ttopological\torder.\tThis\tcan\talso\tbe\tdefined as:\ta\tdirected\tgraph\thas\ta\tunique\ttopological\tordering\tif\tand\tonly\tif\tit\thas\ta\tHamiltonian\tpath.\tIf the\tdigraph\thas\tmultiple\ttopological\torderings,\tthen\ta\tsecond\ttopological\torder\tcan\tbe\tobtained by\tswapping\ta\tpair\tof\tconsecutive\tvertices. Problem-28\u2003\u2003Let\tus\tconsider\tthe\tprerequisites\tfor\tcourses\tat\tIIT\tBombay.\tSuppose\tthat\tall prerequisites\tare\tmandatory,\tevery\tcourse\tis\toffered\tevery\tsemester,\tand\tthere\tis\tno\tlimit to\tthe\tnumber\tof\tcourses\twe\tcan\ttake\tin\tone\tsemester.\tWe\twould\tlike\tto\tknow\tthe\tminimum number\tof\tsemesters\trequired\tto\tcomplete\tthe\tmajor.\tDescribe\tthe\tdata\tstructure\twe\twould use\tto\trepresent\tthis\tproblem,\tand\toutline\ta\tlinear\ttime\talgorithm\tfor\tsolving\tit. Solution:\t Use\t a\t directed\t acyclic\t graph\t (DAG).\t The\t vertices\t represent\t courses\t and\t the\t edges represent\t the\t prerequisite\t relation\t between\t courses\t at\t IIT\t Bombay.\t It\t is\t a\t DAG,\t because\t the prerequisite\trelation\thas\tno\tcycles. The\tnumber\tof\tsemesters\trequired\tto\tcomplete\tthe\tmajor\tis\tone\tmore\tthan\tthe\tlongest\tpath\tin\tthe dag.\tThis\tcan\tbe\tcalculated\ton\tthe\tDFS\ttree\trecursively\tin\tlinear\ttime.\tThe\tlongest\tpath\tout\tof\ta vertex\tx\tis\t0\tif\tx\thas\toutdegree\t0,\totherwise\tit\tis\t1\t+\tmax\t{longest\tpath\tout\tof\ty\t|\t(x,y)\tis\tan\tedge of\tG}. Problem-29\u2003\u2003At\ta\tuniversity\tlet\u2019s\tsay\tIIT\tBombay),\tthere\tis\ta\tlist\tof\tcourses\talong\twith\ttheir prerequisites.\tThat\tmeans,\ttwo\tlists\tare\tgiven: A\t\u2013\tCourses\tlist B\t\u2013\tPrerequisites:\tB\tcontains\tcouples\t(x,y)\twhere\tx,y\t\u2208\tA\tindicating\tthat\tcourse\tx\tcan\u2019t\tbe taken\tbefore\tcourse\ty. Let\tus\tconsider\ta\tstudent\twho\twants\tto\ttake\tonly\tone\tcourse\tin\ta\tsemester.\tDesign\ta\tschedule for\tthis\tstudent. Example:\t A\t =\t {C-Lang,\t Data\t Structures,\t OS,\t CO,\t Algorithms,\t Design\t Patterns, Programming}.\t B\t =\t {\t (C-Lang,\t CO),\t (OS,\t CO),\t (Data\t Structures,\t Algorithms),\t (Design Patterns,\tProgramming)\t}.\tOne\tpossible\tschedule\tcould\tbe: Semester\t1: Data\tStructures Semester\t2: Algorithms Semester\t3: C-Lang Semester\t4: OS Semester\t5: CO Semester\t6: Design\tPatterns Semester\t7: Programming Solution:\tThe\tsolution\tto\tthis\tproblem\tis\texactly\tthe\tsame\tas\tthat\tof\ttopological\tsort.\tAssume\tthat the\tcourses\tnames\tare\tintegers\tin\tthe\trange\t[1..n],\tn\tis\tknown\t(n\tis\tnot\tconstant).\tThe\trelations between\tthe\tcourses\twill\tbe\trepresented\tby\ta\tdirected\tgraph\tG\t=\t(V,E),\twhere\tV\tare\tthe\tset\tof courses\tand\tif\tcourse\ti\tis\tprerequisite\tof\tcourse\tj,\tE\twill\tcontain\tthe\tedge\t(i,j).\tLet\tus\tassume\tthat the\tgraph\twill\tbe\trepresented\tas\tan\tAdjacency\tlist. First,\tlet\u2019s\tobserve\tanother\talgorithm\tto\ttopologically\tsort\ta\tDAG\tin\tO(|V|\t+\t|E|). \u2022 Find\tin-degree\tof\tall\tthe\tvertices\t-\tO(|V|\t+\t|E|) \u2022 Repeat: Find\ta\tvertex\tv\twith\tin-degree=0\t-\tO(|V|) Output\tv\tand\tremove\tit\tfrom\tG,\talong\twith\tits\tedges\t-\tO(|V|) Reduce\tthe\tin-degree\tof\teach\tnode\tu\tsuch\tas\t(v,\tu)\twas\tan\tedge\tin\tG\tand\tkeep\ta\tlist of\tvertices\twith\tin-degree=0\t\u2013\tO(degree(v)) Repeat\tthe\tprocess\tuntil\tall\tthe\tvertices\tare\tremoved The\ttime\tcomplexity\tof\tthis\talgorithm\tis\talso\tthe\tsame\tas\tthat\tof\tthe\ttopological\tsort\tand\tit\tis\tO(|V| +\t|E|). Problem-30\u2003\u2003In\t Problem-29,\t a\t student\t wants\t to\t take\t all\t the\t courses\t in\t A,\t in\t the\t minimal number\tof\tsemesters.\tThat\tmeans\tthe\tstudent\tis\tready\tto\ttake\tany\tnumber\tof\tcourses\tin\ta semester.\tDesign\ta\tschedule\tfor\tthis\tscenario.\tOne\tpossible\tschedule\tis: Semester\t1:\tC-Lang,\tOS,\tDesign\tPatterns Semester\t2:\tData\tStructures,\tCO,\tProgramming Semester\t3:\tAlgorithms Solution:\t A\t variation\t of\t the\t above\t topological\t sort\t algorithm\t with\t a\t slight\t change:\t In\t each semester,\t instead\t of\t taking\t one\t subject,\t take\t all\t the\t subjects\t with\t zero\t indegree.\t That\t means, execute\tthe\talgorithm\ton\tall\tthe\tnodes\twith\tdegree\t0\t(instead\tof\tdealing\twith\tone\tsource\tin\teach stage,\tall\tthe\tsources\twill\tbe\tdealt\tand\tprinted). Time\tComplexity:\tO(|V|\t+\t|E|). Problem-31\u2003\u2003LCA\t of\t a\t DAG:\t Given\t a\t DAG\t and\t two\t vertices\t v\t and\t w,\t find\t the\t lowest common\tancestor\t(LCA)\tof\tv\tand\tw.\tThe\tLCA\tof\tv\tand\tw\tis\tan\tancestor\tof\tv\tand\tw\tthat has\tno\tdescendants\tthat\tare\talso\tancestors\tof\tv\tand\tw. Hint:\tDefine\tthe\theight\tof\ta\tvertex\tv\tin\ta\tDAG\tto\tbe\tthe\tlength\tof\tthe\tlongest\tpath\tfrom\troot\tto\tv. Among\tthe\tvertices\tthat\tare\tancestors\tof\tboth\tv\tand\tw,\tthe\tone\twith\tthe\tgreatest\theight\tis\tan\tLCA of\tv\tand\tw. Problem-32\u2003\u2003Shortest\t ancestral\t path:\t Given\t a\t DAG\t and\t two\t vertices\t v\t and\t w,\t find\t the shortest\tancestral\tpath\tbetween\tv\tand\tw.\tAn\tancestral\tpath\tbetween\tv\tand\tw\tis\ta\tcommon ancestor\tx\t along\t with\t a\t shortest\t path\t from\t v\t to\t x\t and\t a\t shortest\t path\t from\t w\t to\tx.\t The shortest\tancestral\tpath\tis\tthe\tancestral\tpath\twhose\ttotal\tlength\tis\tminimized. Hint:\t Run\t BFS\t two\t times.\t First\t run\t from\t v\t and\t second\t time\t from\t w.\t Find\t a\t DAG\t where\t the shortest\tancestral\tpath\tgoes\tto\ta\tcommon\tancestor\tx\tthat\tis\tnot\tan\tLCA. Problem-33\u2003\u2003Let\tus\tassume\tthat\twe\thave\ttwo\tgraphs\tG1\tand\tG2.\tHow\tdo\twe\tcheck\twhether they\tare\tisomorphic\tor\tnot? Solution:\t There\t are\t many\t ways\t of\t representing\t the\t same\t graph.\t As\t an\t example,\t consider\t the following\tsimple\tgraph.\tIt\tcan\tbe\tseen\tthat\tall\tthe\trepresentations\tbelow\thave\tthe\tsame\tnumber\tof vertices\tand\tthe\tsame\tnumber\tof\tedges. Definition:\tGraphs\tG1\t=\t{V1,\tE1}\tand\tG2\t=\t{V2,\tE2}\tare\tisomorphic\tif 1) There\tis\ta\tone-to-one\tcorrespondence\tfrom\tV1\tto\tV2\tand 2) There\tis\ta\tone-to-one\tcorrespondence\tfrom\tE1\tto\tE2\tthat\tmap\teach\tedge\tof\tG1\tto\tG2. Now,\tfor\tthe\tgiven\tgraphs\thow\tdo\twe\tcheck\twhether\tthey\tare\tisomorphic\tor\tnot? In\tgeneral,\tit\tis\tnot\ta\tsimple\ttask\tto\tprove\tthat\ttwo\tgraphs\tare\tisomorphic.\tFor\tthat\treason\twe must\t consider\t some\t properties\t of\t isomorphic\t graphs.\t That\t means\t those\t properties\t must\t be satisfied\tif\tthe\tgraphs\tare\tisomorphic.\tIf\tthe\tgiven\tgraph\tdoes\tnot\tsatisfy\tthese\tproperties\tthen\twe say\tthey\tare\tnot\tisomorphic\tgraphs. Property:\t Two\t graphs\t are\t isomorphic\t if\t and\t only\t if\t for\t some\t ordering\t of\t their\t vertices\t their adjacency\tmatrices\tare\tequal. Based\ton\tthe\tabove\tproperty\twe\tdecide\twhether\tthe\tgiven\tgraphs\tare\tisomorphic\tor\tnot.\tI\torder to\tcheck\tthe\tproperty,\twe\tneed\tto\tdo\tsome\tmatrix\ttransformation\toperations. Problem-34\u2003\u2003How\tmany\tsimple\tundirected\tnon-isomorphic\tgraphs\tare\tthere\twith\tn\tvertices? Solution:\tWe\twill\ttry\tto\tanswer\tthis\tquestion\tin\ttwo\tsteps.\tFirst,\twe\tcount\tall\tlabeled\tgraphs. Assume\tall\tthe\trepresentations\tbelow\tare\tlabeled\twith\t{1,2,3}\tas\tvertices.\tThe\tset\tof\tall\tsuch graphs\tfor\tn\t=\t3\tare: There\tare\tonly\ttwo\tchoices\tfor\teach\tedge:\tit\teither\texists\tor\tit\tdoes\tnot.\tTherefore,\tsince\tthe maximum\t number\t of\t edges\t is\t \t (and\t since\t the\t maximum\t number\t of\t edges\t in\t an\t undirected graph\twith\tn\tvertices\tis\t ,\tthe\ttotal\tnumber\tof\tundirected\tlabeled\tgraphs\tis\t . Problem-35\u2003\u2003Hamiltonian\tpath\tin\tDAGs:\tGiven\ta\tDAG,\tdesign\ta\tlinear\ttime\talgorithm\tto determine\twhether\tthere\tis\ta\tpath\tthat\tvisits\teach\tvertex\texactly\tonce. Solution:\t The\t Hamiltonian\t path\t problem\t is\t an\t NP-Complete\t problem\t (for\t more\t details\t ref Complexity\t Classes\t chapter).\t To\t solve\t this\t problem,\t we\t will\t try\t to\t give\t the\t approximation algorithm\t(which\tsolves\tthe\tproblem,\tbut\tit\tmay\tnot\talways\tproduce\tthe\toptimal\tsolution). Let\tus\tconsider\tthe\ttopological\tsort\talgorithm\tfor\tsolving\tthis\tproblem.\tTopological\tsort\thas\tan interesting\tproperty:\tthat\tif\tall\tpairs\tof\tconsecutive\tvertices\tin\tthe\tsorted\torder\tare\tconnected\tby edges,\tthen\tthese\tedges\tform\ta\tdirected\tHamiltonian\tpath\tin\tthe\tDAG.\tIf\ta\tHamiltonian\t path exists,\t the\t topological\t sort\t order\t is\t unique.\t Also,\t if\t a\t topological\t sort\t does\t not\t form\t a Hamiltonian\tpath,\tthe\tDAG\twill\thave\ttwo\tor\tmore\ttopological\torderings. Approximation\tAlgorithm:\tCompute\ta\ttopological\tsort\tand\tcheck\tif\tthere\tis\tan\tedge\tbetween\teach consecutive\tpair\tof\tvertices\tin\tthe\ttopological\torder. In\tan\tunweighted\tgraph,\tfind\ta\tpath\tfrom\ts\tto\tt\tthat\tvisits\teach\tvertex\texactly\tonce.\tThe\tbasic solution\tbased\ton\tbacktracking\tis,\twe\tstart\tat\ts\tand\ttry\tall\tof\tits\tneighbors\trecursively,\tmaking sure\twe\tnever\tvisit\tthe\tsame\tvertex\ttwice.\tThe\talgorithm\tbased\ton\tthis\timplementation\tcan\tbe given\tas: Note\tthat\tif\twe\thave\ta\tpartial\tpath\tfrom\ts\tto\tu\tusing\tvertices\ts\t=\tv1,\tv2,...,\tvk\t=\tu,\tthen\twe\tdon\u2019t care\tabout\tthe\torder\tin\twhich\twe\tvisited\tthese\tvertices\tso\tas\tto\tfigure\tout\twhich\tvertex\tto\tvisit next.\tAll\tthat\twe\tneed\tto\tknow\tis\tthe\tset\tof\tvertices\twe\thave\tseen\t(the\tseenTable[]\tarray)\tand which\tvertex\twe\tare\tat\tright\tnow\t(u).\tThere\tare\t2n\tpossible\tsets\tof\tvertices\tand\tn\tchoices\tfor\tu.\tIn other\t words,\t there\t are\t 2n\t possible\t seenTable[]\t arrays\t and\t n\t different\t parameters\t to Hamiltonian_path().\t What\t Hamiltonian_path()\t does\t during\t any\t particular\t recursive\t call\t is completely\tdetermined\tby\tthe\tseenTable[\t]\tarray\tand\tthe\tparameter\tu. Problem-36\u2003\u2003For\ta\tgiven\tgraph\tG\twith\tn\tvertices\thow\tmany\ttrees\twe\tcan\tconstruct? Solution:\tThere\tis\ta\tsimple\tformula\tfor\tthis\tproblem\tand\tit\tis\tnamed\tafter\tArthur\tCayley.\tFor\ta given\tgraph\twith\tn\tlabeled\tvertices\tthe\tformula\tfor\tfinding\tnumber\tof\ttrees\ton\tis\tnn\u20132.\tBelow,\tthe number\tof\ttrees\twith\tdifferent\tn\tvalues\tis\tshown. Problem-37\u2003\u2003For\ta\tgiven\tgraph\tG\twith\tn\tvertices\thow\tmany\tspanning\ttrees\tcan\twe\tconstruct? Solution:\tThe\tsolution\tto\tthis\tproblem\tis\tthe\tsame\tas\tthat\tof\tProblem-36.\tIt\tis\tjust\tanother\tway\tof asking\tthe\tsame\tquestion.\tBecause\tthe\tnumber\tof\tedges\tin\tboth\tregular\ttree\tand\tspanning\ttree\tare the\tsame. Problem-38\u2003\u2003The\tHamiltonian\tcycle\tproblem:\tIs\tit\tpossible\tto\ttraverse\teach\tof\tthe\tvertices of\ta\tgraph\texactly\tonce,\tstarting\tand\tending\tat\tthe\tsame\tvertex? Solution:\t Since\t the\t Hamiltonian\t path\t problem\t is\t an\t NP-Complete\t problem,\t the\t Hamiltonian cycle\tproblem\tis\tan\tNP-Complete\tproblem.\tA\tHamiltonian\tcycle\tis\ta\tcycle\tthat\ttraverses\tevery vertex\tof\ta\tgraph\texactly\tonce.\tThere\tare\tno\tknown\tconditions\tin\twhich\tare\tboth\tnecessary\tand sufficient,\tbut\tthere\tare\ta\tfew\tsufficient\tconditions. \u2022 For\ta\tgraph\tto\thave\ta\tHamiltonian\tcycle\tthe\tdegree\tof\teach\tvertex\tmust\tbe\ttwo\tor more. \u2022 The\tPetersen\tgraph\tdoes\tnot\thave\ta\tHamiltonian\tcycle\tand\tthe\tgraph\tis\tgiven\tbelow. \u2022 In\tgeneral,\tthe\tmore\tedges\ta\tgraph\thas,\tthe\tmore\tlikely\tit\tis\tto\thave\ta\tHamiltonian cycle. \u2022 Let\tG\tbe\ta\tsimple\tgraph\twith\tn\t\u2265\t3\tvertices.\tIf\tevery\tvertex\thas\ta\tdegree\tof\tat\tleast\t ,\tthen\tG\thas\ta\tHamiltonian\tcycle. \u2022 The\tbest\tknown\talgorithm\tfor\tfinding\ta\tHamiltonian\tcycle\thas\tan\texponential\tworst- case\tcomplexity. Note:\tFor\tthe\tapproximation\talgorithm\tof\tHamiltonian\tpath,\trefer\tto\tthe\tDynamic\tProgramming chapter. Problem-39\u2003\u2003What\tis\tthe\tdifference\tbetween\tDijkstra\u2019s\tand\tPrim\u2019s\talgorithm? Solution:\t Dijkstra\u2019s\t algorithm\t is\t almost\t identical\t to\t that\t of\t Prim\u2019s.\t The\t algorithm\t begins\t at\t a specific\tvertex\tand\textends\toutward\twithin\tthe\tgraph\tuntil\tall\tvertices\thave\tbeen\treached.\tThe only\tdistinction\tis\tthat\tPrim\u2019s\talgorithm\tstores\ta\tminimum\tcost\tedge\twhereas\tDijkstra\u2019s\talgorithm stores\tthe\ttotal\tcost\tfrom\ta\tsource\tvertex\tto\tthe\tcurrent\tvertex.\tMore\tsimply,\tDijkstra\u2019s\talgorithm stores\ta\tsummation\tof\tminimum\tcost\tedges\twhereas\tPrim\u2019s\talgorithm\tstores\tat\tmost\tone\tminimum cost\tedge. Problem-40\u2003\u2003Reversing\tGraph:\t:\tGive\tan\talgorithm\tthat\treturns\tthe\treverse\tof\tthe\tdirected graph\t(each\tedge\tfrom\tv\tto\tw\tis\treplaced\tby\tan\tedge\tfrom\tw\tto\tv). Solution:\tIn\tgraph\ttheory,\tthe\treverse\t(also\tcalled\ttranspose)\tof\ta\tdirected\tgraph\tG\tis\tanother directed\tgraph\ton\tthe\tsame\tset\tof\tvertices\twith\tall\tthe\tedges\treversed.\tThat\tmeans,\tif\tG\tcontains an\tedge\t(u,\tv)\tthen\tthe\treverse\tof\tG\tcontains\tan\tedge\t(v,\tu)\tand\tvice\tversa. Algorithm: Problem-41\u2003\u2003Travelling\tSales\tPerson\tProblem:\tFind\tthe\tshortest\tpath\tin\ta\tgraph\tthat\tvisits each\tvertex\tat\tleast\tonce,\tstarting\tand\tending\tat\tthe\tsame\tvertex? Solution:\t The\t Traveling\t Salesman\t Problem\t (TSP)\t is\t related\t to\t finding\t a\t Hamiltonian\t cycle. Given\ta\tweighted\tgraph\tG,\twe\twant\tto\tfind\tthe\tshortest\tcycle\t(may\tbe\tnon-simple)\tthat\tvisits\tall the\tvertices. Approximation\talgorithm:\tThis\talgorithm\tdoes\tnot\tsolve\tthe\tproblem\tbut\tgives\ta\tsolution\twhich is\twithin\ta\tfactor\tof\t2\tof\toptimal\t(in\tthe\tworst-case). 1) Find\ta\tMinimal\tSpanning\tTree\t(MST). 2) Do\ta\tDFS\tof\tthe\tMST. For\tdetails,\trefer\tto\tthe\tchapter\ton\tComplexity\tClasses. Problem-42\u2003\u2003Discuss\tBipartite\tmatchings? Solution:\tIn\tBipartite\tgraphs,\twe\tdivide\tthe\tgraphs\tin\tto\ttwo\tdisjoint\tsets,\tand\teach\tedge\tconnects a\tvertex\tfrom\tone\tset\tto\ta\tvertex\tin\tanother\tsubset\t(as\tshown\tin\tfigure). Definition:\tA\tsimple\tgraph\tG\t=\t(V,\tE)\tis\tcalled\ta\tbipartite\tgraph\tif\tits\tvertices\tcan\tbe\tdivided into\ttwo\tdisjoint\tsets\tV\t=\tV1\t\u22c3\tV2,\tsuch\tthat\tevery\tedge\thas\tthe\tform\te\t=\t(a,b)\twhere\ta\t\u2208\tV1\tand b\t\u2208\tV2.\tOne\timportant\tcondition\tis\tthat\tno\tvertices\tboth\tin\tV1\tor\tboth\tin\tV2\tare\tconnected. Properties\tof\tBipartite\tGraphs \u2022 A\tgraph\tis\tcalled\tbipartite\tif\tand\tonly\tif\tthe\tgiven\tgraph\tdoes\tnot\thave\tan\todd\tlength cycle. \u2022 A\tcomplete\tbipartite\tgraph\tKm,n\tis\ta\tbipartite\tgraph\tthat\thas\teach\tvertex\tfrom\tone set\tadjacent\tto\teach\tvertex\tfrom\tanother\tset. \u2022 A\tsubset\tof\tedges\tM\t\u2282\tE\tis\ta\tmatching\tif\tno\ttwo\tedges\thave\ta\tcommon\tvertex.\tAs an\texample,\tmatching\tsets\tof\tedges\tare\trepresented\twith\tdotted\tlines.\tA\tmatching\tM is\tcalled\tmaximum\tif\tit\thas\tthe\tlargest\tnumber\tof\tpossible\tedges.\tIn\tthe\tgraphs,\tthe dotted\tedges\trepresent\tthe\talternative\tmatching\tfor\tthe\tgiven\tgraph. \u2022 A\tmatching\tM\tis\tperfect\tif\tit\tmatches\tall\tvertices.\tWe\tmust\thave\tV1\t=\tV2\tin\torder\tto have\tperfect\tmatching. \u2022 An\t alternating\t path\t is\t a\t path\t whose\t edges\t alternate\t between\t matched\t and unmatched\tedges.\tIf\twe\tfind\tan\talternating\tpath,\tthen\twe\tcan\timprove\tthe\tmatching. This\tis\tbecause\tan\talternating\tpath\tconsists\tof\tmatched\tand\tunmatched\tedges.\tThe number\t of\t unmatched\t edges\t exceeds\t the\t number\t of\t matched\t edges\t by\t one. Therefore,\tan\talternating\tpath\talways\tincreases\tthe\tmatching\tby\tone. The\t next\t question\t is,\t how\t do\t we\t find\t a\t perfect\t matching?\t Based\t on\t the\t above\t theory\t and definition,\twe\tcan\tfind\tthe\tperfect\tmatching\twith\tthe\tfollowing\tapproximation\talgorithm. Matching\tAlgorithm\t(Hungarian\talgorithm) 1) Start\tat\tunmatched\tvertex. 2) Find\tan\talternating\tpath. 3) If\tit\texists,\tchange\tmatching\tedges\tto\tno\tmatching\tedges\tand\tconversely.\tIf\tit\tdoes\tnot exist,\tchoose\tanother\tunmatched\tvertex. 4) If\tthe\tnumber\tof\tedges\tequals\tV/2,\tstop.\tOtherwise\tproceed\tto\tstep\t1\tand\trepeat,\tas long\tas\tall\tvertices\thave\tbeen\texamined\twithout\tfinding\tany\talternating\tpaths. Time\t Complexity\t of\t the\t Matching\t Algorithm:\t The\t number\t of\t iterations\t is\t in\t O(V).\t The complexity\tof\tfinding\tan\talternating\tpath\tusing\tBFS\tis\tO(E).\tTherefore,\tthe\ttotal\ttime\tcomplexity is\tO(V\t\u00d7\tE). Problem-43\u2003\u2003Marriage\tand\tPersonnel\tProblem? Marriage\t Problem:\t There\t are\t X\t men\t and\t Y\t women\t who\t desire\t to\t get\t married.\t Participants indicate\twho\tamong\tthe\topposite\tsex\tcould\tbe\ta\tpotential\tspouse\tfor\tthem.\tEvery\twoman\tcan\tbe married\tto\tat\tmost\tone\tman,\tand\tevery\tman\tto\tat\tmost\tone\twoman.\tHow\tcan\twe\tmarry\teverybody to\tsomeone\tthey\tlike? Personnel\tProblem:\tYou\tare\tthe\tboss\tof\ta\tcompany.\tThe\tcompany\thas\tM\tworkers\tand\tN\tjobs. Each\t worker\t is\t qualified\t to\t do\t some\t jobs,\t but\t not\t others.\t How\t will\t you\t assign\t jobs\t to\t each worker? Solution:\tThese\ttwo\tcases\tare\tjust\tanother\tway\tof\tasking\tabout\tbipartite\tgraphs,\tand\tthe\tsolution is\tthe\tsame\tas\tthat\tof\tProblem-42. Problem-44\u2003\u2003How\tmany\tedges\twill\tbe\tthere\tin\tcomplete\tbipartite\tgraph\tKm,n? Solution:\tm\t\u00d7\tn.\tThis\tis\tbecause\teach\tvertex\tin\tthe\tfirst\tset\tcan\tconnect\tall\tvertices\tin\tthe\tsecond set. Problem-45\u2003\u2003A\tgraph\tis\tcalled\ta\tregular\tgraph\tif\tit\thas\tno\tloops\tand\tmultiple\tedges\twhere each\t vertex\t has\t the\t same\t number\t of\t neighbors;\t i.e.,\t every\t vertex\t has\t the\t same\t degree. Now,\tif\tKm,n\tis\ta\tregular\tgraph,\twhat\tis\tthe\trelation\tbetween\tm\tand\tn? Solution:\tSince\teach\tvertex\tshould\thave\tthe\tsame\tdegree,\tthe\trelation\tshould\tbe\tm\t=\tn. Problem-46\u2003\u2003What\tis\tthe\tmaximum\tnumber\tof\tedges\tin\tthe\tmaximum\tmatching\tof\ta\tbipartite graph\twith\tn\tvertices? Solution:\tFrom\tthe\tdefinition\tof\tmatching,\twe\tshould\tnot\thave\tedges\twith\tcommon\tvertices.\tSo in\ta\tbipartite\tgraph,\teach\tvertex\tcan\tconnect\tto\tonly\tone\tvertex.\tSince\twe\tdivide\tthe\ttotal\tvertices into\ttwo\tsets,\twe\tcan\tget\tthe\tmaximum\tnumber\tof\tedges\tif\twe\tdivide\tthem\tin\thalf.\tFinally\tthe answer\tis\t . Problem-47\u2003\u2003Discuss\t Planar\t Graphs.\t Planar\t graph:\t Is\t it\t possible\t to\t draw\t the\t edges\t of\t a graph\tin\tsuch\ta\tway\tthat\tthe\tedges\tdo\tnot\tcross? Solution:\tA\tgraph\tG\tis\tsaid\tto\tbe\tplanar\tif\tit\tcan\tbe\tdrawn\tin\tthe\tplane\tin\tsuch\ta\tway\tthat\tno\ttwo edges\tmeet\teach\tother\texcept\tat\ta\tvertex\tto\twhich\tthey\tare\tincident.\tAny\tsuch\tdrawing\tis\tcalled\ta plane\tdrawing\tof\tG.\tAs\tan\texample\tconsider\tthe\tbelow\tgraph: This\tgraph\twe\tcan\teasily\tconvert\tto\ta\tplanar\tgraph\tas\tbelow\t(without\tany\tcrossed\tedges). How\tdo\twe\tdecide\twhether\ta\tgiven\tgraph\tis\tplanar\tor\tnot? The\tsolution\tto\tthis\tproblem\tis\tnot\tsimple,\tbut\tresearchers\thave\tfound\tsome\tinteresting\tproperties that\twe\tcan\tuse\tto\tdecide\twhether\tthe\tgiven\tgraph\tis\ta\tplanar\tgraph\tor\tnot. Properties\tof\tPlanar\tGraphs \u2022 If\ta\tgraph\tG\tis\ta\tconnected\tplanar\tsimple\tgraph\twith\tV\tvertices,\twhere\tV\t=\t3\tand\tE edges,\tthen\tE\t=\t3V\t\u2013\t6. \u2022 K5\tis\tnon-planar.\t[K5\tstands\tfor\tcomplete\tgraph\twith\t5\tvertices]. \u2022 If\ta\tgraph\tG\tis\ta\tconnected\tplanar\tsimple\tgraph\twith\tV\tvertices\tand\tE\tedges,\tand\tno triangles,\tthen\tE\t=\t2V\t\u2013\t4. \u2022 K3,3\tis\tnon-planar.\t[K3,3\tstands\tfor\tbipartite\tgraph\twith\t3\tvertices\ton\tone\tside\tand the\tother\t3\tvertices\ton\tthe\tother\tside.\tK3,3\tcontains\t6\tvertices]. \u2022 If\ta\tgraph\tG\tis\ta\tconnected\tplanar\tsimple\tgraph,\tthen\tG\tcontains\tat\tleast\tone\tvertex of\t5\tdegrees\tor\tless. \u2022 A\tgraph\tis\tplanar\tif\tand\tonly\tif\tit\tdoes\tnot\tcontain\ta\tsubgraph\tthat\thas\tK5\tand\tK3,3\tas a\tcontraction. \u2022 If\ta\tgraph\tG\tcontains\ta\tnonplanar\tgraph\tas\ta\tsubgraph,\tthen\tG\tis\tnon-planar. \u2022 If\ta\tgraph\tG\tis\ta\tplanar\tgraph,\tthen\tevery\tsubgraph\tof\tG\tis\tplanar. \u2022 For\tany\tconnected\tplanar\tgraph\tG\t=\t(V,E),\tthe\tfollowing\tformula\tshould\thold:\tV\t+\tF \u2013\tE\t=\t2,\twhere\tF\tstands\tfor\tthe\tnumber\tof\tfaces. \u2022 For\tany\tplanar\tgraph\tG\t=\t(V,\tE)\twith\tK\tcomponents,\tthe\tfollowing\tformula\tholds:\tV +\tF\t\u2013\tE\t=\t1\t+\tK. In\torder\tto\ttest\tthe\tplanarity\tof\ta\tgiven\tgraph,\twe\tuse\tthese\tproperties\tand\tdecide\twhether\tit\tis\ta planar\tgraph\tor\tnot.\tNote\tthat\tall\tthe\tabove\tproperties\tare\tonly\tthe\tnecessary\tconditions\tbut\tnot sufficient. Problem-48\u2003\u2003How\tmany\tfaces\tdoes\tK2,3\thave? Solution:\tFrom\tthe\tabove\tdiscussion,\twe\tknow\tthat\tV\t+\tF\t\u2013\tE\t=\t2,\tand\tfrom\tan\tearlier\tproblem we\tknow\tthat\tE\t=\tm\t\u00d7\tn\t=\t2\t\u00d7\t3\t=\t6\tand\tV\t=\tm\t+\tn\t=\t5.\t\u2234\t5\t+\tF\t\u2013\t6\t=\t2\t\u21d2\tF\t=\t3. Problem-49\u2003\u2003Discuss\tGraph\tColoring Solution:\tA\tk\t\u2013coloring\tof\ta\tgraph\tG\tis\tan\tassignment\tof\tone\tcolor\tto\teach\tvertex\tof\tG\tsuch\tthat no\tmore\tthan\tk\tcolors\tare\tused\tand\tno\ttwo\tadjacent\tvertices\treceive\tthe\tsame\tcolor.\tA\tgraph\tis called\tk\t\u2013colorable\tif\tand\tonly\tif\tit\thas\ta\tk\t\u2013coloring. Applications\t of\t Graph\t Coloring:\t The\t graph\t coloring\t problem\t has\t many\t applications\t such\t as scheduling,\tregister\tallocation\tin\tcompilers,\tfrequency\tassignment\tin\tmobile\tradios,\tetc. Clique:\tA\tclique\tin\ta\tgraph\tG\tis\tthe\tmaximum\tcomplete\tsubgraph\tand\tis\tdenoted\tby\t\u03c9(G). Chromatic\tnumber:\tThe\tchromatic\tnumber\tof\ta\tgraph\tG\tis\tthe\tsmallest\tnumber\tk\tsuch\tthat\tG\tis\tk \u2013colorable,\tand\tit\tis\tdenoted\tby\tX\t(G). The\tlower\tbound\tfor\tX\t(G)\tis\t\u03c9(G),\tand\tthat\tmeans\t\u03c9(G)\t\u2264\tX\t(G). Properties\tof\tChromatic\tnumber:\tLet\tG\tbe\ta\tgraph\twith\tn\tvertices\tand\tG\u2032\tis\tits\tcomplement. Then, \u2022 X\t(G)\t\u2264\t\u2206\t(G)\t+\t1,\twhere\t\u2206\t(G)\tis\tthe\tmaximum\tdegree\tof\tG. \u2022 X(G)\t\u03c9(G\u2032)\t\u2265\tn \u2022 X(G)\t+\t\u03c9(G\u2032)\t\u2264\tn\t+\t1 \u2022 X(G)\t+\t(G\u2032)\t\u2264\tn\t+\t1 K-colorability\tproblem:\tGiven\ta\tgraph\tG\t=\t(V,E)\tand\ta\tpositive\tinteger\tk\t\u2264\tV.\tCheck\twhether\tG is\tk\t\u2013colorable? This\t problem\t is\t NP-complete\t and\t will\t be\t discussed\t in\t detail\t in\t the\t chapter\t on\t Complexity Classes. Graph\tcoloring\talgorithm:\tAs\tdiscussed\tearlier,\tthis\tproblem\tis\tNP-Complete.\tSo\twe\tdo\tnot have\ta\tpolynomial\ttime\talgorithm\tto\tdetermine\tX(G).\tLet\tus\tconsider\tthe\tfollowing\tapproximation (no\tefficient)\talgorithm. \u2022 Consider\ta\tgraph\tG\twith\ttwo\tnon-adjacent\tvertices\ta\tand\tb.\tThe\tconnection\tG1\tis obtained\t by\t joining\t the\t two\t non-adjacent\t vertices\t a\t and\t b\t with\t an\t edge.\t The contraction\tG2\tis\tobtained\tby\tshrinking\t{a,b}\tinto\ta\tsingle\tvertex\tc(a,\tb)\t and\t by joining\tit\tto\teach\tneighbor\tin\tG\tof\tvertex\ta\tand\tof\tvertex\tb\t(and\teliminating\tmultiple edges). \u2022 A\tcoloring\tof\tG\tin\twhich\ta\tand\tb\thave\tthe\tsame\tcolor\tyields\ta\tcoloring\tof\tG1.\t A coloring\tof\tG\tin\twhich\ta\tand\tb\thave\tdifferent\tcolors\tyields\ta\tcoloring\tof\tG2. \u2022 Repeat\tthe\toperations\tof\tconnection\tand\tcontraction\tin\teach\tgraph\tgenerated,\tuntil the\tresulting\tgraphs\tare\tall\tcliques.\tIf\tthe\tsmallest\tresulting\tclique\tis\ta\tK\t\u2013clique, then\t(G)\t=\tK. Important\tnotes\ton\tGraph\tColoring \u2022 Any\tsimple\tplanar\tgraph\tG\tcan\tbe\tcolored\twith\t6\tcolors. \u2022 Every\tsimple\tplanar\tgraph\tcan\tbe\tcolored\twith\tless\tthan\tor\tequal\tto\t5\tcolors. Problem-50\u2003\u2003What\tis\tthe\tfour\tcoloring\tproblem? Solution:\tA\tgraph\tcan\tbe\tconstructed\tfrom\tany\tmap.\tThe\tregions\tof\tthe\tmap\tare\trepresented\tby the\tvertices\tof\tthe\tgraph,\tand\ttwo\tvertices\tare\tjoined\tby\tan\tedge\tif\tthe\tregions\tcorresponding\tto the\tvertices\tare\tadjacent.\tThe\tresulting\tgraph\tis\tplanar.\tThat\tmeans\tit\tcan\tbe\tdrawn\tin\tthe\tplane without\tany\tedges\tcrossing. The\tFour\tColor\tProblem\tis\twhether\tthe\tvertices\tof\ta\tplanar\tgraph\tcan\tbe\tcolored\twith\tat\tmost four\tcolors\tso\tthat\tno\ttwo\tadjacent\tvertices\tuse\tthe\tsame\tcolor. History:\t The\t Four\t Color\t Problem\t was\t first\t given\t by\t Francis\t Guthrie.\t He\t was\t a\t student\t at University\tCollege\tLondon\twhere\the\tstudied\tunder\tAugusts\tDe\tMorgan.\tAfter\tgraduating\tfrom London\the\tstudied\tlaw,\tbut\tsome\tyears\tlater\this\tbrother\tFrederick\tGuthrie\thad\tbecome\ta\tstudent of\tDe\tMorgan.\tOne\tday\tFrancis\tasked\this\tbrother\tto\tdiscuss\tthis\tproblem\twith\tDe\tMorgan. Problem-51\u2003\u2003When\tan\tadjacency-matrix\trepresentation\tis\tused,\tmost\tgraph\talgorithms\trequire time\tO(V2).\tShow\tthat\tdetermining\twhether\ta\tdirected\tgraph,\trepresented\tin\tan\tadjacency- matrix\tthat\tcontains\ta\tsink\tcan\tbe\tdone\tin\ttime\tO(V).\tA\tsink\tis\ta\tvertex\twith\tin-degree\t|V| \u2013\t1\tand\tout-degree\t0\t(Only\tone\tcan\texist\tin\ta\tgraph). Solution:\tA\tvertex\ti\tis\ta\tsink\tif\tand\tonly\tif\tM[i,j]\t=\t0\tfor\tall\tj\tand\tM[j,\ti]\t=\t1\tfor\tall\tj\t\u2260\ti.\tFor\tany pair\tof\tvertices\ti\tand\tj: Algorithm: \u2022 Start\tat\ti\t=\t1,j\t=\t1 \u2022 If\tM[i,j]\t=\t0\t\u2192\ti\twins,\tj\t+\t+ \u2022 If\tM[i,j]\t=\t1\t\u2192\tj\twins,\ti\t+\t+ \u2022 Proceed\twith\tthis\tprocess\tuntil\tj\t=\tn\tor\ti\t=\tn\t+\t1 \u2022 If\ti\t==\tn\t+\t1,\tthe\tgraph\tdoes\tnot\tcontain\ta\tsink \u2022 Otherwise,\tcheck\trow\ti\t\u2013\tit\tshould\tbe\tall\tzeros;\tand\tcheck\tcolumn\ti\t\u2013\tit\tshould\tbe\tall but\tM[i,\ti]\tones;\t\u2013\tif\tso,\tt\tis\ta\tsink. Time\tComplexity:\tO(V),\tbecause\tat\tmost\t2|V|\tcells\tin\tthe\tmatrix\tare\texamined. Problem-52\u2003\u2003What\tis\tthe\tworst\t\u2013\tcase\tmemory\tusage\tof\tDFS? Solution:\tIt\toccurs\twhen\tthe\tO(|V|),\twhich\thappens\tif\tthe\tgraph\tis\tactually\ta\tlist.\tSo\tthe\talgorithm is\tmemory\tefficient\ton\tgraphs\twith\tsmall\tdiameter. Problem-53\u2003\u2003Does\tDFS\tfind\tthe\tshortest\tpath\tfrom\tstart\tnode\tto\tsome\tnode\tw\t? Solution:\tNo.\tIn\tDFS\tit\tis\tnot\tcompulsory\tto\tselect\tthe\tsmallest\tweight\tedge. Problem-54\u2003\u2003True\t or\t False:\t Dijkstra\u2019s\t algorithm\t does\t not\t compute\t the\t \u201call\t pairs\u201d\t shortest paths\t in\t a\t directed\t graph\t with\t positive\t edge\t weights\t because,\t running\t the\t algorithm\t a single\ttime,\tstarting\tfrom\tsome\tsingle\tvertex\tx,\tit\twill\tcompute\tonly\tthe\tmin\tdistance\tfrom x\tto\ty\tfor\tall\tnodes\ty\tin\tthe\tgraph. Solution:\tTrue. Problem-55\u2003\u2003True\tor\tFalse:\tPrim\u2019s\tand\tKruskal\u2019s\talgorithms\tmay\tcompute\tdifferent\tminimum spanning\ttrees\twhen\trun\ton\tthe\tsame\tgraph. Solution:\tTrue."
            },
            {
                "subchapter_title": "10.1\tWhat\tis\tSorting?",
                "content": "Sorting\tis\tan\talgorithm\tthat\tarranges\tthe\telements\tof\ta\tlist\tin\ta\tcertain\torder\t[either\tascending\tor descending].\tThe\toutput\tis\ta\tpermutation\tor\treordering\tof\tthe\tinput."
            },
            {
                "subchapter_title": "10.2\tWhy\tis\tSorting\tNecessary?",
                "content": "Sorting\tis\tone\tof\tthe\timportant\tcategories\tof\talgorithms\tin\tcomputer\tscience\tand\ta\tlot\tof\tresearch has\tgone\tinto\tthis\tcategory.\tSorting\tcan\tsignificantly\treduce\tthe\tcomplexity\tof\ta\tproblem,\tand\tis often\tused\tfor\tdatabase\talgorithms\tand\tsearches."
            },
            {
                "subchapter_title": "10.3\tClassification\tof\tSorting\tAlgorithms",
                "content": "Sorting\talgorithms\tare\tgenerally\tcategorized\tbased\ton\tthe\tfollowing\tparameters. By\tNumber\tof\tComparisons In\t this\t method,\t sorting\t algorithms\t are\t classified\t based\t on\t the\t number\t of\t comparisons.\t For comparison\tbased\tsorting\talgorithms,\tbest\tcase\tbehavior\tis\tO(nlogn)\tand\tworst\tcase\tbehavior\tis O(n2).\tComparison-based\tsorting\talgorithms\tevaluate\tthe\telements\tof\tthe\tlist\tby\tkey\tcomparison operation\tand\tneed\tat\tleast\tO(nlogn)\tcomparisons\tfor\tmost\tinputs. Later\tin\tthis\tchapter\twe\twill\tdiscuss\ta\tfew\tnon\t\u2013\tcomparison\t(linear)\tsorting\talgorithms\tlike Counting\tsort,\tBucket\tsort,\tRadix\tsort,\tetc.\tLinear\tSorting\talgorithms\timpose\tfew\trestrictions\ton the\tinputs\tto\timprove\tthe\tcomplexity. By\tNumber\tof\tSwaps In\t this\t method,\t sorting\t algorithms\t are\t categorized\t by\t the\t number\t of\t swaps\t (also\t called inversions). By\tMemory\tUsage Some\t sorting\t algorithms\t are\t \u201cin\t place\u201d\t and\t they\t need\t O(1)\t or\t O(logn)\t memory\t to\t create auxiliary\tlocations\tfor\tsorting\tthe\tdata\ttemporarily. By\tRecursion Sorting\talgorithms\tare\teither\trecursive\t[quick\tsort]\tor\tnon-recursive\t[selection\tsort,\tand\tinsertion sort],\tand\tthere\tare\tsome\talgorithms\twhich\tuse\tboth\t(merge\tsort). By\tStability Sorting\talgorithm\tis\tstable\tif\tfor\tall\tindices\ti\tand\tj\tsuch\tthat\tthe\tkey\tA[i]\tequals\tkey\tA[j],\tif\trecord R[i]\tprecedes\trecord\tR[j]\tin\tthe\toriginal\tfile,\trecord\tR[i]\tprecedes\trecord\tR[j]\tin\tthe\tsorted\tlist. Few\t sorting\t algorithms\t maintain\t the\t relative\t order\t of\t elements\t with\t equal\t keys\t (equivalent elements\tretain\ttheir\trelative\tpositions\teven\tafter\tsorting). By\tAdaptability With\ta\tfew\tsorting\talgorithms,\tthe\tcomplexity\tchanges\tbased\ton\tpre-sortedness\t[quick\tsort]:\tpre- sortedness\tof\tthe\tinput\taffects\tthe\trunning\ttime.\tAlgorithms\tthat\ttake\tthis\tinto\taccount\tare\tknown\tto be\tadaptive."
            },
            {
                "subchapter_title": "10.4\tOther\tClassifications",
                "content": "Another\tmethod\tof\tclassifying\tsorting\talgorithms\tis: \u2022 Internal\tSort \u2022 External\tSort Internal\tSort Sort\t algorithms\t that\t use\t main\t memory\t exclusively\t during\t the\t sort\t are\t called\t internal\t sorting algorithms.\tThis\tkind\tof\talgorithm\tassumes\thigh-speed\trandom\taccess\tto\tall\tmemory. External\tSort Sorting\talgorithms\tthat\tuse\texternal\tmemory,\tsuch\tas\ttape\tor\tdisk,\tduring\tthe\tsort\tcome\tunder\tthis category."
            },
            {
                "subchapter_title": "10.5\tBubble\tSort",
                "content": "Bubble\tsort\tis\tthe\tsimplest\tsorting\talgorithm.\tIt\tworks\tby\titerating\tthe\tinput\tarray\tfrom\tthe\tfirst element\tto\tthe\tlast,\tcomparing\teach\tpair\tof\telements\tand\tswapping\tthem\tif\tneeded.\tBubble\tsort continues\tits\titerations\tuntil\tno\tmore\tswaps\tare\tneeded.\tThe\talgorithm\tgets\tits\tname\tfrom\tthe\tway smaller\telements\t\u201cbubble\u201d\tto\tthe\ttop\tof\tthe\tlist.\tGenerally,\tinsertion\tsort\thas\tbetter\tperformance than\tbubble\tsort.\tSome\tresearchers\tsuggest\tthat\twe\tshould\tnot\tteach\tbubble\tsort\tbecause\tof\tits simplicity\tand\thigh\ttime\tcomplexity. The\tonly\tsignificant\tadvantage\tthat\tbubble\tsort\thas\tover\tother\timplementations\tis\tthat\tit\tcan\tdetect whether\tthe\tinput\tlist\tis\talready\tsorted\tor\tnot. Implementation Algorithm\ttakes\tO(n2)\t(even\tin\tbest\tcase).\tWe\tcan\timprove\tit\tby\tusing\tone\textra\tflag.\tNo\tmore swaps\tindicate\tthe\tcompletion\tof\tsorting.\tIf\tthe\tlist\tis\talready\tsorted,\twe\tcan\tuse\tthis\tflag\tto\tskip the\tremaining\tpasses. This\tmodified\tversion\timproves\tthe\tbest\tcase\tof\tbubble\tsort\tto\tO(n). Performance Worst\tcase\tcomplexity\t:\tO(n2) Best\tcase\tcomplexity\t(Improved\tversion)\t:\tO(n) Average\tcase\tcomplexity\t(Basic\tversion)\t:\tO(n2) Worst\tcase\tspace\tcomplexity\t:\tO(1)\tauxiliary"
            },
            {
                "subchapter_title": "10.6\tSelection\tSort",
                "content": "Selection\tsort\tis\tan\tin-place\tsorting\talgorithm.\tSelection\tsort\tworks\twell\tfor\tsmall\tfiles.\tIt\tis\tused for\tsorting\tthe\tfiles\twith\tvery\tlarge\tvalues\tand\tsmall\tkeys.\tThis\tis\tbecause\tselection\tis\tmade based\ton\tkeys\tand\tswaps\tare\tmade\tonly\twhen\trequired. Advantages \u2022 Easy\tto\timplement \u2022 In-place\tsort\t(requires\tno\tadditional\tstorage\tspace) Disadvantages \u2022 Doesn\u2019t\tscale\twell:\tO(n2) Algorithm"
            }
        ]
    },
    {
        "chapter_title": "1.",
        "subchapters": [
            {
                "subchapter_title": "Find\tthe\tminimum\tvalue\tin\tthe\tlist",
                "content": ""
            }
        ]
    },
    {
        "chapter_title": "2.",
        "subchapters": [
            {
                "subchapter_title": "Swap\tit\twith\tthe\tvalue\tin\tthe\tcurrent\tposition",
                "content": ""
            }
        ]
    },
    {
        "chapter_title": "3.",
        "subchapters": [
            {
                "subchapter_title": "Repeat\tthis\tprocess\tfor\tall\tthe\telements\tuntil\tthe\tentire\tarray\tis\tsorted",
                "content": "This\talgorithm\tis\tcalled\tselection\tsort\tsince\tit\trepeatedly\tselects\tthe\tsmallest\telement. Implementation Performance Worst\tcase\tcomplexity\t:\tO(n2) Best\tcase\tcomplexity\t:\tO(n2) Average\tcase\tcomplexity\t:\tO(n2) Worst\tcase\tspace\tcomplexity:\tO(1)\tauxiliary"
            },
            {
                "subchapter_title": "10.7\tInsertion\tSort",
                "content": "Insertion\tsort\tis\ta\tsimple\tand\tefficient\tcomparison\tsort.\tIn\tthis\talgorithm,\teach\titeration\tremoves an\telement\tfrom\tthe\tinput\tdata\tand\tinserts\tit\tinto\tthe\tcorrect\tposition\tin\tthe\tlist\tbeing\tsorted.\tThe choice\tof\tthe\telement\tbeing\tremoved\tfrom\tthe\tinput\tis\trandom\tand\tthis\tprocess\tis\trepeated\tuntil all\tinput\telements\thave\tgone\tthrough. Advantages \u2022 Simple\timplementation \u2022 Efficient\tfor\tsmall\tdata \u2022 Adaptive:\tIf\tthe\tinput\tlist\tis\tpresorted\t[may\tnot\tbe\tcompletely]\tthen\tinsertions\tsort takes\tO(n\t+\td),\twhere\td\tis\tthe\tnumber\tof\tinversions \u2022 Practically\tmore\tefficient\tthan\tselection\tand\tbubble\tsorts,\teven\tthough\tall\tof\tthem have\tO(n2)\tworst\tcase\tcomplexity \u2022 Stable:\tMaintains\trelative\torder\tof\tinput\tdata\tif\tthe\tkeys\tare\tsame \u2022 In-place:\tIt\trequires\tonly\ta\tconstant\tamount\tO(1)\tof\tadditional\tmemory\tspace \u2022 Online:\tInsertion\tsort\tcan\tsort\tthe\tlist\tas\tit\treceives\tit Algorithm Every\trepetition\tof\tinsertion\tsort\tremoves\tan\telement\tfrom\tthe\tinput\tdata,\tand\tinserts\tit\tinto\tthe correct\tposition\tin\tthe\talready-sorted\tlist\tuntil\tno\tinput\telements\tremain.\tSorting\tis\ttypically\tdone in-place.\tThe\tresulting\tarray\tafter\tk\titerations\thas\tthe\tproperty\twhere\tthe\tfirst\tk\t+\t1\tentries\tare sorted. Each\telement\tgreater\tthan\tx\tis\tcopied\tto\tthe\tright\tas\tit\tis\tcompared\tagainst\tx. Implementation Example Given\tan\tarray:\t6\t8\t1\t4\t5\t3\t7\t2\tand\tthe\tgoal\tis\tto\tput\tthem\tin\tascending\torder. Analysis Worst\tcase\tanalysis Worst\tcase\toccurs\twhen\tfor\tevery\ti\tthe\tinner\tloop\thas\tto\tmove\tall\telements\tA[1],\t.\t.\t.\t,\tA[i\t\u2013\t1] (which\thappens\twhen\tA[i]\t=\tkey\tis\tsmaller\tthan\tall\tof\tthem),\tthat\ttakes\t\u0398(i\t\u2013\t1)\ttime. Average\tcase\tanalysis For\tthe\taverage\tcase,\tthe\tinner\tloop\twill\tinsert\tA[i]\tin\tthe\tmiddle\tof\tA[1],\t.\t.\t.\t,\tA[i\t\u2013\t1].\tThis takes\t\u0398(i/2)\ttime. Performance If\tevery\telement\tis\tgreater\tthan\tor\tequal\tto\tevery\telement\tto\tits\tleft,\tthe\trunning\ttime\tof\tinsertion sort\tis\t\u0398(n).\tThis\tsituation\toccurs\tif\tthe\tarray\tstarts\tout\talready\tsorted,\tand\tso\tan\talready-sorted array\tis\tthe\tbest\tcase\tfor\tinsertion\tsort. Worst\tcase\tcomplexity:\t\u0398(n2) Best\tcase\tcomplexity:\t\u0398(n) Average\tcase\tcomplexity:\t\u0398(n2) Worst\tcase\tspace\tcomplexity:\tO(n2)\ttotal,\tO(1)\tauxiliary Comparisons\tto\tOther\tSorting\tAlgorithms Insertion\tsort\tis\tone\tof\tthe\telementary\tsorting\talgorithms\twith\tO(n2)\tworst-case\ttime.\tInsertion sort\tis\tused\twhen\tthe\tdata\tis\tnearly\tsorted\t(due\tto\tits\tadaptiveness)\tor\twhen\tthe\tinput\tsize\tis\tsmall (due\tto\tits\tlow\toverhead).\tFor\tthese\treasons\tand\tdue\tto\tits\tstability,\tinsertion\tsort\tis\tused\tas\tthe recursive\tbase\tcase\t(when\tthe\tproblem\tsize\tis\tsmall)\tfor\thigher\toverhead\tdivide-and-conquer sorting\talgorithms,\tsuch\tas\tmerge\tsort\tor\tquick\tsort. Notes: \u2022 Bubble\tsort\ttakes\t \tcomparisons\tand\t \tswaps\t(inversions)\tin\tboth\taverage\tcase and\tin\tworst\tcase. \u2022 Selection\tsort\ttakes\t \tcomparisons\tand\tn\tswaps. \u2022 Insertion\tsort\ttakes\t \tcomparisons\tand\t \tswaps\tin\taverage\tcase\tand\tin\tthe\tworst case\tthey\tare\tdouble. \u2022 Insertion\tsort\tis\talmost\tlinear\tfor\tpartially\tsorted\tinput. \u2022 Selection\tsort\tis\tbest\tsuits\tfor\telements\twith\tbigger\tvalues\tand\tsmall\tkeys."
            },
            {
                "subchapter_title": "10.8\tShell\tSort",
                "content": "Shell\tsort\t(also\tcalled\tdiminishing\tincrement\tsort)\twas\tinvented\tby\tDonald\tShell.\tThis\tsorting algorithm\t is\t a\t generalization\t of\t insertion\t sort.\t Insertion\t sort\t works\t efficiently\t on\t input\t that\t is already\talmost\tsorted.\tShell\tsort\tis\talso\tknown\tas\tn-gap\tinsertion\tsort.\tInstead\tof\tcomparing\tonly the\t adjacent\t pair,\t shell\t sort\t makes\t several\t passes\t and\t uses\t various\t gaps\t between\t adjacent elements\t(ending\twith\tthe\tgap\tof\t1\tor\tclassical\tinsertion\tsort). In\tinsertion\tsort,\tcomparisons\tare\tmade\tbetween\tthe\tadjacent\telements.\tAt\tmost\t1\tinversion\tis eliminated\tfor\teach\tcomparison\tdone\twith\tinsertion\tsort.\tThe\tvariation\tused\tin\tshell\tsort\tis\tto avoid\tcomparing\tadjacent\telements\tuntil\tthe\tlast\tstep\tof\tthe\talgorithm.\tSo,\tthe\tlast\tstep\tof\tshell sort\t is\t effectively\t the\t insertion\t sort\t algorithm.\t It\t improves\t insertion\t sort\t by\t allowing\t the comparison\tand\texchange\tof\telements\tthat\tare\tfar\taway.\tThis\tis\tthe\tfirst\talgorithm\twhich\tgot\tless than\tquadratic\tcomplexity\tamong\tcomparison\tsort\talgorithms. Shellsort\tis\tactually\ta\tsimple\textension\tfor\tinsertion\tsort.\tThe\tprimary\tdifference\tis\tits\tcapability of\t exchanging\t elements\t that\t are\t far\t apart,\t making\t it\t considerably\t faster\t for\t elements\t to\t get\t to where\tthey\tshould\tbe.\tFor\texample,\tif\tthe\tsmallest\telement\thappens\tto\tbe\tat\tthe\tend\tof\tan\tarray, with\tinsertion\tsort\tit\twill\trequire\tthe\tfull\tarray\tof\tsteps\tto\tput\tthis\telement\tat\tthe\tbeginning\tof\tthe array.\tHowever,\twith\tshell\tsort,\tthis\telement\tcan\tjump\tmore\tthan\tone\tstep\ta\ttime\tand\treach\tthe proper\tdestination\tin\tfewer\texchanges. The\t basic\t idea\t in\t shellsort\t is\t to\t exchange\t every\t hth\t element\t in\t the\t array.\t Now\t this\t can\t be confusing\tso\twe\u2019ll\ttalk\tmore\tabout\tthis,\th\tdetermines\thow\tfar\tapart\telement\texchange\tcan\thappen, say\t for\t example\t take\t h\t as\t 13,\t the\t first\t element\t (index-0)\t is\t exchanged\t with\t the\t 14th\t element (index-13)\tif\tnecessary\t(of\tcourse).\tThe\tsecond\telement\twith\tthe\t15th\telement,\tand\tso\ton.\tNow\tif we\ttake\thas\t1,\tit\tis\texactly\tthe\tsame\tas\ta\tregular\tinsertion\tsort. Shellsort\tworks\tby\tstarting\twith\tbig\tenough\t(but\tnot\tlarger\tthan\tthe\tarray\tsize)\th\tso\tas\tto\tallow eligible\telement\texchanges\tthat\tare\tfar\tapart.\tOnce\ta\tsort\tis\tcomplete\twith\ta\tparticular\th,\t the array\t can\t be\t said\t as\t h-sorted.\t The\t next\t step\t is\t to\t reduce\t h\t by\t a\t certain\t sequence,\t and\t again perform\tanother\tcomplete\th-sort.\tOnce\th\tis\t1\tand\th-sorted,\tthe\tarray\tis\tcompletely\tsorted.\tNotice that\tthe\tlast\tsequence\tfor\tft\tis\t1\tso\tthe\tlast\tsort\tis\talways\tan\tinsertion\tsort,\texcept\tby\tthis\ttime\tthe array\tis\talready\twell-formed\tand\teasier\tto\tsort. Shell\tsort\tuses\ta\tsequence\th1,h2,\t...,ht\tcalled\tthe\tincrement\tsequence.\tAny\tincrement\tsequence\tis fine\tas\tlong\tas\th1\t=\t1,\tand\tsome\tchoices\tare\tbetter\tthan\tothers.\tShell\tsort\tmakes\tmultiple\tpasses through\tthe\tinput\tlist\tand\tsorts\ta\tnumber\tof\tequally\tsized\tsets\tusing\tthe\tinsertion\tsort.\tShell\tsort improves\tthe\tefficiency\tof\tinsertion\tsort\tby\tquickly\tshifting\tvalues\tto\ttheir\tdestination. Implementation Note\t that\t when\t h\t ==\t 1,\t the\t algorithm\t makes\t a\t pass\t over\t the\t entire\t list,\t comparing\t adjacent elements,\tbut\tdoing\tvery\tfew\telement\texchanges.\tFor\th\t==\t1,\tshell\tsort\tworks\tjust\tlike\tinsertion sort,\texcept\tthe\tnumber\tof\tinversions\tthat\thave\tto\tbe\teliminated\tis\tgreatly\treduced\tby\tthe\tprevious steps\tof\tthe\talgorithm\twith\th\t>\t1. Analysis Shell\tsort\tis\tefficient\tfor\tmedium\tsize\tlists.\tFor\tbigger\tlists,\tthe\talgorithm\tis\tnot\tthe\tbest\tchoice.\tIt is\tthe\tfastest\tof\tall\tO(n2)\tsorting\talgorithms. The\tdisadvantage\tof\tShell\tsort\tis\tthat\tit\tis\ta\tcomplex\talgorithm\tand\tnot\tnearly\tas\tefficient\tas\tthe merge,\theap,\tand\tquick\tsorts.\tShell\tsort\tis\tsignificantly\tslower\tthan\tthe\tmerge,\theap,\tand\tquick sorts,\tbut\tis\ta\trelatively\tsimple\talgorithm,\twhich\tmakes\tit\ta\tgood\tchoice\tfor\tsorting\tlists\tof\tless than\t 5000\t items\t unless\t speed\t is\t important.\t It\t is\t also\t a\t good\t choice\t for\t repetitive\t sorting\t of smaller\tlists. The\tbest\tcase\tin\tShell\tsort\tis\twhen\tthe\tarray\tis\talready\tsorted\tin\tthe\tright\torder.\tThe\tnumber\tof comparisons\tis\tless.\tThe\trunning\ttime\tof\tShell\tsort\tdepends\ton\tthe\tchoice\tof\tincrement\tsequence. Performance Worst\tcase\tcomplexity\tdepends\ton\tgap\tsequence.\tBest\tknown:\tO(nlog2n) Best\tcase\tcomplexity:\tO(n) Average\tcase\tcomplexity\tdepends\ton\tgap\tsequence Worst\tcase\tspace\tcomplexity:\tO(n)"
            },
            {
                "subchapter_title": "10.9\tMerge\tSort",
                "content": "Merge\tsort\tis\tan\texample\tof\tthe\tdivide\tand\tconquer\tstrategy. Important\tNotes \u2022 Merging\tis\tthe\tprocess\tof\tcombining\ttwo\tsorted\tfiles\tto\tmake\tone\tbigger\tsorted\tfile. \u2022 Selection\tis\tthe\tprocess\tof\tdividing\ta\tfile\tinto\ttwo\tparts:\tk\tsmallest\telements\tand\tn\t\u2013 k\tlargest\telements. \u2022 Selection\tand\tmerging\tare\topposite\toperations \u25cb selection\tsplits\ta\tlist\tinto\ttwo\tlists \u25cb merging\tjoins\ttwo\tfiles\tto\tmake\tone\tfile \u2022 Merge\tsort\tis\tQuick\tsort\u2019s\tcomplement \u2022 Merge\tsort\taccesses\tthe\tdata\tin\ta\tsequential\tmanner \u2022 This\talgorithm\tis\tused\tfor\tsorting\ta\tlinked\tlist \u2022 Merge\tsort\tis\tinsensitive\tto\tthe\tinitial\torder\tof\tits\tinput \u2022 In\tQuick\tsort\tmost\tof\tthe\twork\tis\tdone\tbefore\tthe\trecursive\tcalls.\tQuick\tsort\tstarts with\tthe\tlargest\tsubfile\tand\tfinishes\twith\tthe\tsmall\tones\tand\tas\ta\tresult\tit\tneeds stack.\tMoreover,\tthis\talgorithm\tis\tnot\tstable.\tMerge\tsort\tdivides\tthe\tlist\tinto\ttwo parts;\t then\t each\t part\t is\t conquered\t individually.\t Merge\t sort\t starts\t with\t the\t small subfiles\tand\tfinishes\twith\tthe\tlargest\tone.\tAs\ta\tresult\tit\tdoesn\u2019t\tneed\tstack.\tThis algorithm\tis\tstable. Implementation Analysis In\t Merge\t sort\t the\t input\t list\t is\t divided\t into\t two\t parts\t and\t these\t are\t solved\t recursively.\t After solving\tthe\tsub\tproblems,\tthey\tare\tmerged\tby\tscanning\tthe\tresultant\tsub\tproblems.\tLet\tus\tassume T(n)\tis\tthe\tcomplexity\tof\tMerge\tsort\twith\tn\telements.\tThe\trecurrence\tfor\tthe\tMerge\tSort\tcan\tbe defined\tas: Note:\tFor\tmore\tdetails,\trefer\tto\tDivide\tand\tConquer\tchapter. Performance Worst\tcase\tcomplexity\t:\t\u0398(nlogn) Best\tcase\tcomplexity\t:\t\u0398(nlogn) Average\tcase\tcomplexity\t:\t\u0398(nlogn) Worst\tcase\tspace\tcomplexity:\t\u0398(n)\tauxiliary"
            },
            {
                "subchapter_title": "10.10\tHeap\tSort",
                "content": "Heapsort\t is\t a\t comparison-based\t sorting\t algorithm\t and\t is\t part\t of\t the\t selection\t sort\t family. Although\tsomewhat\tslower\tin\tpractice\ton\tmost\tmachines\tthan\ta\tgood\timplementation\tof\tQuick sort,\tit\thas\tthe\tadvantage\tof\ta\tmore\tfavorable\tworst-case\t\u0398(nlogn)\truntime.\tHeapsort\tis\tan\tin- place\talgorithm\tbut\tis\tnot\ta\tstable\tsort. Performance Worst\tcase\tperformance:\t\u0398(nlogn) Best\tcase\tperformance:\t\u0398(nlogn) Average\tcase\tperformance:\t\u0398(nlogn) Worst\tcase\tspace\tcomplexity:\t\u0398(n)\ttotal,\t\u0398(1)\tauxiliary For\tother\tdetails\ton\tHeapsort\trefer\tto\tthe\tPriority\tQueues\tchapter."
            },
            {
                "subchapter_title": "10.11\tQuicksort",
                "content": "Quick\t sort\t is\t an\t example\t of\t a\t divide-and-conquer\t algorithmic\t technique.\t It\t is\t also\t called partition\t exchange\t sort.\t It\t uses\t recursive\t calls\t for\t sorting\t the\t elements,\t and\t it\t is\t one\t of\t the famous\talgorithms\tamong\tcomparison-based\tsorting\talgorithms. Divide:\tThe\tarray\tA[low\t...high]\tis\tpartitioned\tinto\ttwo\tnon-empty\tsub\tarrays\tA[low\t...q]\tand\tA[q +\t1...\thigh],\tsuch\tthat\teach\telement\tof\tA[low\t...\thigh]\tis\tless\tthan\tor\tequal\tto\teach\telement\tof\tA[q +\t1...\thigh].\tThe\tindex\tq\tis\tcomputed\tas\tpart\tof\tthis\tpartitioning\tprocedure. Conquer:\tThe\ttwo\tsub\tarrays\tA[low\t...q]\tand\tA[q\t+\t1\t...high]\tare\tsorted\tby\trecursive\tcalls\tto Quick\tsort. Algorithm The\trecursive\talgorithm\tconsists\tof\tfour\tsteps: 1) If\tthere\tare\tone\tor\tno\telements\tin\tthe\tarray\tto\tbe\tsorted,\treturn. 2) Pick\t an\t element\t in\t the\t array\t to\t serve\t as\t the\t \u201cpivot\u201d\t point.\t (Usually\t the\t left-most element\tin\tthe\tarray\tis\tused.) 3) Split\tthe\tarray\tinto\ttwo\tparts\t\u2013\tone\twith\telements\tlarger\tthan\tthe\tpivot\tand\tthe\tother with\telements\tsmaller\tthan\tthe\tpivot. 4) Recursively\trepeat\tthe\talgorithm\tfor\tboth\thalves\tof\tthe\toriginal\tarray. Implementation Analysis Let\tus\tassume\tthat\tT(n)\tbe\tthe\tcomplexity\tof\tQuick\tsort\tand\talso\tassume\tthat\tall\telements\tare distinct.\t Recurrence\t for\t T(n)\t depends\t on\t two\t subproblem\t sizes\t which\t depend\t on\t partition element.\tIf\tpivot\tis\tith\tsmallest\telement\tthen\texactly\t(i\t\u2013\t1)\titems\twill\tbe\tin\tleft\tpart\tand\t(n\t\u2013\ti)\tin right\tpart.\tLet\tus\tcall\tit\tas\ti\t\u2013split.\tSince\teach\telement\thas\tequal\tprobability\tof\tselecting\tit\tas pivot\tthe\tprobability\tof\tselecting\tith\telement\tis\t . Best\tCase:\tEach\tpartition\tsplits\tarray\tin\thalves\tand\tgives T(n)\t=\t2T(n/2)\t+\t\u0398(n)\t=\t\u0398(nlogn),\t[using\tDivide\tand\tConquer\tmaster\ttheorem] Worst\tCase:\tEach\tpartition\tgives\tunbalanced\tsplits\tand\twe\tget T(n)\t=\tT(n\t\u2013\t1)\t+\t\u0398(n)\t=\t\u0398(n2)[using\tSubtraction\tand\tConquer\tmaster\ttheorem] The\tworst-case\toccurs\twhen\tthe\tlist\tis\talready\tsorted\tand\tlast\telement\tchosen\tas\tpivot. Average\tCase:\tIn\tthe\taverage\tcase\tof\tQuick\tsort,\twe\tdo\tnot\tknow\twhere\tthe\tsplit\thappens.\tFor this\treason,\twe\ttake\tall\tpossible\tvalues\tof\tsplit\tlocations,\tadd\tall\ttheir\tcomplexities\tand\tdivide with\tn\tto\tget\tthe\taverage\tcase\tcomplexity. Multiply\tboth\tsides\tby\tn. Same\tformula\tfor\tn\t\u2013\t1. Subtract\tthe\tn\t\u2013\t1\tformula\tfrom\tn. Divide\twith\tn(n\t+\t1). Time\tComplexity,\tT(n)\t=\tO(nlogn). Performance Worst\tcase\tComplexity:\tO(n2) Best\tcase\tComplexity:\tO(nlogn) Average\tcase\tComplexity:\tO(nlogn) Worst\tcase\tspace\tComplexity:\tO(1) Randomized\tQuick\tsort In\taverage-case\tbehavior\tof\tQuick\tsort,\twe\tassume\tthat\tall\tpermutations\tof\tthe\tinput\tnumbers\tare equally\tlikely.\tHowever,\twe\tcannot\talways\texpect\tit\tto\thold.\tWe\tcan\tadd\trandomization\tto\tan algorithm\tin\torder\tto\treduce\tthe\tprobability\tof\tgetting\tworst\tcase\tin\tQuick\tsort. There\tare\ttwo\tways\tof\tadding\trandomization\tin\tQuick\tsort:\teither\tby\trandomly\tplacing\tthe\tinput data\t in\t the\t array\t or\t by\t randomly\t choosing\t an\t element\t in\t the\t input\t data\t for\t pivot.\t The\t second choice\t is\t easier\t to\t analyze\t and\t implement.\t The\t change\t will\t only\t be\t done\t at\t the\t partition algorithm. In\t normal\t Quick\t sort,\t pivot\t element\t was\t always\t the\t leftmost\t element\t in\t the\t list\t to\t be\t sorted. Instead\t of\t always\t using\t A[low]\t as\t pivot,\t we\t will\t use\t a\t randomly\t chosen\t element\t from\t the subarray\tA[low..high]\tin\tthe\trandomized\tversion\tof\tQuick\tsort.\tIt\tis\tdone\tby\texchanging\telement A[low]\twith\tan\telement\tchosen\tat\trandom\tfrom\tA[low..high].\tThis\tensures\tthat\tthe\tpivot\telement\tis equally\tlikely\tto\tbe\tany\tof\tthe\thigh\t\u2013\tlow\t+\t1\telements\tin\tthe\tsubarray. Since\t the\t pivot\t element\t is\t randomly\t chosen,\t we\t can\t expect\t the\t split\t of\t the\t input\t array\t to\t be reasonably\twell\tbalanced\ton\taverage.\tThis\tcan\thelp\tin\tpreventing\tthe\tworst-case\tbehavior\tof quick\tsort\twhich\toccurs\tin\tunbalanced\tpartitioning.\tEven\tthough\tthe\trandomized\tversion\timproves the\t worst\t case\t complexity,\t its\t worst\t case\t complexity\t is\t still\t O(n2).\t One\t way\t to\t improve Randomized\t\u2013\tQuick\tsort\tis\tto\tchoose\tthe\tpivot\tfor\tpartitioning\tmore\tcarefully\tthan\tby\tpicking\ta random\telement\tfrom\tthe\tarray.\tOne\tcommon\tapproach\tis\tto\tchoose\tthe\tpivot\tas\tthe\tmedian\tof\ta set\tof\t3\telements\trandomly\tselected\tfrom\tthe\tarray."
            },
            {
                "subchapter_title": "10.12\tTree\tSort",
                "content": "Tree\tsort\tuses\ta\tbinary\tsearch\ttree.\tIt\tinvolves\tscanning\teach\telement\tof\tthe\tinput\tand\tplacing\tit into\tits\tproper\tposition\tin\ta\tbinary\tsearch\ttree.\tThis\thas\ttwo\tphases: \u2022 First\tphase\tis\tcreating\ta\tbinary\tsearch\ttree\tusing\tthe\tgiven\tarray\telements. \u2022 Second\tphase\tis\ttraversing\tthe\tgiven\tbinary\tsearch\ttree\tin\tinorder,\tthus\tresulting\tin\ta sorted\tarray. Performance The\taverage\tnumber\tof\tcomparisons\tfor\tthis\tmethod\tis\tO(nlogn).\tBut\tin\tworst\tcase,\tthe\tnumber\tof comparisons\tis\treduced\tby\tO(n2),\ta\tcase\twhich\tarises\twhen\tthe\tsort\ttree\tis\tskew\ttree."
            },
            {
                "subchapter_title": "10.13\tComparison\tof\tSorting\tAlgorithms",
                "content": "Note:\tn\tdenotes\tthe\tnumber\tof\telements\tin\tthe\tinput."
            },
            {
                "subchapter_title": "10.14\tLinear\tSorting\tAlgorithms",
                "content": "In\tearlier\tsections,\twe\thave\tseen\tmany\texamples\tof\tcomparison-based\tsorting\talgorithms.\tAmong them,\tthe\tbest\tcomparison-based\tsorting\thas\tthe\tcomplexity\tO(nlogn).\tIn\tthis\tsection,\twe\twill discuss\tother\ttypes\tof\talgorithms:\tLinear\tSorting\tAlgorithms.\tTo\timprove\tthe\ttime\tcomplexity\tof sorting\tthese\talgorithms,\twe\tmake\tsome\tassumptions\tabout\tthe\tinput.\tA\tfew\texamples\tof\tLinear Sorting\tAlgorithms\tare: \u2022 Counting\tSort \u2022 Bucket\tSort \u2022 Radix\tSort"
            },
            {
                "subchapter_title": "10.15\tCounting\tSort",
                "content": "Counting\t sort\t is\t not\t a\t comparison\t sort\t algorithm\t and\t gives\t O(n)\t complexity\t for\t sorting.\t To achieve\t O(n)\t complexity,\t counting\t sort\t assumes\t that\t each\t of\t the\t elements\t is\t an\tinteger\t in\t the range\t1\tto\tK,\tfor\tsome\tinteger\tK.\tWhen\tif\t=\tO(n),\tthe\tcounting\tsort\truns\tin\tO(n)\ttime.\tThe\tbasic idea\tof\tCounting\tsort\tis\tto\tdetermine,\tfor\teach\tinput\telement\tX,\tthe\tnumber\tof\telements\tless\tthan X.\tThis\tinformation\tcan\tbe\tused\tto\tplace\tit\tdirectly\tinto\tits\tcorrect\tposition.\tFor\texample,\tif\t10 elements\tare\tless\tthan\tX,\tthen\tX\tbelongs\tto\tposition\t11\tin\tthe\toutput. In\tthe\tcode\tbelow,\tA[0\t..n\t\u2013\t1]\tis\tthe\tinput\tarray\twith\tlength\tn.\tIn\tCounting\tsort\twe\tneed\ttwo\tmore arrays:\tlet\tus\tassume\tarray\tB[0\t..n\t\u2013\t 1]\t contains\t the\t sorted\t output\t and\t the\t array\tC[0\t ..K\t \u2013\t 1] provides\ttemporary\tstorage. Total\tComplexity:\tO(K)\t+\tO(n)\t+\tO(K)\t+\tO(n)\t=\tO(n)\tif\tK\t=O(n).\tSpace\tComplexity:\tO(n)\tif\tK =O(n). Note:\tCounting\tworks\twell\tif\tK\t=O(n).\tOtherwise,\tthe\tcomplexity\twill\tbe\tgreater."
            },
            {
                "subchapter_title": "10.16\tBucket\tSort\t(or\tBin\tSort)",
                "content": "Like\t Counting\t sort,\t Bucket\t sort\t also\t imposes\t restrictions\t on\t the\t input\t to\t improve\t the performance.\tIn\tother\twords,\tBucket\tsort\tworks\twell\tif\tthe\tinput\tis\tdrawn\tfrom\tfixed\tset.\tBucket sort\tis\tthe\tgeneralization\tof\tCounting\tSort.\tFor\texample,\tassume\tthat\tall\tthe\tinput\telements\tfrom {0,\t1,\t.\t.\t.\t,\tK\t\u2013\t1},\ti.e.,\tthe\tset\tof\tintegers\tin\tthe\tinterval\t[0,\tK\t\u2013\t1].\tThat\tmeans,\tK\tis\tthe\tnumber of\tdistant\telements\tin\tthe\tinput.\tBucket\tsort\tuses\tK\tcounters.\tThe\tith\tcounter\tkeeps\ttrack\tof\tthe number\tof\toccurrences\tof\tthe\tith\telement.\tBucket\tsort\twith\ttwo\tbuckets\tis\teffectively\ta\tversion\tof Quick\tsort\twith\ttwo\tbuckets. For\tbucket\tsort,\tthe\thash\tfunction\tthat\tis\tused\tto\tpartition\tthe\telements\tneed\tto\tbe\tvery\tgood\tand must\tproduce\tordered\thash:\tif\ti\t<\tk\tthen\thash(i)\t<\thash(k).\tSecond,\tthe\telements\tto\tbe\tsorted\tmust be\tuniformly\tdistributed. The\t aforementioned\t aside,\t bucket\t sort\t is\t actually\t very\t good\t considering\t that\t counting\t sort\t is reasonably\tspeaking\tits\tupper\tbound.\tAnd\tcounting\tsort\tis\tvery\tfast.\tThe\tparticular\tdistinction\tfor bucket\tsort\tis\tthat\tit\tuses\ta\thash\tfunction\tto\tpartition\tthe\tkeys\tof\tthe\tinput\tarray,\tso\tthat\tmultiple keys\tmay\thash\tto\tthe\tsame\tbucket.\tHence\teach\tbucket\tmust\teffectively\tbe\ta\tgrowable\tlist;\tsimilar to\tradix\tsort. In\tthe\tbelow\tcode\tinsertionsort\tis\tused\tto\tsort\teach\tbucket.\tThis\tis\tto\tinculcate\tthat\tthe\tbucket\tsort algorithm\t does\t not\t specify\t which\t sorting\t technique\t to\t use\t on\t the\t buckets.\t A\t programmer\t may choose\tto\tcontinuously\tuse\tbucket\tsort\ton\teach\tbucket\tuntil\tthe\tcollection\tis\tsorted\t(in\tthe\tmanner of\tthe\tradix\tsort\tprogram\tbelow).\tWhichever\tsorting\tmethod\tis\tused\ton\tthe\t,\tbucket\tsort\tstill\ttends toward\tO(n). Time\tComplexity:\tO(n).\tSpace\tComplexity:\tO(n)."
            },
            {
                "subchapter_title": "10.17\tRadix\tSort",
                "content": "Similar\t to\t Counting\t sort\t and\t Bucket\t sort,\t this\t sorting\t algorithm\t also\t assumes\t some\t kind\t of information\tabout\tthe\tinput\telements.\tSuppose\tthat\tthe\tinput\tvalues\tto\tbe\tsorted\tare\tfrom\tbase\td. That\tmeans\tall\tnumbers\tare\td-digit\tnumbers. In\tRadix\tsort,\tfirst\tsort\tthe\telements\tbased\ton\tthe\tlast\tdigit\t[the\tleast\tsignificant\tdigit].\tThese results\tare\tagain\tsorted\tby\tsecond\tdigit\t[the\tnext\tto\tleast\tsignificant\tdigit].\tContinue\tthis\tprocess for\tall\tdigits\tuntil\twe\treach\tthe\tmost\tsignificant\tdigits.\tUse\tsome\tstable\tsort\tto\tsort\tthem\tby\tlast digit.\tThen\tstable\tsort\tthem\tby\tthe\tsecond\tleast\tsignificant\tdigit,\tthen\tby\tthe\tthird,\tetc.\tIf\twe\tuse Counting\tsort\tas\tthe\tstable\tsort,\tthe\ttotal\ttime\tis\tO(nd)\t\u2248\tO(n). Algorithm: 1) Take\tthe\tleast\tsignificant\tdigit\tof\teach\telement. 2) Sort\tthe\tlist\tof\telements\tbased\ton\tthat\tdigit,\tbut\tkeep\tthe\torder\tof\telements\twith\tthe same\tdigit\t(this\tis\tthe\tdefinition\tof\ta\tstable\tsort). 3) Repeat\tthe\tsort\twith\teach\tmore\tsignificant\tdigit. The\tspeed\tof\tRadix\tsort\tdepends\ton\tthe\tinner\tbasic\toperations.\tIf\tthe\toperations\tare\tnot\tefficient enough,\tRadix\tsort\tcan\tbe\tslower\tthan\tother\talgorithms\tsuch\tas\tQuick\tsort\tand\tMerge\tsort.\tThese operations\tinclude\tthe\tinsert\tand\tdelete\tfunctions\tof\tthe\tsub-lists\tand\tthe\tprocess\tof\tisolating\tthe digit\twe\twant.\tIf\tthe\tnumbers\tare\tnot\tof\tequal\tlength\tthen\ta\ttest\tis\tneeded\tto\tcheck\tfor\tadditional digits\tthat\tneed\tsorting.\tThis\tcan\tbe\tone\tof\tthe\tslowest\tparts\tof\tRadix\tsort\tand\talso\tone\tof\tthe hardest\tto\tmake\tefficient. Since\tRadix\tsort\tdepends\ton\tthe\tdigits\tor\tletters,\tit\tis\tless\tflexible\tthan\tother\tsorts.\tFor\tevery different\ttype\tof\tdata,\tRadix\tsort\tneeds\tto\tbe\trewritten,\tand\tif\tthe\tsorting\torder\tchanges,\tthe\tsort needs\tto\tbe\trewritten\tagain.\tIn\tshort,\tRadix\tsort\ttakes\tmore\ttime\tto\twrite,\tand\tit\tis\tvery\tdifficult\tto write\ta\tgeneral\tpurpose\tRadix\tsort\tthat\tcan\thandle\tall\tkinds\tof\tdata. For\tmany\tprograms\tthat\tneed\ta\tfast\tsort,\tRadix\tsort\tis\ta\tgood\tchoice.\tStill,\tthere\tare\tfaster\tsorts, which\tis\tone\treason\twhy\tRadix\tsort\tis\tnot\tused\tas\tmuch\tas\tsome\tother\tsorts. Time\tComplexity:\tO(nd)\t\u2248\tO(n),\tif\td\tis\tsmall."
            },
            {
                "subchapter_title": "10.18\tTopological\tSort",
                "content": "Refer\tto\tGraph\tAlgorithms\tChapter."
            },
            {
                "subchapter_title": "10.19\tExternal\tSorting",
                "content": "External\t sorting\t is\t a\t generic\t term\t for\t a\t class\t of\t sorting\t algorithms\t that\t can\t handle\t massive amounts\tof\tdata.\tThese\texternal\tsorting\talgorithms\tare\tuseful\twhen\tthe\tfiles\tare\ttoo\tbig\tand\tcannot fit\tinto\tmain\tmemory. As\twith\tinternal\tsorting\talgorithms,\tthere\tare\ta\tnumber\tof\talgorithms\tfor\texternal\tsorting.\tOne such\t algorithm\t is\t External\t Mergesort.\t In\t practice,\t these\t external\t sorting\t algorithms\t are\t being supplemented\tby\tinternal\tsorts. Simple\tExternal\tMergesort A\tnumber\tof\trecords\tfrom\teach\ttape\tare\tread\tinto\tmain\tmemory,\tsorted\tusing\tan\tinternal\tsort,\tand then\toutput\tto\tthe\ttape.\tFor\tthe\tsake\tof\tclarity,\tlet\tus\tassume\tthat\t900\tmegabytes\tof\tdata\tneeds\tto be\tsorted\tusing\tonly\t100\tmegabytes\tof\tRAM. 1) Read\t100MB\tof\tthe\tdata\tinto\tmain\tmemory\tand\tsort\tby\tsome\tconventional\tmethod (let\tus\tsay\tQuick\tsort). 2) Write\tthe\tsorted\tdata\tto\tdisk. 3) Repeat\tsteps\t1\tand\t2\tuntil\tall\tof\tthe\tdata\tis\tsorted\tin\tchunks\tof\t100MB.\tNow\twe\tneed to\tmerge\tthem\tinto\tone\tsingle\tsorted\toutput\tfile. 4) Read\tthe\tfirst\t10MB\tof\teach\tsorted\tchunk\t(call\tthem\tinput\tbuffers)\tin\tmain\tmemory (90MB\ttotal)\tand\tallocate\tthe\tremaining\t10MB\tfor\toutput\tbuffer. 5) Perform\t a\t 9-way\t Mergesort\t and\t store\t the\t result\t in\t the\t output\t buffer.\t If\t the\t output buffer\tis\tfull,\twrite\tit\tto\tthe\tfinal\tsorted\tfile.\tIf\tany\tof\tthe\t9\tinput\tbuffers\tgets\tempty, fill\tit\twith\tthe\tnext\t10MB\tof\tits\tassociated\t100MB\tsorted\tchunk;\tor\tif\tthere\tis\tno more\tdata\tin\tthe\tsorted\tchunk,\tmark\tit\tas\texhausted\tand\tdo\tnot\tuse\tit\tfor\tmerging. The\tabove\talgorithm\tcan\tbe\tgeneralized\tby\tassuming\tthat\tthe\tamount\tof\tdata\tto\tbe\tsorted\texceeds the\tavailable\tmemory\tby\ta\tfactor\tof\tK.\tThen,\tK\tchunks\tof\tdata\tneed\tto\tbe\tsorted\tand\ta\tK\t-way merge\thas\tto\tbe\tcompleted. If\tX\tis\tthe\tamount\tof\tmain\tmemory\tavailable,\tthere\twill\tbe\tK\tinput\tbuffers\tand\t1\toutput\tbuffer\tof size\t X/(K\t +\t 1)\t each.\t Depending\t on\t various\t factors\t (how\t fast\t is\t the\t hard\t drive?)\t better performance\tcan\tbe\tachieved\tif\tthe\toutput\tbuffer\tis\tmade\tlarger\t(for\texample,\ttwice\tas\tlarge\tas one\tinput\tbuffer). Complexity\tof\tthe\t2-way\tExternal\tMerge\tsort:\tIn\teach\tpass\twe\tread\t+\twrite\teach\tpage\tin\tfile.\tLet us\tassume\tthat\tthere\tare\tn\tpages\tin\tfile.\tThat\tmeans\twe\tneed\t\u2308logn\u2309\t+\t1\tnumber\tof\tpasses.\tThe total\tcost\tis\t2n(\u2308logn\u2309\t+\t1)."
            },
            {
                "subchapter_title": "10.20\tSorting:\tProblems\t&\tSolutions",
                "content": "Problem-1\u2003\u2003Given\tan\tarray\tA[0...n\u2013\t1]\tof\tn\tnumbers\tcontaining\tthe\trepetition\tof\tsome\tnumber. Give\tan\talgorithm\tfor\tchecking\twhether\tthere\tare\trepeated\telements\tor\tnot.\tAssume\tthat we\tare\tnot\tallowed\tto\tuse\tadditional\tspace\t(i.e.,\twe\tcan\tuse\ta\tfew\ttemporary\tvariables, O(1)\tstorage). Solution:\tSince\twe\tare\tnot\tallowed\tto\tuse\textra\tspace,\tone\tsimple\tway\tis\tto\tscan\tthe\telements one-by-one\tand\tfor\teach\telement\tcheck\twhether\tthat\telement\tappears\tin\tthe\tremaining\telements.\tIf we\tfind\ta\tmatch\twe\treturn\ttrue. Each\titeration\tof\tthe\tinner,\tj-indexed\tloop\tuses\tO(1)\tspace,\tand\tfor\ta\tfixed\tvalue\tof\ti,\tthe\tj\tloop executes\t n\t \u2013\t i\t times.\t The\t outer\t loop\t executes\t n\t \u2013\t 1\t times,\t so\t the\t entire\t function\t uses\t time proportional\tto Time\tComplexity:\tO(n2).\tSpace\tComplexity:\tO(1). Problem-2\u2003\u2003Can\twe\timprove\tthe\ttime\tcomplexity\tof\tProblem-1? Solution:\tYes,\tusing\tsorting\ttechnique. Heapsort\tfunction\ttakes\tO(nlogn)\ttime,\tand\trequires\tO(1)\tspace.\tThe\tscan\tclearly\ttakes\tn\t \u2013\t 1 iterations,\teach\titeration\tusing\tO(1)\ttime.\tThe\toverall\ttime\tis\tO(nlogn\t+\tn)\t=\tO(nlogn). Time\tComplexity:\tO(nlogn).\tSpace\tComplexity:\tO(1). Note:\tFor\tvariations\tof\tthis\tproblem,\trefer\tSearching\tchapter. Problem-3\u2003\u2003Given\tan\tarray\tA[0\t...n\t\u2013\t1],\twhere\teach\telement\tof\tthe\tarray\trepresents\ta\tvote\tin the\telection.\tAssume\tthat\teach\tvote\tis\tgiven\tas\tan\tinteger\trepresenting\tthe\tID\tof\tthe\tchosen candidate.\tGive\tan\talgorithm\tfor\tdetermining\twho\twins\tthe\telection. Solution:\tThis\tproblem\tis\tnothing\tbut\tfinding\tthe\telement\twhich\trepeated\tthe\tmaximum\tnumber\tof times.\tThe\tsolution\tis\tsimilar\tto\tthe\tProblem-1\tsolution:\tkeep\ttrack\tof\tcounter. Time\tComplexity:\tO(n2).\tSpace\tComplexity:\tO(1). Note:\tFor\tvariations\tof\tthis\tproblem,\trefer\tto\tSearching\tchapter. Problem-4\u2003\u2003Can\twe\timprove\tthe\ttime\tcomplexity\tof\tProblem-3?\tAssume\twe\tdon\u2019t\thave\tany extra\tspace. Solution:\tYes.\tThe\tapproach\tis\tto\tsort\tthe\tvotes\tbased\ton\tcandidate\tID,\tthen\tscan\tthe\tsorted\tarray and\tcount\tup\twhich\tcandidate\tso\tfar\thas\tthe\tmost\tvotes.\tWe\tonly\thave\tto\tremember\tthe\twinner,\tso we\tdon\u2019t\tneed\ta\tclever\tdata\tstructure.\tWe\tcan\tuse\tHeapsort\tas\tit\tis\tan\tin-place\tsorting\talgorithm. Since\t Heapsort\t time\t complexity\t is\t O(nlogn)\t and\t in-place,\t it\t only\t uses\t an\t additional\t O(1)\t of storage\t in\t addition\t to\t the\t input\t array.\t The\t scan\t of\t the\t sorted\t array\t does\t a\t constant-time conditional\tn\t\u2013\t1\ttimes,\tthus\tusing\tO(n)\ttime.\tThe\toverall\ttime\tbound\tis\tO(nlogn). Problem-5\u2003\u2003Can\twe\tfurther\timprove\tthe\ttime\tcomplexity\tof\tProblem-3? Solution:\t In\t the\t given\t problem,\t the\t number\t of\t candidates\t is\t less\t but\t the\t number\t of\t votes\t is significantly\tlarge.\tFor\tthis\tproblem\twe\tcan\tuse\tcounting\tsort. Time\tComplexity:\tO(n),\tn\tis\tthe\tnumber\tof\tvotes\t(elements)\tin\tthe\tarray.\tSpace\tComplexity:\tO(k), k\tis\tthe\tnumber\tof\tcandidates\tparticipating\tin\tthe\telection. Problem-6\u2003\u2003Given\tan\tarray\tA\tof\tn\telements,\teach\tof\twhich\tis\tan\tinteger\tin\tthe\trange\t[1,\tn2], how\tdo\twe\tsort\tthe\tarray\tin\tO(n)\ttime? Solution:\tIf\twe\tsubtract\teach\tnumber\tby\t1\tthen\twe\tget\tthe\trange\t[0,\tn2\t\u2013\t1].\tIf\twe\tconsider\tall numbers\tas\t2\t\u2013digit\tbase\tn.\tEach\tdigit\tranges\tfrom\t0\tto\tn2\t\u2013\t1.\tSort\tthis\tusing\tradix\tsort.\tThis\tuses only\ttwo\tcalls\tto\tcounting\tsort.\tFinally,\tadd\t1\tto\tall\tthe\tnumbers.\tSince\tthere\tare\t2\tcalls,\tthe complexity\tis\tO(2n)\t\u2248\tO(n). Problem-7\u2003\u2003For\tProblem-6,\twhat\tif\tthe\trange\tis\t[1...\tn3]? Solution:\tIf\twe\tsubtract\teach\tnumber\tby\t1\tthen\twe\tget\tthe\trange\t[0,\tn3\t \u2013\t 1].\t Considering\t all numbers\tas\t3-digit\tbase\tn:\teach\tdigit\tranges\tfrom\t0\tto\tn3\t\u2013\t1.\tSort\tthis\tusing\tradix\tsort.\tThis\tuses only\tthree\tcalls\tto\tcounting\tsort.\tFinally,\tadd\t1\tto\tall\tthe\tnumbers.\tSince\tthere\tare\t3\tcalls,\tthe complexity\tis\tO(3n)\t\u2248\tO(n). Problem-8\u2003\u2003Given\tan\tarray\twith\tn\tintegers,\teach\tof\tvalue\tless\tthan\tn100,\tcan\tit\tbe\tsorted\tin linear\ttime? Solution:\tYes.\tThe\treasoning\tis\tsame\tas\tin\tof\tProblem-6\tand\tProblem-7. Problem-9\u2003\u2003Let\t A\t and\t B\t be\t two\t arrays\t of\t n\t elements\t each.\t Given\t a\t number\t K,\t give\t an O(nlogn)\ttime\talgorithm\tfor\tdetermining\twhether\tthere\texists\ta\t\u2208\tA\tand\tb\t\u2208\tB\tsuch\tthat\ta +\tb\t=\tK. Solution:\tSince\twe\tneed\tO(nlogn),\tit\tgives\tus\ta\tpointer\tthat\twe\tneed\tto\tsort.\tSo,\twe\twill\tdo\tthat. Note:\tFor\tvariations\tof\tthis\tproblem,\trefer\tto\tSearching\tchapter. Problem-10\u2003\u2003Let\tA,B\tand\tC\tbe\tthree\tarrays\tof\tn\telements\teach.\tGiven\ta\tnumber\tK,\tgive\tan O(nlogn)\ttime\talgorithm\tfor\tdetermining\twhether\tthere\texists\ta\t\u2208\tA,\tb\t\u2208\tB\tand\tc\t\u2208\tC\tsuch that\ta\t+\tb\t+\tc\t=\tK. Solution:\tRefer\tto\tSearching\tchapter. Problem-11\u2003\u2003Given\t an\t array\t of\t n\t elements,\t can\t we\t output\t in\t sorted\t order\t the\t K\t elements following\tthe\tmedian\tin\tsorted\torder\tin\ttime\tO(n\t+\tKlogK). Solution:\tYes.\tFind\tthe\tmedian\tand\tpartition\tthe\tmedian.\tWith\tthis\twe\tcan\tfind\tall\tthe\telements greater\tthan\tit.\tNow\tfind\tthe\tKth\tlargest\telement\tin\tthis\tset\tand\tpartition\tit;\tand\tget\tall\tthe\telements less\tthan\tit.\tOutput\tthe\tsorted\tlist\tof\tthe\tfinal\tset\tof\telements.\tClearly,\tthis\toperation\ttakes\tO(n\t+ KlogK)\ttime. Problem-12\u2003\u2003Consider\t the\t sorting\t algorithms:\t Bubble\t sort,\t Insertion\t sort,\t Selection\t sort, Merge\tsort,\tHeap\tsort,\tand\tQuick\tsort.\tWhich\tof\tthese\tare\tstable? Solution:\tLet\tus\tassume\tthat\tA\tis\tthe\tarray\tto\tbe\tsorted.\tAlso,\tlet\tus\tsay\tR\tand\tS\thave\tthe\tsame\tkey and\tR\tappears\tearlier\tin\tthe\tarray\tthan\tS.\tThat\tmeans,\tR\tis\tat\tA[i]\tand\tS\tis\tat\tA[j],\twith\ti\t<\tj.\tTo show\tany\tstable\talgorithm,\tin\tthe\tsorted\toutput\tR\tmust\tprecede\tS. Bubble\tsort:\tYes.\tElements\tchange\torder\tonly\twhen\ta\tsmaller\trecord\tfollows\ta\tlarger.\tSince\tS\tis not\tsmaller\tthan\tR\tit\tcannot\tprecede\tit. Selection\tsort:\tNo.\tIt\tdivides\tthe\tarray\tinto\tsorted\tand\tunsorted\tportions\tand\titeratively\tfinds\tthe minimum\tvalues\tin\tthe\tunsorted\tportion.\tAfter\tfinding\ta\tminimum\tx,\tif\tthe\talgorithm\tmoves\tx\tinto the\tsorted\tportion\tof\tthe\tarray\tby\tmeans\tof\ta\tswap,\tthen\tthe\telement\tswapped\tcould\tbe\tR\twhich then\tcould\tbe\tmoved\tbehind\tS.\tThis\twould\tinvert\tthe\tpositions\tof\tR\tand\tS,\tso\tin\tgeneral\tit\tis\tnot stable.\tIf\tswapping\tis\tavoided,\tit\tcould\tbe\tmade\tstable\tbut\tthe\tcost\tin\ttime\twould\tprobably\tbe very\tsignificant. Insertion\tsort:\tYes.\tAs\tpresented,\twhen\tS\tis\tto\tbe\tinserted\tinto\tsorted\tsubarray\tA[1..j\t\u2013\t1],\tonly records\t larger\t than\t S\t are\t shifted.\t Thus\t R\t would\t not\t be\t shifted\t during\t S\u2019s\t insertion\t and\t hence would\talways\tprecede\tit. Merge\t sort:\t Yes,\t In\t the\t case\t of\t records\t with\t equal\t keys,\t the\t record\t in\t the\t left\t subarray\t gets preference.\t Those\t are\t the\t records\t that\t came\t first\t in\t the\t unsorted\t array.\t As\t a\t result,\t they\t will precede\tlater\trecords\twith\tthe\tsame\tkey. Heap\tsort:\tNo.\tSuppose\ti\t=\t1\tand\tR\tand\tS\thappen\tto\tbe\tthe\ttwo\trecords\twith\tthe\tlargest\tkeys\tin the\tinput.\tThen\tR\twill\tremain\tin\tlocation\t1\tafter\tthe\tarray\tis\theapified,\tand\twill\tbe\tplaced\tin location\tn\tin\tthe\tfirst\titeration\tof\tHeapsort.\tThus\tS\twill\tprecede\tR\tin\tthe\toutput. Quick\tsort:\tNo.\tThe\tpartitioning\tstep\tcan\tswap\tthe\tlocation\tof\trecords\tmany\ttimes,\tand\tthus\ttwo records\twith\tequal\tkeys\tcould\tswap\tposition\tin\tthe\tfinal\toutput. Problem-13\u2003\u2003Consider\tthe\tsame\tsorting\talgorithms\tas\tthat\tof\tProblem-12.\tWhich\tof\tthem\tare in-place? Solution: Bubble\tsort:\tYes,\tbecause\tonly\ttwo\tintegers\tare\trequired. Insertion\tsort:\tYes,\tsince\twe\tneed\tto\tstore\ttwo\tintegers\tand\ta\trecord. Selection\tsort:\tYes.\tThis\talgorithm\twould\tlikely\tneed\tspace\tfor\ttwo\tintegers\tand\tone\trecord. Merge\tsort:\tNo.\tArrays\tneed\tto\tperform\tthe\tmerge.\t(If\tthe\tdata\tis\tin\tthe\tform\tof\ta\tlinked\tlist,\tthe sorting\tcan\tbe\tdone\tin-place,\tbut\tthis\tis\ta\tnontrivial\tmodification.) Heap\tsort:\tYes,\tsince\tthe\theap\tand\tpartially-sorted\tarray\toccupy\topposite\tends\tof\tthe\tinput\tarray. Quicksort:\t No,\t since\t it\t is\t recursive\t and\t stores\t O(logn)\t activation\t records\t on\t the\t stack. Modifying\tit\tto\tbe\tnon-recursive\tis\tfeasible\tbut\tnontrivial. Problem-14\u2003\u2003Among\t Quick\t sort,\t Insertion\t sort,\t Selection\t sort,\t and\t Heap\t sort\t algorithms, which\tone\tneeds\tthe\tminimum\tnumber\tof\tswaps? Solution:\tSelection\tsort\t\u2013\tit\tneeds\tn\tswaps\tonly\t(refer\tto\ttheory\tsection). Problem-15\u2003\u2003What\tis\tthe\tminimum\tnumber\tof\tcomparisons\trequired\tto\tdetermine\tif\tan\tinteger appears\tmore\tthan\tn/2\ttimes\tin\ta\tsorted\tarray\tof\tn\tintegers? Solution:\tRefer\tto\tSearching\tchapter. Problem-16\u2003\u2003Sort\tan\tarray\tof\t0\u2019s,\t1\u2019s\tand\t2\u2019s:\tGiven\tan\tarray\tA[]\tconsisting\tof\t0\u2019s,\t1\u2019s\tand 2\u2019s,\tgive\tan\talgorithm\tfor\tsorting\tA[].\tThe\talgorithm\tshould\tput\tall\t0\u2019s\tfirst,\tthen\tall\t1\u2019s\tand all\t2\u2019s\tlast. Example:\tInput\t=\t{0,1,1,0,1,2,1,2,0,0,0,1},\tOutput\t=\t{0,0,0,0,0,1,1,1,1,1,2,2} Solution:\tUse\tCounting\tsort.\tSince\tthere\tare\tonly\tthree\telements\tand\tthe\tmaximum\tvalue\tis\t2,\twe need\ta\ttemporary\tarray\twith\t3\telements. Time\tComplexity:\tO(n).\tSpace\tComplexity:\tO(1). Note:\tFor\tvariations\tof\tthis\tproblem,\trefer\tto\tSearching\tchapter. Problem-17\u2003\u2003Is\tthere\tany\tother\tway\tof\tsolving\tProblem-16? Solution:\tUsing\tQuick\tdort.\tSince\twe\tknow\tthat\tthere\tare\tonly\t3\telements,\t0,1\tand\t2\tin\tthe\tarray, we\tcan\tselect\t1\tas\ta\tpivot\telement\tfor\tQuick\tsort.\tQuick\tsort\tfinds\tthe\tcorrect\tplace\tfor\t1\tby moving\tall\t0\u2019s\tto\tthe\tleft\tof\t1\tand\tall\t2\u2019s\tto\tthe\tright\tof\t1.\tFor\tdoing\tthis\tit\tuses\tonly\tone\tscan. Time\tComplexity:\tO(n).\tSpace\tComplexity:\tO(1). Note:\tFor\tefficient\talgorithm,\trefer\tto\tSearching\tchapter. Problem-18\u2003\u2003How\tdo\twe\tfind\tthe\tnumber\tthat\tappeared\tthe\tmaximum\tnumber\tof\ttimes\tin\tan array? Solution:\t One\t simple\t approach\t is\t to\t sort\t the\t given\t array\t and\t scan\t the\t sorted\t array.\t While scanning,\tkeep\ttrack\tof\tthe\telements\tthat\toccur\tthe\tmaximum\tnumber\tof\ttimes. Algorithm: Time\t Complexity\t =\t Time\t for\t Sorting\t +\t Time\t for\t Scan\t =\t O(nlogn)\t +O(n)\t =\t O(nlogn).\t Space Complexity:\tO(1). Note:\tFor\tvariations\tof\tthis\tproblem,\trefer\tto\tSearching\tchapter. Problem-19\u2003\u2003Is\tthere\tany\tother\tway\tof\tsolving\tProblem-18? Solution:\tUsing\tBinary\tTree.\tCreate\ta\tbinary\ttree\twith\tan\textra\tfield\tcount\twhich\tindicates\tthe number\tof\ttimes\tan\telement\tappeared\tin\tthe\tinput.\tLet\tus\tsay\twe\thave\tcreated\ta\tBinary\tSearch Tree\t[BST].\tNow,\tdo\tthe\tIn-Order\ttraversal\tof\tthe\ttree.\tThe\tIn-Order\ttraversal\tof\tBST\tproduces the\tsorted\tlist.\tWhile\tdoing\tthe\tIn-Order\ttraversal\tkeep\ttrack\tof\tthe\tmaximum\telement. Time\tComplexity:\tO(n)\t+\tO(n)\t\u2248\tO(n).\tThe\tfirst\tparameter\tis\tfor\tconstructing\tthe\tBST\tand\tthe second\tparameter\tis\tfor\tInorder\tTraversal.\tSpace\tComplexity:\tO(2n)\t\u2248\tO(n),\tsince\tevery\tnode\tin BST\tneeds\ttwo\textra\tpointers. Problem-20\u2003\u2003Is\tthere\tyet\tanother\tway\tof\tsolving\tProblem-18? Solution:\tUsing\tHash\tTable.\tFor\teach\telement\tof\tthe\tgiven\tarray\twe\tuse\ta\tcounter,\tand\tfor\teach occurrence\tof\tthe\telement\twe\tincrement\tthe\tcorresponding\tcounter.\tAt\tthe\tend\twe\tcan\tjust\treturn the\telement\twhich\thas\tthe\tmaximum\tcounter. Time\tComplexity:\tO(n).\tSpace\tComplexity:\tO(n).\tFor\tconstructing\tthe\thash\ttable\twe\tneed\tO(n). Note:\tFor\tthe\tefficient\talgorithm,\trefer\tto\tthe\tSearching\tchapter. Problem-21\u2003\u2003Given\ta\t2\tGB\tfile\twith\tone\tstring\tper\tline,\twhich\tsorting\talgorithm\twould\twe use\tto\tsort\tthe\tfile\tand\twhy? Solution:\tWhen\twe\thave\ta\tsize\tlimit\tof\t2GB,\tit\tmeans\tthat\twe\tcannot\tbring\tall\tthe\tdata\tinto\tthe main\tmemory. Algorithm:\tHow\tmuch\tmemory\tdo\twe\thave\tavailable?\tLet\u2019s\tassume\twe\thave\tX\tMB\tof\tmemory available.\tDivide\tthe\tfile\tinto\tK\tchunks,\twhere\tX\t*\tK\t~\t2\tGB. \u2022 Bring\teach\tchunk\tinto\tmemory\tand\tsort\tthe\tlines\tas\tusual\t(any\tO(nlogn)\talgorithm). \u2022 Save\tthe\tlines\tback\tto\tthe\tfile. \u2022 Now\tbring\tthe\tnext\tchunk\tinto\tmemory\tand\tsort. \u2022 Once\twe\u2019re\tdone,\tmerge\tthem\tone\tby\tone;\tin\tthe\tcase\tof\tone\tset\tfinishing,\tbring\tmore data\tfrom\tthe\tparticular\tchunk. The\tabove\talgorithm\tis\talso\tknown\tas\texternal\tsort.\tStep\t3\t\u2013\t4\tis\tknown\tas\tK-way\tmerge.\tThe idea\tbehind\tgoing\tfor\tan\texternal\tsort\tis\tthe\tsize\tof\tdata.\tSince\tthe\tdata\tis\thuge\tand\twe\tcan\u2019t\tbring it\tto\tthe\tmemory,\twe\tneed\tto\tgo\tfor\ta\tdisk-based\tsorting\talgorithm. Problem-22\u2003\u2003Nearly\tsorted:\tGiven\tan\tarray\tof\tn\telements,\teach\twhich\tis\tat\tmost\tK\tpositions from\tits\ttarget\tposition,\tdevise\tan\talgorithm\tthat\tsorts\tin\tO(n\tlogK)\ttime. Solution:\tDivide\tthe\telements\tinto\tn/K\tgroups\tof\tsize\tK,\tand\tsort\teach\tpiece\tin\tO(KlogK)\ttime, let\u2019s\tsay\tusing\tMergesort.\tThis\tpreserves\tthe\tproperty\tthat\tno\telement\tis\tmore\tthan\tK\telements\tout of\tposition.\tNow,\tmerge\teach\tblock\tof\tK\telements\twith\tthe\tblock\tto\tits\tleft. Problem-23\u2003\u2003Is\tthere\tany\tother\tway\tof\tsolving\tProblem-22? Solution:\tInsert\tthe\tfirst\tK\telements\tinto\ta\tbinary\theap.\tInsert\tthe\tnext\telement\tfrom\tthe\tarray\tinto the\theap,\tand\tdelete\tthe\tminimum\telement\tfrom\tthe\theap.\tRepeat. Problem-24\u2003\u2003Merging\tK\tsorted\tlists:\tGiven\tK\tsorted\tlists\twith\ta\ttotal\tof\tn\telements,\tgive\tan O(nlogK)\talgorithm\tto\tproduce\ta\tsorted\tlist\tof\tall\tn\telements. Solution:\tSimple\tAlgorithm\tfor\tmerging\tK\tsorted\tlists:\tConsider\tgroups\teach\thaving\t \telements. Take\tthe\tfirst\tlist\tand\tmerge\tit\twith\tthe\tsecond\tlist\tusing\ta\tlinear-time\talgorithm\tfor\tmerging\ttwo sorted\tlists,\tsuch\tas\tthe\tmerging\talgorithm\tused\tin\tmerge\tsort.\tThen,\tmerge\tthe\tresulting\tlist\tof\t elements\twith\tthe\tthird\tlist,\tand\tthen\tmerge\tthe\tresulting\tlist\tof\t \telements\twith\tthe\tfourth\tlist. Repeat\tthis\tuntil\twe\tend\tup\twith\ta\tsingle\tsorted\tlist\tof\tall\tn\telements. Time\tComplexity:\tIn\teach\titeration\twe\tare\tmerging\tK\telements. Problem-25\u2003\u2003Can\twe\timprove\tthe\ttime\tcomplexity\tof\tProblem-24? Solution:\tOne\tmethod\tis\tto\trepeatedly\tpair\tup\tthe\tlists\tand\tthen\tmerge\teach\tpair.\tThis\tmethod\tcan also\tbe\tseen\tas\ta\ttail\tcomponent\tof\tthe\texecution\tmerge\tsort,\twhere\tthe\tanalysis\tis\tclear.\tThis\tis called\tthe\tTournament\tMethod.\tThe\tmaximum\tdepth\tof\tthe\tTournament\tMethod\tis\tlogK\t and\t in each\titeration\twe\tare\tscanning\tall\tthe\tn\telements. Time\tComplexity;\tO(nlogK). Problem-26\u2003\u2003Is\tthere\tany\tother\tway\tof\tsolving\tProblem-24? Solution:\tThe\tother\tmethod\tis\tto\tuse\ta\train\tpriority\tqueue\tfor\tthe\tminimum\telements\tof\teach\tof the\tif\tlists.\tAt\teach\tstep,\twe\toutput\tthe\textracted\tminimum\tof\tthe\tpriority\tqueue,\tdetermine\tfrom which\tof\tthe\tK\tlists\tit\tcame,\tand\tinsert\tthe\tnext\telement\tfrom\tthat\tlist\tinto\tthe\tpriority\tqueue.\tSince we\tare\tusing\tpriority\tqueue,\tthat\tmaximum\tdepth\tof\tpriority\tqueue\tis\tlogK. Time\tComplexity;\tO(nlogK). Problem-27\u2003\u2003Which\tsorting\tmethod\tis\tbetter\tfor\tLinked\tLists? Solution:\t Merge\t Sort\t is\t a\t better\t choice.\t At\t first\t appearance,\t merge\t sort\t may\t not\t be\t a\t good selection\tsince\tthe\tmiddle\tnode\tis\trequired\tto\tsubdivide\tthe\tgiven\tlist\tinto\ttwo\tsub-lists\tof\tequal length.\tWe\tcan\teasily\tsolve\tthis\tproblem\tby\tmoving\tthe\tnodes\talternatively\tto\ttwo\tlists\t(refer\tto Linked\tLists\t chapter).\t Then,\t sorting\t these\t two\t lists\t recursively\t and\t merging\t the\t results\t into\t a single\tlist\twill\tsort\tthe\tgiven\tone. Note:\tAppend()\tappends\tthe\tfirst\targument\tto\tthe\ttail\tof\ta\tsingly\tlinked\tlist\twhose\thead\tand\ttail are\tdefined\tby\tthe\tsecond\tand\tthird\targuments. All\texternal\tsorting\talgorithms\tcan\tbe\tused\tfor\tsorting\tlinked\tlists\tsince\teach\tinvolved\tfile\tcan\tbe considered\tas\ta\tlinked\tlist\tthat\tcan\tonly\tbe\taccessed\tsequentially.\tWe\tcan\tsort\ta\tdoubly\tlinked\tlist using\tits\tnext\tfields\tas\tif\tit\twas\ta\tsingly\tlinked\tone\tand\treconstruct\tthe\tprev\tfields\tafter\tsorting with\tan\tadditional\tscan. Problem-28\u2003\u2003Can\twe\timplement\tLinked\tLists\tSorting\twith\tQuick\tSort? Solution:\tThe\toriginal\tQuick\tSort\tcannot\tbe\tused\tfor\tsorting\tSingly\tLinked\tLists.\tThis\tis\tbecause we\tcannot\tmove\tbackward\tin\tSingly\tLinked\tLists.\tBut\twe\tcan\tmodify\tthe\toriginal\tQuick\tSort\tand make\tit\twork\tfor\tSingly\tLinked\tLists. Let\tus\tconsider\tthe\tfollowing\tmodified\tQuick\tSort\timplementation.\tThe\tfirst\tnode\tof\tthe\tinput\tlist is\tconsidered\ta\tpivot\tand\tis\tmoved\tto\tequal.\tThe\tvalue\tof\teach\tnode\tis\tcompared\twith\tthe\tpivot and\tmoved\tto\tless\t(respectively,\tequal\tor\tlarger)\tif\tthe\tnodes\tvalue\tis\tsmaller\tthan\t(respectively, equal\tto\tor\tlarger\tthan)\tthe\tpivot.\tThen,\tless\tand\tlarger\tare\tsorted\trecursively.\tFinally,\tjoining less,\tequal\tand\tlarger\tinto\ta\tsingle\tlist\tyields\ta\tsorted\tone. Append()\tappends\tthe\tfirst\targument\tto\tthe\ttail\tof\ta\tsingly\tlinked\tlist\twhose\thead\tand\ttail\tare defined\tby\tthe\tsecond\tand\tthird\targuments.\tOn\treturn,\tthe\tfirst\targument\twill\tbe\tmodified\tso\tthat\tit points\tto\tthe\tnext\tnode\tof\tthe\tlist.\tJoin()\tappends\tthe\tlist\twhose\thead\tand\ttail\tare\tdefined\tby\tthe third\t and\t fourth\t arguments\t to\t the\t list\t whose\t head\t and\t tail\t are\t defined\t by\t the\t first\t and\t second arguments.\tFor\tsimplicity,\tthe\tfirst\tand\tfourth\targuments\tbecome\tthe\thead\tand\ttail\tof\tthe\tresulting list. Problem-29\u2003\u2003Given\tan\tarray\tof\t100,000\tpixel\tcolor\tvalues,\teach\tof\twhich\tis\tan\tinteger\tin\tthe range\t[0,255].\tWhich\tsorting\talgorithm\tis\tpreferable\tfor\tsorting\tthem? Solution:\tCounting\tSort.\tThere\tare\tonly\t256\tkey\tvalues,\tso\tthe\tauxiliary\tarray\twould\tonly\tbe\tof size\t256,\tand\tthere\twould\tbe\tonly\ttwo\tpasses\tthrough\tthe\tdata,\twhich\twould\tbe\tvery\tefficient\tin both\ttime\tand\tspace. Problem-30\u2003\u2003Similar\tto\tProblem-29,\tif\twe\thave\ta\ttelephone\tdirectory\twith\t10\tmillion\tentries, which\tsorting\talgorithm\tis\tbest? Solution:\tBucket\tSort.\tIn\tBucket\tSort\tthe\tbuckets\tare\tdefined\tby\tthe\tlast\t7\tdigits.\tThis\trequires\tan auxiliary\tarray\tof\tsize\t10\tmillion\tand\thas\tthe\tadvantage\tof\trequiring\tonly\tone\tpass\tthrough\tthe data\ton\tdisk.\tEach\tbucket\tcontains\tall\ttelephone\tnumbers\twith\tthe\tsame\tlast\t7\tdigits\tbut\twith different\tarea\tcodes.\tThe\tbuckets\tcan\tthen\tbe\tsorted\tby\tarea\tcode\twith\tselection\tor\tinsertion\tsort; there\tare\tonly\ta\thandful\tof\tarea\tcodes. Problem-31\u2003\u2003Give\tan\talgorithm\tfor\tmerging\tK-sorted\tlists. Solution:\tRefer\tto\tPriority\tQueues\tchapter. Problem-32\u2003\u2003Given\ta\tbig\tfile\tcontaining\tbillions\tof\tnumbers.\tFind\tmaximum\t10\tnumbers\tfrom this\tfile. Solution:\tRefer\tto\tPriority\tQueues\tchapter. Problem-33\u2003\u2003There\tare\ttwo\tsorted\tarrays\tA\tand\tB.\tThe\tfirst\tone\tis\tof\tsize\tm\t+\tn\tcontaining only\tm\telements.\tAnother\tone\tis\tof\tsize\tn\tand\tcontains\tn\telements.\tMerge\tthese\ttwo\tarrays into\tthe\tfirst\tarray\tof\tsize\tm\t+\tn\tsuch\tthat\tthe\toutput\tis\tsorted. Solution:\tThe\ttrick\tfor\tthis\tproblem\tis\tto\tstart\tfilling\tthe\tdestination\tarray\tfrom\tthe\tback\twith\tthe largest\telements.\tWe\twill\tend\tup\twith\ta\tmerged\tand\tsorted\tdestination\tarray. Time\tComplexity:\tO(m\t+\tn).\tSpace\tComplexity:\tO(1). Problem-34\u2003\u2003Nuts\tand\tBolts\tProblem:\tGiven\ta\tset\tof\tn\tnuts\tof\tdifferent\tsizes\tand\tn\t bolts such\tthat\tthere\tis\ta\tone-to-one\tcorrespondence\tbetween\tthe\tnuts\tand\tthe\tbolts,\tfind\tfor\teach nut\t its\t corresponding\t bolt.\t Assume\t that\t we\t can\t only\t compare\t nuts\t to\t bolts:\t we\t cannot compare\tnuts\tto\tnuts\tand\tbolts\tto\tbolts. Alternative\tway\tof\tframing\tthe\tquestion:\tWe\tare\tgiven\ta\tbox\twhich\tcontains\tbolts\tand nuts.\tAssume\tthere\tare\tn\tnuts\tand\tn\tbolts\tand\tthat\teach\tnut\tmatches\texactly\tone\tbolt\t(and vice\tversa).\tBy\ttrying\tto\tmatch\ta\tbolt\tand\ta\tnut\twe\tcan\tsee\twhich\tone\tis\tbigger,\tbut\twe cannot\tcompare\ttwo\tbolts\tor\ttwo\tnuts\tdirectly.\tDesign\tan\tefficient\talgorithm\tfor\tmatching the\tnuts\tand\tbolts. Solution:\tBrute\tForce\tApproach:\tStart\twith\tthe\tfirst\tbolt\tand\tcompare\tit\twith\teach\tnut\tuntil\twe find\ta\tmatch.\tIn\tthe\tworst\tcase,\twe\trequire\tn\tcomparisons.\tRepeat\tthis\tfor\tsuccessive\tbolts\ton\tall remaining\tgives\tO(n2)\tcomplexity. Problem-35\u2003\u2003For\tProblem-34,\tcan\twe\timprove\tthe\tcomplexity? Solution:\tIn\tProblem-34,\twe\tgot\tO(n2)\tcomplexity\tin\tthe\tworst\tcase\t(if\tbolts\tare\tin\tascending order\t and\t nuts\t are\t in\t descending\t order).\t Its\t analysis\t is\t the\t same\t as\t that\t of\t Quick\t Sort.\t The improvement\t is\t also\t along\t the\t same\t lines.\t To\t reduce\t the\t worst\t case\t complexity,\t instead\t of selecting\t the\t first\t bolt\t every\t time,\t we\t can\t select\t a\t random\t bolt\t and\t match\t it\t with\t nuts.\t This randomized\tselection\treduces\tthe\tprobability\tof\tgetting\tthe\tworst\tcase,\tbut\tstill\tthe\tworst\tcase\tis O(n2). Problem-36\u2003\u2003For\tProblem-34,\tcan\twe\tfurther\timprove\tthe\tcomplexity? Solution:\tWe\tcan\tuse\ta\tdivide-and-conquer\ttechnique\tfor\tsolving\tthis\tproblem\tand\tthe\tsolution\tis very\t similar\t to\t randomized\t Quick\t Sort.\t For\t simplicity\t let\t us\t assume\t that\t bolts\t and\t nuts\t are represented\tin\ttwo\tarrays\tB\tand\tN. The\talgorithm\tfirst\tperforms\ta\tpartition\toperation\tas\tfollows:\tpick\ta\trandom\tboltB[t].\tUsing\tthis bolt,\trearrange\tthe\tarray\tof\tnuts\tinto\tthree\tgroups\tof\telements: \u2022 First\tthe\tnuts\tsmaller\tthan\tB[i] \u2022 Then\tthe\tnut\tthat\tmatches\tB[i],\tand \u2022 Finally,\tthe\tnuts\tlarger\tthan\tB[i]. Next,\tusing\tthe\tnut\tthat\tmatches\tB[i],\tperform\ta\tsimilar\tpartition\ton\tthe\tarray\tof\tbolts.\tThis\tpair\tof partitioning\toperations\tcan\teasily\tbe\timplemented\tin\tO(n)\ttime,\tand\tit\tleaves\tthe\tbolts\tand\tnuts nicely\tpartitioned\tso\tthat\tthe\t\u201cpivot\u201d\tbolt\tand\tnut\tare\taligned\twith\teach\tother\tand\tall\tother\tbolts and\tnuts\tare\ton\tthe\tcorrect\tside\tof\tthese\tpivots\t\u2013\tsmaller\tnuts\tand\tbolts\tprecede\tthe\tpivots,\tand larger\t nuts\t and\t bolts\t follow\t the\t pivots.\t Our\t algorithm\t then\t completes\t by\t recursively\t applying itself\tto\tthe\tsubarray\tto\tthe\tleft\tand\tright\tof\tthe\tpivot\tposition\tto\tmatch\tthese\tremaining\tbolts\tand nuts.\t We\t can\t assume\t by\t induction\t on\t n\t that\t these\t recursive\t calls\t will\t properly\t match\t the remaining\tbolts. To\tanalyze\tthe\trunning\ttime\tof\tour\talgorithm,\twe\tcan\tuse\tthe\tsame\tanalysis\tas\tthat\tof\trandomized Quick\t Sort.\t Therefore,\t applying\t the\t analysis\t from\t Quick\t Sort,\t the\t time\t complexity\t of\t our algorithm\tis\tO(nlogn). Alternative\tAnalysis:\tWe\tcan\tsolve\tthis\tproblem\tby\tmaking\ta\tsmall\tchange\tto\tQuick\tSort.\tLet\tus assume\tthat\twe\tpick\tthe\tlast\telement\tas\tthe\tpivot,\tsay\tit\tis\ta\tnut.\tCompare\tthe\tnut\twith\tonly\tbolts as\twe\twalk\tdown\tthe\tarray.\tThis\twill\tpartition\tthe\tarray\tfor\tthe\tbolts.\tEvery\tbolt\tless\tthan\tthe partition\tnut\twill\tbe\ton\tthe\tleft.\tAnd\tevery\tbolt\tgreater\tthan\tthe\tpartition\tnut\twill\tbe\ton\tthe\tright. While\t traversing\t down\t the\t list,\t find\t the\t matching\t bolt\t for\t the\t partition\t nut.\t Now\t we\t do\t the partition\tagain\tusing\tthe\tmatching\tbolt.\tAs\ta\tresult,\tall\tthe\tnuts\tless\tthan\tthe\tmatching\tbolt\twill\tbe on\t the\t left\t side\t and\t all\t the\t nuts\t greater\t than\t the\t matching\t bolt\t will\t be\t on\t the\t right\t side. Recursively\tcall\ton\tthe\tleft\tand\tright\tarrays. The\ttime\tcomplexity\tis\tO(2nlogn)\t\u2248\tO(nlogn). Problem-37\u2003\u2003Given\ta\tbinary\ttree,\tcan\twe\tprint\tits\telements\tin\tsorted\torder\tin\tO(n)\ttime\tby performing\tan\tIn-order\ttree\ttraversal? Solution:\tYes,\tif\tthe\ttree\tis\ta\tBinary\tSearch\tTree\t[BST].\tFor\tmore\tdetails\trefer\tto\tTrees\tchapter. Problem-38\u2003\u2003Given\tan\tarray\tof\telements,\tconvert\tit\tinto\tan\tarray\tsuch\tthat\tA\t<\tB\t>\tC\t<\tD\t>\tE <\tF\tand\tso\ton. Solution:\tSort\tthe\tarray,\tthen\tswap\tevery\tadjacent\telement\tto\tget\tthe\tfinal\tresult. The\ttime\tcomplexity\tis\tO(nlogn+n)\t\u2248\tO(nlogn),\tfor\tsorting\tand\ta\tscan. Problem-39\u2003\u2003Can\twe\tdo\tProblem-38\twith\tO(n)\ttime? Solution:\tMake\tsure\tall\teven\tpositioned\telements\tare\tgreater\tthan\ttheir\tadjacent\todd\telements, and\t we\t don\u2019t\t need\t to\t worry\t about\t odd\t positioned\t elements.\t Traverse\t all\t even\t positioned elements\tof\tinput\tarray,\tand\tdo\tthe\tfollowing: \u2022 If\tthe\tcurrent\telement\tis\tsmaller\tthan\tthe\tprevious\todd\telement,\tswap\tprevious\tand current. \u2022 If\tthe\tcurrent\telement\tis\tsmaller\tthan\tthe\tnext\todd\telement,\tswap\tnext\tand\tcurrent. The\ttime\tcomplexity\tis\tO(n). Problem-40\u2003\u2003Merge\tsort\tuses (a) Divide\tand\tconquer\tstrategy (b) Backtracking\tapproach (c) Heuristic\tsearch (d) Greedy\tapproach Solution:\t(a).\tRefer\ttheory\tsection. Problem-41\u2003\u2003Which\t of\t the\t following\t algorithm\t design\t techniques\t is\t used\t in\t the\t quicksort algorithm? (a) Dynamic\tprogramming (b) Backtracking (c) Divide\tand\tconquer (d) Greedy\tmethod Solution:\t(c).\tRefer\ttheory\tsection. Problem-42\u2003\u2003For\tmerging\ttwo\tsorted\tlists\tof\tsizes\tm\tand\tn\tinto\ta\tsorted\tlist\tof\tsize\tm+n,\twe required\tcomparisons\tof (a) O(m) (b) O(n) (c) O(m\t+\tn) (d) O(logm\t+\tlogn) Solution:\t(c).\tWe\tcan\tuse\tmerge\tsort\tlogic.\tRefer\ttheory\tsection. Problem-43\u2003\u2003Quick-sort\tis\trun\ton\ttwo\tinputs\tshown\tbelow\tto\tsort\tin\tascending\torder (i) 1,2,3\t....n (ii)\u2003n,\tn-\t1,\tn-2,\t....\t2,\t1 Let\tC1\tand\tC2\tbe\tthe\tnumber\tof\tcomparisons\tmade\tfor\tthe\tinputs\t(i)\tand\t(ii)\trespectively. Then, (a) C1\t<\tC2 (b) C1\t>\tC2 (c) C1\t=\tC2 (d) we\tcannot\tsay\tanything\tfor\tarbitrary\tn. Solution:\t(b).\tSince\tthe\tgiven\tproblems\tneeds\tthe\toutput\tin\tascending\torder,\tQuicksort\ton\talready sorted\t order\t gives\t the\t worst\t case\t (O(n2)).\t So,\t (i)\t generates\t worst\t case\t and\t (ii)\t needs\t fewer comparisons. Problem-44\u2003\u2003Give\tthe\tcorrect\tmatching\tfor\tthe\tfollowing\tpairs: (A) O(logn) (B) O(n) (C) O(nlogn) (D) O(n2) (P) Selection (Q) Insertion\tsort (R) Binary\tsearch (S) Merge\tsort (a) A\t\u2013\tR\tB\t\u2013\tP\tC\t\u2013\tQ\t\u2013\tD\t\u2013\tS (b) A\t\u2013\tR\tB\t\u2013\tP\tC\t\u2013\tS\tD\t\u2013\tQ (c) A\t\u2013\tP\tB\t\u2013\tR\tC\t\u2013\tS\tD\t\u2013\tQ (d) A\t\u2013\tP\tB\t\u2013\tS\tC\t\u2013\tR\tD\t\u2013\tQ Solution:\t(b).\tRefer\ttheory\tsection. Problem-45\u2003\u2003Let\ts\tbe\ta\tsorted\tarray\tof\tn\tintegers.\tLet\tt(n)\tdenote\tthe\ttime\ttaken\tfor\tthe\tmost efficient\talgorithm\tto\tdetermine\tif\tthere\tare\ttwo\telements\twith\tsum\tless\tthan\t1000\tin\ts. which\tof\tthe\tfollowing\tstatements\tis\ttrue? a) t(n)\tis\tO(1) b) n\t<\tt(n)\t<\t c) d) Solution:\t (a).\t Since\t the\t given\t array\t is\t already\t sorted\t it\t is\t enough\t if\t we\t check\t the\t first\t two elements\tof\tthe\tarray. Problem-46\u2003\u2003The\tusual\t\u0398(n2)\timplementation\t of\t Insertion\t Sort\t to\t sort\t an\t array\t uses\t linear search\tto\tidentify\tthe\tposition\twhere\tan\telement\tis\tto\tbe\tinserted\tinto\tthe\talready\tsorted part\tof\tthe\tarray.\tIf,\tinstead,\twe\tuse\tbinary\tsearch\tto\tidentify\tthe\tposition,\tthe\tworst\tcase running\ttime\twill (a) remain\t\u0398(n2) (b) become\t\u0398(n(log\tn)2) (c) become\t\u0398(nlogn) (d) become\t\u0398(n) Solution:\t(a).\tIf\twe\tuse\tbinary\tsearch\tthen\tthere\twill\tbe\t \tcomparisons\tin\tthe\tworst\tcase, which\t is\t \u0398(nlogn).\t But\t the\t algorithm\t as\t a\t whole\t will\t still\t have\t a\t running\t time\t of\t \u0398(n2)\t on average\tbecause\tof\tthe\tseries\tof\tswaps\trequired\tfor\teach\tinsertion. Problem-47\u2003\u2003In\tquick\tsort,\tfor\tsorting\tn\telements,\tthe\tn/4th\tsmallest\telement\tis\tselected\tas pivot\tusing\tan\tO(n)\ttime\talgorithm.\tWhat\tis\tthe\tworst\tcase\ttime\tcomplexity\tof\tthe\tquick sort? (A) \u0398(n) (B) \u0398(nLogn) (C) \u0398(n2) (D) \u0398(n2logn) Solution:\tThe\trecursion\texpression\tbecomes:\tT(n)\t=\tT(n/4)\t+\tT(3n/4)\t+\ten.\tSolving\tthe\trecursion using\tvariant\tof\tmaster\ttheorem,\twe\tget\t\u0398(nLogn). Problem-48\u2003\u2003Consider\tthe\tQuicksort\talgorithm.\tSuppose\tthere\tis\ta\tprocedure\tfor\tfinding\ta pivot\telement\twhich\tsplits\tthe\tlist\tinto\ttwo\tsub-lists\teach\tof\twhich\tcontains\tat\tleast\tone- fifth\tof\tthe\telements.\tLet\tT(n)\tbe\tthe\tnumber\tof\tcomparisons\trequired\tto\tsort\tn\telements. Then A) T\t(n)\t\u2264\t2T\t(n\t/5)\t+\tn B) T\t(n)\t\u2264\tT\t(n\t/5)\t+\tT\t(4n\t/5)\t+\tn C) T\t(n)\t\u2264\t2T\t(4n\t/5)\t+\tn D) T\t(n)\t\u2264\t2T\t(n\t/2)\t+\tn Solution:\t(C).\tFor\tthe\tcase\twhere\tn/5\telements\tare\tin\tone\tsubset,\tT(n/5)\tcomparisons\tare\tneeded for\tthe\tfirst\tsubset\twith\tn/5\telements,\tT(4n/5)\tis\tfor\tthe\trest\t4n/5\telements,\tand\tn\tis\tfor\tfinding\tthe pivot.\t If\t there\t are\t more\t than\t n/5\t elements\t in\t one\t set\t then\t other\t set\t will\t have\t less\t than\t 4n/5 elements\tand\ttime\tcomplexity\twill\tbe\tless\tthan\tT(n/5)\t+\tT(4n/5)\t+\tn. Problem-49\u2003\u2003Which\t of\t the\t following\t sorting\t algorithms\t has\t the\t lowest\t worst-case complexity? (A) Merge\tsort (B) Bubble\tsort (C) Quick\tsort (D) Selection\tsort Solution:\t(A).\tRefer\ttheory\tsection. Problem-50\u2003\u2003Which\t one\t of\t the\t following\t in\t place\t sorting\t algorithms\t needs\t the\t minimum number\tof\tswaps? (A) Quick\tsort (B) Insertion\tsort (C) Selection\tsort (D) Heap\tsort Solution:\t(C).\tRefer\ttheory\tsection. Problem-51\u2003\u2003You\thave\tan\tarray\tof\tn\telements.\tSuppose\tyou\timplement\tquicksort\tby\talways choosing\tthe\tcentral\telement\tof\tthe\tarray\tas\tthe\tpivot.\tThen\tthe\ttightest\tupper\tbound\tfor\tthe worst\tcase\tperformance\tis (A) O(n2) (B) O(nlogn) (C) \u0398(nlogn) (D) O(n3) Solution:\t(A).\tWhen\twe\tchoose\tthe\tfirst\telement\tas\tthe\tpivot,\tthe\tworst\tcase\tof\tquick\tsort\tcomes if\tthe\tinput\tis\tsorted-\teither\tin\tascending\tor\tdescending\torder. Problem-52\u2003\u2003Let\tP\tbe\ta\tQuicksort\tProgram\tto\tsort\tnumbers\tin\tascending\torder\tusing\tthe\tfirst element\tas\tpivot.\tLet\tt1\tand\tt2\tbe\tthe\tnumber\tof\tcomparisons\tmade\tby\tP\tfor\tthe\tinputs\t{1, 2,\t3,\t4,\t5}\tand\t{4,\t1,\t5,\t3,\t2}\trespectively.\tWhich\tone\tof\tthe\tfollowing\tholds? (A) t1\t=\t5 (B) t1\t<\tt2 (C) t1\t>\tt2 (D) t1\t=\tt2 Solution:\t(C).\tQuick\tSort\u2019s\tworst\tcase\toccurs\twhen\tfirst\t(or\tlast)\telement\tis\tchosen\tas\tpivot\twith sorted\tarrays. Problem-53\u2003\u2003The\t minimum\t number\t of\t comparisons\t required\t to\t find\t the\t minimum\t and\t the maximum\tof\t100\tnumbers\tis\t\u2014\u2014 Solution:\t 147\t (Formula\t for\t the\t minimum\t number\t of\t comparisons\t required\t is\t 3n/2\t \u2013\t 3\t with\t n numbers). Problem-54\u2003\u2003The\tnumber\tof\telements\tthat\tcan\tbe\tsorted\tin\tT(logn)\ttime\tusing\theap\tsort\tis (A) \u0398(1) (B) \u0398(sqrt(logn)) (C) \u0398(log\tn/(log\tlog\tn)) (D) \u0398(logn) Solution:\t(D).\tSorting\tan\tarray\twith\tk\telements\ttakes\ttime\t\u0398(k\tlog\tk)\tas\tk\tgrows.\tWe\twant\tto choose\tk\tsuch\tthat\t\u0398(k\tlog\tk)\t=\t\u0398(logn).\tChoosing\tk\t=\t\u0398(logn)\tdoesn\u2019t\tnecessarily\twork,\tsince \u0398(k\tlog\tk)\t=\t\u0398(logn\tloglogn)\t\u2260\t\u0398(logn).\tOn\tthe\tother\thand,\tif\tyou\tchoose\tk\t=\tT(log\tn\t/\tlog\tlog\tn), then\tthe\truntime\tof\tthe\tsort\twill\tbe Notice\tthat\t1\t\u2013\tlogloglogn\t/\tloglogn\ttends\ttoward\t1\tas\tn\tgoes\tto\tinfinity,\tso\tthe\tabove\texpression actually\tis\t\u0398(log\tn),\tas\trequired.\tTherefore,\tif\tyou\ttry\tto\tsort\tan\tarray\tof\tsize\t\u0398(logn\t/\tloglogn) using\theap\tsort,\tas\ta\tfunction\tof\tn,\tthe\truntime\tis\t\u0398(logn). Problem-55\u2003\u2003Which\t one\t of\t the\t following\t is\t the\t tightest\t upper\t bound\t that\t represents\t the number\tof\tswaps\trequired\tto\tsort\tn\tnumbers\tusing\tselection\tsort? (A) O(logn) (B) O(n) (C) O(nlogn) (D) O(n2) Solution:\t(B).\tSelection\tsort\trequires\tonly\tO(n)\tswaps. Problem-56\u2003\u2003Which\tone\tof\tthe\tfollowing\tis\tthe\trecurrence\tequation\tfor\tthe\tworst\tcase\ttime complexity\t of\t the\t Quicksort\t algorithm\t for\t sorting\t n(\u2265\t 2)\t numbers?\t In\t the\t recurrence equations\tgiven\tin\tthe\toptions\tbelow,\tc\tis\ta\tconstant. (A)T(n)\t=\t2T\t(n/2)\t+\tcn (B) T(n)\t=\tT(n\t\u2013\t1)\t+\tT(0)\t+\tcn (C) T(n)\t=\t2T\t(n\t\u2013\t2)\t+\tcn (D) T(n)\t=\tT(n/2)\t+\tcn Solution:\t(B).\tWhen\tthe\tpivot\tis\tthe\tsmallest\t(or\tlargest)\telement\tat\tpartitioning\ton\ta\tblock\tof\tsize n\tthe\tresult\tyields\tone\tempty\tsub-block,\tone\telement\t(pivot)\tin\tthe\tcorrect\tplace\tand\tsub\tblock\tof size\tn\t\u2013\t1. Problem-57\u2003\u2003True\tor\tFalse.\tIn\trandomized\tquicksort,\teach\tkey\tis\tinvolved\tin\tthe\tsame\tnumber of\tcomparisons. Solution:\tFalse. Problem-58\u2003\u2003True\tor\tFalse:\tIf\tQuicksort\tis\twritten\tso\tthat\tthe\tpartition\talgorithm\talways\tuses the\tmedian\tvalue\tof\tthe\tsegment\tas\tthe\tpivot,\tthen\tthe\tworst-case\tperformance\tis\tO(nlogn). Soution:\tTrue."
            },
            {
                "subchapter_title": "11.1\tWhat\tis\tSearching?",
                "content": "In\tcomputer\tscience,\tsearching\tis\tthe\tprocess\tof\tfinding\tan\titem\twith\tspecified\tproperties\tfrom\ta collection\tof\titems.\tThe\titems\tmay\tbe\tstored\tas\trecords\tin\ta\tdatabase,\tsimple\tdata\telements\tin arrays,\ttext\tin\tfiles,\tnodes\tin\ttrees,\tvertices\tand\tedges\tin\tgraphs,\tor\tthey\tmay\tbe\telements\tof\tother search\tspaces."
            },
            {
                "subchapter_title": "11.2\tWhy\tdo\twe\tneed\tSearching?",
                "content": "Searching\tis\tone\tof\tthe\tcore\tcomputer\tscience\talgorithms.\tWe\tknow\tthat\ttoday\u2019s\tcomputers\tstore a\tlot\tof\tinformation.\tTo\tretrieve\tthis\tinformation\tproficiently\twe\tneed\tvery\tefficient\tsearching algorithms.\tThere\tare\tcertain\tways\tof\torganizing\tthe\tdata\tthat\timproves\tthe\tsearching\tprocess. That\tmeans,\tif\twe\tkeep\tthe\tdata\tin\tproper\torder,\tit\tis\teasy\tto\tsearch\tthe\trequired\telement.\tSorting is\tone\tof\tthe\ttechniques\tfor\tmaking\tthe\telements\tordered.\tIn\tthis\tchapter\twe\twill\tsee\tdifferent searching\talgorithms."
            },
            {
                "subchapter_title": "11.3\tTypes\tof\tSearching",
                "content": "Following\tare\tthe\ttypes\tof\tsearches\twhich\twe\twill\tbe\tdiscussing\tin\tthis\tbook. \u2022 Unordered\tLinear\tSearch \u2022 Sorted/Ordered\tLinear\tSearch \u2022 Binary\tSearch \u2022 Interpolation\tsearch \u2022 Binary\tSearch\tTrees\t(operates\ton\ttrees\tand\trefer\tTrees\tchapter) \u2022 Symbol\tTables\tand\tHashing \u2022 String\tSearching\tAlgorithms:\tTries,\tTernary\tSearch\tand\tSuffix\tTrees"
            },
            {
                "subchapter_title": "11.4\tUnordered\tLinear\tSearch",
                "content": "Let\tus\tassume\twe\tare\tgiven\tan\tarray\twhere\tthe\torder\tof\tthe\telements\tis\tnot\tknown.\tThat\tmeans\tthe elements\tof\tthe\tarray\tare\tnot\tsorted.\tIn\tthis\tcase,\tto\tsearch\tfor\tan\telement\twe\thave\tto\tscan\tthe complete\tarray\tand\tsee\tif\tthe\telement\tis\tthere\tin\tthe\tgiven\tlist\tor\tnot. Time\tcomplexity:\tO(n),\tin\tthe\tworst\tcase\twe\tneed\tto\tscan\tthe\tcomplete\tarray.\tSpace\tcomplexity: O(1)."
            },
            {
                "subchapter_title": "11.5\tSorted/Ordered\tLinear\tSearch",
                "content": "If\t the\t elements\t of\t the\t array\t are\t already\t sorted,\t then\t in\t many\t cases\t we\t don\u2019t\t have\t to\t scan\t the complete\tarray\tto\tsee\tif\tthe\telement\tis\tthere\tin\tthe\tgiven\tarray\tor\tnot.\tIn\tthe\talgorithm\tbelow,\tit can\tbe\tseen\tthat,\tat\tany\tpoint\tif\tthe\tvalue\tat\tA[i]\tis\tgreater\tthan\tthe\tdata\tto\tbe\tsearched,\tthen\twe just\treturn\t\u20131\twithout\tsearching\tthe\tremaining\tarray. Time\tcomplexity\tof\tthis\talgorithm\tis\tO(n).This\tis\tbecause\tin\tthe\tworst\tcase\twe\tneed\tto\tscan\tthe complete\tarray.\tBut\tin\tthe\taverage\tcase\tit\treduces\tthe\tcomplexity\teven\tthough\tthe\tgrowth\trate\tis the\tsame. Space\tcomplexity:\tO(1). Note:\tFor\tthe\tabove\talgorithm\twe\tcan\tmake\tfurther\timprovement\tby\tincrementing\tthe\tindex\tat\ta faster\trate\t(say,\t2).\tThis\twill\treduce\tthe\tnumber\tof\tcomparisons\tfor\tsearching\tin\tthe\tsorted\tlist."
            },
            {
                "subchapter_title": "11.6\tBinary\tSearch",
                "content": "Let\tus\tconsider\tthe\tproblem\tof\tsearching\ta\tword\tin\ta\tdictionary.\tTypically,\twe\tdirectly\tgo\tto some\tapproximate\tpage\t[say,\tmiddle\tpage]\tand\tstart\tsearching\tfrom\tthat\tpoint.\tIf\tthe\tname\tthat\twe are\tsearching\tis\tthe\tsame\tthen\tthe\tsearch\tis\tcomplete.\tIf\tthe\tpage\tis\tbefore\tthe\tselected\tpages\tthen apply\tthe\tsame\tprocess\tfor\tthe\tfirst\thalf;\totherwise\tapply\tthe\tsame\tprocess\tto\tthe\tsecond\thalf. Binary\tsearch\talso\tworks\tin\tthe\tsame\tway.\tThe\talgorithm\tapplying\tsuch\ta\tstrategy\tis\treferred\tto as\tbinary\tsearch\talgorithm. Recurrence\t for\t binary\t search\t is\t .\t This\t is\t because\t we\t are\t always considering\tonly\thalf\tof\tthe\tinput\tlist\tand\tthrowing\tout\tthe\tother\thalf.\tUsing\tDivide\tand\tConquer master\ttheorem,\twe\tget,\tT(n)\t=\tO(logn). Time\tComplexity:\tO(logn).\tSpace\tComplexity:\tO(1)\t[for\titerative\talgorithm]."
            },
            {
                "subchapter_title": "11.7\tInterpolation\tSearch",
                "content": "Undoubtedly\t binary\t search\t is\t a\t great\t algorithm\t for\t searching\t with\t average\t running\t time complexity\tof\tlogn.\tIt\talways\tchooses\tthe\tmiddle\tof\tthe\tremaining\tsearch\tspace,\tdiscarding\tone half\tor\tthe\tother,\tagain\tdepending\ton\tthe\tcomparison\tbetween\tthe\tkey\tvalue\tfound\tat\tthe\testimated (middle)\tposition\tand\tthe\tkey\tvalue\tsought.\tThe\tremaining\tsearch\tspace\tis\treduced\tto\tthe\tpart before\tor\tafter\tthe\testimated\tposition. In\tthe\tmathematics,\tinterpolation\tis\ta\tprocess\tof\tconstructing\tnew\tdata\tpoints\twithin\tthe\trange\tof\ta discrete\tset\tof\tknown\tdata\tpoints.\tIn\tcomputer\tscience,\tone\toften\thas\ta\tnumber\tof\tdata\tpoints which\t represent\t the\t values\t of\t a\t function\t for\t a\t limited\t number\t of\t values\t of\t the\t independent variable.\t It\t is\t often\t required\t to\t interpolate\t (i.e.\t estimate)\t the\t value\t of\t that\t function\t for\t an intermediate\tvalue\tof\tthe\tindependent\tvariable. For\texample,\tsuppose\twe\thave\ta\ttable\tlike\tthis,\twhich\tgives\tsome\tvalues\tof\tan\tunknown\tfunction f.\tInterpolation\tprovides\ta\tmeans\tof\testimating\tthe\tfunction\tat\tintermediate\tpoints,\tsuch\tas\tx\t=\t55. x f(x) 1 10 2 20 3 30 4 40 5 50 6 60 7 70 There\t are\t many\t different\t interpolation\t methods,\t and\t one\t of\t the\t simplest\t methods\t is\t linear interpolation.\t Since\t 55\t is\t midway\t between\t 50\t and\t 60,\t it\t is\t reasonable\t to\t take\t f(55)\t midway between\tf(5)\t=\t50\tand\tf(6)\t=\t60,\twhich\tyields\t55. Linear\tinterpolation\ttakes\ttwo\tdata\tpoints,\tsay\t(x1;\ty2)\tand\t(x2,\ty2),\tand\tthe\tinterpolant\tis\tgiven\tby: With\tabove\tinputs,\twhat\twill\thappen\tif\twe\tdon\u2019t\tuse\tthe\tconstant\t\u00bd,\tbut\tanother\tmore\taccurate constant\t\u201cK\u201d,\tthat\tcan\tlead\tus\tcloser\tto\tthe\tsearched\titem. This\t algorithm\t tries\t to\t follow\t the\t way\t we\t search\t a\t name\t in\t a\t phone\t book,\t or\t a\t word\t in\t the dictionary.\tWe,\thumans,\tknow\tin\tadvance\tthat\tin\tcase\tthe\tname\twe\u2019re\tsearching\tstarts\twith\ta\t\u201cm\u201d, like\t\u201cmonk\u201d\tfor\tinstance,\twe\tshould\tstart\tsearching\tnear\tthe\tmiddle\tof\tthe\tphone\tbook.\tThus\tif we\u2019re\t searching\t the\t word\t \u201ccareer\u201d\t in\t the\t dictionary,\t you\t know\t that\t it\t should\t be\t placed somewhere\t at\t the\t beginning.\t This\t is\t because\t we\t know\t the\t order\t of\t the\t letters,\t we\t know\t the interval\t (a-z),\t and\t somehow\t we\t intuitively\t know\t that\t the\t words\t are\t dispersed\t equally.\t These facts\tare\tenough\tto\trealize\tthat\tthe\tbinary\tsearch\tcan\tbe\ta\tbad\tchoice.\tIndeed\tthe\tbinary\tsearch algorithm\tdivides\tthe\tlist\tin\ttwo\tequal\tsub-lists,\twhich\tis\tuseless\tif\twe\tknow\tin\tadvance\tthat\tthe searched\titem\tis\tsomewhere\tin\tthe\tbeginning\tor\tthe\tend\tof\tthe\tlist.\tYes,\twe\tcan\tuse\talso\tjump search\tif\tthe\titem\tis\tat\tthe\tbeginning,\tbut\tnot\tif\tit\tis\tat\tthe\tend,\tin\tthat\tcase\tthis\talgorithm\tis\tnot\tso effective. The\tinterpolation\tsearch\talgorithm\ttries\tto\timprove\tthe\tbinary\tsearch.\tThe\tquestion\tis\thow\tto\tfind this\tvalue?\tWell,\twe\tknow\tbounds\tof\tthe\tinterval\tand\tlooking\tcloser\tto\tthe\timage\tabove\twe\tcan define\tthe\tfollowing\tformula. This\tconstant\tK\tis\tused\tto\tnarrow\tdown\tthe\tsearch\tspace.\tFor\tbinary\tsearch,\tthis\tconstant\tK\tis (low\t+\thigh)/2. Now\twe\tcan\tbe\tsure\tthat\twe\u2019re\tcloser\tto\tthe\tsearched\tvalue.\tOn\taverage\tthe\tinterpolation\tsearch makes\tabout\tlog\t(logn)\tcomparisons\t(if\tthe\telements\tare\tuniformly\tdistributed),\twhere\tn\tis\tthe number\tof\telements\tto\tbe\tsearched.\tIn\tthe\tworst\tcase\t(for\tinstance\twhere\tthe\tnumerical\tvalues\tof the\tkeys\tincrease\texponentially)\tit\tcan\tmake\tup\tto\tO(n)\tcomparisons.\tIn\tinterpolation-sequential search,\tinterpolation\tis\tused\tto\tfind\tan\titem\tnear\tthe\tone\tbeing\tsearched\tfor,\tthen\tlinear\tsearch\tis used\tto\tfind\tthe\texact\titem.\tFor\tthis\talgorithm\tto\tgive\tbest\tresults,\tthe\tdataset\tshould\tbe\tordered and\tuniformly\tdistributed."
            },
            {
                "subchapter_title": "11.8\tComparing\tBasic\tSearching\tAlgorithms",
                "content": "Note:\tFor\tdiscussion\ton\tbinary\tsearch\ttrees\trefer\tTrees\tchapter."
            },
            {
                "subchapter_title": "11.9\tSymbol\tTables\tand\tHashing",
                "content": "Refer\tto\tSymbol\tTables\tand\tHashing\tchapters."
            },
            {
                "subchapter_title": "11.10\tString\tSearching\tAlgorithms",
                "content": "Refer\tto\tString\tAlgorithms\tchapter."
            },
            {
                "subchapter_title": "11.11\tSearching:\tProblems\t&\tSolutions",
                "content": "Problem-1\u2003\u2003Given\tan\tarray\tof\tn\tnumbers,\tgive\tan\talgorithm\tfor\tchecking\twhether\tthere\tare any\tduplicate\telements\tin\tthe\tarray\tor\tno? Solution:\t This\t is\t one\t of\t the\t simplest\t problems.\t One\t obvious\t answer\t to\t this\t is\t exhaustively searching\tfor\tduplicates\tin\tthe\tarray.\tThat\tmeans,\tfor\teach\tinput\telement\tcheck\twhether\tthere\tis any\telement\twith\tthe\tsame\tvalue.\tThis\twe\tcan\tsolve\tjust\tby\tusing\ttwo\tsimple\tfor\tloops.\tThe\tcode for\tthis\tsolution\tcan\tbe\tgiven\tas: Time\tComplexity:\tO(n2),\tfor\ttwo\tnested\tfor\tloops.\tSpace\tComplexity:\tO(1). Problem-2\u2003\u2003Can\twe\timprove\tthe\tcomplexity\tof\tProblem-1\u2019s\tsolution? Solution:\t Yes.\t Sort\t the\t given\t array.\t After\t sorting,\t all\t the\t elements\t with\t equal\t values\t will\t be adjacent.\tNow,\tdo\tanother\tscan\ton\tthis\tsorted\tarray\tand\tsee\tif\tthere\tare\telements\twith\tthe\tsame value\tand\tadjacent. Time\tComplexity:\tO(nlogn),\tfor\tsorting\t(assuming\tnlogn\tsorting\talgorithm).\tSpace\tComplexity: O(1). Problem-3\u2003\u2003Is\tthere\tany\talternative\tway\tof\tsolving\tProblem-1? Solution:\tYes,\tusing\thash\ttable.\tHash\ttables\tare\ta\tsimple\tand\teffective\tmethod\tused\tto\timplement dictionaries.\tAverage\ttime\tto\tsearch\tfor\tan\telement\tis\tO(1),\twhile\tworst-case\ttime\tis\tO(n).\tRefer to\tHashing\tchapter\tfor\tmore\tdetails\ton\thashing\talgorithms.\tAs\tan\texample,\tconsider\tthe\tarray,\tA\t= {3,2,1,2,2,3}. Scan\tthe\tinput\tarray\tand\tinsert\tthe\telements\tinto\tthe\thash.\tFor\teach\tinserted\telement,\tkeep\tthe counter\t as\t 1\t (assume\t initially\t all\t entires\t are\t filled\t with\t zeros).\t This\t indicates\t that\t the corresponding\telement\thas\toccurred\talready.\tFor\tthe\tgiven\tarray,\tthe\thash\ttable\twill\tlook\tlike (after\tinserting\tthe\tfirst\tthree\telements\t3,2\tand\t1): Now\tif\twe\ttry\tinserting\t2,\tsince\tthe\tcounter\tvalue\tof\t2\tis\talready\t1,\twe\tcan\tsay\tthe\telement\thas appeared\ttwice. Time\tComplexity:\tO(n).\tSpace\tComplexity:\tO(n). Problem-4\u2003\u2003Can\twe\tfurther\timprove\tthe\tcomplexity\tof\tProblem-1\tsolution? Solution:\tLet\tus\tassume\tthat\tthe\tarray\telements\tare\tpositive\tnumbers\tand\tall\tthe\telements\tare\tin the\trange\t0\tto\tn\t\u2013\t1.\tFor\teach\telement\tA[i],\tgo\tto\tthe\tarray\telement\twhose\tindex\tis\tA[i].\t That means\tselect\tA[A[i]]\tand\tmark\t-\tA[A[i]]\t(negate\tthe\tvalue\tat\tA[A[i]]).\tContinue\tthis\tprocess\tuntil we\tencounter\tthe\telement\twhose\tvalue\tis\talready\tnegated.\tIf\tone\tsuch\telement\texists\tthen\twe\tsay duplicate\telements\texist\tin\tthe\tgiven\tarray.\tAs\tan\texample,\tconsider\tthe\tarray,\tA\t=\t{3,2,1,2,2,3}. Initially, At\tstep-1,\tnegate\tA[abs(A[0])], At\tstep-2,\tnegate\tA[abs(A[l])], At\tstep-3,\tnegate\tA[abs(A[2])], At\tstep-4,\tnegate\tA[abs(A[3])], At\tstep-4,\tobserve\tthat\tA[abs(A[3])]\tis\talready\tnegative.\tThat\tmeans\twe\thave\tencountered\tthe same\tvalue\ttwice. Time\tComplexity:\tO(n).\tSince\tonly\tone\tscan\tis\trequired.\tSpace\tComplexity:\tO(1). Notes: \u2022 This\tsolution\tdoes\tnot\twork\tif\tthe\tgiven\tarray\tis\tread\tonly. \u2022 This\tsolution\twill\twork\tonly\tif\tall\tthe\tarray\telements\tare\tpositive. \u2022 If\tthe\telements\trange\tis\tnot\tin\t0\tto\tn\t\u2013\t1\tthen\tit\tmay\tgive\texceptions. Problem-5\u2003\u2003Given\tan\tarray\tof\tn\tnumbers.\tGive\tan\talgorithm\tfor\tfinding\tthe\telement\twhich appears\tthe\tmaximum\tnumber\tof\ttimes\tin\tthe\tarray? Brute\tForce\tSolution:\tOne\tsimple\tsolution\tto\tthis\tis,\tfor\teach\tinput\telement\tcheck\twhether\tthere is\tany\telement\twith\tthe\tsame\tvalue,\tand\tfor\teach\tsuch\toccurrence,\tincrement\tthe\tcounter.\tEach time,\tcheck\tthe\tcurrent\tcounter\twith\tthe\tmax\tcounter\tand\tupdate\tit\tif\tthis\tvalue\tis\tgreater\tthan\tmax counter.\tThis\twe\tcan\tsolve\tjust\tby\tusing\ttwo\tsimple\tfor\tloops. Time\tComplexity:\tO(n2),\tfor\ttwo\tnested\tfor\tloops.\tSpace\tComplexity:\tO(1). Problem-6\u2003\u2003Can\twe\timprove\tthe\tcomplexity\tof\tProblem-5\tsolution? Solution:\t Yes.\t Sort\t the\t given\t array.\t After\t sorting,\t all\t the\t elements\t with\t equal\t values\t come adjacent.\tNow,\tjust\tdo\tanother\tscan\ton\tthis\tsorted\tarray\tand\tsee\twhich\telement\tis\tappearing\tthe maximum\tnumber\tof\ttimes. Time\tComplexity:\tO(nlogn).\t(for\tsorting).\tSpace\tComplexity:\tO(1). Problem-7\u2003\u2003Is\tthere\tany\tother\tway\tof\tsolving\tProblem-5? Solution:\tYes,\tusing\thash\ttable.\tFor\teach\telement\tof\tthe\tinput,\tkeep\ttrack\tof\thow\tmany\ttimes\tthat element\tappeared\tin\tthe\tinput.\tThat\tmeans\tthe\tcounter\tvalue\trepresents\tthe\tnumber\tof\toccurrences for\tthat\telement. Time\tComplexity:\tO(n).\tSpace\tComplexity:\tO(n). Problem-8\u2003\u2003or\tProblem-5,\tcan\twe\timprove\tthe\ttime\tcomplexity?\tAssume\tthat\tthe\telements\u2019 range\tis\t1\tto\tn.\tThat\tmeans\tall\tthe\telements\tare\twithin\tthis\trange\tonly. Solution:\tYes.\tWe\tcan\tsolve\tthis\tproblem\tin\ttwo\tscans.\tWe\tcannot\tuse\tthe\tnegation\ttechnique\tof Problem-3\t for\t this\t problem\t because\t of\t the\t number\t of\t repetitions.\t In\t the\t first\t scan,\t instead\t of negating,\tadd\tthe\tvalue\tn.\tThat\tmeans\tfor\teach\toccurrence\tof\tan\telement\tadd\tthe\tarray\tsize\tto\tthat element.\tIn\tthe\tsecond\tscan,\tcheck\tthe\telement\tvalue\tby\tdividing\tit\tby\tn\tand\treturn\tthe\telement which\tgives\tthe\tmaximum\tvalue.\tThe\tcode\tbased\ton\tthis\tmethod\tis\tgiven\tbelow. Notes: \u2022 This\tsolution\tdoes\tnot\twork\tif\tthe\tgiven\tarray\tis\tread\tonly. \u2022 This\tsolution\twill\twork\tonly\tif\tthe\tarray\telements\tare\tpositive. \u2022 If\tthe\telements\trange\tis\tnot\tin\t1\tto\tn\tthen\tit\tmay\tgive\texceptions. Time\tComplexity:\tO(n).\tSince\tno\tnested\tfor\tloops\tare\trequired.\tSpace\tComplexity:\tO(1). Problem-9\u2003\u2003Given\tan\tarray\tof\tn\tnumbers,\tgive\tan\talgorithm\tfor\tfinding\tthe\tfirst\telement\tin\tthe array\twhich\tis\trepeated.\tFor\texample,\tin\tthe\tarray\tA\t=\t{3,2,1,2,2,3},\tthe\tfirst\trepeated number\tis\t3\t(not\t2).\tThat\tmeans,\twe\tneed\tto\treturn\tthe\tfirst\telement\tamong\tthe\trepeated elements. Solution:\tWe\tcan\tuse\tthe\tbrute\tforce\tsolution\tthat\twe\tused\tfor\tProblem-1.\tFor\teach\telement,\tsince it\tchecks\twhether\tthere\tis\ta\tduplicate\tfor\tthat\telement\tor\tnot,\twhichever\telement\tduplicates\tfirst will\tbe\treturned. Problem-10\u2003\u2003For\tProblem-9,\tcan\twe\tuse\tthe\tsorting\ttechnique? Solution:\tNo.\tFor\tproving\tthe\tfailed\tcase,\tlet\tus\tconsider\tthe\tfollowing\tarray.\tFor\texample,\tA\t= {3,\t2,\t1,\t2,\t2,\t3}.\tAfter\tsorting\twe\tget\tA\t=\t{1,2,2,2,3,3}.\tIn\tthis\tsorted\tarray\tthe\tfirst\trepeated element\tis\t2\tbut\tthe\tactual\tanswer\tis\t3. Problem-11\u2003\u2003For\tProblem-9,\tcan\twe\tuse\thashing\ttechnique? Solution:\tYes.\tBut\tthe\tsimple\thashing\ttechnique\twhich\twe\tused\tfor\tProblem-3\twill\tnot\twork.\tFor example,\tif\twe\tconsider\tthe\tinput\tarray\tas\tA\t=\t{3,2,1,2,3},\tthen\tthe\tfirst\trepeated\telement\tis\t3, but\tusing\tour\tsimple\thashing\ttechnique\twe\tget\tthe\tanswer\tas\t2.\tThis\tis\tbecause\t2\tis\tcoming\ttwice before\t3.\tNow\tlet\tus\tchange\tthe\thashing\ttable\tbehavior\tso\tthat\twe\tget\tthe\tfirst\trepeated\telement. Let\tus\tsay,\tinstead\tof\tstoring\t1\tvalue,\tinitially\twe\tstore\tthe\tposition\tof\tthe\telement\tin\tthe\tarray.\tAs a\tresult\tthe\thash\ttable\twill\tlook\tlike\t(after\tinserting\t3,2\tand\t1): Now,\tif\twe\tsee\t2\tagain,\twe\tjust\tnegate\tthe\tcurrent\tvalue\tof\t2\tin\tthe\thash\ttable.\tThat\tmeans,\twe make\tits\tcounter\tvalue\tas\t\u20132.\tThe\tnegative\tvalue\tin\tthe\thash\ttable\tindicates\tthat\twe\thave\tseen\tthe same\telement\ttwo\ttimes.\tSimilarly,\tfor\t3\t(the\tnext\telement\tin\tthe\tinput)\talso,\twe\tnegate\tthe\tcurrent value\tof\tthe\thash\ttable\tand\tfinally\tthe\thash\ttable\twill\tlook\tlike: After\t processing\t the\t complete\t input\t array,\t scan\t the\t hash\t table\t and\t return\t the\t highest\t negative indexed\tvalue\tfrom\tit\t(i.e.,\t\u20131\tin\tour\tcase).\tThe\thighest\tnegative\tvalue\tindicates\tthat\twe\thave\tseen that\telement\tfirst\t(among\trepeated\telements)\tand\talso\trepeating. What\tif\tthe\telement\tis\trepeated\tmore\tthan\ttwice?\tIn\tthis\tcase,\tjust\tskip\tthe\telement\tif\tthe corresponding\tvalue\ti\tis\talready\tnegative. Problem-12\u2003\u2003For\tProblem-9,\tcan\twe\tuse\tthe\ttechnique\tthat\twe\tused\tfor\tProblem-3\t(negation technique)? Solution:\tNo.\tAs\tan\texample\tof\tcontradiction,\tfor\tthe\tarray\tA\t=\t{3,2,1,2,2,3}\tthe\tfirst\trepeated element\tis\t3.\tBut\twith\tnegation\ttechnique\tthe\tresult\tis\t2. Problem-13\u2003\u2003Finding\tthe\tMissing\tNumber:\tWe\tare\tgiven\ta\tlist\tof\tn\t\u2013\t1\tintegers\tand\tthese integers\tare\tin\tthe\trange\tof\t1\tto\tn.\tThere\tare\tno\tduplicates\tin\tthe\tlist.\tOne\tof\tthe\tintegers\tis missing\t in\t the\t list.\t Given\t an\t algorithm\t to\t find\t the\t missing\t integer.\t Example:\t I/P: [1,2,4,6,3,7,8]\tO/P:\t5 Brute\tForce\tSolution:\tOne\tsimple\tsolution\tto\tthis\tis,\tfor\teach\tnumber\tin\t1\tto\tn,\tcheck\twhether that\tnumber\tis\tin\tthe\tgiven\tarray\tor\tnot. Time\tComplexity:\tO(n2).\tSpace\tComplexity:\tO(1). Problem-14\u2003\u2003For\tProblem-13,\tcan\twe\tuse\tsorting\ttechnique? Solution:\tYes.\tSorting\tthe\tlist\twill\tgive\tthe\telements\tin\tincreasing\torder\tand\twith\tanother\tscan\twe can\tfind\tthe\tmissing\tnumber. Time\tComplexity:\tO(nlogn),\tfor\tsorting.\tSpace\tComplexity:\tO(1). Problem-15\u2003\u2003For\tProblem-13,\tcan\twe\tuse\thashing\ttechnique? Solution:\tYes.\tScan\tthe\tinput\tarray\tand\tinsert\telements\tinto\tthe\thash.\tFor\tinserted\telements,\tkeep counter\t as\t 1\t (assume\t initially\t all\t entires\t are\t filled\t with\t zeros).\t This\t indicates\t that\t the corresponding\t element\t has\t occurred\t already.\t Now,\t scan\t the\t hash\t table\t and\t return\t the\t element which\thas\tcounter\tvalue\tzero. Time\tComplexity:\tO(n).\tSpace\tComplexity:\tO(n). Problem-16\u2003\u2003For\tProblem-13,\tcan\twe\timprove\tthe\tcomplexity? Solution:\tYes.\tWe\tcan\tuse\tsummation\tformula. 1) Get\tthe\tsum\tof\tnumbers,\tsum\t=\tn\t\u00d7\t(n\t+\tl)/2. 2) Subtract\tall\tthe\tnumbers\tfrom\tsum\tand\tyou\twill\tget\tthe\tmissing\tnumber. Time\tComplexity:\tO(n),\tfor\tscanning\tthe\tcomplete\tarray. Problem-17\u2003\u2003In\tProblem-13,\tif\tthe\tsum\tof\tthe\tnumbers\tgoes\tbeyond\tthe\tmaximum\tallowed integer,\tthen\tthere\tcan\tbe\tinteger\toverflow\tand\twe\tmay\tnot\tget\tthe\tcorrect\tanswer.\tCan\twe solve\tthis\tproblem? Solution: 1) XOR\tall\tthe\tarray\telements,\tlet\tthe\tresult\tof\tXOR\tbe\tX. 2) XOR\tall\tnumbers\tfrom\t1\tto\tn,\tlet\tXOR\tbe\tY. 3) XOR\tof\tX\tand\tY\tgives\tthe\tmissing\tnumber. Time\tComplexity:\tO(n),\tfor\tscanning\tthe\tcomplete\tarray.\tSpace\tComplexity:\tO(1). Problem-18\u2003\u2003Find\t the\t Number\t Occurring\t an\t Odd\t Number\t of\t Times:\t Given\t an\t array\t of positive\tintegers,\tall\tnumbers\toccur\tan\teven\tnumber\tof\ttimes\texcept\tone\tnumber\twhich occurs\tan\todd\tnumber\tof\ttimes.\tFind\tthe\tnumber\tin\tO(n)\ttime\t&\tconstant\tspace.\tExample\t: I/P\t=\t[1,2,3,2,3,1,3]\tO/P\t=\t3 Solution:\tDo\ta\tbitwise\tXOR\tof\tall\tthe\telements.\tWe\tget\tthe\tnumber\twhich\thas\todd\toccurrences. This\tis\tbecause,\tA\tXOR\tA\t=\t0. Time\tComplexity:\tO(n).\tSpace\tComplexity:\tO(1). Problem-19\u2003\u2003Find\tthe\ttwo\trepeating\telements\tin\ta\tgiven\tarray:\tGiven\tan\tarray\twith\tsize, all\telements\tof\tthe\tarray\tare\tin\trange\t1\tto\tn\tand\talso\tall\telements\toccur\tonly\tonce\texcept two\tnumbers\twhich\toccur\ttwice.\tFind\tthose\ttwo\trepeating\tnumbers.\tFor\texample:\tif\tthe array\tis\t4,2,4,5,2,3,1\twith\tsize\t=\t7\tand\tn\t=\t5.\tThis\tinput\thas\tn\t+\t2\t=\t7\telements\twith\tall elements\toccurring\tonce\texcept\t2\tand\t4\twhich\toccur\ttwice.\tSo\tthe\toutput\tshould\tbe\t4\t2. Solution:\tOne\tsimple\tway\tis\tto\tscan\tthe\tcomplete\tarray\tfor\teach\telement\tof\tthe\tinput\telements. That\tmeans\tuse\ttwo\tloops.\tIn\tthe\touter\tloop,\tselect\telements\tone\tby\tone\tand\tcount\tthe\tnumber\tof occurrences\t of\t the\t selected\t element\t in\t the\t inner\t loop.\t For\t the\t code\t below,\t assume\t that PrintRepeatedElements\tis\tcalled\twith\tn\t+\t2\tto\tindicate\tthe\tsize. Time\tComplexity:\tO(n2).\tSpace\tComplexity:\tO(1). Problem-20\u2003\u2003For\tProblem-19,\tcan\twe\timprove\tthe\ttime\tcomplexity? Solution:\tSort\tthe\tarray\tusing\tany\tcomparison\tsorting\talgorithm\tand\tsee\tif\tthere\tare\tany\telements which\tare\tcontiguous\twith\tthe\tsame\tvalue. Time\tComplexity:\tO(nlogn).\tSpace\tComplexity:\tO(1). Problem-21\u2003\u2003For\tProblem-19,\tcan\twe\timprove\tthe\ttime\tcomplexity? Solution:\tUse\tCount\tArray.\tThis\tsolution\tis\tlike\tusing\ta\thash\ttable.\tFor\tsimplicity\twe\tcan\tuse array\tfor\tstoring\tthe\tcounts.\tTraverse\tthe\tarray\tonce\tand\tkeep\ttrack\tof\tthe\tcount\tof\tall\telements\tin the\tarray\tusing\ta\ttemp\tarray\tcount[]\tof\tsize\tn.\tWhen\twe\tsee\tan\telement\twhose\tcount\tis\talready set,\tprint\tit\tas\tduplicate.\tFor\tthe\tcode\tbelow\tassume\tthat\tPrintRepeatedElements\tis\tcalled\twith\tn +\t2\tto\tindicate\tthe\tsize. Time\tComplexity:\tO(n).\tSpace\tComplexity:\tO(n). Problem-22\u2003\u2003Consider\tProblem-19.\tLet\tus\tassume\tthat\tthe\tnumbers\tare\tin\tthe\trange\t1\tto\tn.\tIs there\tany\tother\tway\tof\tsolving\tthe\tproblem? Solution:\tYes,\tby\tusing\tXOR\tOperation.\tLet\tthe\trepeating\tnumbers\tbe\tX\tand\tY,\tif\twe\tXOR\tall the\telements\tin\tthe\tarray\tand\talso\tall\tintegers\tfrom\t1\tto\tn,\tthen\tthe\tresult\twill\tbe\tX\tXOR\tY.\tThe\t1\u2019s in\tbinary\trepresentation\tof\tX\tXOR\tY\tcorrespond\tto\tthe\tdifferent\tbits\tbetween\tX\tand\tY.\tIf\tthe\tkth\tbit of\tX\tXOR\tY\tis\t1,\twe\tcan\tXOR\tall\tthe\telements\tin\tthe\tarray\tand\talso\tall\tintegers\tfrom\t1\tto\tn\twhose kth\tbits\tare\t1.\tThe\tresult\twill\tbe\tone\tof\tX\tand\tY. Time\tComplexity:\tO(n).\tSpace\tComplexity:\tO(1). Problem-23\u2003\u2003Consider\tProblem-19.\tLet\tus\tassume\tthat\tthe\tnumbers\tare\tin\tthe\trange\t1\tto\tn.\tIs there\tyet\tother\tway\tof\tsolving\tthe\tproblem? Solution:\tWe\tcan\tsolve\tthis\tby\tcreating\ttwo\tsimple\tmathematical\tequations.\tLet\tus\tassume\tthat two\tnumbers\twe\tare\tgoing\tto\tfind\tare\tX\tand\tY.\tWe\tknow\tthe\tsum\tof\tn\tnumbers\tis\tn(n\t+\tl)/2\tand the\tproduct\tis\tn!.\tMake\ttwo\tequations\tusing\tthese\tsum\tand\tproduct\tformulae,\tand\tget\tvalues\tof two\t unknowns\t using\t the\t two\t equations.\t Let\t the\t summation\t of\t all\t numbers\t in\t array\t be\t S\t and product\tbe\tP\tand\tthe\tnumbers\twhich\tare\tbeing\trepeated\tare\tX\tand\tY. Using\t the\t above\t two\t equations,\t we\t can\t find\t out\t X\t and\t Y.\t There\t can\t be\t an\t addition\t and multiplication\toverflow\tproblem\twith\tthis\tapproach. Time\tComplexity:\tO(n).\tSpace\tComplexity:\tO(1). Problem-24\u2003\u2003Similar\tto\tProblem-19,\tlet\tus\tassume\tthat\tthe\tnumbers\tare\tin\tthe\trange\t1\tto\tn. Also,\tn\t\u2013\t1\telements\tare\trepeating\tthrice\tand\tremaining\telement\trepeated\ttwice.\tFind\tthe element\twhich\trepeated\ttwice. Solution:\t If\t we\t XOR\t all\t the\t elements\t in\t the\t array\t and\t all\t integers\t from\t 1\t to\t n,\t then\t all\t the elements\t which\t are\t repeated\t thrice\t will\t become\t zero.\t This\t is\t because,\t since\t the\t element\t is repeating\tthrice\tand\tXOR\tanother\ttime\tfrom\trange\tmakes\tthat\telement\tappear\tfour\ttimes.\tAs\ta result,\tthe\toutput\tof\ta\tXOR\ta\tXOR\ta\tXOR\ta\t=\t0.\tIt\tis\tthe\tsame\tcase\twith\tall\telements\tthat\tare repeated\tthree\ttimes. With\tthe\tsame\tlogic,\tfor\tthe\telement\twhich\trepeated\ttwice,\tif\twe\tXOR\tthe\tinput\telements\tand\talso the\trange,\tthen\tthe\ttotal\tnumber\tof\tappearances\tfor\tthat\telement\tis\t3.\tAs\ta\tresult,\tthe\toutput\tof\ta XOR\ta\tXOR\ta\t=\ta.\tFinally,\twe\tget\tthe\telement\twhich\trepeated\ttwice. Time\tComplexity:\tO(n).\tSpace\tComplexity:\tO(1). Problem-25\u2003\u2003Given\tan\tarray\tof\tn\telements.\tFind\ttwo\telements\tin\tthe\tarray\tsuch\tthat\ttheir\tsum is\tequal\tto\tgiven\telement\tK. Brute\tForce\tSolution:\tOne\tsimple\tsolution\tto\tthis\tis,\tfor\teach\tinput\telement,\tcheck\twhether\tthere is\tany\telement\twhose\tsum\tis\tK.\tThis\twe\tcan\tsolve\tjust\tby\tusing\ttwo\tsimple\tfor\tloops.\tThe\tcode for\tthis\tsolution\tcan\tbe\tgiven\tas: Time\tComplexity:\tO(n2).\tThis\tis\tbecause\tof\ttwo\tnested\tfor\tloops.\tSpace\tComplexity:\tO(1). Problem-26\u2003\u2003For\tProblem-25,\tcan\twe\timprove\tthe\ttime\tcomplexity? Solution:\tYes.\tLet\tus\tassume\tthat\twe\thave\tsorted\tthe\tgiven\tarray.\tThis\toperation\ttakes\tO(nlogn). On\tthe\tsorted\tarray,\tmaintain\tindices\tloIndex\t=\t0\tand\thiIndex\t=\tn\t\u2013\t1\tand\tcompute\tA[loIndex]\t+ A[hiIndex].\tIf\tthe\tsum\tequals\tK,\tthen\twe\tare\tdone\twith\tthe\tsolution.\tIf\tthe\tsum\tis\tless\tthan\tK, decrement\thiIndex,\tif\tthe\tsum\tis\tgreater\tthan\tK,\tincrement\tloIndex. Time\tComplexity:\tO(nlogn).\tIf\tthe\tgiven\tarray\tis\talready\tsorted\tthen\tthe\tcomplexity\tis\tO(n). Space\tComplexity:\tO(1). Problem-27\u2003\u2003Does\tthe\tsolution\tof\tProblem-25\twork\teven\tif\tthe\tarray\tis\tnot\tsorted? Solution:\tYes.\tSince\twe\tare\tchecking\tall\tpossibilities,\tthe\talgorithm\tensures\tthat\twe\tget\tthe\tpair of\tnumbers\tif\tthey\texist. Problem-28\u2003\u2003Is\tthere\tany\tother\tway\tof\tsolving\tProblem-25? Solution:\tYes,\tusing\thash\ttable.\tSince\tour\tobjective\tis\tto\tfind\ttwo\tindexes\tof\tthe\tarray\twhose\tsum is\tK.\tLet\tus\tsay\tthose\tindexes\tare\tX\tand\tY.\tThat\tmeans,\tA[X]\t+\tA[Y]\t=\tK.\tWhat\twe\tneed\tis,\tfor each\telement\tof\tthe\tinput\tarray\tA[X],\tcheck\twhether\tK\t\u2013\tA[X]\talso\texists\tin\tthe\tinput\tarray.\tNow, let\tus\tsimplify\tthat\tsearching\twith\thash\ttable. Algorithm: \u2022 For\teach\telement\tof\tthe\tinput\tarray,\tinsert\tit\tinto\tthe\thash\ttable.\tLet\tus\tsay\tthe\tcurrent element\tis\tA[X]. \u2022 Before\tproceeding\tto\tthe\tnext\telement\twe\tcheck\twhether\tK\t\u2013\tA[X]\talso\texists\tin\tthe hash\ttable\tor\tnot. \u2022 Ther\texistence\tof\tsuch\tnumber\tindicates\tthat\twe\tare\table\tto\tfind\tthe\tindexes. \u2022 Otherwise\tproceed\tto\tthe\tnext\tinput\telement. Time\tComplexity:\tO(n).\tSpace\tComplexity:\tO(n). Problem-29\u2003\u2003Given\tan\tarray\tA\tof\tn\telements.\tFind\tthree\tindices,\ti,j\t&\tk\tsuch\tthat\tA[i]2\t+\tA[j]2 =\tA[k]2? Solution: Algorithm: \u2022 Sort\tthe\tgiven\tarray\tin-place. \u2022 For\teach\tarray\tindex\ti\tcompute\tA[i]2\tand\tstore\tin\tarray. \u2022 Search\tfor\t2\tnumbers\tin\tarray\tfrom\t0\tto\ti\t\u2013\t1\twhich\tadds\tto\tA[i]\tsimilar\tto\tProblem-"
            }
        ]
    },
    {
        "chapter_title": "25.\tThis\twill\tgive\tus\tthe\tresult\tin\tO(n)\ttime.\tIf\twe\tfind\tsuch\ta\tsum,\treturn\ttrue,",
        "subchapters": [
            {
                "subchapter_title": "otherwise\tcontinue.",
                "content": "Time\tComplexity:\tTime\tfor\tsorting\t+\tn\t\u00d7\t(Time\tfor\tfinding\tthe\tsum)\t=\tO(nlogn)\t+\tn\t\u00d7\tO(n)=\tn2. Space\tComplexity:\tO(1). Problem-30\u2003\u2003Two\telements\twhose\tsum\tis\tclosest\tto\tzero.\tGiven\tan\tarray\twith\tboth\tpositive and\tnegative\tnumbers,\tfind\tthe\ttwo\telements\tsuch\tthat\ttheir\tsum\tis\tclosest\tto\tzero.\tFor\tthe below\tarray,\talgorithm\tshould\tgive\t-80\tand\t85.\tExample:\t1\t60\t\u2013\t10\t70\t\u2013\t80\t85 Brute\tForce\tSolution:\tFor\teach\telement,\tfind\tthe\tsum\twith\tevery\tother\telement\tin\tthe\tarray\tand compare\tsums.\tFinally,\treturn\tthe\tminimum\tsum. Time\tcomplexity:\tO(n2).\tSpace\tComplexity:\tO(1). Problem-31\u2003\u2003Can\twe\timprove\tthe\ttime\tcomplexity\tof\tProblem-30? Solution:\tUse\tSorting. Algorithm:"
            }
        ]
    },
    {
        "chapter_title": "1.",
        "subchapters": [
            {
                "subchapter_title": "Sort\tall\tthe\telements\tof\tthe\tgiven\tinput\tarray.",
                "content": ""
            }
        ]
    },
    {
        "chapter_title": "2.",
        "subchapters": [
            {
                "subchapter_title": "Maintain\ttwo\tindexes,\tone\tat\tthe\tbeginning\t(i\t=\t0)\tand\tthe\tother\tat\tthe\tending\t(j\t=\tn\t\u2013",
                "content": "1).\tAlso,\tmaintain\ttwo\tvariables\tto\tkeep\ttrack\tof\tthe\tsmallest\tpositive\tsum\tclosest to\tzero\tand\tthe\tsmallest\tnegative\tsum\tclosest\tto\tzero."
            }
        ]
    },
    {
        "chapter_title": "3.",
        "subchapters": [
            {
                "subchapter_title": "While\ti\t<\tj:",
                "content": "a. If\tthe\tcurrent\tpair\tsum\tis\t>\tzero\tand\t<\tpostiveClosest\tthen\tupdate\tthe postiveClosest.\tDecrement\tj. b. If\tthe\tcurrent\tpair\tsum\tis\t<\tzero\tand\t>\tnegativeClosest\tthen\tupdate\tthe negativeClosest.\tIncrement\ti. c. Else,\tprint\tthe\tpair Time\tComplexity:\tO(nlogn),\tfor\tsorting.\tSpace\tComplexity:\tO(1). Problem-32\u2003\u2003Given\tan\tarray\tof\tn\telements.\tFind\tthree\telements\tin\tthe\tarray\tsuch\tthat\ttheir\tsum is\tequal\tto\tgiven\telement\tK? Brute\t Force\t Solution:\t The\t default\t solution\t to\t this\t is,\t for\t each\t pair\t of\t input\t elements\t check whether\tthere\tis\tany\telement\twhose\tsum\tis\tK.\tThis\twe\tcan\tsolve\tjust\tby\tusing\tthree\tsimple\tfor loops.\tThe\tcode\tfor\tthis\tsolution\tcan\tbe\tgiven\tas: Time\tComplexity:\tO(n3),\tfor\tthree\tnested\tfor\tloops.\tSpace\tComplexity:\tO(1). Problem-33\u2003\u2003Does\tthe\tsolution\tof\tProblem-32\twork\teven\tif\tthe\tarray\tis\tnot\tsorted? Solution:\tYes.\tSince\twe\tare\tchecking\tall\tpossibilities,\tthe\talgorithm\tensures\tthat\twe\tcan\tfind three\tnumbers\twhose\tsum\tis\tK\tif\tthey\texist. Problem-34\u2003\u2003Can\twe\tuse\tsorting\ttechnique\tfor\tsolving\tProblem-32? Solution:\tYes. Time\t Complexity:\t Time\t for\t sorting\t +\t Time\t for\t searching\t in\t sorted\t list\t =\t O(nlogn)\t +\tO(n2)\t \u2248 O(n2).\tThis\tis\tbecause\tof\ttwo\tnested\tfor\tloops.\tSpace\tComplexity:\tO(1). Problem-35\u2003\u2003Can\twe\tuse\thashing\ttechnique\tfor\tsolving\tProblem-32? Solution:\tYes.\tSince\tour\tobjective\tis\tto\tfind\tthree\tindexes\tof\tthe\tarray\twhose\tsum\tis\tK.\tLet\tus\tsay those\tindexes\tare\tX,Y\tand\tZ.\tThat\tmeans,\tA[X]\t+\tA[Y]\t+\tA[Z]\t=\tK. Let\tus\tassume\tthat\twe\thave\tkept\tall\tpossible\tsums\talong\twith\ttheir\tpairs\tin\thash\ttable.\tThat\tmeans the\tkey\tto\thash\ttable\tis\tK\t\u2013\tA[X]\tand\tvalues\tfor\tK\t\u2013\tA[X]\tare\tall\tpossible\tpairs\tof\tinput\twhose sum\tis\tif\t\u2013\tA[X]. Algorithm: \u2022 Before\tstarting\tthe\tsearch,\tinsert\tall\tpossible\tsums\twith\tpairs\tof\telements\tinto\tthe hash\ttable. \u2022 For\teach\telement\tof\tthe\tinput\tarray,\tinsert\tinto\tthe\thash\ttable.\tLet\tus\tsay\tthe\tcurrent element\tis\tA[X]. \u2022 Check\twhether\tthere\texists\ta\thash\tentry\tin\tthe\ttable\twith\tkey:\tK\t\u2013\tA[X]. \u2022 If\tsuch\telement\texists\tthen\tscan\tthe\telement\tpairs\tof\tK\t\u2013\tA[X]\tand\treturn\tall\tpossible pairs\tby\tincluding\tA[X]\talso. \u2022 If\tno\tsuch\telement\texists\t(with\tK\t\u2013\tA[X]\tas\tkey)\tthen\tgo\tto\tnext\telement. Time\tComplexity:\tThe\ttime\tfor\tstoring\tall\tpossible\tpairs\tin\tHash\ttable\t+\tsearching\t=\tO(n2)\t + O(n2)\t\u2248\tO(n2).\tSpace\tComplexity:\tO(n). Problem-36\u2003\u2003Given\tan\tarray\tof\tn\tintegers,\tthe\t3\t\u2013\tsum\tproblem\tis\tto\tfind\tthree\tintegers\twhose sum\tis\tclosest\tto\tzero. Solution:\tThis\tis\tthe\tsame\tas\tthat\tof\tProblem-32\twith\tK\tvalue\tis\tzero. Problem-37\u2003\u2003Let\tA\tbe\tan\tarray\tof\tn\tdistinct\tintegers.\tSuppose\tA\thas\tthe\tfollowing\tproperty: there\texists\tan\tindex\t1\t\u2264\tk\t\u2264\tn\tsuch\tthat\tA[l],...,\tA[k]\tis\tan\tincreasing\tsequence\tand\tA[k\t+ 1],...,\tA[n]\tis\ta\tdecreasing\tsequence.\tDesign\tand\tanalyze\tan\tefficient\talgorithm\tfor\tfinding k. Similar\tquestion:\t Let\t us\t assume\t that\t the\t given\t array\t is\t sorted\t but\t starts\t with\t negative numbers\t and\t ends\t with\t positive\t numbers\t [such\t functions\t are\t called\t monotonically increasing\tfunctions].\tIn\tthis\tarray\tfind\tthe\tstarting\tindex\tof\tthe\tpositive\tnumbers.\tAssume that\twe\tknow\tthe\tlength\tof\tthe\tinput\tarray.\tDesign\ta\tO(logn)\talgorithm. Solution:\tLet\tus\tuse\ta\tvariant\tof\tthe\tbinary\tsearch. The\trecursion\tequation\tis\tT(n)\t=\t2T(n/2)\t+\tc.\tUsing\tmaster\ttheorem,\twe\tget\tO(logn). Problem-38\u2003\u2003If\twe\tdon\u2019t\tknow\tn,\thow\tdo\twe\tsolve\tthe\tProblem-37? Solution:\tRepeatedly\tcompute\tA[1],A[2],A[4],A[8],A[16]\tand\tso\ton,\tuntil\twe\tfind\ta\tvalue\tof\tn such\tthat\tA[n]\t>\t0. Time\t Complexity:\t O(logn),\t since\t we\t are\t moving\t at\t the\t rate\t of\t 2.\t Refer\t to\t Introduction\t to Analysis\tof\tAlgorithms\tchapter\tfor\tdetails\ton\tthis. Problem-39\u2003\u2003Given\tan\tinput\tarray\tof\tsize\tunknown\twith\tall\t1\u2019s\tin\tthe\tbeginning\tand\t0\u2019s\tin\tthe end.\tFind\tthe\tindex\tin\tthe\tarray\tfrom\twhere\t0\u2019s\tstart.\tConsider\tthere\tare\tmillions\tof\t1\u2019s\tand 0\u2019s\tin\tthe\tarray.\tE.g.\tarray\tcontents\t1111111\u2026\u2026..1100000\u2026\u2026..0000000. Solution:\tThis\tproblem\tis\talmost\tsimilar\tto\tProblem-38.\tCheck\tthe\tbits\tat\tthe\trate\tof\t2Kwhere\tk =\t0,1,2\t....\tSince\twe\tare\tmoving\tat\tthe\trate\tof\t2,\tthe\tcomplexity\tis\tO(logn). Problem-40\u2003\u2003Given\ta\tsorted\tarray\tof\tn\tintegers\tthat\thas\tbeen\trotated\tan\tunknown\tnumber\tof times,\tgive\ta\tO(logn)\talgorithm\tthat\tfinds\tan\telement\tin\tthe\tarray. Example:\tFind\t5\tin\tarray\t(15\t16\t19\t20\t25\t1\t3\t4\t5\t7\t10\t14)\tOutput:\t8\t(the\tindex\tof\t5\tin the\tarray) Solution:\tLet\tus\tassume\tthat\tthe\tgiven\tarray\tis\tA[]and\tuse\tthe\tsolution\tof\tProblem-37\t with\t an extension.\t The\t function\t below\t FindPivot\t returns\t the\t k\t value\t (let\t us\t assume\t that\t this\t function returns\tthe\tindex\tinstead\tof\tthe\tvalue).\tFind\tthe\tpivot\tpoint,\tdivide\tthe\tarray\tinto\ttwo\tsub-arrays and\tcall\tbinary\tsearch. The\tmain\tidea\tfor\tfinding\tthe\tpivot\tpoint\tis\t\u2013\tfor\ta\tsorted\t(in\tincreasing\torder)\tand\tpivoted\tarray, the\tpivot\telement\tis\tthe\tonly\telement\tfor\twhich\tthe\tnext\telement\tto\tit\tis\tsmaller\tthan\tit.\tUsing\tthe above\tcriteria\tand\tthe\tbinary\tsearch\tmethodology\twe\tcan\tget\tpivot\telement\tin\tO(logn)\ttime. Algorithm: 1) Find\tout\tthe\tpivot\tpoint\tand\tdivide\tthe\tarray\tinto\ttwo\tsub-arrays. 2) Now\tcall\tbinary\tsearch\tfor\tone\tof\tthe\ttwo\tsub-arrays. a. if\t the\t element\t is\t greater\t than\t the\t first\t element\t then\t search\t in\t left subarray. b. else\tsearch\tin\tright\tsubarray. 3) If\telement\tis\tfound\tin\tselected\tsub-array,\tthen\treturn\tindex\telse\treturn\t\u20131. Time\tcomplexity:\tO(logn). Problem-41\u2003\u2003For\tProblem-40,\tcan\twe\tsolve\twith\trecursion? Solution:\tYes. Time\tcomplexity:\tO(logn). Problem-42\u2003\u2003Bitonic\tsearch:\tAn\tarray\tis\tbitonic\tif\tit\tis\tcomprised\tof\tan\tincreasing\tsequence of\tintegers\tfollowed\timmediately\tby\ta\tdecreasing\tsequence\tof\tintegers.\tGiven\ta\tbitonic array\tA\tof\tn\tdistinct\tintegers,\tdescribe\thow\tto\tdetermine\twhether\ta\tgiven\tinteger\tis\tin\tthe array\tin\tO(logn)\tsteps. Solution:\tThe\tsolution\tis\tthe\tsame\tas\tthat\tfor\tProblem-37. Problem-43\u2003\u2003Yet,\tother\tway\tof\tframing\tProblem-37. Let\t A[]\t be\t an\t array\t that\t starts\t out\t increasing,\t reaches\t a\t maximum,\t and\t then\t decreases. Design\tan\tO(logn)\talgorithm\tto\tfind\tthe\tindex\tof\tthe\tmaximum\tvalue. Problem-44\u2003\u2003Give\t an\t O(nlogn)\t algorithm\t for\t computing\t the\t median\t of\t a\t sequence\t of\t n integers. Solution:\tSort\tand\treturn\telement\tat\t . Problem-45\u2003\u2003Given\ttwo\tsorted\tlists\tof\tsize\tm\tand\tn,\tfind\tmedian\tof\tall\telements\tin\tO(log\t(m +\tn))\ttime. Solution:\tRefer\tto\tDivide\tand\tConquer\tchapter. Problem-46\u2003\u2003Given\ta\tsorted\tarray\tA\tof\tn\telements,\tpossibly\twith\tduplicates,\tfind\tthe\tindex\tof the\tfirst\toccurrence\tof\ta\tnumber\tin\tO(logn)\ttime. Solution:\tTo\tfind\tthe\tfirst\toccurrence\tof\ta\tnumber\twe\tneed\tto\tcheck\tfor\tthe\tfollowing\tcondition. Return\tthe\tposition\tif\tany\tone\tof\tthe\tfollowing\tis\ttrue: Time\tComplexity:\tO(logn). Problem-47\u2003\u2003Given\ta\tsorted\tarray\tA\tof\tn\telements,\tpossibly\twith\tduplicates.\tFind\tthe\tindex\tof the\tlast\toccurrence\tof\ta\tnumber\tin\tO(logn)\ttime. Solution:\tTo\tfind\tthe\tlast\toccurrence\tof\ta\tnumber\twe\tneed\tto\tcheck\tfor\tthe\tfollowing\tcondition. Return\tthe\tposition\tif\tany\tone\tof\tthe\tfollowing\tis\ttrue: Time\tComplexity:\tO(logn). Problem-48\u2003\u2003Given\ta\tsorted\tarray\tof\tn\telements,\tpossibly\twith\tduplicates.\tFind\tthe\tnumber\tof occurrences\tof\ta\tnumber. Brute\tForce\tSolution:\tDo\ta\tlinear\tsearch\tof\tthe\tarray\tand\tincrement\tcount\tas\tand\twhen\twe\tfind the\telement\tdata\tin\tthe\tarray. Time\tComplexity:\tO(n). Problem-49\u2003\u2003Can\twe\timprove\tthe\ttime\tcomplexity\tof\tProblem-48? Solution:\tYes.\tWe\tcan\tsolve\tthis\tby\tusing\tone\tbinary\tsearch\tcall\tfollowed\tby\tanother\tsmall\tscan. Algorithm: \u2022 Do\ta\tbinary\tsearch\tfor\tthe\tdata\tin\tthe\tarray.\tLet\tus\tassume\tits\tposition\tis\tK. \u2022 Now\ttraverse\ttowards\tthe\tleft\tfrom\tK\tand\tcount\tthe\tnumber\tof\toccurrences\tof\tdata. Let\tthis\tcount\tbe\tleftCount. \u2022 Similarly,\ttraverse\ttowards\tright\tand\tcount\tthe\tnumber\tof\toccurrences\tof\tdata.\tLet this\tcount\tbe\trightCount. \u2022 Total\tnumber\tof\toccurrences\t=\tleftCount\t+\t1\t+\trightCount Time\tComplexity\t\u2013\tO(logn\t+\tS)\twhere\t5\tis\tthe\tnumber\tof\toccurrences\tof\tdata. Problem-50\u2003\u2003Is\tthere\tany\talternative\tway\tof\tsolving\tProblem-48? Solution: Algorithm: \u2022 Find\tfirst\toccurrence\tof\tdata\tand\tcall\tits\tindex\tas\tfirstOccurrence\t (for\t algorithm refer\tto\tProblem-46) \u2022 Find\t last\t occurrence\t of\t data\t and\t call\t its\t index\t as\t lastOccurrence\t (for\t algorithm refer\tto\tProblem-47) \u2022 Return\tlastOccurrence\t\u2013\tfirstOccurrence\t+\t1 Time\tComplexity\t=\tO(logn\t+\tlogn)\t=\tO(logn). Problem-51\u2003\u2003What\tis\tthe\tnext\tnumber\tin\tthe\tsequence\t1,11,21\tand\twhy? Solution:\tRead\tthe\tgiven\tnumber\tloudly.\tThis\tis\tjust\ta\tfun\tproblem. So\t the\t answer\t is:\t the\t next\t number\t is\t the\t representation\t of\t the\t previous\t number\t by\t reading\t it loudly. Problem-52\u2003\u2003Finding\tsecond\tsmallest\tnumber\tefficiently. Solution:\tWe\tcan\tconstruct\ta\theap\tof\tthe\tgiven\telements\tusing\tup\tjust\tless\tthan\tn\t comparisons (Refer\tto\tthe\tPriority\tQueues\tchapter\tfor\tthe\talgorithm).\tThen\twe\tfind\tthe\tsecond\tsmallest\tusing logn\tcomparisons\tfor\tthe\tGetMax()\toperation.\tOverall,\twe\tget\tn\t+\tlogn\t+\tconstant. Problem-53\u2003\u2003Is\tthere\tany\tother\tsolution\tfor\tProblem-52? Solution:\t Alternatively,\t split\t the\t n\t numbers\t into\t groups\t of\t 2,\t perform\t n/2\t comparisons successively\tto\tfind\tthe\tlargest,\tusing\ta\ttournament-like\tmethod.\tThe\tfirst\tround\twill\tyield\tthe maximum\tin\tn\t\u2013\t1\tcomparisons.\tThe\tsecond\tround\twill\tbe\tperformed\ton\tthe\twinners\tof\tthe\tfirst round\tand\tthe\tones\tthat\tthe\tmaximum\tpopped.\tThis\twill\tyield\tlogn\t\u2013\t1\tcomparison\tfor\ta\ttotal\tof\tn +\tlogn\t\u2013\t2.\tThe\tabove\tsolution\tis\tcalled\tthe\ttournament\tproblem. Problem-54\u2003\u2003An\telement\tis\ta\tmajority\tif\tit\tappears\tmore\tthan\tn/2\ttimes.\tGive\tan\talgorithm takes\tan\tarray\tof\tn\telement\tas\targument\tand\tidentifies\ta\tmajority\t(if\tit\texists). Solution:\tThe\tbasic\tsolution\tis\tto\thave\ttwo\tloops\tand\tkeep\ttrack\tof\tthe\tmaximum\tcount\tfor\tall different\telements.\tIf\tthe\tmaximum\tcount\tbecomes\tgreater\tthan\tn/2,\tthen\tbreak\tthe\tloops\tand\treturn the\telement\thaving\tmaximum\tcount.\tIf\tmaximum\tcount\tdoesn\u2019t\tbecome\tmore\tthan\tn/2,\t then\t the majority\telement\tdoesn\u2019t\texist. Time\tComplexity:\tO(n2).\tSpace\tComplexity:\tO(1). Problem-55\u2003\u2003Can\twe\timprove\tProblem-54\ttime\tcomplexity\tto\tO(nlogn)? Solution:\tUsing\tbinary\tsearch\twe\tcan\tachieve\tthis.\tNode\tof\tthe\tBinary\tSearch\tTree\t(used\tin\tthis approach)\twill\tbe\tas\tfollows. Insert\telements\tin\tBST\tone\tby\tone\tand\tif\tan\telement\tis\talready\tpresent\tthen\tincrement\tthe\tcount\tof the\tnode.\tAt\tany\tstage,\tif\tthe\tcount\tof\ta\tnode\tbecomes\tmore\tthan\tn/2,\tthen\treturn.\tThis\tmethod works\twell\tfor\tthe\tcases\twhere\tn/2\t+1\toccurrences\tof\tthe\tmajority\telement\tare\tpresent\tat\tthe\tstart of\tthe\tarray,\tfor\texample\t{1,1,1,1,1,2,3,\tand\t4}. Time\tComplexity:\tIf\ta\tbinary\tsearch\ttree\tis\tused\tthen\tworst\ttime\tcomplexity\twill\tbe\tO(n2).\tIf\ta balanced-binary-search\ttree\tis\tused\tthen\tO(nlogn).\tSpace\tComplexity:\tO(n). Problem-56\u2003\u2003Is\tthere\tany\tother\tof\tachieving\tO(nlogn)\tcomplexity\tfor\tProblem-54? Solution:\tSort\tthe\tinput\tarray\tand\tscan\tthe\tsorted\tarray\tto\tfind\tthe\tmajority\telement. Time\tComplexity:\tO(nlogn).\tSpace\tComplexity:\tO(1). Problem-57\u2003\u2003Can\twe\timprove\tthe\tcomplexity\tfor\tProblem-54? Solution:\tIf\tan\telement\toccurs\tmore\tthan\tn/2\ttimes\tin\tA\tthen\tit\tmust\tbe\tthe\tmedian\tof\tA.\tBut,\tthe reverse\tis\tnot\ttrue,\tso\tonce\tthe\tmedian\tis\tfound,\twe\tmust\tcheck\tto\tsee\thow\tmany\ttimes\tit\toccurs\tin A.\t We\t can\t use\t linear\t selection\t which\t takes\t O(n)\t time\t (for\t algorithm,\t refer\t to\t Selection Algorithms\tchapter). int\tCheckMajority(int\tA[],\tin\tn)\t{ 1) Use\tlinear\tselection\tto\tfind\tthe\tmedian\tm\tof\tA. 2) Do\tone\tmore\tpass\tthrough\tA\tand\tcount\tthe\tnumber\tof\toccurrences\tof\tm. a. If\tm\toccurs\tmore\tthan\tn/2\ttimes\tthen\treturn\ttrue; b. Otherwise\treturn\tfalse. } Problem-58\u2003\u2003Is\tthere\tany\tother\tway\tof\tsolving\tProblem-54? Solution:\tSince\tonly\tone\telement\tis\trepeating,\twe\tcan\tuse\ta\tsimple\tscan\tof\tthe\tinput\tarray\tby keeping\ttrack\tof\tthe\tcount\tfor\tthe\telements.\tIf\tthe\tcount\tis\t0,\tthen\twe\tcan\tassume\tthat\tthe\telement visited\tfor\tthe\tfirst\ttime\totherwise\tthat\tthe\tresultant\telement. Time\tComplexity:\tO(n).\tSpace\tComplexity:\tO(1). Problem-59\u2003\u2003Given\t an\t array\t of\t 2n\t elements\t of\t which\t n\t elements\t are\t the\t same\t and\t the remaining\tn\telements\tare\tall\tdifferent.\tFind\tthe\tmajority\telement. Solution:\tThe\trepeated\telements\twill\toccupy\thalf\tthe\tarray.\tNo\tmatter\twhat\tarrangement\tit\tis, only\tone\tof\tthe\tbelow\twill\tbe\ttrue: \u2022 All\tduplicate\telements\twill\tbe\tat\ta\trelative\tdistance\tof\t2\tfrom\teach\tother.\tEx:n,\t1,\tn, 100,\tn,\t54,\tn... \u2022 At\tleast\ttwo\tduplicate\telements\twill\tbe\tnext\tto\teach\tother. Ex:\tn,n,\t1,100,\tn,\t54,\tn,.... n,\t1,n,n,n,54,100... 1,100,54,\tn.n.n.n.... In\tworst\tcase,\twe\twill\tneed\ttwo\tpasses\tover\tthe\tarray: \u2022 First\tPass:\tcompare\tA[i]\tand\tA[i\t+\t1] \u2022 Second\tPass:\tcompare\tA[i]\tand\tA[i\t+\t2] Something\twill\tmatch\tand\tthat\u2019s\tyour\telement.\tThis\twill\tcost\tO(n)\tin\ttime\tand\tO(1)\tin\tspace. Problem-60\u2003\u2003Given\t an\t array\t with\t 2n\t +\t 1\t integer\t elements,\t n\t elements\t appear\t twice\t in arbitrary\t places\t in\t the\t array\t and\t a\t single\t integer\t appears\t only\t once\t somewhere\t inside. Find\tthe\tlonely\tinteger\twith\tO(n)\toperations\tand\tO(1)\textra\tmemory. Solution:\tExcept\tfor\tone\telement,\tall\telements\tare\trepeated.\tWe\tknow\tthat\tA\tXOR\tA\t=\t0.\tBased on\tthis\tif\twe\tXOR\tall\tthe\tinput\telements\tthen\twe\tget\tthe\tremaining\telement. Time\tComplexity:\tO(n).\tSpace\tComplexity:\tO(1). Problem-61\u2003\u2003Throwing\teggs\tfrom\tan\tn-story\tbuilding:\tSuppose\twe\thave\tan\tn\tstory\tbuilding and\ta\tnumber\tof\teggs.\tAlso\tassume\tthat\tan\tegg\tbreaks\tif\tit\tis\tthrown\tfrom\tfloor\tF\tor\thigher, and\t will\t not\t break\t otherwise.\t Devise\t a\t strategy\t to\t determine\t floor\t F,\t while\t breaking O(logn)\teggs. Solution:\tRefer\tto\tDivide\tand\tConquer\tchapter. Problem-62\u2003\u2003Local\tminimum\tof\tan\tarray:\tGiven\tan\tarray\tA\tof\tn\tdistinct\tintegers,\tdesign\tan O(logn)\talgorithm\tto\tfind\ta\tlocal\tminimum:\tan\tindex\ti\tsuch\tthat\tA[i\t\u2013\t1]\t<\tA[i]\t<\tA[i\t+\t1]. Solution:\tCheck\tthe\tmiddle\tvalue\tA[n/2],\tand\ttwo\tneighbors\tA[n/2\t\u2013\t1]\tand\tA[n/2\t+\t1].\tIf\tA[n/2] is\tlocal\tminimum,\tstop;\totherwise\tsearch\tin\thalf\twith\tsmaller\tneighbor. Problem-63\u2003\u2003Give\tan\tn\t\u00d7\tn\tarray\tof\telements\tsuch\tthat\teach\trow\tis\tin\tascending\torder\tand each\t column\t is\t in\t ascending\t order,\t devise\t an\t O(n)\t algorithm\t to\t determine\t if\t a\t given element\tx\tis\tin\tthe\tarray.\tYou\tmay\tassume\tall\telements\tin\tthe\tn\t\u00d7\tn\tarray\tare\tdistinct. Solution:\tLet\tus\tassume\tthat\tthe\tgiven\tmatrix\tis\tA[n][n].\tStart\twith\tthe\tlast\trow,\tfirst\tcolumn\t[or first\trow,\tlast\tcolumn].\tIf\tthe\telement\twe\tare\tsearching\tfor\tis\tgreater\tthan\tthe\telement\tat\tA[1][n], then\tthe\tfirst\tcolumn\tcan\tbe\teliminated.\tIf\tthe\tsearch\telement\tis\tless\tthan\tthe\telement\tat\tA[1][n], then\t the\t last\t row\t can\t be\t completely\t eliminated.\t Once\t the\t first\t column\t or\t the\t last\t row\t is eliminated,\t start\t the\t process\t again\t with\t the\t left-bottom\t end\t of\t the\t remaining\t array.\t In\t this algorithm,\tthere\twould\tbe\tmaximum\tn\telements\tthat\tthe\tsearch\telement\twould\tbe\tcompared\twith. Time\tComplexity:\tO(n).\tThis\tis\tbecause\twe\twill\ttraverse\tat\tmost\t2n\tpoints.\tSpace\tComplexity: O(1). Problem-64\u2003\u2003Given\tan\tn\t\u00d7\tn\tarray\ta\tof\tn2\tnumbers,\tgive\tan\tO(n)\talgorithm\tto\tfind\ta\tpair\tof indices\ti\tand\tj\tsuch\tthat\tA[i][j]\t<\tA[i\t+\t1][j].A[i][j]\t<\tA[i][j\t+\t1],A[i][j]\t<\tA[i\t\u2013\t1][j],\tand A[i][j]\t<\tA[i][j\t\u2013\t1]. Solution:\tThis\tproblem\tis\tthe\tsame\tas\tProblem-63. Problem-65\u2003\u2003Given\tn\t\u00d7\tn\tmatrix,\tand\tin\teach\trow\tall\t1\u2019s\tare\tfollowed\tby\t0\u2019s.\tFind\tthe\trow with\tthe\tmaximum\tnumber\tof\t0\u2019s. Solution:\tStart\twith\tfirst\trow,\tlast\tcolumn.\tIf\tthe\telement\tis\t0\tthen\tmove\tto\tthe\tprevious\tcolumn\tin the\tsame\trow\tand\tat\tthe\tsame\ttime\tincrease\tthe\tcounter\tto\tindicate\tthe\tmaximum\tnumber\tof\t0\u2019s.\tIf the\telement\tis\t1\tthen\tmove\tto\tthe\tnext\trow\tin\tthe\tthe\tsame\tcolumn.\tRepeat\tthis\tprocess\tuntil\tyour reach\tlast\trow,\tfirst\tcolumn. Time\tComplexity:\tO(2n)\t\u2248\tO(n)\t(similar\tto\tProblem-63). Problem-66\u2003\u2003Given\tan\tinput\tarray\tof\tsize\tunknown,\twith\tall\tnumbers\tin\tthe\tbeginning\tand special\tsymbols\tin\tthe\tend.\tFind\tthe\tindex\tin\tthe\tarray\tfrom\twhere\tthe\tspecial\tsymbols start. Solution:\tRefer\tto\tDivide\tand\tConquer\tchapter. Problem-67\u2003\u2003Separate\t even\t and\t odd\t numbers:\t Given\t an\t array\t A[],\t write\t a\t function\t that segregates\teven\tand\todd\tnumbers.\tThe\tfunctions\tshould\tput\tall\teven\tnumbers\tfirst,\tand\tthen odd\tnumbers.\tExample:\tInput\t=\t{12,34,45,9,8,90,3}\tOutput\t=\t{12,34,90,8,9,45,3} Note:\tIn\tthe\toutput,\tthe\torder\tof\tnumbers\tcan\tbe\tchanged,\ti.e.,\tin\tthe\tabove\texample\t34\tcan come\tbefore\t12,\tand\t3\tcan\tcome\tbefore\t9. Solution:\tThe\tproblem\tis\tvery\tsimilar\tto\tSeparate\t0\u2019s\tand\t1\u2019s\t(Problem-68)\tin\tan\tarray,\tand\tboth problems\tare\tvariations\tof\tthe\tfamous\tDutch\tnational\tflag\tproblem. Algorithm:\tThe\tlogic\tis\tsimilar\tto\tQuick\tsort. 1) Initialize\ttwo\tindex\tvariables\tleft\tand\tright:\tleft\t=\t0,\tright\t=\tn\t\u2013\t1 2) Keep\tincrementing\tthe\tleft\tindex\tuntil\tyou\tsee\tan\todd\tnumber. 3) Keep\tdecrementing\tthe\tright\tindex\tuntil\tyoue\tsee\tan\teven\tnumber. 4) If\tleft\t<\tright\tthen\tswap\tA[left]\tand\tA[right] Time\tComplexity:\tO(n). Problem-68\u2003\u2003The\t following\t is\t another\t way\t of\t structuring\t Problem-67,\t but\t with\t a\t slight difference. Separate\t0\u2019s\tand\t1\u2019s\tin\tan\tarray:\tWe\tare\tgiven\tan\tarray\tof\t0\u2019s\tand\t1\u2019s\tin\trandom\torder. Separate\t0\u2019s\ton\tthe\tleft\tside\tand\t1\u2019s\ton\tthe\tright\tside\tof\tthe\tarray.\tTraverse\tthe\tarray\tonly once. Input\tarray\t=\t[0,1,0,1,0,0,1,1,1,0]\tOutput\tarray\t=\t[0,0,0,0,0,1,1,1,1,1] Solution:\tCounting\t0\u2019s\tor\t1\u2019s"
            }
        ]
    },
    {
        "chapter_title": "1.",
        "subchapters": [
            {
                "subchapter_title": "Count\tthe\tnumber\tof\t0\u2019s.\tLet\tthe\tcount\tbe\tC.",
                "content": ""
            }
        ]
    },
    {
        "chapter_title": "2.",
        "subchapters": [
            {
                "subchapter_title": "Once\twe\thave\tthe\tcount,\tput\tC\t0\u2019s\tat\tthe\tbeginning\tand\t1\u2019s\tat\tthe\tremaining\tn-\t C",
                "content": "positions\tin\tthe\tarray. Time\tComplexity:\tO(n).\tThis\tsolution\tscans\tthe\tarray\ttwo\ttimes. Problem-69\u2003\u2003Can\twe\tsolve\tProblem-68\tin\tone\tscan? Solution:\tYes.\tUse\ttwo\tindexes\tto\ttraverse:\tMaintain\ttwo\tindexes.\tInitialize\tthe\tfirst\tindex\tleft\tas 0\tand\tthe\tsecond\tindex\tright\tas\tn\t\u2013\t1.\tDo\tthe\tfollowing\twhile\tleft\t<\tright: 1) Keep\tthe\tincrementing\tindex\tleft\twhile\tthere\tare\tOs\tin\tit 2) Keep\tthe\tdecrementing\tindex\tright\twhile\tthere\tare\tIs\tin\tit 3) If\tleft\t<\tright\tthen\texchange\tA[left]\tand\tA[right] Time\tComplexity:\tO(n).\tSpace\tComplexity:\tO(1). Problem-70\u2003\u2003Sort\tan\tarray\tof\t0\u2019s,\t1\u2019s\tand\t2\u2019s\t[or\tR\u2019s,\tG\u2019s\tand\tB\u2019s]:\tGiven\tan\tarray\tA[] consisting\tof\t0\u2019s,\t1\u2019s\tand\t2\u2019s,\tgive\tan\talgorithm\tfor\tsorting\tA[].The\talgorithm\tshould\tput\tall 0\u2019s\t first,\t then\t all\t 1\u2019s\t and\t finally\t all\t 2\u2019s\t at\t the\t end.\t Example\t Input\t = {0,1,1,0,1,2,1,2,0,0,0,1},\tOutput\t=\t{0,0,0,0,0,1,1,1,1,1,2,2} Solution: Time\tComplexity:\tO(n).\tSpace\tComplexity:\tO(1). Problem-71\u2003\u2003Maximum\tdifference\tbetween\ttwo\telements:\tGiven\tan\tarray\tA[]\tof\tintegers, find\tout\tthe\tdifference\tbetween\tany\ttwo\telements\tsuch\tthat\tthe\tlarger\telement\tappears\tafter the\tsmaller\tnumber\tin\tA[]. Examples:\tIf\tarray\tis\t[2,3,10,6,4,8,1]\tthen\treturned\tvalue\tshould\tbe\t8\t(Difference\tbetween 10\t and\t 2).\t If\t array\t is\t [\t 7,9,5,6,3,2\t ]\t then\t the\t returned\t value\t should\t be\t 2\t (Difference between\t7\tand\t9) Solution:\tRefer\tto\tDivide\tand\tConquer\tchapter. Problem-72\u2003\u2003Given\tan\tarray\tof\t101\telements.\tOut\tof\t101\telements,\t25\telements\tare\trepeated twice,\t12\telements\tare\trepeated\t4\ttimes,\tand\tone\telement\tis\trepeated\t3\ttimes.\tFind\tthe element\twhich\trepeated\t3\ttimes\tin\tO(1). Solution:\tBefore\tsolving\tthis\tproblem,\tlet\tus\tconsider\tthe\tfollowing\tXOR\toperation\tproperty:\ta XOR\ta\t=\t0.\tThat\tmeans,\tif\twe\tapply\tthe\tXOR\ton\tthe\tsame\telements\tthen\tthe\tresult\tis\t0. Algorithm: \u2022 XOR\tall\tthe\telements\tof\tthe\tgiven\tarray\tand\tassume\tthe\tresult\tis\tA. \u2022 After\tthis\toperation,\t2\toccurrences\tof\tthe\tnumber\twhich\tappeared\t3\ttimes\tbecomes\t0 and\tone\toccurrence\tremains\tthe\tsame. \u2022 The\t12\telements\tthat\tare\tappearing\t4\ttimes\tbecome\t0. \u2022 The\t25\telements\tthat\tare\tappearing\t2\ttimes\tbecome\t0. \u2022 So\tjust\tXOR\u2019ing\tall\tthe\telements\tgives\tthe\tresult. Time\tComplexity:\tO(n),\tbecause\twe\tare\tdoing\tonly\tone\tscan.\tSpace\tComplexity:\tO(1). Problem-73\u2003\u2003Given\ta\tnumber\tn,\tgive\tan\talgorithm\tfor\tfinding\tthe\tnumber\tof\ttrailing\tzeros\tin n!. Solution: Time\tComplexity:\tO(logn). Problem-74\u2003\u2003Given\tan\tarray\tof\t2n\tintegers\tin\tthe\tfollowing\tformat\ta1\ta2\ta3\t...an\tb1\tb2\tb3 ...bn.\tShuffle\tthe\tarray\tto\ta1\tb1\ta2\tb2\ta3\tb3\t...\tan\tbn\twithout\tany\textra\tmemory. Solution:\tA\tbrute\tforce\tsolution\tinvolves\ttwo\tnested\tloops\tto\trotate\tthe\telements\tin\tthe\tsecond half\tof\tthe\tarray\tto\tthe\tleft.\tThe\tfirst\tloop\truns\tn\ttimes\tto\tcover\tall\telements\tin\tthe\tsecond\thalf\tof the\tarray.\tThe\tsecond\tloop\trotates\tthe\telements\tto\tthe\tleft.\tNote\tthat\tthe\tstart\tindex\tin\tthe\tsecond loop\tdepends\ton\twhich\telement\twe\tare\trotating\tand\tthe\tend\tindex\tdepends\ton\thow\tmany\tpositions we\tneed\tto\tmove\tto\tthe\tleft. Time\tComplexity:\tO(n2). Problem-75\u2003\u2003Can\twe\timprove\tProblem-74\tsolution? Solution:\t Refer\t to\t the\t Divide\t and\t Conquer\t chapter.\t A\t better\t solution\t of\t time\t complexity O(nlogn)\tcan\tbe\tachieved\tusing\tthe\tDivide\tand\tConcur\ttechnique.\tLet\tus\tlook\tat\tan\texample"
            }
        ]
    },
    {
        "chapter_title": "1.",
        "subchapters": [
            {
                "subchapter_title": "Start\twith\tthe\tarray:\ta1\ta2\ta3\ta4\tb1\tb2\tb3\tb4",
                "content": ""
            }
        ]
    },
    {
        "chapter_title": "2.",
        "subchapters": [
            {
                "subchapter_title": "Split\tthe\tarray\tinto\ttwo\thalves:\ta1\ta2\ta3\ta4\t:\tb1\tb2\tb3\tb4",
                "content": ""
            }
        ]
    },
    {
        "chapter_title": "3.",
        "subchapters": [
            {
                "subchapter_title": "Exchange\telements\taround\tthe\tcenter:\texchange\ta3\ta4\twith\tb1\tb2\tand\tyou\tget:\ta1\ta.2",
                "content": "b1\tb2\ta3\ta4\tb3\tb4"
            }
        ]
    },
    {
        "chapter_title": "4.",
        "subchapters": [
            {
                "subchapter_title": "Split\ta1\ta2\tb1\tb2\tinto\ta1\ta2\t:\tb1\tb2.\tThen\tsplit\ta3\ta4\tb3\tb4\tinto\ta3\ta4\t:\tb3\tb4",
                "content": ""
            }
        ]
    },
    {
        "chapter_title": "5.",
        "subchapters": [
            {
                "subchapter_title": "Exchange\telements\taround\tthe\tcenter\tfor\teach\tsubarray\tyou\tget:\ta1\tb1\ta2\tb2\tand\ta3",
                "content": "b3\ta4\tb4 Note\tthat\tthis\tsolution\tonly\thandles\tthe\tcase\twhen\tn\t=\t2i\twhere\ti\t=\t0,1,2,3,\tetc.\tIn\tour\texample\tn =\t22\t=\t4\twhich\tmakes\tit\teasy\tto\trecursively\tsplit\tthe\tarray\tinto\ttwo\thalves.\tThe\tbasic\tidea\tbehind swapping\telements\taround\tthe\tcenter\tbefore\tcalling\tthe\trecursive\tfunction\tis\tto\tproduce\tsmaller size\tproblems.\tA\tsolution\twith\tlinear\ttime\tcomplexity\tmay\tbe\tachieved\tif\tthe\telements\tare\tof\ta specific\tnature.\tFor\texample,\tif\tyou\tcan\tcalculate\tthe\tnew\tposition\tof\tthe\telement\tusing\tthe\tvalue of\tthe\telement\titself.\tThis\tis\tnothing\tbut\ta\thashing\ttechnique. Problem-76\u2003\u2003Given\tan\tarray\tA[],\tfind\tthe\tmaximum\tj\t\u2013\ti\tsuch\tthat\tA[j]\t>\tA[i].\tFor\texample, Input:\t{34,\t8,\t10,\t3,\t2,\t80,\t30,\t33,\t1}\tand\tOutput:\t6\t(j\t=\t7,\ti\t=\t1). Solution:\tBrute\tForce\tApproach:\tRun\ttwo\tloops.\tIn\tthe\touter\tloop,\tpick\telements\tone\tby\tone from\tthe\tleft.\tIn\tthe\tinner\tloop,\tcompare\tthe\tpicked\telement\twith\tthe\telements\tstarting\tfrom\tthe right\tside.\tStop\tthe\tinner\tloop\twhen\tyou\tsee\tan\telement\tgreater\tthan\tthe\tpicked\telement\tand\tkeep updating\tthe\tmaximum\tj\t\u2013\ti\tso\tfar. Time\tComplexity:\tO(n2).\tSpace\tComplexity:\tO(1). Problem-77\u2003\u2003Can\twe\timprove\tthe\tcomplexity\tof\tProblem-76? Solution:\tTo\tsolve\tthis\tproblem,\twe\tneed\tto\tget\ttwo\toptimum\tindexes\tof\tA[]:\tleft\tindex\ti\t and right\tindex\tj.\tFor\tan\telement\tA[i],\twe\tdo\tnot\tneed\tto\tconsider\tA[i]\tfor\tthe\tleft\tindex\tif\tthere\tis\tan element\tsmaller\tthan\tA[i]\ton\tthe\tleft\tside\tof\tA[i].\tSimilarly,\tif\tthere\tis\ta\tgreater\telement\ton\tthe right\tside\tof\tA[j]\tthen\twe\tdo\tnot\tneed\tto\tconsider\tthis\tj\tfor\tthe\tright\tindex. So\twe\tconstruct\ttwo\tauxiliary\tArrays\tLeftMins[]\tand\tRightMaxs[]\tsuch\tthat\tLeftMins[i]\tholds\tthe smallest\t element\t on\t the\t left\t side\t of\t A[i]\t including\t A[i],\t and\t RightMaxs[j]\t holds\t the\t greatest element\ton\tthe\tright\tside\tof\tA[j]\tincluding\tA[j].\tAfter\tconstructing\tthese\ttwo\tauxiliary\tarrays,\twe traverse\tboth\tthese\tarrays\tfrom\tleft\tto\tright. While\t traversing\t LeftMins[]\t and\t RightMaxs[],\t if\t we\t see\t that\t LeftMins[i]\t is\t greater\t than RightMaxs[j],\tthen\twe\tmust\tmove\tahead\tin\tLeftMins[]\t(or\tdo\ti++)\tbecause\tall\telements\ton\tthe\tleft of\t LeftMins[i]\t are\t greater\t than\t or\t equal\t to\t LeftMins[i].\t Otherwise\t we\t must\t move\t ahead\t in RightMaxs[j]\tto\tlook\tfor\ta\tgreater\ty\t\u2013\ti\tvalue. Time\tComplexity:\tO(n).\tSpace\tComplexity:\tO(n). Problem-78\u2003\u2003Given\t an\t array\t of\t elements,\t how\t do\t you\t check\t whether\t the\t list\t is\t pairwise sorted\tor\tnot?\tA\tlist\tis\tconsidered\tpairwise\tsorted\tif\teach\tsuccessive\tpair\tof\tnumbers\tis\tin sorted\t(non-decreasing)\torder. Solution: Time\tComplexity:\tO(n).\tSpace\tComplexity:\tO(1). Problem-79\u2003\u2003Given\t an\t array\t of\t n\t elements,\t how\t do\t you\t print\t the\t frequencies\t of\t elements without\tusing\textra\tspace.\tAssume\tall\telements\tare\tpositive,\teditable\tand\tless\tthan\tn. Solution:\tUse\tnegation\ttechnique. Array\tshould\thave\tnumbers\tin\tthe\trange\t[1,\tn]\t(where\tn\tis\tthe\tsize\tof\tthe\tarray).\tThe\tif\tcondition (A[pos]\t >\t 0\t &&\t A[expectedPos]\t >\t 0)\t means\t that\t both\t the\t numbers\t at\t indices\t pos\t and expectedPos\tare\tactual\tnumbers\tin\tthe\tarray\tbut\tnot\ttheir\tfrequencies.\tSo\twe\twill\tswap\tthem\tso that\tthe\tnumber\tat\tthe\tindex\tpos\twill\tgo\tto\tthe\tposition\twhere\tit\tshould\thave\tbeen\tif\tthe\tnumbers 1,\t2,\t3,\t....,\tn\tare\tkept\tin\t0,\t1,\t2,\t...,\tn\t\u2013\t1\tindices.\tIn\tthe\tabove\texample\tinput\tarray,\tinitially\tpos\t= 0,\tso\t10\tat\tindex\t0\twill\tgo\tto\tindex\t9\tafter\tthe\tswap.\tAs\tthis\tis\tthe\tfirst\toccurrence\tof\t10,\tmake\tit to\t-1.\tNote\tthat\twe\tare\tstoring\tthe\tfrequencies\tas\tnegative\tnumbers\tto\tdifferentiate\tbetween\tactual numbers\tand\tfrequencies. The\telse\tif\tcondition\t(A[pos]\t>\t0)\tmeans\tA[pos]\tis\ta\tnumber\tand\tA[expectedPos]\tis\tits\tfrequency without\tincluding\tthe\toccurrence\tof\tA[pos].\tSo\tincrement\tthe\tfrequency\tby\t1\t(that\tis\tdecrement\tby 1\tin\tterms\tof\tnegative\tnumbers).\tAs\twe\tcount\tits\toccurrence\twe\tneed\tto\tmove\tto\tnext\tpos,\tso\tpos +\t+,\tbut\tbefore\tmoving\tto\tthat\tnext\tposition\twe\tshould\tmake\tthe\tfrequency\tof\tthe\tnumber\tpos\t+\t1 which\tcorresponds\tto\tindex\tpos\tof\tzero,\tsince\tsuch\ta\tnumber\thas\tnot\tyet\toccurred. The\tfinal\telse\tpart\tmeans\tthe\tcurrent\tindex\tpos\talready\thas\tthe\tfrequency\tof\tthe\tnumber\tpos\t+\t1, so\tmove\tto\tthe\tnext\tpos,\thence\tpos\t+\t+. Time\tComplexity:\tO(n).\tSpace\tComplexity:\tO(1). Problem-80\u2003\u2003Which\tis\tfaster\tand\tby\thow\tmuch,\ta\tlinear\tsearch\tof\tonly\t1000\telements\ton\ta\t5- GHz\tcomputer\tor\ta\tbinary\tsearch\tof\t1\tmillion\telements\ton\ta\t1-GHz\tcomputer.\tAssume\tthat the\texecution\tof\teach\tinstruction\ton\tthe\t5-GHz\tcomputer\tis\tfive\ttimes\tfaster\tthan\ton\tthe\t1- GHz\tcomputer\tand\tthat\teach\titeration\tof\tthe\tlinear\tsearch\talgorithm\tis\ttwice\tas\tfast\tas\teach iteration\tof\tthe\tbinary\tsearch\talgorithm. Solution:\t A\t binary\t search\t of\t 1\t million\t elements\t would\t require\t \t or\t about\t 20 iterations\t at\t most\t (i.e.,\t worst\t case).\t A\t linear\t search\t of\t 1000\t elements\t would\t require\t 500 iretations\ton\tthe\taverage\t(i.e.,\tgoing\thalfway\tthrough\tthe\tarray).\tTherefore,\tbinary\tsearch\twould be\t \t faster\t (in\t terms\t of\t iterations)\t than\t linear\t search.\t However,\t since\t linear\t search iterations\tare\ttwice\tas\tfast,\tbinary\tsearch\twould\tbe\t \tor\tabout\t12\ttimes\tfaster\tthan\tlinear\tsearch overall,\ton\tthe\tsame\tmachine.\tSince\twe\trun\tthem\ton\tdifferent\tmachines,\twhere\tan\tinstruction\ton the\t5-GhZ\tmachine\tis\t5\ttimes\tfaster\tthan\tan\tinstruction\ton\ta\t1-GHz\tmachine,\tbinary\tsearch\twould be\t \tor\tabout\t2\ttimes\tfaster\tthan\tlinear\tsearch!\tThe\tkey\tidea\tis\tthat\tsoftware\timprovements\tcan make\tan\talgorithm\trun\tmuch\tfaster\twithout\thaving\tto\tuse\tmore\tpowerful\tsoftware."
            },
            {
                "subchapter_title": "12.1\tWhat\tare\tSelection\tAlgorithms?",
                "content": "Selection\t algorithm\t is\t an\t algorithm\t for\t finding\t the\t kth\t smallest/largest\t number\t in\t a\t list\t (also called\tas\tkth\torder\tstatistic).\tThis\tincludes\tfinding\tthe\tminimum,\tmaximum,\tand\tmedian\telements. For\t finding\t the\t kth\t order\t statistic,\t there\t are\t multiple\t solutions\t which\t provide\t different complexities,\tand\tin\tthis\tchapter\twe\twill\tenumerate\tthose\tpossibilities."
            },
            {
                "subchapter_title": "12.2\tSelection\tby\tSorting",
                "content": "A\tselection\tproblem\tcan\tbe\tconverted\tto\ta\tsorting\tproblem.\tIn\tthis\tmethod,\twe\tfirst\tsort\tthe\tinput elements\tand\tthen\tget\tthe\tdesired\telement.\tIt\tis\tefficient\tif\twe\twant\tto\tperform\tmany\tselections. For\texample,\tlet\tus\tsay\twe\twant\tto\tget\tthe\tminimum\telement.\tAfter\tsorting\tthe\tinput\telements\twe can\tsimply\treturn\tthe\tfirst\telement\t(assuming\tthe\tarray\tis\tsorted\tin\tascending\torder).\tNow,\tif\twe want\tto\tfind\tthe\tsecond\tsmallest\telement,\twe\tcan\tsimply\treturn\tthe\tsecond\telement\tfrom\tthe\tsorted list. That\tmeans,\tfor\tthe\tsecond\tsmallest\telement\twe\tare\tnot\tperforming\tthe\tsorting\tagain.\tThe\tsame\tis also\tthe\tcase\twith\tsubsequent\tqueries.\tEven\tif\twe\twant\tto\tget\tkth\tsmallest\telement,\tjust\tone\tscan of\t the\t sorted\t list\t is\t enough\t to\t find\t the\t element\t (or\t we\t can\t return\t the\t kth-indexed\t value\t if\t the elements\tare\tin\tthe\tarray). From\tthe\tabove\tdiscussion\twhat\twe\tcan\tsay\tis,\twith\tthe\tinitial\tsorting\twe\tcan\tanswer\tany\tquery in\tone\tscan,\tO(n).\tIn\tgeneral,\tthis\tmethod\trequires\tO(nlogn)\ttime\t(for\tsorting),\twhere\tn\tis\tthe length\tof\tthe\tinput\tlist.\tSuppose\twe\tare\tperforming\tn\tqueries,\tthen\tthe\taverage\tcost\tper\toperation is\tjust\t .\tThis\tkind\tof\tanalysis\tis\tcalled\tamortized\tanalysis."
            },
            {
                "subchapter_title": "12.3\tPartition-based\tSelection\tAlgorithm",
                "content": "For\tthe\talgorithm\tcheck\tProblem-6.\tThis\talgorithm\tis\tsimilar\tto\tQuick\tsort."
            },
            {
                "subchapter_title": "12.4\tLinear\tSelection\tAlgorithm\t-\tMedian\tof\tMedians\tAlgorithm",
                "content": "Worst-case\tperformance O(n) Best-case\tperformance O(n) Worst-case\tspace\tcomplexity O(1)\tauxiliary Refer\tto\tProblem-11."
            },
            {
                "subchapter_title": "12.5\tFinding\tthe\tK\tSmallest\tElements\tin\tSorted\tOrder",
                "content": "For\tthe\talgorithm\tcheck\tProblem-6.\tThis\talgorithm\tis\tsimilar\tto\tQuick\tsort."
            },
            {
                "subchapter_title": "12.6\tSelection\tAlgorithms:\tProblems\t&\tSolutions",
                "content": "Problem-1\u2003\u2003Find\tthe\tlargest\telement\tin\tan\tarray\tA\tof\tsize\tn. Solution:\tScan\tthe\tcomplete\tarray\tand\treturn\tthe\tlargest\telement. Time\tComplexity\t-\tO(n).\tSpace\tComplexity\t-\tO(1). Note:\tAny\tdeterministic\talgorithm\tthat\tcan\tfind\tthe\tlargest\tof\tn\tkeys\tby\tcomparison\tof\tkeys\ttakes at\tleast\tn\t-1\tcomparisons. Problem-2\u2003\u2003Find\tthe\tsmallest\tand\tlargest\telements\tin\tan\tarray\tA\tof\tsize\tn. Solution: Time\tComplexity\t-\tO(n).\tSpace\tComplexity\t-\tO(1).\tThe\tworst-case\tnumber\tof\tcomparisons\tis\t2(n \u2013\t1). Problem-3\u2003\u2003Can\twe\timprove\tthe\tprevious\talgorithms? Solution:\tYes.\tWe\tcan\tdo\tthis\tby\tcomparing\tin\tpairs. Time\tComplexity\t-\tO(n).\tSpace\tComplexity\t-\tO(1). Number\tof\tcomparisons:\t Summary: Straightforward\tcomparison\t\u2013\t2(n\t\u2013\t1)\tcomparisons Compare\tfor\tmin\tonly\tif\tcomparison\tfor\tmax\tfails Best\tcase:\tincreasing\torder\t\u2013\tn\t\u2013\t1\tcomparisons Worst\tcase:\tdecreasing\torder\t\u2013\t2(n\t\u2013\t1)\tcomparisons Average\tcase:\t3n/2\t\u2013\t1\tcomparisons Note:\tFor\tdivide\tand\tconquer\ttechniques\trefer\tto\tDivide\tand\tConquer\tchapter. Problem-4\u2003\u2003Give\tan\talgorithm\tfor\tfinding\tthe\tsecond\tlargest\telement\tin\tthe\tgiven\tinput\tlist\tof elements. Solution:\tBrute\tForce\tMethod Algorithm: \u2022 Find\tlargest\telement:\tneeds\tn\t\u2013\t1\tcomparisons \u2022 Delete\t(discard)\tthe\tlargest\telement \u2022 Again\tfind\tlargest\telement:\tneeds\tn\t\u2013\t2\tcomparisons Total\tnumber\tof\tcomparisons:\tn\t\u2013\t1\t+\tn\t\u2013\t2\t=\t2n\t\u2013\t3 Problem-5\u2003\u2003Can\twe\treduce\tthe\tnumber\tof\tcomparisons\tin\tProblem-4\tsolution? Solution:\tThe\tTournament\tmethod:\tFor\tsimplicity,\tassume\tthat\tthe\tnumbers\tare\tdistinct\tand\tthat n\tis\ta\tpower\tof\t2.\tWe\tpair\tthe\tkeys\tand\tcompare\tthe\tpairs\tin\trounds\tuntil\tonly\tone\tround\tremains. If\tthe\tinput\thas\teight\tkeys,\tthere\tare\tfour\tcomparisons\tin\tthe\tfirst\tround,\ttwo\tin\tthe\tsecond,\tand one\t in\t the\t last.\t The\t winner\t of\t the\t last\t round\t is\t the\t largest\t key.\t The\t figure\t below\t shows\t the method. The\ttournament\tmethod\tdirectly\tapplies\tonly\twhen\tn\tis\ta\tpower\tof\t2.\tWhen\tthis\tis\tnot\tthe\tcase, we\tcan\tadd\tenough\titems\tto\tthe\tend\tof\tthe\tarray\tto\tmake\tthe\tarray\tsize\ta\tpower\tof\t2.\tIf\tthe\ttree\tis complete\tthen\tthe\tmaximum\theight\tof\tthe\ttree\tis\tlogn.\tIf\twe\tconstruct\tthe\tcomplete\tbinary\ttree,\twe need\tn\t\u2013\t1\tcomparisons\tto\tfind\tthe\tlargest.\tThe\tsecond\tlargest\tkey\thas\tto\tbe\tamong\tthe\tones\tthat were\tlost\tin\ta\tcomparison\twith\tthe\tlargest\tone.\tThat\tmeans,\tthe\tsecond\tlargest\telement\tshould\tbe one\tof\tthe\topponents\tof\tthe\tlargest\telement.\tThe\tnumber\tof\tkeys\tthat\tare\tlost\tto\tthe\tlargest\tkey\tis the\theight\tof\tthe\ttree,\ti.e.\tlogn\t[if\tthe\ttree\tis\ta\tcomplete\tbinary\ttree].\tThen\tusing\tthe\tselection algorithm\tto\tfind\tthe\tlargest\tamong\tthem,\ttake\tlogn\t\u2013\t1\tcomparisons.\tThus\tthe\ttotal\tnumber\tof comparisons\tto\tfind\tthe\tlargest\tand\tsecond\tlargest\tkeys\tis\tn\t+\tlogn\t\u2013\t2. Problem-6\u2003\u2003Find\t the\t k-smallest\t elements\t in\t an\t array\t S\t of\t n\t elements\t using\t partitioning method. Solution:\tBrute\tForce\tApproach:\tScan\tthrough\tthe\tnumbers\tk\ttimes\tto\thave\tthe\tdesired\telement. This\t method\t is\t the\t one\t used\t in\t bubble\t sort\t (and\t selection\t sort),\t every\t time\t we\t find\t out\t the smallest\telement\tin\tthe\twhole\tsequence\tby\tcomparing\tevery\telement.\tIn\tthis\tmethod,\tthe\tsequence has\tto\tbe\ttraversed\tk\ttimes.\tSo\tthe\tcomplexity\tis\tO(n\t\u00d7\tk). Problem-7\u2003\u2003Can\twe\tuse\tthe\tsorting\ttechnique\tfor\tsolving\tProblem-6? Solution:\tYes.\tSort\tand\ttake\tthe\tfirst\tk\telements."
            }
        ]
    },
    {
        "chapter_title": "1.",
        "subchapters": [
            {
                "subchapter_title": "Sort\tthe\tnumbers.",
                "content": ""
            }
        ]
    },
    {
        "chapter_title": "2.",
        "subchapters": [
            {
                "subchapter_title": "Pick\tthe\tfirst\tk\telements.",
                "content": "The\ttime\tcomplexity\tcalculation\tis\ttrivial.\tSorting\tof\tn\tnumbers\tis\tof\tO(nlogn)\t and\t picking\t k elements\tis\tof\tO(k).\tThe\ttotal\tcomplexity\tis\tO(nlogn\t+\tk)\t=\tO(nlogn). Problem-8\u2003\u2003Can\twe\tuse\tthe\ttree\tsorting\ttechnique\tfor\tsolving\tProblem-6? Solution:\tYes."
            }
        ]
    },
    {
        "chapter_title": "1.",
        "subchapters": [
            {
                "subchapter_title": "Insert\tall\tthe\telements\tin\ta\tbinary\tsearch\ttree.",
                "content": ""
            }
        ]
    },
    {
        "chapter_title": "2.",
        "subchapters": [
            {
                "subchapter_title": "Do\tan\tInOrder\ttraversal\tand\tprint\tk\telements\twhich\twill\tbe\tthe\tsmallest\tones.\tSo,\twe",
                "content": "have\tthe\tk\tsmallest\telements. The\tcost\tof\tcreation\tof\ta\tbinary\tsearch\ttree\twith\tn\telements\tis\tO(nlogn)\tand\tthe\ttraversal\tup\tto\tk elements\tis\tO(k).\tHence\tthe\tcomplexity\tis\tO(nlogn\t+\tk)\t=\tO(nlogn). Disadvantage:\tIf\tthe\tnumbers\tare\tsorted\tin\tdescending\torder,\twe\twill\tbe\tgetting\ta\ttree\twhich will\tbe\tskewed\ttowards\tthe\tleft.\tIn\tthat\tcase,\tthe\tconstruction\tof\tthe\ttree\twill\tbe\t0\t+\tl\t+\t2\t+\t...\t+ (n\u2013\t1)\t \twhich\tis\tO(n2).\tTo\tescape\tfrom\tthis,\twe\tcan\tkeep\tthe\ttree\tbalanced,\tso\tthat\tthe cost\tof\tconstructing\tthe\ttree\twill\tbe\tonly\tnlogn. Problem-9\u2003\u2003Can\twe\timprove\tthe\ttree\tsorting\ttechnique\tfor\tsolving\tProblem-6? Solution:\tYes.\tUse\ta\tsmaller\ttree\tto\tgive\tthe\tsame\tresult."
            }
        ]
    },
    {
        "chapter_title": "1.",
        "subchapters": [
            {
                "subchapter_title": "Take\tthe\tfirst\tk\telements\tof\tthe\tsequence\tto\tcreate\ta\tbalanced\ttree\tof\tk\tnodes\t(this",
                "content": "will\tcost\tklogk)."
            }
        ]
    },
    {
        "chapter_title": "2.",
        "subchapters": [
            {
                "subchapter_title": "Take\tthe\tremaining\tnumbers\tone\tby\tone,\tand",
                "content": "a. If\tthe\tnumber\tis\tlarger\tthan\tthe\tlargest\telement\tof\tthe\ttree,\treturn. b. If\tthe\tnumber\tis\tsmaller\tthan\tthe\tlargest\telement\tof\tthe\ttree,\tremove\tthe largest\telement\tof\tthe\ttree\tand\tadd\tthe\tnew\telement.\tThis\tstep\tis\tto make\tsure\tthat\ta\tsmaller\telement\treplaces\ta\tlarger\telement\tfrom\tthe tree.\tAnd\tof\tcourse\tthe\tcost\tof\tthis\toperation\tis\tlogk\tsince\tthe\ttree\tis\ta balanced\ttree\tof\tk\telements. Once\tStep\t2\tis\tover,\tthe\tbalanced\ttree\twith\tk\telements\twill\thave\tthe\tsmallest\tk\telements.\tThe\tonly remaining\ttask\tis\tto\tprint\tout\tthe\tlargest\telement\tof\tthe\ttree. Time\tComplexity:"
            }
        ]
    },
    {
        "chapter_title": "1.",
        "subchapters": [
            {
                "subchapter_title": "For\tthe\tfirst\tk\telements,\twe\tmake\tthe\ttree.\tHence\tthe\tcost\tis\tklogk.",
                "content": ""
            }
        ]
    },
    {
        "chapter_title": "2.",
        "subchapters": [
            {
                "subchapter_title": "For\tthe\trest\tn\t\u2013\tk\telements,\tthe\tcomplexity\tis\tO(logk).",
                "content": "Step\t2\thas\ta\tcomplexity\tof\t(n\t\u2013\tk)\tlogk.\tThe\ttotal\tcost\tis\tklogk\t+\t(n\t\u2013\tk)\tlogk\t=\tnlogk\twhich\tis O(nlogk).\tThis\tbound\tis\tactually\tbetter\tthan\tthe\tones\tprovided\tearlier. Problem-10\u2003\u2003Can\twe\tuse\tthe\tpartitioning\ttechnique\tfor\tsolving\tProblem-6? Solution:\tYes. Algorithm"
            }
        ]
    },
    {
        "chapter_title": "1.",
        "subchapters": [
            {
                "subchapter_title": "Choose\ta\tpivot\tfrom\tthe\tarray.",
                "content": ""
            }
        ]
    },
    {
        "chapter_title": "2.",
        "subchapters": [
            {
                "subchapter_title": "Partition\tthe\tarray\tso\tthat:\tA[low...pivotpoint\t\u2013\t1]\t<=\tpivotpoint\t<=\tA[pivotpoint\t+",
                "content": "1..high]."
            }
        ]
    },
    {
        "chapter_title": "3.",
        "subchapters": [
            {
                "subchapter_title": "if\t k\t <\t pivotpoint\t then\t it\t must\t be\t on\t the\t left\t of\t the\t pivot,\t so\t do\t the\t same\t method",
                "content": "recursively\ton\tthe\tleft\tpart."
            }
        ]
    },
    {
        "chapter_title": "4.",
        "subchapters": [
            {
                "subchapter_title": "if\t k\t =\t pivotpoint\t then\t it\t must\t be\t the\t pivot\t and\t print\t all\t the\t elements\t from\t low\t to",
                "content": "pivotpoint."
            }
        ]
    },
    {
        "chapter_title": "5.",
        "subchapters": [
            {
                "subchapter_title": "if\t k\t >\t pivotpoint\t then\t it\t must\t be\t on\t the\t right\t of\t pivot,\t so\t do\t the\t same\t method",
                "content": "recursively\ton\tthe\tright\tpart. The\ttop-level\tcall\twould\tbe\tkthSmallest\t=\tSelection(1,\tn,\tk). Time\tComplexity:\tO(n2)\tin\tworst\tcase\tas\tsimilar\tto\tQuicksort.\tAlthough\tthe\tworst\tcase\tis\tthe same\tas\tthat\tof\tQuicksort,\tthis\tperforms\tmuch\tbetter\ton\tthe\taverage\t[O(nlogk)\t\u2013\tAverage\tcase]. Problem-11\u2003\u2003Find\tthe\tkth-smallest\telement\tin\tan\tarray\tS\tof\tn\telements\tin\tbest\tpossible\tway. Solution:\tThis\tproblem\tis\tsimilar\tto\tProblem-6\tand\tall\tthe\tsolutions\tdiscussed\tfor\tProblem-6\tare valid\tfor\tthis\tproblem.\tThe\tonly\tdifference\tis\tthat\tinstead\tof\tprinting\tall\tthe\tk\telements,\twe\tprint only\tthe\tkth\t element.\t We\t can\t improve\t the\t solution\t by\t using\t the\tmedian\t of\t medians\t algorithm. Median\tis\ta\tspecial\tcase\tof\tthe\tselection\talgorithm.\tThe\talgorithm\tSelection(A,\tk)\tto\tfind\tthe\tkth smallest\telement\tfrom\tset\tA\tof\tn\telements\tis\tas\tfollows: Algorithm:\tSelection(A,\tk)"
            }
        ]
    },
    {
        "chapter_title": "1.",
        "subchapters": [
            {
                "subchapter_title": "Partition\tA\tinto",
                "content": "groups,\twith\teach\tgroup\thaving\tfive\titems\t(the last\tgroup\tmay\thave\tfewer\titems)."
            }
        ]
    },
    {
        "chapter_title": "2.",
        "subchapters": [
            {
                "subchapter_title": "Sort\teach\tgroup\tseparately\t(e.g.,\tinsertion\tsort).",
                "content": ""
            }
        ]
    },
    {
        "chapter_title": "3.",
        "subchapters": [
            {
                "subchapter_title": "Find\tthe\tmedian\tof\teach\tof\tthe\t \tgroups\tand\tstore\tthem\tin\tsome\tarray\t(let\tus\tsay\tA\u2032).",
                "content": ""
            }
        ]
    },
    {
        "chapter_title": "4.",
        "subchapters": [
            {
                "subchapter_title": "Use\tSelection\trecursively\tto\tfind\tthe\tmedian\tof\tA\u2032\t(median\tof\tmedians).\tLet\tus\tasay",
                "content": "the\tmedian\tof\tmedians\tis\tm."
            }
        ]
    },
    {
        "chapter_title": "5.",
        "subchapters": [
            {
                "subchapter_title": "Let\tq\t=\t#\telements\tof\tA\tsmaller\tthan\tm;",
                "content": ""
            }
        ]
    },
    {
        "chapter_title": "6.",
        "subchapters": [
            {
                "subchapter_title": "If(k\t==\tq\t+\t1)",
                "content": ""
            }
        ]
    },
    {
        "chapter_title": "7.",
        "subchapters": [
            {
                "subchapter_title": "Else\tpartition\tA\tinto\tX\tand\tY",
                "content": "\u2022 X\t=\t{items\tsmaller\tthan\tm) \u2022 Y\t=\t{items\tlarger\tthan\tm}"
            }
        ]
    },
    {
        "chapter_title": "8.",
        "subchapters": [
            {
                "subchapter_title": "If(k\t<\tq\t+\t1)",
                "content": ""
            }
        ]
    },
    {
        "chapter_title": "9.",
        "subchapters": [
            {
                "subchapter_title": "Else",
                "content": "Before\tdeveloping\trecurrence,\tlet\tus\tconsider\tthe\trepresentation\tof\tthe\tinput\tbelow.\tIn\tthe\tfigure, each\tcircle\tis\tan\telement\tand\teach\tcolumn\tis\tgrouped\twith\t5\telements.\tThe\tblack\tcircles\tindicate the\t median\t in\t each\t group\t of\t 5\t elements.\t As\t discussed,\t sort\t each\t column\t using\t constant\t time insertion\tsort. In\tthe\tfigure\tabove\tthe\tgray\tcircled\titem\tis\tthe\tmedian\tof\tmedians\t(let\tus\tcall\tthis\tm).\tIt\tcan\tbe seen\t that\t at\t least\t 1/2\t of\t 5\t element\t group\t medians\t \u2264m.\t Also,\t these\t 1/2\t of\t 5\t element\t groups contribute\t3\telements\tthat\tare\t\u2264\tm\texcept\t2\tgroups\t[last\tgroup\twhich\tmay\tcontain\tfewer\tthan\t5 elements,\t and\t other\t group\t which\t contains\t m].\t Similarly,\t at\t least\t 1/2\t of\t 5\t element\t groups contribute\t3\telements\tthat\tare\t\u2265\tm\tas\tshown\tabove.\t1/2\tof\t5\telement\tgroups\tcontribute\t3\telements, except\t 2\t groups\t gives:\t .\t The\t remaining\t are\t .\tSince\t \tis\tgreater\tthan\t \twe\tneed\tto\tconsider\t for\tworst. Components\tin\trecurrence: \u2022 In\tour\tselection\talgorithm,\twe\tchoose\tm,\twhich\tis\tthe\tmedian\tof\tmedians,\tto\tbe\ta\tpivot,\tand partition\tA\tinto\ttwo\tsets\tX\tand\tY.\tWe\tneed\tto\tselect\tthe\tset\twhich\tgives\tmaximum\tsize\t(to get\tthe\tworst\tcase). \u2022 The\ttime\tin\tfunction\tSelection\twhen\tcalled\tfrom\tprocedure\tpartition.\tThe\tnumber\tof\tkeys in\tthe\tinput\tto\tthis\tcall\tto\tSelection\tis\t . \u2022 The\tnumber\tof\tcomparisons\trequired\tto\tpartition\tthe\tarray.\tThis\tnumber\tis\tlength(S),\tlet\tus say\tn. We\t have\t established\t the\t following\t recurrence:\t From\tthe\tabove\tdiscussion\twe\thave\tseen\tthat,\tif\twe\tselect\tmedian\tof\tmedians\tm\tas\tpivot,\tthe partition\tsizes\tare:\t \tand\t .\tIf\twe\tselect\tthe\tmaximum\tof\tthese,\tthen\twe\tget: Problem-12\u2003\u2003In\t Problem-11,\t we\t divided\t the\t input\t array\t into\t groups\t of\t 5\t elements.\t The constant\t5\tplay\tan\timportant\tpart\tin\tthe\tanalysis.\tCan\twe\tdivide\tin\tgroups\tof\t3\twhich\twork in\tlinear\ttime? Solution:\tIn\tthis\tcase\tthe\tmodification\tcauses\tthe\troutine\tto\ttake\tmore\tthan\tlinear\ttime.\tIn\tthe worst\t case,\t at\t least\t half\t of\t the\t \t medians\t found\t in\t the\t grouping\t step\t are\t greater\t than\t the median\tof\tmedians\tm,\tbut\ttwo\tof\tthose\tgroups\tcontribute\tless\tthan\ttwo\telements\tlarger\tthan\tm.\tSo as\tan\tupper\tbound,\tthe\tnumber\tof\telements\tlarger\tthan\tthe\tpivotpoint\tis\tat\tleast: Likewise\tthis\tis\ta\tlower\tbound.\tThus\tup\tto\t \telements\tare\tfed\tinto\tthe recursive\tcall\tto\tSelect.\tThe\trecursive\tstep\tthat\tfinds\tthe\tmedian\tof\tmedians\truns\ton\ta\tproblem\tof size\t ,\tand\tconsequently\tthe\ttime\trecurrence\tis: Assuming\t that\t T(n)\t is\t monotonically\t increasing,\t we\t may\t conclude\t that\t ,\t and\t we\t can\t say\t the\t upper\t bound\t for\t this\t as\t ,\twhich\tis\tO(nlogn).\tTherefore,\twe\tcannot\tselect\t3\tas\tthe\tgroup size. Problem-13\u2003\u2003As\tin\tProblem-12,\tcan\twe\tuse\tgroups\tof\tsize\t7? Solution:\tFollowing\ta\tsimilar\treasoning,\twe\tonce\tmore\tmodify\tthe\troutine,\tnow\tusing\tgroups\tof\t7 instead\t of\t 5.\t In\t the\t worst\t case,\t at\t least\t half\t the\t \t medians\t found\t in\t the\t grouping\t step\t are greater\tthan\tthe\tmedian\tof\tmedians\tm,\tbut\ttwo\tof\tthose\tgroups\tcontribute\tless\tthan\tfour\telements larger\tthan\tm.\tSo\tas\tan\tupper\tbound,\tthe\tnumber\tof\telements\tlarger\tthan\tthe\tpivotpoint\tis\tat\tleast: Likewise\tthis\tis\ta\tlower\tbound.\tThus\tup\tto\t \telements\tare\tfed\tinto\tthe recursive\tcall\tto\tSelect.\tThe\trecursive\tstep\tthat\tfinds\tthe\tmedian\tof\tmedians\truns\ton\ta\tproblem\tof size\t ,\tand\tconsequently\tthe\ttime\trecurrence\tis This\tis\tbounded\tabove\tby\t(a\t+\tc)\tn\tprovided\tthat\t .\tTherefore,\twe\tcan\tselect\t7 as\tthe\tgroup\tsize. Problem-14\u2003\u2003Given\t two\t arrays\t each\t containing\t n\t sorted\t elements,\t give\t an\t O(logn)-time algorithm\tto\tfind\tthe\tmedian\tof\tall\t2n\telements. Solution:\tThe\tsimple\tsolution\tto\tthis\tproblem\tis\tto\tmerge\tthe\ttwo\tlists\tand\tthen\ttake\tthe\taverage of\tthe\tmiddle\ttwo\telements\t(note\tthe\tunion\talways\tcontains\tan\teven\tnumber\tof\tvalues).\tBut,\tthe merge\twould\tbe\t\u0398(n),\tso\tthat\tdoesn\u2019t\tsatisfy\tthe\tproblem\tstatement.\tTo\tget\tlogn\tcomplexity,\tlet medianA\tand\tmedianB\tbe\tthe\tmedians\tof\tthe\trespective\tlists\t(which\tcan\tbe\teasily\tfound\tsince both\tlists\tare\tsorted).\tIf\tmedianA\t==\tmedianB,\tthen\tthat\tis\tthe\toverall\tmedian\tof\tthe\tunion\tand\twe are\tdone.\tOtherwise,\tthe\tmedian\tof\tthe\tunion\tmust\tbe\tbetween\tmedianA\tand\tmedianB.\tSuppose that\tmedianA\t<\tmedianB\t(the\topposite\tcase\tis\tentirely\tsimilar).\tThen\twe\tneed\tto\tfind\tthe\tmedian of\tthe\tunion\tof\tthe\tfollowing\ttwo\tsets: So,\twe\tcan\tdo\tthis\trecursively\tby\tresetting\tthe\tboundaries\tof\tthe\ttwo\tarrays.\tThe\talgorithm\ttracks both\tarrays\t(which\tare\tsorted)\tusing\ttwo\tindices.\tThese\tindices\tare\tused\tto\taccess\tand\tcompare the\tmedian\tof\tboth\tarrays\tto\tfind\twhere\tthe\toverall\tmedian\tlies. Time\tComplexity:\tO(logn),\tsince\twe\tare\treducing\tthe\tproblem\tsize\tby\thalf\tevery\ttime. Problem-15\u2003\u2003Let\tA\tand\tB\tbe\ttwo\tsorted\tarrays\tof\tn\telements\teach.\tWe\tcan\teasily\tfind\tthe\tkth smallest\telement\tin\tA\tin\tO(1)\ttime\tby\tjust\toutputting\tA[k].\tSimilarly,\twe\tcan\teasily\tfind\tthe kth\tsmallest\telement\tin\tB.\tGive\tan\tO(logk)\ttime\talgorithm\tto\tfind\tthe\tkth\tsmallest\telement overall\t{i.e.,\tthe\tkth\tsmallest\tin\tthe\tunion\tof\tA\tand\tB. Solution:\tIt\u2019s\tjust\tanother\tway\tof\tasking\tProblem-14. Problem-16\u2003\u2003Find\tthe\tk\tsmallest\telements\tin\tsorted\torder:\tGiven\ta\tset\tof\tn\telements\tfrom\ta totally-ordered\tdomain,\tfind\tthe\tk\tsmallest\telements,\tand\tlist\tthem\tin\tsorted\torder.\tAnalyze the\tworst-case\trunning\ttime\tof\tthe\tbest\timplementation\tof\tthe\tapproach. Solution:\tSort\tthe\tnumbers,\tand\tlist\tthe\tk\tsmallest. T(n)\t=\tTime\tcomplexity\tof\tsort\t+\tlisting\tk\tsmallest\telements\t=\t\u0398(nlogn)\t+\t\u0398(n)\t=\t\u0398(nlogn). Problem-17\u2003\u2003For\tProblem-16,\tif\twe\tfollow\tthe\tapproach\tbelow,\tthen\twhat\tis\tthe\tcomplexity? Solution:\tUsing\tthe\tpriority\tqueue\tdata\tstructure\tfrom\theap\tsort,\tconstruct\ta\tmin-heap\tover\tthe set,\t and\t perform\t extract-min\t k\t times.\t Refer\t to\t the\t Priority\t Queues\t (Heaps)\t chapter\t for\t more details. Problem-18\u2003\u2003For\tProblem-16,\tif\twe\tfollow\tthe\tapproach\tbelow\tthen\twhat\tis\tthe\tcomplexity? Find\tthe\tkth-smallest\telement\tof\tthe\tset,\tpartition\taround\tthis\tpivot\telement,\tand\tsort\tthe\tk\tsmallest elements. Solution: T\t(n)\t=\tTime\tcomplexity\tof\tkth\t\u2013\tsmallest\t+\tFinding\tpivot\t+\tSorting\tprefix \u2003\u2003\u2003=\t\u0398(n)\t+\t\u0398(n)\t+\t\u0398(klogk)\t=\t\u0398(n\t+\tklogk) Since,\tk\t\u2264\tn,\tthis\tapproach\tis\tbetter\tthan\tProblem-16\tand\tProblem-17. Problem-19\u2003\u2003Find\tk\tnearest\tneighbors\tto\tthe\tmedian\tof\tn\tdistinct\tnumbers\tin\tO(n)\ttime. Solution:\tLet\tus\tassume\tthat\tthe\tarray\telements\tare\tsorted.\tNow\tfind\tthe\tmedian\tof\tn\tnumbers\tand call\tits\tindex\tas\tX\t(since\tarray\tis\tsorted,\tmedian\twill\tbe\tat\t \tlocation).\tAll\twe\tneed\tto\tdo\tis select\tk\telements\twith\tthe\tsmallest\tabsolute\tdifferences\tfrom\tthe\tmedian,\tmoving\tfrom\tX\t\u2013\t1\tto\t0, and\tX\t+\t1\tto\tn\t\u2013\t1\twhen\tthe\tmedian\tis\tat\tindex\tm. Time\tComplexity:\tEach\tstep\ttakes\t\u0398(n).\tSo\tthe\ttotal\ttime\tcomplexity\tof\tthe\talgorithm\tis\t\u0398(n). Problem-20\u2003\u2003Is\tthere\tany\tother\tway\tof\tsolving\tProblem-19? Solution:\tAssume\tfor\tsimplicity\tthat\tn\tis\todd\tand\tk\tis\teven.\tIf\tset\tA\tis\tin\tsorted\torder,\tthe\tmedian is\tin\tposition\tn/2\tand\tthe\tk\tnumbers\tin\tA\tthat\tare\tclosest\tto\tthe\tmedian\tare\tin\tpositions\t(n\t\u2013\tk)/2 through\t(n\t+\tk)/2. We\tfirst\tuse\tlinear\ttime\tselection\tto\tfind\tthe\t(n\t\u2013\tk)/2,\tn/2,\tand\t(n\t+\tk)/2\telements\tand\tthen\tpass through\t set\t A\t to\t find\t the\t numbers\t less\t than\t the\t (n\t +\t k)/2\t element,\t greater\t than\t the\t (n\t \u2013\t k)/2 element,\tand\tnot\tequal\tto\tthe\tn/\t2\telement.\tThe\talgorithm\ttakes\tO(n)\ttime\tas\twe\tuse\tlinear\ttime selection\texactly\tthree\ttimes\tand\ttraverse\tthe\tn\tnumbers\tin\tA\tonce. Problem-21\u2003\u2003Given\t(x,y)\tcoordinates\tof\tn\thouses,\twhere\tshould\tyou\tbuild\ta\troad\tparallel\tto x-axis\tto\tminimize\tthe\tconstruction\tcost\tof\tbuilding\tdriveways? Solution:\tThe\troad\tcosts\tnothing\tto\tbuild.\tIt\tis\tthe\tdriveways\tthat\tcost\tmoney.\tThe\tdriveway\tcost is\tproportional\tto\tits\tdistance\tfrom\tthe\troad.\tObviously,\tthey\twill\tbe\tperpendicular.\tThe\tsolution is\tto\tput\tthe\tstreet\tat\tthe\tmedian\tof\tthe\ty\tcoordinates. Problem-22\u2003\u2003Given\ta\tbig\tfile\tcontaining\tbillions\tof\tnumbers,\tfind\tthe\tmaximum\t10\tnumbers from\tthat\tfile. Solution:\tRefer\tto\tthe\tPriority\tQueues\tchapter. Problem-23\u2003\u2003Suppose\tthere\tis\ta\tmilk\tcompany.\tThe\tcompany\tcollects\tmilk\tevery\tday\tfrom\tall its\tagents.\tThe\tagents\tare\tlocated\tat\tdifferent\tplaces.\tTo\tcollect\tthe\tmilk,\twhat\tis\tthe\tbest place\tto\tstart\tso\tthat\tthe\tleast\tamount\tof\ttotal\tdistance\tis\ttravelled? Solution:\tStarting\tat\tthe\tmedian\treduces\tthe\ttotal\tdistance\ttravelled\tbecause\tit\tis\tthe\tplace\twhich is\tat\tthe\tcenter\tof\tall\tthe\tplaces."
            },
            {
                "subchapter_title": "13.1\tIntroduction",
                "content": "Since\t childhood,\t we\t all\t have\t used\t a\t dictionary,\t and\t many\t of\t us\t have\t a\t word\t processor\t (say, Microsoft\tWord)\twhich\tcomes\twith\ta\tspell\tchecker.\tThe\tspell\tchecker\tis\talso\ta\tdictionary\tbut limited\tin\tscope.\tThere\tare\tmany\treal\ttime\texamples\tfor\tdictionaries\tand\ta\tfew\tof\tthem\tare: \u2022 Spell\tchecker \u2022 The\tdata\tdictionary\tfound\tin\tdatabase\tmanagement\tapplications \u2022 Symbol\ttables\tgenerated\tby\tloaders,\tassemblers,\tand\tcompilers \u2022 Routing\ttables\tin\tnetworking\tcomponents\t(DNS\tlookup) In\t computer\t science,\t we\t generally\t use\t the\t term\t \u2018symbol\t table\u2019\t rather\t than\t \u2018dictionary\u2019\t when referring\tto\tthe\tabstract\tdata\ttype\t(ADT)."
            },
            {
                "subchapter_title": "13.2\tWhat\tare\tSymbol\tTables?",
                "content": "We\tcan\tdefine\tthe\tsymbol\ttable\tas\ta\tdata\tstructure\tthat\tassociates\ta\tvalue\twith\ta\tkey.\tIt\tsupports the\tfollowing\toperations: \u2022 Search\twhether\ta\tparticular\tname\tis\tin\tthe\ttable \u2022 Get\tthe\tattributes\tof\tthat\tname \u2022 Modify\tthe\tattributes\tof\tthat\tname \u2022 Insert\ta\tnew\tname\tand\tits\tattributes \u2022 Delete\ta\tname\tand\tits\tattributes There\tare\tonly\tthree\tbasic\toperations\ton\tsymbol\ttables:\tsearching,\tinserting,\tand\tdeleting. Example:\tDNS\tlookup.\tLet\tus\tassume\tthat\tthe\tkey\tin\tthis\tcase\tis\tthe\tURL\tand\tthe\tvalue\tis\tan\tIP address. \u2022 Insert\tURL\twith\tspecified\tIP\taddress \u2022 Given\tURL,\tfind\tcorresponding\tIP\taddress Key[Website] Value\t[IP\tAddress] www.CareerMonks.com 128.112.136.11 www.AuthorsInn.com 128.112.128.15 www.AuthInn.com 130.132.143.21 www.klm.com 128.103.060.55 www.CareerMonk.com 209.052.165.60"
            },
            {
                "subchapter_title": "13.3\tSymbol\tTable\tImplementations",
                "content": "Before\timplementing\tsymbol\ttables,\tlet\tus\tenumerate\tthe\tpossible\timplementations.\tSymbol\ttables can\tbe\timplemented\tin\tmany\tways\tand\tsome\tof\tthem\tare\tlisted\tbelow. Unordered\tArray\tImplementation With\tthis\tmethod,\tjust\tmaintaining\tan\tarray\tis\tenough.\tIt\tneeds\tO(n)\ttime\tfor\tsearching,\tinsertion and\tdeletion\tin\tthe\tworst\tcase. Ordered\t[Sorted]\tArray\tImplementation In\tthis\twe\tmaintain\ta\tsorted\tarray\tof\tkeys\tand\tvalues. \u2022 Store\tin\tsorted\torder\tby\tkey \u2022 keys[i]\t=\tith\tlargest\tkey \u2022 values[i]\t=\tvalue\tassociated\twith\tith\tlargest\tkey Since\tthe\telements\tare\tsorted\tand\tstored\tin\tarrays,\twe\tcan\tuse\ta\tsimple\tbinary\tsearch\tfor\tfinding an\telement.\tIt\ttakes\tO(logn)\ttime\tfor\tsearching\tand\tO(n)\ttime\tfor\tinsertion\tand\tdeletion\tin\tthe worst\tcase. Unordered\tLinked\tList\tImplementation Just\tmaintaining\ta\tlinked\tlist\twith\ttwo\tdata\tvalues\tis\tenough\tfor\tthis\tmethod.\tIt\tneeds\tO(n)\ttime for\tsearching,\tinsertion\tand\tdeletion\tin\tthe\tworst\tcase. Ordered\tLinked\tList\tImplementation In\tthis\tmethod,\twhile\tinserting\tthe\tkeys,\tmaintain\tthe\torder\tof\tkeys\tin\tthe\tlinked\tlist.\tEven\tif\tthe list\tis\tsorted,\tin\tthe\tworst\tcase\tit\tneeds\tO(n)\ttime\tfor\tsearching,\tinsertion\tand\tdeletion. Binary\tSearch\tTrees\tImplementation Refer\tto\tTrees\tchapter.\tThe\tadvantages\tof\tthis\tmethod\tare:\tit\tdoes\tnot\tneed\tmuch\tcode\tand\tit\thas\ta fast\tsearch\t[O(logn)\ton\taverage]. Balanced\tBinary\tSearch\tTrees\tImplementation Refer\tto\tTrees\tchapter.\tIt\tis\tan\textension\tof\tbinary\tsearch\ttrees\timplementation\tand\ttakes\tO(logn) in\tworst\tcase\tfor\tsearch,\tinsert\tand\tdelete\toperations. Ternary\tSearch\tImplementation Refer\tto\tString\tAlgorithms\tchapter.\tThis\tis\tone\tof\tthe\timportant\tmethods\tused\tfor\timplementing dictionaries. Hashing\tImplementation This\tmethod\tis\timportant.\tFor\ta\tcomplete\tdiscussion,\trefer\tto\tthe\tHashing\tchapter."
            },
            {
                "subchapter_title": "13.4\tComparison\tTable\tof\tSymbols\tfor\tImplementations",
                "content": "Let\tus\tconsider\tthe\tfollowing\tcomparison\ttable\tfor\tall\tthe\timplementations. Notes: \u2022 In\tthe\tabove\ttable,\tn\tis\tthe\tinput\tsize. \u2022 Table\tindicates\tthe\tpossible\timplementations\tdiscussed\tin\tthis\tbook.\tBut,\tthere\tcould be\tother\timplementations."
            },
            {
                "subchapter_title": "14.1\tWhat\tis\tHashing?",
                "content": "Hashing\tis\ta\ttechnique\tused\tfor\tstoring\tand\tretrieving\tinformation\tas\tquickly\tas\tpossible.\tIt\tis used\tto\tperform\toptimal\tsearches\tand\tis\tuseful\tin\timplementing\tsymbol\ttables."
            },
            {
                "subchapter_title": "14.2\tWhy\tHashing?",
                "content": "In\tthe\tTrees\tchapter\twe\tsaw\tthat\tbalanced\tbinary\tsearch\ttrees\tsupport\toperations\tsuch\tas\tinsert, delete\t and\t search\t in\t O(logn)\t time.\t In\t applications,\t if\t we\t need\t these\t operations\t in\t O(1),\t then hashing\tprovides\ta\tway.\tRemember\tthat\tworst\tcase\tcomplexity\tof\thashing\tis\tstill\tO(n),\t but\t it gives\tO(1)\ton\tthe\taverage."
            },
            {
                "subchapter_title": "14.3\tHashTable\tADT",
                "content": "The\tcommon\toperations\tfor\thash\ttable\tare: \u2022 CreatHashTable:\tCreates\ta\tnew\thash\ttable \u2022 HashSearch:\tSearches\tthe\tkey\tin\thash\ttable \u2022 Hashlnsert:\tInserts\ta\tnew\tkey\tinto\thash\ttable \u2022 HashDelete:\tDeletes\ta\tkey\tfrom\thash\ttable \u2022 DeleteHashTable:\tDeletes\tthe\thash\ttable"
            },
            {
                "subchapter_title": "14.4\tUnderstanding\tHashing",
                "content": "In\tsimple\tterms\twe\tcan\ttreat\tarray\tas\ta\thash\ttable.\tFor\tunderstanding\tthe\tuse\tof\thash\ttables,\tlet\tus consider\t the\t following\t example:\t Give\t an\t algorithm\t for\t printing\t the\t first\t repeated\t character\t if there\tare\tduplicated\telements\tin\tit.\tLet\tus\tthink\tabout\tthe\tpossible\tsolutions.\tThe\tsimple\tand\tbrute force\tway\tof\tsolving\tis:\tgiven\ta\tstring,\tfor\teach\tcharacter\tcheck\twhether\tthat\tcharacter\tis\trepeated or\tnot.\tThe\ttime\tcomplexity\tof\tthis\tapproach\tis\tO(n2)\twith\tO(1)\tspace\tcomplexity. Now,\tlet\tus\tfind\ta\tbetter\tsolution\tfor\tthis\tproblem.\tSince\tour\tobjective\tis\tto\tfind\tthe\tfirst\trepeated character,\twhat\tif\twe\tremember\tthe\tprevious\tcharacters\tin\tsome\tarray? We\tknow\tthat\tthe\tnumber\tof\tpossible\tcharacters\tis\t256\t(for\tsimplicity\tassume\tASCII\tcharacters only).\tCreate\tan\tarray\tof\tsize\t256\tand\tinitialize\tit\twith\tall\tzeros.\tFor\teach\tof\tthe\tinput\tcharacters go\t to\t the\t corresponding\t position\t and\t increment\t its\t count.\t Since\t we\t are\t using\t arrays,\t it\t takes constant\ttime\tfor\treaching\tany\tlocation.\tWhile\tscanning\tthe\tinput,\tif\twe\tget\ta\tcharacter\twhose counter\tis\talready\t1\tthen\twe\tcan\tsay\tthat\tthe\tcharacter\tis\tthe\tone\twhich\tis\trepeating\tfor\tthe\tfirst time. Why\tnot\tArrays? In\tthe\tprevious\tproblem,\twe\thave\tused\tan\tarray\tof\tsize\t256\tbecause\twe\tknow\tthe\tnumber\tof different\tpossible\tcharacters\t[256]\tin\tadvance.\tNow,\tlet\tus\tconsider\ta\tslight\tvariant\tof\tthe\tsame problem.\tSuppose\tthe\tgiven\tarray\thas\tnumbers\tinstead\tof\tcharacters,\tthen\thow\tdo\twe\tsolve\tthe problem? In\tthis\tcase\tthe\tset\tof\tpossible\tvalues\tis\tinfinity\t(or\tat\tleast\tvery\tbig).\tCreating\ta\thuge\tarray\tand storing\t the\t counters\t is\t not\t possible.\t That\t means\t there\t are\t a\t set\t of\t universal\t keys\t and\t limited locations\tin\tthe\tmemory.\tIf\twe\twant\tto\tsolve\tthis\tproblem\twe\tneed\tto\tsomehow\tmap\tall\tthese possible\tkeys\tto\tthe\tpossible\tmemory\tlocations.\tFrom\tthe\tabove\tdiscussion\tand\tdiagram\tit\tcan\tbe seen\tthat\twe\tneed\ta\tmapping\tof\tpossible\tkeys\tto\tone\tof\tthe\tavailable\tlocations.\tAs\ta\tresult\tusing simple\tarrays\tis\tnot\tthe\tcorrect\tchoice\tfor\tsolving\tthe\tproblems\twhere\tthe\tpossible\tkeys\tare\tvery big.\tThe\tprocess\tof\tmapping\tthe\tkeys\tto\tlocations\tis\tcalled\thashing. Note:\tFor\tnow,\tdo\tnot\tworry\tabout\thow\tthe\tkeys\tare\tmapped\tto\tlocations.\tThat\tdepends\ton\tthe function\tused\tfor\tconversions.\tOne\tsuch\tsimple\tfunction\tis\tkey\t%\ttable\tsize."
            },
            {
                "subchapter_title": "14.5\tComponents\tof\tHashing",
                "content": "Hashing\thas\tfour\tkey\tcomponents: 1) Hash\tTable 2) Hash\tFunctions 3) Collisions 4) Collision\tResolution\tTechniques"
            },
            {
                "subchapter_title": "14.6\tHash\tTable",
                "content": "Hash\ttable\tis\ta\tgeneralization\tof\tarray.\tWith\tan\tarray,\twe\tstore\tthe\telement\twhose\tkey\tis\tk\tat\ta position\tk\tof\tthe\tarray.\tThat\tmeans,\tgiven\ta\tkey\tk,\twe\tfind\tthe\telement\twhose\tkey\tis\tk\tby\tjust looking\tin\tthe\tkth\tposition\tof\tthe\tarray.\tThis\tis\tcalled\tdirect\taddressing. Direct\taddressing\tis\tapplicable\twhen\twe\tcan\tafford\tto\tallocate\tan\tarray\twith\tone\tposition\tfor every\tpossible\tkey.\tBut\tif\twe\tdo\tnot\thave\tenough\tspace\tto\tallocate\ta\tlocation\tfor\teach\tpossible key,\tthen\twe\tneed\ta\tmechanism\tto\thandle\tthis\tcase.\tAnother\tway\tof\tdefining\tthe\tscenario\tis:\tif\twe have\tless\tlocations\tand\tmore\tpossible\tkeys,\tthen\tsimple\tarray\timplementation\tis\tnot\tenough. In\tthese\tcases\tone\toption\tis\tto\tuse\thash\ttables.\tHash\ttable\tor\thash\tmap\tis\ta\tdata\tstructure\tthat stores\tthe\tkeys\tand\ttheir\tassociated\tvalues,\tand\thash\ttable\tuses\ta\thash\tfunction\tto\tmap\tkeys\tto their\tassociated\tvalues.\tThe\tgeneral\tconvention\tis\tthat\twe\tuse\ta\thash\ttable\twhen\tthe\tnumber\tof keys\tactually\tstored\tis\tsmall\trelative\tto\tthe\tnumber\tof\tpossible\tkeys."
            },
            {
                "subchapter_title": "14.7\tHash\tFunction",
                "content": "The\thash\tfunction\tis\tused\tto\ttransform\tthe\tkey\tinto\tthe\tindex.\tIdeally,\tthe\thash\tfunction\tshould\tmap each\tpossible\tkey\tto\ta\tunique\tslot\tindex,\tbut\tit\tis\tdifficult\tto\tachieve\tin\tpractice. Given\ta\tcollection\tof\telements,\ta\thash\tfunction\tthat\tmaps\teach\titem\tinto\ta\tunique\tslot\tis\treferred to\tas\ta\tperfect\thash\tfunction.\tIf\twe\tknow\tthe\telements\tand\tthe\tcollection\twill\tnever\tchange,\tthen it\tis\tpossible\tto\tconstruct\ta\tperfect\thash\tfunction.\tUnfortunately,\tgiven\tan\tarbitrary\tcollection\tof elements,\tthere\tis\tno\tsystematic\tway\tto\tconstruct\ta\tperfect\thash\tfunction.\tLuckily,\twe\tdo\tnot\tneed the\thash\tfunction\tto\tbe\tperfect\tto\tstill\tgain\tperformance\tefficiency. One\tway\tto\talways\thave\ta\tperfect\thash\tfunction\tis\tto\tincrease\tthe\tsize\tof\tthe\thash\ttable\tso\tthat each\tpossible\tvalue\tin\tthe\telement\trange\tcan\tbe\taccommodated.\tThis\tguarantees\tthat\teach\telement will\thave\ta\tunique\tslot.\tAlthough\tthis\tis\tpractical\tfor\tsmall\tnumbers\tof\telements,\tit\tis\tnot\tfeasible when\t the\t number\t of\t possible\t elements\t is\t large.\t For\t example,\t if\t the\t elements\t were\t nine-digit Social\tSecurity\tnumbers,\tthis\tmethod\twould\trequire\talmost\tone\tbillion\tslots.\tIf\twe\tonly\twant\tto store\tdata\tfor\ta\tclass\tof\t25\tstudents,\twe\twill\tbe\twasting\tan\tenormous\tamount\tof\tmemory. Our\tgoal\tis\tto\tcreate\ta\thash\tfunction\tthat\tminimizes\tthe\tnumber\tof\tcollisions,\tis\teasy\tto\tcompute, and\tevenly\tdistributes\tthe\telements\tin\tthe\thash\ttable.\tThere\tare\ta\tnumber\tof\tcommon\tways\tto extend\tthe\tsimple\tremainder\tmethod.\tWe\twill\tconsider\ta\tfew\tof\tthem\there. The\tfolding\tmethod\tfor\tconstructing\thash\tfunctions\tbegins\tby\tdividing\tthe\telements\tinto\tequal- size\tpieces\t(the\tlast\tpiece\tmay\tnot\tbe\tof\tequal\tsize).\tThese\tpieces\tare\tthen\tadded\ttogether\tto\tgive the\tresulting\thash\tvalue.\tFor\texample,\tif\tour\telement\twas\tthe\tphone\tnumber\t436-555-4601,\twe would\t take\t the\t digits\t and\t divide\t them\t into\t groups\t of\t 2\t (43,65,55,46,01).\t After\t the\t addition, 43+65+55+46+01,\twe\tget\t210.\tIf\twe\tassume\tour\thash\ttable\thas\t11\tslots,\tthen\twe\tneed\tto\tperform the\textra\tstep\tof\tdividing\tby\t11\tand\tkeeping\tthe\tremainder.\tIn\tthis\tcase\t210\t%\t11\tis\t1,\tso\tthe phone\t number\t 436-555-4601\t hashes\t to\t slot\t 1.\t Some\t folding\t methods\t go\t one\t step\t further\t and reverse\t every\t other\t piece\t before\t the\t addition.\t For\t the\t above\t example,\t we\t get 43+56+55+64+01=219\twhich\tgives\t219\t%\t11\t=\t10. How\tto\tChoose\tHash\tFunction? The\tbasic\tproblems\tassociated\twith\tthe\tcreation\tof\thash\ttables\tare: \u2022 An\tefficient\thash\tfunction\tshould\tbe\tdesigned\tso\tthat\tit\tdistributes\tthe\tindex\tvalues of\tinserted\tobjects\tuniformly\tacross\tthe\ttable. \u2022 An\tefficient\tcollision\tresolution\talgorithm\tshould\tbe\tdesigned\tso\tthat\tit\tcomputes\tan alternative\tindex\tfor\ta\tkey\twhose\thash\tindex\tcorresponds\tto\ta\tlocation\tpreviously inserted\tin\tthe\thash\ttable. \u2022 We\t must\t choose\t a\t hash\t function\t which\t can\t be\t calculated\t quickly,\t returns\t values within\tthe\trange\tof\tlocations\tin\tour\ttable,\tand\tminimizes\tcollisionsns. Characteristics\tof\tGood\tHash\tFunctions A\tgood\thash\tfunction\tshould\thave\tthe\tfollowing\tcharacteristics: \u2022 Minimize\tcollision \u2022 Be\teasy\tand\tquick\tto\tcompute \u2022 Distribute\tkey\tvalues\tevenly\tin\tthe\thash\ttable \u2022 Use\tall\tthe\tinformation\tprovided\tin\tthe\tkey \u2022 Have\ta\thigh\tload\tfactor\tfor\ta\tgiven\tset\tof\tkeys"
            },
            {
                "subchapter_title": "14.8\tLoad\tFactor",
                "content": "The\tload\tfactor\tof\ta\tnon-empty\thash\ttable\tis\tthe\tnumber\tof\titems\tstored\tin\tthe\ttable\tdivided\tby\tthe size\t of\t the\t table.\t This\t is\t the\t decision\t parameter\t used\t when\t we\t want\t to\t rehash\t or\t expand\t the existing\thash\ttable\tentries.\tThis\talso\thelps\tus\tin\tdetermining\tthe\tefficiency\tof\tthe\thashing\tfunction. That\tmeans,\tit\ttells\twhether\tthe\thash\tfunction\tis\tdistributing\tthe\tkeys\tuniformly\tor\tnot."
            },
            {
                "subchapter_title": "14.9\tCollisions",
                "content": "Hash\tfunctions\tare\tused\tto\tmap\teach\tkey\tto\ta\tdifferent\taddress\tspace,\tbut\tpractically\tit\tis\tnot possible\t to\t create\t such\t a\t hash\t function\t and\t the\t problem\t is\t called\t collision.\t Collision\t is\t the condition\twhere\ttwo\trecords\tare\tstored\tin\tthe\tsame\tlocation."
            },
            {
                "subchapter_title": "14.10\tCollision\tResolution\tTechniques",
                "content": "The\t process\t of\t finding\t an\t alternate\t location\t is\t called\t collision\t resolution.\t Even\t though\t hash tables\thave\tcollision\tproblems,\tthey\tare\tmore\tefficient\tin\tmany\tcases\tcompared\tto\tall\tother\tdata structures,\tlike\tsearch\ttrees.\tThere\tare\ta\tnumber\tof\tcollision\tresolution\ttechniques,\tand\tthe\tmost popular\tare\tdirect\tchaining\tand\topen\taddressing. \u2022 Direct\tChaining:\tAn\tarray\tof\tlinked\tlist\tapplication \u25cb Separate\tchaining \u2022 Open\tAddressing:\tArray-based\timplementation \u25cb Linear\tprobing\t(linear\tsearch) \u25cb Quadratic\tprobing\t(nonlinear\tsearch) \u25cb Double\thashing\t(use\ttwo\thash\tfunctions)"
            },
            {
                "subchapter_title": "14.11\tSeparate\tChaining",
                "content": "Collision\tresolution\tby\tchaining\tcombines\tlinked\trepresentation\twith\thash\ttable.\tWhen\ttwo\tor more\t records\t hash\t to\t the\t same\t location,\t these\t records\t are\t constituted\t into\t a\t singly-linked\t list called\ta\tchain."
            },
            {
                "subchapter_title": "14.12\tOpen\tAddressing",
                "content": "In\topen\taddressing\tall\tkeys\tare\tstored\tin\tthe\thash\ttable\titself.\tThis\tapproach\tis\talso\tknown\tas closed\thashing.\tThis\tprocedure\tis\tbased\ton\tprobing.\tA\tcollision\tis\tresolved\tby\tprobing. Linear\tProbing The\tinterval\tbetween\tprobes\tis\tfixed\tat\t1.\tIn\tlinear\tprobing,\twe\tsearch\tthe\thash\ttable\tsequentially, starting\tfrom\tthe\toriginal\thash\tlocation.\tIf\ta\tlocation\tis\toccupied,\twe\tcheck\tthe\tnext\tlocation.\tWe wrap\taround\tfrom\tthe\tlast\ttable\tlocation\tto\tthe\tfirst\ttable\tlocation\tif\tnecessary.\tThe\tfunction\tfor rehashing\tis\tthe\tfollowing: rehash(key)\t=\t(n\t+\t1)%\ttablesize One\tof\tthe\tproblems\twith\tlinear\tprobing\tis\tthat\ttable\titems\ttend\tto\tcluster\ttogether\tin\tthe\thash table.\t This\t means\t that\t the\t table\t contains\t groups\t of\t consecutively\t occupied\t locations\t that\t are called\tclustering. Clusters\tcan\tget\tclose\tto\tone\tanother,\tand\tmerge\tinto\ta\tlarger\tcluster.\tThus,\tthe\tone\tpart\tof\tthe table\tmight\tbe\tquite\tdense,\teven\tthough\tanother\tpart\thas\trelatively\tfew\titems.\tClustering\tcauses long\tprobe\tsearches\tand\ttherefore\tdecreases\tthe\toverall\tefficiency. The\tnext\tlocation\tto\tbe\tprobed\tis\tdetermined\tby\tthe\tstep-size,\twhere\tother\tstep-sizes\t(more\tthan one)\tare\tpossible.\tThe\tstep-size\tshould\tbe\trelatively\tprime\tto\tthe\ttable\tsize,\ti.e.\ttheir\tgreatest common\tdivisor\tshould\tbe\tequal\tto\t1.\tIf\twe\tchoose\tthe\ttable\tsize\tto\tbe\ta\tprime\tnumber,\tthen\tany step-size\tis\trelatively\tprime\tto\tthe\ttable\tsize.\tClustering\tcannot\tbe\tavoided\tby\tlarger\tstep-sizes. Quadratic\tProbing The\t interval\t between\t probes\t increases\t proportionally\t to\t the\t hash\t value\t (the\t interval\t thus increasing\t linearly,\t and\t the\t indices\t are\t described\t by\t a\t quadratic\t function).\t The\t problem\t of Clustering\tcan\tbe\teliminated\tif\twe\tuse\tthe\tquadratic\tprobing\tmethod. In\tquadratic\tprobing,\twe\tstart\tfrom\tthe\toriginal\thash\tlocation\ti.\t If\t a\t location\t is\t occupied,\t we check\tthe\tlocations\ti\t+\t12\t,\ti\t+22,\ti\t+\t32,\ti\t+\t42...\tWe\twrap\taround\tfrom\tthe\tlast\ttable\tlocation\tto the\tfirst\ttable\tlocation\tif\tnecessary.\tThe\tfunction\tfor\trehashing\tis\tthe\tfollowing: rehash(key)\t=\t(n\t+\tk2)%\ttablesize Example:\tLet\tus\tassume\tthat\tthe\ttable\tsize\tis\t11\t(0..10) Hash\tFunction:\th(key)\t=\tkey\tmod\t11 Insert\tkeys 31\tmod\t11\t=\t9 19\tmod\t11\t=\t8 2\tmod\t11\t=\t2 13\tmod\t11\t=\t2\t\u2192\t2\t+\t12\t=\t3 25\tmod\t11\t=\t3\t\u2192\t3\t+\t12=4 24\tmod\t11\t=\t2\t\u2192\t2\t+\t12,\t2\t+\t22\t=\t6 21\tmod\t11\t=\t10 9\tmod\t11\t=\t9\t\u2192\t9\t+\t12,\t9\t+\t22\tmod\t11,\t9\t+\t32\tmod\t11=7 Even\t though\t clustering\t is\t avoided\t by\t quadratic\t probing,\t still\t there\t are\t chances\t of\t clustering. Clustering\t is\t caused\t by\t multiple\t search\t keys\tmapped\t to\t the\tsame\t hash\t key.\t Thus,\t the\t probing sequence\tfor\tsuch\tsearch\tkeys\tis\tprolonged\tby\trepeated\tconflicts\talong\tthe\tprobing\tsequence. Both\tlinear\tand\tquadratic\tprobing\tuse\ta\tprobing\tsequence\tthat\tis\tindependent\tof\tthe\tsearch\tkey. Double\tHashing The\t interval\t between\t probes\t is\t computed\t by\t another\t hash\t function.\t Double\t hashing\t reduces clustering\t in\t a\t better\t way.\t The\t increments\t for\t the\t probing\t sequence\t are\t computed\t by\t using\t a second\thash\tfunction.\tThe\tsecond\thash\tfunction\th2\tshould\tbe: h2(key)\t\u2260\t0\tand\th2\t\u2260\th1 We\tfirst\tprobe\tthe\tlocation\th1(key).\tIf\tthe\tlocation\tis\toccupied,\twe\tprobe\tthe\tlocation\th1(key)\t+ h2(key),\th1(key)\t+\t2\t*\th2(key),\t... Example: Table\tsize\tis\t11\t(0..10) Hash\tFunction:\tassume\th1(key)\t=\tkey\tmod\t11\tand\th2(key)\t=\t7-\t(key\tmod\t7) Insert\tkeys: 58\tmod\t11\t=\t3 14\tmod\t11\t=\t3\t\u2192\t3\t+\t7\t=\t10 91\tmod\t11\t=\t3\t\u2192\t3+\t7,3+\t2*\t7\tmod\t11\t=\t6 25\tmod\t11\t=\t3\t\u2192\t3\t+\t3,3\t+\t2*3\t=\t9"
            },
            {
                "subchapter_title": "14.13\tComparison\tof\tCollision\tResolution\tTechniques",
                "content": "Comparisons:\tLinear\tProbing\tvs.\tDouble\tHashing The\tchoice\tbetween\tlinear\tprobing\tand\tdouble\thashing\tdepends\ton\tthe\tcost\tof\tcomputing\tthe\thash function\tand\ton\tthe\tload\tfactor\t[number\tof\telements\tper\tslot]\tof\tthe\ttable.\tBoth\tuse\tfew\tprobes\tbut double\thashing\ttake\tmore\ttime\tbecause\tit\thashes\tto\tcompare\ttwo\thash\tfunctions\tfor\tlong\tkeys. Comparisons:\tOpen\tAddressing\tvs.\tSeparate\tChaining It\tis\tsomewhat\tcomplicated\tbecause\twe\thave\tto\taccount\tfor\tthe\tmemory\tusage.\tSeparate\tchaining uses\textra\tmemory\tfor\tlinks.\tOpen\taddressing\tneeds\textra\tmemory\timplicitly\twithin\tthe\ttable\tto terminate\tthe\tprobe\tsequence.\tOpen-addressed\thash\ttables\tcannot\tbe\tused\tif\tthe\tdata\tdoes\tnot have\tunique\tkeys.\tAn\talternative\tis\tto\tuse\tseparate\tchained\thash\ttables. Comparisons:\tOpen\tAddressing\tmethods"
            },
            {
                "subchapter_title": "14.14\tHow\tHashing\tGets\tO(1)\tComplexity",
                "content": "From\tthe\tprevious\tdiscussion,\tone\tdoubts\thow\thashing\tgets\tO(1)\tif\tmultiple\telements\tmap\tto\tthe same\tlocation... The\tanswer\tto\tthis\tproblem\tis\tsimple.\tBy\tusing\tthe\tload\tfactor\twe\tmake\tsure\tthat\teach\tblock\t(for example,\tlinked\tlist\tin\tseparate\tchaining\tapproach)\ton\tthe\taverage\tstores\tthe\tmaximum\tnumber\tof elements\tless\tthan\tthe\tload\tfactor.\tAlso,\tin\tpractice\tthis\tload\tfactor\tis\ta\tconstant\t(generally,\t10\tor 20).\tAs\ta\tresult,\tsearching\tin\t20\telements\tor\t10\telements\tbecomes\tconstant. If\t the\t average\t number\t of\t elements\t in\t a\t block\t is\t greater\t than\t the\t load\t factor,\t we\t rehash\t the elements\t with\t a\t bigger\t hash\t table\t size.\t One\t thing\t we\t should\t remember\t is\t that\t we\t consider average\t occupancy\t (total\t number\t of\t elements\t in\t the\t hash\t table\t divided\t by\t table\t size)\t when deciding\tthe\trehash. The\t access\t time\t of\t the\t table\t depends\t on\t the\t load\t factor\t which\t in\t turn\t depends\t on\t the\t hash function.\tThis\tis\tbecause\thash\tfunction\tdistributes\tthe\telements\tto\tthe\thash\ttable.\tFor\tthis\treason, we\tsay\thash\ttable\tgives\tO(1)\tcomplexity\ton\taverage.\tAlso,\twe\tgenerally\tuse\thash\ttables\tin\tcases where\tsearches\tare\tmore\tthan\tinsertion\tand\tdeletion\toperations."
            },
            {
                "subchapter_title": "14.15\tHashing\tTechniques",
                "content": "There\tare\ttwo\ttypes\tof\thashing\ttechniques:\tstatic\thashing\tand\tdynamic\thashing Static\tHashing If\tthe\tdata\tis\tfixed\tthen\tstatic\thashing\tis\tuseful.\tIn\tstatic\thashing,\tthe\tset\tof\tkeys\tis\tkept\tfixed\tand given\tin\tadvance,\tand\tthe\tnumber\tof\tprimary\tpages\tin\tthe\tdirectory\tare\tkept\tfixed. Dynamic\tHashing If\tthe\tdata\tis\tnot\tfixed,\tstatic\thashing\tcan\tgive\tbad\tperformance,\tin\twhich\tcase\tdynamic\thashing\tis the\talternative,\tin\twhich\tcase\tthe\tset\tof\tkeys\tcan\tchange\tdynamically."
            },
            {
                "subchapter_title": "14.16\tProblems\tfor\twhich\tHash\tTables\tare\tnot\tsuitable",
                "content": "\u2022 Problems\tfor\twhich\tdata\tordering\tis\trequired \u2022 Problems\thaving\tmultidimensional\tdata \u2022 Prefix\tsearching,\tespecially\tif\tthe\tkeys\tare\tlong\tand\tof\tvariable-lengths \u2022 Problems\tthat\thave\tdynamic\tdata \u2022 Problems\tin\twhich\tthe\tdata\tdoes\tnot\thave\tunique\tkeys."
            },
            {
                "subchapter_title": "14.17\tBloom\tFilters",
                "content": "A\tBloom\tfilter\tis\ta\tprobabilistic\tdata\tstructure\twhich\twas\tdesigned\tto\tcheck\twhether\tan\telement is\tpresent\tin\ta\tset\twith\tmemory\tand\ttime\tefficiency.\tIt\ttells\tus\tthat\tthe\telement\teither\tdefinitely\tis not\tin\tthe\tset\tor\tmay\tbe\tin\tthe\tset.\tThe\tbase\tdata\tstructure\tof\ta\tBloom\tfilter\tis\ta\tBit\tVector.\tThe algorithm\twas\tinvented\tin\t1970\tby\tBurton\tBloom\tand\tit\trelies\ton\tthe\tuse\tof\ta\tnumber\tof\tdifferent hash\tfunctions. How\tit\tworks? Now\tthat\tthe\tbits\tin\tthe\tbit\tvector\thave\tbeen\tset\tfor\tElement1\tand\tElement2; we\tcan\tquery\tthe\tbloom\tfilter\tto\ttell\tus\tif\tsomething\thas\tbeen\tseen\tbefore. The\telement\tis\thashed\tbut\tinstead\tof\tsetting\tthe\tbits,\tthis\ttime\ta\tcheck\tis\tdone and\tif\tthe\tbits\tthat\twould\thave\tbeen\tset\tare\talready\tset\tthe\tbloom\tfilter\twill return\ttrue\tthat\tthe\telement\thas\tbeen\tseen\tbefore. A\tBloom\tfilter\tstarts\toff\twith\ta\tbit\tarray\tinitialized\tto\tzero.\tTo\tstore\ta\tdata\tvalue,\twe\tsimply apply\tk\tdifferent\thash\tfunctions\tand\ttreat\tthe\tresulting\tk\tvalues\tas\tindices\tin\tthe\tarray,\tand\twe\tset each\tof\tthe\tk\tarray\telements\tto\t1.\tWe\trepeat\tthis\tfor\tevery\telement\tthat\twe\tencounter. Now\tsuppose\tan\telement\tturns\tup\tand\twe\twant\tto\tknow\tif\twe\thave\tseen\tit\tbefore.\tWhat\twe\tdo\tis apply\tthe\tk\thash\tfunctions\tand\tlook\tup\tthe\tindicated\tarray\telements.\tIf\tany\tof\tthem\tare\t0\twe\tcan\tbe 100%\tsure\tthat\twe\thave\tnever\tencountered\tthe\telement\tbefore\t-\tif\twe\thad,\tthe\tbit\twould\thave been\tset\tto\t1.\tHowever,\teven\tif\tall\tof\tthem\tare\tone,\twe\tstill\tcan\u2019t\tconclude\tthat\twe\thave\tseen\tthe element\t before\t because\t all\t of\t the\t bits\t could\t have\t been\t set\t by\t the\t k\t hash\t functions\t applied\t to multiple\tother\telements.\tAll\twe\tcan\tconclude\tis\tthat\tit\tis\tlikely\t that\t we\t have\t encountered\t the element\tbefore. Note\tthat\tit\tis\tnot\tpossible\tto\tremove\tan\telement\tfrom\ta\tBloom\tfilter.\tThe\treason\tis\tsimply\tthat we\tcan\u2019t\tunset\ta\tbit\tthat\tappears\tto\tbelong\tto\tan\telement\tbecause\tit\tmight\talso\tbe\tset\tby\tanother element. If\tthe\tbit\tarray\tis\tmostly\tempty,\ti.e.,\tset\tto\tzero,\tand\tthe\tk\thash\tfunctions\tare\tindependent\tof\tone another,\tthen\tthe\tprobability\tof\ta\tfalse\tpositive\t(i.e.,\tconcluding\tthat\twe\thave\tseen\ta\tdata\titem when\twe\tactually\thaven\u2019t)\tis\tlow.\tFor\texample,\tif\tthere\tare\tonly\tk\tbits\tset,\twe\tcan\tconclude\tthat the\tprobability\tof\ta\tfalse\tpositive\tis\tvery\tclose\tto\tzero\tas\tthe\tonly\tpossibility\tof\terror\tis\tthat\twe entered\ta\tdata\titem\tthat\tproduced\tthe\tsame\tk\thash\tvalues\t-\twhich\tis\tunlikely\tas\tlong\tas\tthe\t\u2018has\u2019 functions\tare\tindependent. As\tthe\tbit\tarray\tfills\tup,\tthe\tprobability\tof\ta\tfalse\tpositive\tslowly\tincreases.\tOf\tcourse\twhen\tthe bit\tarray\tis\tfull,\tevery\telement\tqueried\tis\tidentified\tas\thaving\tbeen\tseen\tbefore.\tSo\tclearly\twe\tcan trade\tspace\tfor\taccuracy\tas\twell\tas\tfor\ttime. One-time\tremoval\tof\tan\telement\tfrom\ta\tBloom\tfilter\tcan\tbe\tsimulated\tby\thaving\ta\tsecond\tBloom filter\tthat\tcontains\telements\tthat\thave\tbeen\tremoved.\tHowever,\tfalse\tpositives\tin\tthe\tsecond\tfilter become\tfalse\tnegatives\tin\tthe\tcomposite\tfilter,\twhich\tmay\tbe\tundesirable.\tIn\tthis\tapproach,\tre- adding\t a\t previously\t removed\t item\t is\t not\t possible,\t as\t one\t would\t have\t to\t remove\t it\t from\t the removed\tfilter. Selecting\thash\tfunctions The\trequirement\tof\tdesigning\tk\tdifferent\tindependent\thash\tfunctions\tcan\tbe\tprohibitive\tfor\tlarge k.\tFor\ta\tgood\thash\tfunction\twith\ta\twide\toutput,\tthere\tshould\tbe\tlittle\tif\tany\tcorrelation\tbetween different\tbit-fields\tof\tsuch\ta\thash,\tso\tthis\ttype\tof\thash\tcan\tbe\tused\tto\tgenerate\tmultiple\tdifferent hash\tfunctions\tby\tslicing\tits\toutput\tinto\tmultiple\tbit\tfields.\tAlternatively,\tone\tcan\tpass\tk\tdifferent initial\tvalues\t(such\tas\t0,\t1,\t...,\tk\t-\t1)\tto\ta\thash\tfunction\tthat\ttakes\tan\tinitial\tvalue\t\u2013\tor\tadd\t(or append)\tthese\tvalues\tto\tthe\tkey.\tFor\tlarger\tm\tand/or\tk,\tindependence\tamong\tthe\thash\tfunctions can\tbe\trelaxed\twith\tnegligible\tincrease\tin\tthe\tfalse\tpositive\trate. Selecting\tsize\tof\tbit\tvector A\tBloom\tfilter\twith\t1%\terror\tand\tan\toptimal\tvalue\tof\tk,\tin\tcontrast,\trequires\tonly\tabout\t9.6\tbits per\t element\t \u2013\t regardless\t of\t the\t size\t of\t the\t elements.\t This\t advantage\t comes\t partly\t from\t its compactness,\t inherited\t from\t arrays,\t and\t partly\t from\t its\t probabilistic\t nature.\t The\t 1%\t false- positive\trate\tcan\tbe\treduced\tby\ta\tfactor\tof\tten\tby\tadding\tonly\tabout\t4.8\tbits\tper\telement. Space\tAdvantages While\t risking\t false\t positives,\t Bloom\t filters\t have\t a\t strong\t space\t advantage\t over\t other\t data structures\tfor\trepresenting\tsets,\tsuch\tas\tself-balancing\tbinary\tsearch\ttrees,\ttries,\thash\ttables,\tor simple\tarrays\tor\tlinked\tlists\tof\tthe\tentries.\tMost\tof\tthese\trequire\tstoring\tat\tleast\tthe\tdata\titems themselves,\twhich\tcan\trequire\tanywhere\tfrom\ta\tsmall\tnumber\tof\tbits,\tfor\tsmall\tintegers,\tto\tan arbitrary\tnumber\tof\tbits,\tsuch\tas\tfor\tstrings\t(tries\tare\tan\texception,\tsince\tthey\tcan\tshare\tstorage between\t elements\t with\t equal\t prefixes).\t Linked\t structures\t incur\t an\t additional\t linear\t space overhead\tfor\tpointers. However,\tif\tthe\tnumber\tof\tpotential\tvalues\tis\tsmall\tand\tmany\tof\tthem\tcan\tbe\tin\tthe\tset,\tthe\tBloom filter\t is\t easily\t surpassed\t by\t the\t deterministic\t bit\t array,\t which\t requires\t only\t one\t bit\t for\t each potential\telement. Time\tAdvantages Bloom\tfilters\talso\thave\tthe\tunusual\tproperty\tthat\tthe\ttime\tneeded\teither\tto\tadd\titems\tor\tto\tcheck whether\tan\titem\tis\tin\tthe\tset\tis\ta\tfixed\tconstant,\tO(k),\tcompletely\tindependent\tof\tthe\tnumber\tof items\t already\t in\t the\t set.\t No\t other\t constant-space\t set\t data\t structure\t has\t this\t property,\t but\t the average\t access\t time\t of\t sparse\t hash\t tables\t can\t make\t them\t faster\t in\t practice\t than\t some\t Bloom filters.\tIn\ta\thardware\timplementation,\thowever,\tthe\tBloom\tfilter\tshines\tbecause\tits\tk\tlookups\tare independent\tand\tcan\tbe\tparallelized. Implementation Refer\tto\tProblems\tSection."
            },
            {
                "subchapter_title": "14.18\tHashing:\tProblems\t&\tSolutions",
                "content": "Problem-1\u2003\u2003Implement\ta\tseparate\tchaining\tcollision\tresolution\ttechnique.\tAlso,\tdiscuss\ttime complexities\tof\teach\tfunction. Solution:\tTo\tcreate\ta\thashtable\tof\tgiven\tsize,\tsay\tn,\twe\tallocate\tan\tarray\tof\tn/L\t(whose\tvalue\tis usually\tbetween\t5\tand\t20)\tpointers\tto\tlist,\tinitialized\tto\tNULL.\tTo\tperform\tSearch/Insert/Delete operations,\twe\tfirst\tcompute\tthe\tindex\tof\tthe\ttable\tfrom\tthe\tgiven\tkey\tby\tusing\thashfunction\tand then\tdo\tthe\tcorresponding\toperation\tin\tthe\tlinear\tlist\tmaintained\tat\tthat\tlocation.\tTo\tget\tuniform distribution\tof\tkeys\tover\ta\thashtable,\tmaintain\ttable\tsize\tas\tthe\tprime\tnumber. CreatHashTable\t\u2013\tO(n).\tHashSearch\t-\tO(1)\taverage.\tHashlnsert\t-\tO(1)\taverage.\tHashDelete\t- O(1)\taverage. Problem-2\u2003\u2003Given\tan\tarray\tof\tcharacters,\tgive\tan\talgorithm\tfor\tremoving\tthe\tduplicates. Solution:\tStart\twith\tthe\tfirst\tcharacter\tand\tcheck\twhether\tit\tappears\tin\tthe\tremaining\tpart\tof\tthe string\t using\t a\t simple\t linear\t search.\t If\t it\t repeats,\t bring\t the\t last\t character\t to\t that\t position\t and decrement\tthe\tsize\tof\tthe\tstring\tby\tone.\tContinue\tthis\tprocess\tfor\teach\tdistinct\tcharacter\tof\tthe given\tstring. Time\tComplexity:\tO(n2).\tSpace\tComplexity:\tO(1). Problem-3\u2003\u2003Can\t we\t find\t any\t other\t idea\t to\t solve\t this\t problem\t in\t better\t time\t than\t O(n2)? Observe\tthat\tthe\torder\tof\tcharacters\tin\tsolutions\tdo\tnot\tmatter. Solution:\tUse\tsorting\tto\tbring\tthe\trepeated\tcharacters\ttogether.\tFinally\tscan\tthrough\tthe\tarray\tto remove\tduplicates\tin\tconsecutive\tpositions. Time\tComplexity:\t\u0398(nlogn).\tSpace\tComplexity:\tO(1). Problem-4\u2003\u2003Can\twe\tsolve\tthis\tproblem\tin\ta\tsingle\tpass\tover\tgiven\tarray? Solution:\tWe\tcan\tuse\thash\ttable\tto\tcheck\twhether\ta\tcharacter\tis\trepeating\tin\tthe\tgiven\tstring\tor not.\tIf\tthe\tcurrent\tcharacter\tis\tnot\tavailable\tin\thash\ttable,\tthen\tinsert\tit\tinto\thash\ttable\tand\tkeep that\tcharacter\tin\tthe\tgiven\tstring\talso.\tIf\tthe\tcurrent\tcharacter\texists\tin\tthe\thash\ttable\tthen\tskip\tthat character. Time\tComplexity:\t\u0398(n)\ton\taverage.\tSpace\tComplexity:\tO(n). Problem-5\u2003\u2003Given\ttwo\tarrays\tof\tunordered\tnumbers,\tcheck\twhether\tboth\tarrays\thave\tthe\tsame set\tof\tnumbers? Solution:\t Let\t us\t assume\t that\t two\t given\t arrays\t are\t A\t and\t B.\t A\t simple\t solution\t to\t the\t given problem\tis:\tfor\teach\telement\tof\tA,\tcheck\twhether\tthat\telement\tis\tin\tB\tor\tnot.\tA\tproblem\tarises with\tthis\tapproach\tif\tthere\tare\tduplicates.\tFor\texample\tconsider\tthe\tfollowing\tinputs: A\t=\t{2,5,6,8,10,2,2} B\t=\t{2,5,5,8,10,5,6} The\tabove\talgorithm\tgives\tthe\twrong\tresult\tbecause\tfor\teach\telement\tof\tA\tthere\tis\tan\telement\tin B\talso.\tBut\tif\twe\tlook\tat\tthe\tnumber\tof\toccurrences,\tthey\tare\tnot\tthe\tsame.\tThis\tproblem\twe\tcan solve\tby\tmoving\tthe\telements\twhich\tare\talready\tcompared\tto\tthe\tend\tof\tthe\tlist.\tThat\tmeans,\tif\twe find\tan\telement\tin\tB,\tthen\twe\tmove\tthat\telement\tto\tthe\tend\tof\tB,\tand\tin\tthe\tnext\tsearching\twe\twill not\tfind\tthose\telements.\tBut\tthe\tdisadvantage\tof\tthis\tis\tit\tneeds\textra\tswaps.\tTime\tComplexity\tof this\tapproach\tis\tO(n2),\tsince\tfor\teach\telement\tof\tA\twe\thave\tto\tscan\tB. Problem-6\u2003\u2003Can\twe\timprove\tthe\ttime\tcomplexity\tof\tProblem-5? Solution:\tYes.\tTo\timprove\tthe\ttime\tcomplexity,\tlet\tus\tassume\tthat\twe\thave\tsorted\tboth\tthe\tlists. Since\tthe\tsizes\tof\tboth\tarrays\tare\tn,\twe\tneed\tO(n\tlog\tn)\ttime\tfor\tsorting\tthem.\tAfter\tsorting,\twe just\tneed\tto\tscan\tboth\tthe\tarrays\twith\ttwo\tpointers\tand\tsee\twhether\tthey\tpoint\tto\tthe\tsame\telement every\ttime,\tand\tkeep\tmoving\tthe\tpointers\tuntil\twe\treach\tthe\tend\tof\tthe\tarrays. Time\tComplexity\tof\tthis\tapproach\tis\tO(n\tlog\tn).\tThis\tis\tbecause\twe\tneed\tO(n\tlog\tn)\tfor\tsorting the\tarrays.\tAfter\tsorting,\twe\tneed\tO(n)\ttime\tfor\tscanning\tbut\tit\tis\tless\tcompared\tto\tO(n\tlog\tn). Problem-7\u2003\u2003Can\twe\tfurther\timprove\tthe\ttime\tcomplexity\tof\tProblem-5? Solution:\tYes,\tby\tusing\ta\thash\ttable.\tFor\tthis,\tconsider\tthe\tfollowing\talgorithm. Algorithm: \u2022 Construct\tthe\thash\ttable\twith\tarray\tA\telements\tas\tkeys. \u2022 While\tinserting\tthe\telements,\tkeep\ttrack\tof\tthe\tnumber\tfrequency\tfor\teach\tnumber. That\tmeans,\tif\tthere\tare\tduplicates,\tthen\tincrement\tthe\tcounter\tof\tthat\tcorresponding key. \u2022 After\tconstructing\tthe\thash\ttable\tfor\tA\u2019s\telements,\tnow\tscan\tthe\tarray\tB. \u2022 For\teach\toccurrence\tof\tB\u2019s\telements\treduce\tthe\tcorresponding\tcounter\tvalues. \u2022 At\tthe\tend,\tcheck\twhether\tall\tcounters\tare\tzero\tor\tnot. \u2022 If\t all\t counters\t are\t zero,\t then\t both\t arrays\t are\t the\t same\t otherwise\t the\t arrays\t are different. Time\tComplexity;\tO(n)\tfor\tscanning\tthe\tarrays.\tSpace\tComplexity;\tO(n)\tfor\thash\ttable. Problem-8\u2003\u2003Given\ta\tlist\tof\tnumber\tpairs;\tif\tpair(i,j)\texists,\tand\tpair(j,i)\texists,\treport\tall\tsuch pairs.\t For\t example,\t in\t {{1,3},{2,6},{3,5},{7,4},{5,3},{8,7}},\t we\t see\t that\t {3,5}\t and {5,3}\t are\t present.\t Report\t this\t pair\t when\t you\t encounter\t {5,3}.\t We\t call\t such\t pairs \u2018symmetric\tpairs\u2019.\tSo,\tgive\tan\tefficient\talgorithm\tfor\tfinding\tall\tsuch\tpairs. Solution:\tBy\tusing\thashing,\twe\tcan\tsolve\tthis\tproblem\tin\tjust\tone\tscan.\tConsider\tthe\tfollowing algorithm. Algorithm: \u2022 Read\tthe\tpairs\tof\telements\tone\tby\tone\tand\tinsert\tthem\tinto\tthe\thash\ttable.\tFor\teach pair,\tconsider\tthe\tfirst\telement\tas\tkey\tand\tthe\tsecond\telement\tas\tvalue. \u2022 While\t inserting\t the\t elements,\t check\t if\t the\t hashing\t of\t the\t second\t element\t of\t the current\tpair\tis\tthe\tsame\tas\tthe\tfirst\tnumber\tof\tthe\tcurrent\tpair. \u2022 If\tthey\tare\tthe\tsame,\tthen\tthat\tindicates\ta\tsymmetric\tpair\texits\tand\toutput\tthat\tpair. \u2022 Otherwise,\t insert\t that\t element\t into\t that.\t That\t means,\t use\t the\t first\t number\t of\t the current\tpair\tas\tkey\tand\tthe\tsecond\tnumber\tas\tvalue\tand\tinsert\tthem\tinto\tthe\thash table. \u2022 By\tthe\ttime\twe\tcomplete\tthe\tscanning\tof\tall\tpairs,\twe\thave\toutput\tall\tthe\tsymmetric pairs. Time\tComplexity;\tO(n)\tfor\tscanning\tthe\tarrays.\tNote\tthat\twe\tare\tdoing\ta\tscan\tonly\tof\tthe\tinput. Space\tComplexity;\tO(n)\tfor\thash\ttable. Problem-9\u2003\u2003Given\ta\tsingly\tlinked\tlist,\tcheck\twhether\tit\thas\ta\tloop\tin\tit\tor\tnot. Solution:\tUsing\tHash\tTables Algorithm: \u2022 Traverse\tthe\tlinked\tlist\tnodes\tone\tby\tone. \u2022 Check\tif\tthe\tnode\u2019s\taddress\tis\tthere\tin\tthe\thash\ttable\tor\tnot. \u2022 If\tit\tis\talready\tthere\tin\tthe\thash\ttable,\tthat\tindicates\twe\tare\tvisiting\ta\tnode\twhich was\talready\tvisited.\tThis\tis\tpossible\tonly\tif\tthe\tgiven\tlinked\tlist\thas\ta\tloop\tin\tit. \u2022 If\tthe\taddress\tof\tthe\tnode\tis\tnot\tthere\tin\tthe\thash\ttable,\tthen\tinsert\tthat\tnode\u2019s\taddress into\tthe\thash\ttable. \u2022 Continue\tthis\tprocess\tuntil\twe\treach\tthe\tend\tof\tthe\tlinked\tlist\tor\twe\tfind\tthe\tloop. Time\tComplexity;\tO(n)\tfor\tscanning\tthe\tlinked\tlist.\tNote\tthat\twe\tare\tdoing\ta\tscan\tonly\tof\tthe input.\tSpace\tComplexity;\tO(n)\tfor\thash\ttable. Note:\tfor\tan\tefficient\tsolution,\trefer\tto\tthe\tLinked\tLists\tchapter. Problem-10\u2003\u2003Given\t an\t array\t of\t 101\t elements.\t Out\t of\t them\t 50\t elements\t are\t distinct,\t 24 elements\tare\trepeated\t2\ttimes,\tand\tone\telement\tis\trepeated\t3\ttimes.\tFind\tthe\telement\tthat\tis repeated\t3\ttimes\tin\tO(1). Solution:\tUsing\tHash\tTables Algorithm: \u2022 Scan\tthe\tinput\tarray\tone\tby\tone. \u2022 Check\tif\tthe\telement\tis\talready\tthere\tin\tthe\thash\ttable\tor\tnot. \u2022 If\tit\tis\talready\tthere\tin\tthe\thash\ttable,\tincrement\tits\tcounter\tvalue\t[this\tindicates\tthe number\tof\toccurrences\tof\tthe\telement]. \u2022 If\tthe\telement\tis\tnot\tthere\tin\tthe\thash\ttable,\tinsert\tthat\tnode\tinto\tthe\thash\ttable\twith counter\tvalue\t1. \u2022 Continue\tthis\tprocess\tuntil\treaching\tthe\tend\tof\tthe\tarray. Time\t Complexity:\t O(n),\t because\t we\t are\t doing\t two\t scans.\t Space\t Complexity:\t O(n),\t for\t hash table. Note:\tFor\tan\tefficient\tsolution\trefer\tto\tthe\tSearching\tchapter. Problem-11\u2003\u2003Given\tm\tsets\tof\tintegers\tthat\thave\tn\telements\tin\tthem,\tprovide\tan\talgorithm\tto find\tan\telement\twhich\tappeared\tin\tthe\tmaximum\tnumber\tof\tsets? Solution:\tUsing\tHash\tTables Algorithm: \u2022 Scan\tthe\tinput\tsets\tone\tby\tone. \u2022 For\teach\telement\tkeep\ttrack\tof\tthe\tcounter.\tThe\tcounter\tindicates\tthe\tfrequency\tof occurrences\tin\tall\tthe\tsets. \u2022 After\t completing\t the\t scan\t of\t all\t the\t sets,\t select\t the\t one\t which\t has\t the\t maximum counter\tvalue. Time\tComplexity:\tO(mn),\tbecause\twe\tneed\tto\tscan\tall\tthe\tsets.\tSpace\tComplexity:\tO(mn),\t for hash\ttable.\tBecause,\tin\tthe\tworst\tcase\tall\tthe\telements\tmay\tbe\tdifferent. Problem-12\u2003\u2003Given\ttwo\tsets\tA\tand\tB,\tand\ta\tnumber\tK,\tGive\tan\talgorithm\tfor\tfinding\twhether there\texists\ta\tpair\tof\telements,\tone\tfrom\tA\tand\tone\tfrom\tB,\tthat\tadd\tup\tto\tK. Solution:\tFor\tsimplicity,\tlet\tus\tassume\tthat\tthe\tsize\tof\tA\tis\tm\tand\tthe\tsize\tof\tB\tis\tn. Algorithm: \u2022 Select\tthe\tset\twhich\thas\tminimum\telements. \u2022 For\tthe\tselected\tset\tcreate\ta\thash\ttable.\tWe\tcan\tuse\tboth\tkey\tand\tvalue\tas\tthe\tsame. \u2022 Now\tscan\tthe\tsecond\tarray\tand\tcheck\twhether\t(K-selected\t element)\t exists\t in\t the hash\ttable\tor\tnot. \u2022 If\tit\texists\tthen\treturn\tthe\tpair\tof\telements. \u2022 Otherwise\tcontinue\tuntil\twe\treach\tthe\tend\tof\tthe\tset. Time\t Complexity:\t O(Max(m,n)),\t because\t we\t are\t doing\t two\t scans.\t Space\t Complexity: O(Min(m,n)),\tfor\thash\ttable.\tWe\tcan\tselect\tthe\tsmall\tset\tfor\tcreating\tthe\thash\ttable. Problem-13\u2003\u2003Give\tan\talgorithm\tto\tremove\tthe\tspecified\tcharacters\tfrom\ta\tgiven\tstring\twhich are\tgiven\tin\tanother\tstring? Solution:\tFor\tsimplicity,\tlet\tus\tassume\tthat\tthe\tmaximum\tnumber\tof\tdifferent\tcharacters\tis\t256. First\twe\tcreate\tan\tauxiliary\tarray\tinitialized\tto\t0.\tScan\tthe\tcharacters\tto\tbe\tremoved,\tand\tfor\teach of\tthose\tcharacters\twe\tset\tthe\tvalue\tto\t1,\twhich\tindicates\tthat\twe\tneed\tto\tremove\tthat\tcharacter. After\tinitialization,\tscan\tthe\tinput\tstring,\tand\tfor\teach\tof\tthe\tcharacters,\twe\tcheck\twhether\tthat character\tneeds\tto\tbe\tdeleted\tor\tnot.\tIf\tthe\tflag\tis\tset\tthen\twe\tsimply\tskip\tto\tthe\tnext\tcharacter, otherwise\twe\tkeep\tthe\tcharacter\tin\tthe\tinput\tstring.\tContinue\tthis\tprocess\tuntil\twe\treach\tthe\tend of\tthe\tinput\tstring.\tAll\tthese\toperations\twe\tcan\tdo\tin-place\tas\tgiven\tbelow. Time\tComplexity:\tTime\tfor\tscanning\tthe\tcharacters\tto\tbe\tremoved\t+\tTime\tfor\tscanning\tthe\tinput array=\tO(n)\t+O(m)\t\u2248\tO(n).\tWhere\tm\tis\tthe\tlength\tof\tthe\tcharacters\tto\tbe\tremoved\tand\tn\tis\tthe length\tof\tthe\tinput\tstring. Space\tComplexity:\tO(m),\tlength\tof\tthe\tcharacters\tto\tbe\tremoved.\tBut\tsince\twe\tare\tassuming\tthe maximum\tnumber\tof\tdifferent\tcharacters\tis\t256,\twe\tcan\ttreat\tthis\tas\ta\tconstant.\tBut\twe\tshould keep\tin\tmind\tthat\twhen\twe\tare\tdealing\twith\tmulti-byte\tcharacters,\tthe\ttotal\tnumber\tof\tdifferent characters\tis\tmuch\tmore\tthan\t256. Problem-14\u2003\u2003Give\tan\talgorithm\tfor\tfinding\tthe\tfirst\tnon-repeated\tcharacter\tin\ta\tstring.\tFor example,\tthe\tfirst\tnon-repeated\tcharacter\tin\tthe\tstring\t\u201cabzddab\u201d\tis\t\u2018z\u2019. Solution:\tThe\tsolution\tto\tthis\tproblem\tis\ttrivial.\tFor\teach\tcharacter\tin\tthe\tgiven\tstring,\twe\tcan scan\tthe\tremaining\tstring\tif\tthat\tcharacter\tappears\tin\tit.\tIf\tit\tdoes\tnot\tappears\tthen\twe\tare\tdone with\tthe\tsolution\tand\twe\treturn\tthat\tcharacter.\tIf\tthe\tcharacter\tappears\tin\tthe\tremaining\tstring,\tthen go\tto\tthe\tnext\tcharacter. Time\tComplexity:\tO(n2),\tfor\ttwo\tfor\tloops.\tSpace\tComplexity:\tO(1). Problem-15\u2003\u2003Can\twe\timprove\tthe\ttime\tcomplexity\tof\tProblem-13? Solution:\tYes.\tBy\tusing\thash\ttables\twe\tcan\treduce\tthe\ttime\tcomplexity.\tCreate\ta\thash\ttable\tby reading\t all\t the\t characters\t in\t the\t input\t string\t and\t keeping\t count\t of\t the\t number\t of\t times\t each character\tappears.\tAfter\tcreating\tthe\thash\ttable,\twe\tcan\tread\tthe\thash\ttable\tentries\tto\tsee\twhich element\thas\ta\tcount\tequal\tto\t1.\tThis\tapproach\ttakes\tO(n)\tspace\tbut\treduces\tthe\ttime\tcomplexity also\tto\tO(n). Time\tComplexity;\tWe\thave\tO(n)\tto\tcreate\tthe\thash\ttable\tand\tanother\tO(n)\tto\tread\tthe\tentries\tof hash\ttable.\tSo\tthe\ttotal\ttime\tis\tO(n)\t+\tO(n)\t=\tO(2n)\t\u2248\tO(n).\tSpace\tComplexity:\tO(n)\tfor\tkeeping the\tcount\tvalues. Problem-16\u2003\u2003Given\ta\tstring,\tgive\tan\talgorithm\tfor\tfinding\tthe\tfirst\trepeating\tletter\tin\ta\tstring? Solution:\tThe\tsolution\tto\tthis\tproblem\tis\tsomewhat\tsimilar\tto\tProblem-13\tand\tProblem-15.\tThe only\tdifference\tis,\tinstead\tof\tscanning\tthe\thash\ttable\ttwice\twe\tcan\tgive\tthe\tanswer\tin\tjust\tone scan.\tThis\tis\tbecause\twhile\tinserting\tinto\tthe\thash\ttable\twe\tcan\tsee\twhether\tthat\telement\talready exists\tor\tnot.\tIf\tit\talready\texists\tthen\twe\tjust\tneed\tto\treturn\tthat\tcharacter. Time\tComplexity:\tWe\thave\tO(n)\tfor\tscanning\tand\tcreating\tthe\thash\ttable.\tNote\tthat\twe\tneed\tonly one\tscan\tfor\tthis\tproblem.\tSo\tthe\ttotal\ttime\tis\tO(n).\tSpace\tComplexity:\tO(n)\tfor\tkeeping\tthe\tcount values. Problem-17\u2003\u2003Given\t an\t array\t of\t n\t numbers,\t create\t an\t algorithm\t which\t displays\t all\t pairs whose\tsum\tis\tS. Solution:\tThis\tproblem\tis\tsimilar\tto\tProblem-12.\tBut\tinstead\tof\tusing\ttwo\tsets\twe\tuse\tonly\tone set. Algorithm: \u2022 Scan\tthe\telements\tof\tthe\tinput\tarray\tone\tby\tone\tand\tcreate\ta\thash\ttable.\tBoth\tkey\tand value\tcan\tbe\tthe\tsame. \u2022 After\t creating\t the\t hash\t table,\t again\t scan\t the\t input\t array\t and\t check\t whether\t (S\t \u2013 selected\telement)\texits\tin\tthe\thash\ttable\tor\tnot. \u2022 If\tit\texits\tthen\treturn\tthe\tpair\tof\telements. \u2022 Otherwise\tcontinue\tand\tread\tall\tthe\telements\tof\tthe\tarray. Time\tComplexity;\tWe\thave\tO(n)\tto\tcreate\tthe\thash\ttable\tand\tanother\tO(n)\tto\tread\tthe\tentries\tof the\thash\ttable.\tSo\tthe\ttotal\ttime\tis\tO(n)\t+\tO(n)\t=\tO(2n)\t\u2248\tO(n).\t Space\tComplexity:\t O(n)\t for keeping\tthe\tcount\tvalues. Problem-18\u2003\u2003Is\tthere\tany\tother\tway\tof\tsolving\tProblem-17? Solution:\tYes.\tThe\talternative\tsolution\tto\tthis\tproblem\tinvolves\tsorting.\tFirst\tsort\tthe\tinput\tarray. After\tsorting,\tuse\ttwo\tpointers,\tone\tat\tthe\tstarting\tand\tanother\tat\tthe\tending.\tEach\ttime\tadd\tthe values\tof\tboth\tthe\tindexes\tand\tsee\tif\ttheir\tsum\tis\tequal\tto\tS.\tIf\tthey\tare\tequal\tthen\tprint\tthat\tpair. Otherwise\tincrease\tthe\tleft\tpointer\tif\tthe\tsum\tis\tless\tthan\tS\tand\tdecrease\tthe\tright\tpointer\tif\tthe sum\tis\tgreater\tthan\tS. Time\tComplexity:\tTime\tfor\tsorting\t+\tTime\tfor\tscanning\t=\tO(nlogn)\t+\tO(n)\t\u2248\tO(nlogn). Space\tComplexity:\tO(1). Problem-19\u2003\u2003We\thave\ta\tfile\twith\tmillions\tof\tlines\tof\tdata.\tOnly\ttwo\tlines\tare\tidentical;\tthe rest\tare\tunique.\tEach\tline\tis\tso\tlong\tthat\tit\tmay\tnot\teven\tfit\tin\tthe\tmemory.\tWhat\tis\tthe\tmost efficient\tsolution\tfor\tfinding\tthe\tidentical\tlines? Solution:\t Since\ta\t complete\t line\t may\t not\t fit\t into\t the\t main\t memory,\t read\t the\tline\t partially\t and compute\tthe\thash\tfrom\tthat\tpartial\tline.\tThen\tread\tthe\tnext\tpart\tof\tthe\tline\tand\tcompute\tthe\thash. This\ttime\tuse\tthe\tprevious\thash\talso\twhile\tcomputing\tthe\tnew\thash\tvalue.\tContinue\tthis\tprocess until\twe\tfind\tthe\thash\tfor\tthe\tcomplete\tline.\tDo\tthis\tfor\teach\tline\tand\tstore\tall\tthe\thash\tvalues\tin\ta file\t[or\tmaintain\ta\thash\ttable\tof\tthese\thashes].\tIf\tat\tany\tpoint\tyou\tget\tsame\thash\tvalue,\tread\tthe corresponding\tlines\tpart\tby\tpart\tand\tcompare. Note:\tRefer\tto\tSearching\tchapter\tfor\trelated\tproblems. Problem-20\u2003\u2003If\th\tis\tthe\thashing\tfunction\tand\tis\tused\tto\thash\tn\tkeys\tinto\ta\ttable\tof\tsize\ts,\twhere n\t<=\ts,\tthe\texpected\tnumber\tof\tcollisions\tinvolving\ta\tparticular\tkey\tX\tis\t: (A) less\tthan\t1. (B) less\tthan\tn. (C) less\tthan\ts. (D) less\tthan\t . Solution:\tA. Problem-21\u2003\u2003Implement\tBloom\tFilters Solution:\t A\t Bloom\t Filter\t is\t a\t data\t structure\t designed\t to\t tell,\t rapidly\t and\t memory-efficiently, whether\t an\t element\t is\t present\t in\t a\t set.\t It\t is\t based\t on\t a\t probabilistic\t mechanism\t where\t false positive\tretrieval\tresults\tare\tpossible,\tbut\tfalse\tnegatives\tare\tnot.\tAt\tthe\tend\twe\twill\tsee\thow\tto tune\tthe\tparameters\tin\torder\tto\tminimize\tthe\tnumber\tof\tfalse\tpositive\tresults. Let\u2019s\tbegin\twith\ta\tlittle\tbit\tof\ttheory.\tThe\tidea\tbehind\tthe\tBloom\tfilter\tis\tto\tallocate\ta\tbit\tvector of\tlength\tm,\tinitially\tall\tset\tto\t0,\tand\tthen\tchoose\tk\tindependent\thash\tfunctions,\th1,\th2,\t...,\thk,\teach with\trange\t[1..m].\tWhen\tan\telement\ta\tis\tadded\tto\tthe\tset\tthen\tthe\tbits\tat\tpositions\th1(a),\th2(a),\t..., hk(a)\tin\tthe\tbit\tvector\tare\tset\tto\t1.\tGiven\ta\tquery\telement\tq\twe\tcan\ttest\twhether\tit\tis\tin\tthe\tset using\tthe\tbits\tat\tpositions\th1(q),\th2(q),\t...,\thk(q)\tin\tthe\tvector.\tIf\tany\tof\tthese\tbits\tis\t0\twe\treport that\tq\tis\tnot\tin\tthe\tset\totherwise\twe\treport\tthat\tq\tis.\tThe\tthing\twe\thave\tto\tcare\tabout\tis\tthat\tin\tthe first\tcase\tthere\tremains\tsome\tprobability\tthat\tq\tis\tnot\tin\tthe\tset\twhich\tcould\tlead\tus\tto\ta\tfalse positive\tresponse."
            },
            {
                "subchapter_title": "15.1\tIntroduction",
                "content": "To\tunderstand\tthe\timportance\tof\tstring\talgorithms\tlet\tus\tconsider\tthe\tcase\tof\tentering\tthe\tURL (Uniform\tTo\tunderstand\tthe\timportance\tof\tstring\talgorithms\tlet\tus\tconsider\tthe\tcase\tof\tentering\tthe URL\t (Uniform\t Resource\t Locator)\t in\t any\t browser\t (say,\t Internet\t Explorer,\t Firefox,\t or\t Google Chrome).\tYou\twill\tobserve\tthat\tafter\ttyping\tthe\tprefix\tof\tthe\tURL,\ta\tlist\tof\tall\tpossible\tURLs\tis displayed.\tThat\tmeans,\tthe\tbrowsers\tare\tdoing\tsome\tinternal\tprocessing\tand\tgiving\tus\tthe\tlist\tof matching\tURLs.\tThis\ttechnique\tis\tsometimes\tcalled\tauto\t\u2013\tcompletion. Similarly,\tconsider\tthe\tcase\tof\tentering\tthe\tdirectory\tname\tin\tthe\tcommand\tline\tinterface\t(in\tboth Windows\tand\tUNIX).\tAfter\ttyping\tthe\tprefix\tof\tthe\tdirectory\tname,\tif\twe\tpress\tthe\ttab\tbutton,\twe get\ta\tlist\tof\tall\tmatched\tdirectory\tnames\tavailable.\tThis\tis\tanother\texample\tof\tauto\tcompletion. In\torder\tto\tsupport\tthese\tkinds\tof\toperations,\twe\tneed\ta\tdata\tstructure\twhich\tstores\tthe\tstring\tdata efficiently.\tIn\tthis\tchapter,\twe\twill\tlook\tat\tthe\tdata\tstructures\tthat\tare\tuseful\tfor\timplementing string\talgorithms. We\tstart\tour\tdiscussion\twith\tthe\tbasic\tproblem\tof\tstrings:\tgiven\ta\tstring,\thow\tdo\twe\tsearch\ta substring\t (pattern)?\t This\t is\t called\t a\t string\t matching\t problem.\t After\t discussing\t various\t string matching\talgorithms,\twe\twill\tlook\tat\tdifferent\tdata\tstructures\tfor\tstoring\tstrings."
            },
            {
                "subchapter_title": "15.2\tString\tMatching\tAlgorithms",
                "content": "In\tthis\tsection,\twe\tconcentrate\ton\tchecking\twhether\ta\tpattern\tP\tis\ta\tsubstring\tof\tanother\tstring\tT (T\t stands\t for\t text)\t or\t not.\t Since\t we\t are\t trying\t to\t check\t a\t fixed\t string\t P,\t sometimes\t these algorithms\tare\tcalled\texact\tstring\tmatching\talgorithms.\tTo\tsimplify\tour\tdiscussion,\tlet\tus\tassume that\tthe\tlength\tof\tgiven\ttext\tT\tis\tn\tand\tthe\tlength\tof\tthe\tpattern\tP\twhich\twe\tare\ttrying\tto\tmatch\thas the\t length\t m.\t That\t means,\t T\t has\t the\t characters\t from\t 0\t to\t n\t \u2013\t 1\t (T[0\t ...n\t \u2013\t 1])\t and\t P\t has\t the characters\tfrom\t0\tto\tm\t\u2013\t1\t(T[0\t...m\t\u2013\t1]).\tThis\talgorithm\tis\timplemented\tin\tC\t+\t+\tas\tstrstr(). In\t the\t subsequent\t sections,\t we\t start\t with\t the\t brute\t force\t method\t and\t gradually\t move\t towards better\talgorithms. \u2022 Brute\tForce\tMethod \u2022 Rabin-Karp\tString\tMatching\tAlgorithm \u2022 String\tMatching\twith\tFinite\tAutomata \u2022 KMP\tAlgorithm \u2022 Boyer-Moore\tAlgorithm \u2022 Suffix\tTrees"
            },
            {
                "subchapter_title": "15.3\tBrute\tForce\tMethod",
                "content": "In\tthis\tmethod,\tfor\teach\tpossible\tposition\tin\tthe\ttext\tT\twe\tcheck\twhether\tthe\tpattern\tP\tmatches\tor not.\tSince\tthe\tlength\tof\tT\tis\tn,\twe\thave\tn\t\u2013\tm\t+\t1\tpossible\tchoices\tfor\tcomparisons.\tThis\tis because\twe\tdo\tnot\tneed\tto\tcheck\tthe\tlast\tm\t\u2013\t1\tlocations\tof\tT\tas\tthe\tpattern\tlength\tis\tm.\t The following\talgorithm\tsearches\tfor\tthe\tfirst\toccurrence\tof\ta\tpattern\tstring\tP\tin\ta\ttext\tstring\tT. Algorithm Time\tComplexity:\tO((n\t\u2013\tm\t+\t1)\t\u00d7\tm)\t\u2248\tO(n\t\u00d7\tm).\tSpace\tComplexity:\tO(1)."
            },
            {
                "subchapter_title": "15.4\tRabin-Karp\tString\tMatching\tAlgorithm",
                "content": "In\t this\t method,\t we\t will\t use\t the\t hashing\t technique\t and\t instead\t of\t checking\t for\t each\t possible position\tin\tT,\twe\tcheck\tonly\tif\tthe\thashing\tof\tP\tand\tthe\thashing\tof\tm\tcharacters\tof\tT\tgive\tthe\tsame result. Initially,\tapply\tthe\thash\tfunction\tto\tthe\tfirst\tm\tcharacters\tof\tT\tand\tcheck\twhether\tthis\tresult\tand P\u2019s\thashing\tresult\tis\tthe\tsame\tor\tnot.\tIf\tthey\tare\tnot\tthe\tsame,\tthen\tgo\tto\tthe\tnext\tcharacter\tof\tT\tand again\tapply\tthe\thash\tfunction\tto\tm\tcharacters\t(by\tstarting\tat\tthe\tsecond\tcharacter).\tIf\tthey\tare\tthe same\tthen\twe\tcompare\tthose\tm\tcharacters\tof\tT\twith\tP. Selecting\tHash\tFunction At\t each\t step,\t since\t we\t are\t finding\t the\t hash\t of\t m\t characters\t of\t T,\t we\t need\t an\t efficient\t hash function.\tIf\tthe\thash\tfunction\ttakes\tO(m)\tcomplexity\tin\tevery\tstep,\tthen\tthe\ttotal\tcomplexity\tis\tO(n \u00d7\tm).\tThis\tis\tworse\tthan\tthe\tbrute\tforce\tmethod\tbecause\tfirst\twe\tare\tapplying\tthe\thash\tfunction and\talso\tcomparing. Our\tobjective\tis\tto\tselect\ta\thash\tfunction\twhich\ttakes\tO(1)\tcomplexity\tfor\tfinding\tthe\thash\tof\tm characters\tof\tT\tevery\ttime.\tOnly\tthen\tcan\twe\treduce\tthe\ttotal\tcomplexity\tof\tthe\talgorithm.\tIf\tthe hash\tfunction\tis\tnot\tgood\t(worst\tcase),\tthe\tcomplexity\tof\tthe\tRabin-Karp\talgorithm\tis\tO(n\t\u2013\tm\t+ 1)\t \u00d7\t m)\t \u2248\t O(n\t \u00d7\t m).\t If\t we\t select\t a\t good\t hash\t function,\t the\t complexity\t of\t the\t Rabin-Karp algorithm\t complexity\t is\t O(m\t +\t n).\t Now\t let\t us\t see\t how\t to\t select\t a\t hash\t function\t which\t can compute\tthe\thash\tof\tm\tcharacters\tof\tT\tat\teach\tstep\tin\tO(1). For\tsimplicity,\tlet\u2019s\tassume\tthat\tthe\tcharacters\tused\tin\tstring\tT\tare\tonly\tintegers.\tThat\tmeans,\tall characters\t in\t T\t \u2208\t {0,1,2,...,9\t }.\t Since\t all\t of\t them\t are\t integers,\t we\t can\t view\t a\t string\t of\t m consecutive\t characters\t as\t decimal\t numbers.\t For\t example,\t string\t \u203261815\u2032\t corresponds\t to\t the number\t 61815.\t With\t the\t above\t assumption,\t the\t pattern\t P\t is\t also\t a\t decimal\t value,\t and\t let\t us assume\tthat\tthe\tdecimal\tvalue\tof\tP\tis\tp.\tFor\tthe\tgiven\ttext\tT[0..n\t\u2013\t1],\tlet\tt(i)\tdenote\tthe\tdecimal value\tof\tlength\u2013m\tsubstring\tT[i..\ti\t+\tm\t\u2013\t1]\tfor\ti\t=\t0,1,\t...,n\t\u2013\tm\u2013\t1.\tSo,\tt(i)\t==\tp\tif\tand\tonly\tif T[i..i\t+\tm\t\u2013\t1]\t==\tP[0..m\t\u2013\t1]. We\tcan\tcompute\tp\tin\tO(m)\ttime\tusing\tHorner\u2019s\tRule\tas: The\tcode\tfor\tthe\tabove\tassumption\tis: We\tcan\tcompute\tall\tt(i),\tfor\ti\t=\t0,1,...,\tn\t\u2013\tm\t\u2013\t1\tvalues\tin\ta\ttotal\tof\tO(n)\ttime.\tThe\tvalue\tof\tt(0) can\tbe\tsimilarly\tcomputed\tfrom\tT[0..\tm\t\u2013\t1]\tin\tO(m)\ttime.\tTo\tcompute\tthe\tremaining\tvalues\tt(0), t(1),...,\tt(n\t\u2013\tm\t\u2013\t1),\tunderstand\tthat\tt(i\t+\t1)\tcan\tbe\tcomputed\tfrom\tt(i)\tin\tconstant\ttime. For\texample,\tif\tT\t=\t\u2033123456\u2033\tand\tm\t=\t3 Step\tby\tStep\texplanation First\t:\tremove\tthe\tfirst\tdigit\t:\t123\t\u2013\t100\t*\t1\t=\t23 Second:\tMultiply\tby\t10\tto\tshift\tit\t:\t23\t*\t10\t=\t230 Third:\tAdd\tlast\tdigit\t:\t230\t+\t4\t=\t234 The\talgorithm\truns\tby\tcomparing,\tt(i)\twith\tp.\tWhen\tt(i)\t==\tp,\tthen\twe\thave\tfound\tthe\tsubstring\tP in\tT,\tstarting\tfrom\tposition\ti."
            },
            {
                "subchapter_title": "15.5\tString\tMatching\twith\tFinite\tAutomata",
                "content": "In\t this\t method\t we\t use\t the\t finite\t automata\t which\t is\t the\t concept\t of\t the\t Theory\t of\t Computation (ToC).\tBefore\tlooking\tat\tthe\talgorithm,\tfirst\tlet\tus\tlook\tat\tthe\tdefinition\tof\tfinite\tautomata. Finite\tAutomata A\tfinite\tautomaton\tF\tis\ta\t5-tuple\t(Q,q0,A,\u2211,\u03b4),\twhere \u2022 Q\tis\ta\tfinite\tset\tof\tstates \u2022 q0\t\u2208\tQ\tis\tthe\tstart\tstate \u2022 A\t\u2286\tQ\tis\ta\tset\tof\taccepting\tstates \u2022 \u2211\tis\ta\tfinite\tinput\talphabet \u2022 \u03b4\tis\tthe\ttransition\tfunction\tthat\tgives\tthe\tnext\tstate\tfor\ta\tgiven\tcurrent\tstate\tand\tinput How\tdoes\tFinite\tAutomata\tWork? \u2022 The\tfinite\tautomaton\tF\tbegins\tin\tstate\tq0 \u2022 Reads\tcharacters\tfrom\t\u2211\tone\tat\ta\ttime \u2022 If\tF\tis\tin\tstate\tq\tand\treads\tinput\tcharacter\ta,\tF\tmoves\tto\tstate\t\u03b4(q,d) \u2022 At\tthe\tend,\tif\tits\tstate\tis\tin\tA,\tthen\twe\tsay,\tF\taccepted\tthe\tinput\tstring\tread\tso\tfar \u2022 If\tthe\tinput\tstring\tis\tnot\taccepted\tit\tis\tcalled\tthe\trejected\tstring Example:\t Let\t us\t assume\t that\t Q\t =\t {0,1{,q0\t =\t 0,A\t =\t {1},\u2211\t =\t {a,\t b}.\t \u03b4(q,d)\t as\t shown\t in\t the transition\ttable/diagram.\tThis\taccepts\tstrings\tthat\tend\tin\tan\todd\tnumber\tof\ta\u2019s;\te.g.,\tabbaaa\t is accepted,\taa\tis\trejected. Important\tNotes\tfor\tConstructing\tthe\tFinite\tAutomata For\t building\t the\t automata,\t first\t we\t start\t with\t the\t initial\t state.\t The\t FA\t will\t be\t in\t state\t k\t if\t k characters\t of\t the\t pattern\t have\t been\t matched.\t If\t the\t next\t text\t character\t is\t equal\t to\t the\t pattern character\t c,\t we\t have\t matched\t k\t +\t 1\t characters\t and\t the\t FA\t enters\t state\t k\t +\t 1.\t If\t the\t next\t text character\tis\tnot\tequal\tto\tthe\tpattern\tcharacter,\tthen\tthe\tFA\tgo\tto\ta\tstate\t0,1,2,....or\tk,\tdepending\ton how\tmany\tinitial\tpattern\tcharacters\tmatch\tthe\ttext\tcharacters\tending\twith\tc. Matching\tAlgorithm Now,\tlet\tus\tconcentrate\ton\tthe\tmatching\talgorithm. \u2022 For\ta\tgiven\tpattern\tP[0..\tm\t\u2013\t1],\tfirst\twe\tneed\tto\tbuild\ta\tfinite\tautomaton\tF \u25cb The\tstate\tset\tis\tQ\t=\t{0,1,2,\t...,m} \u25cb The\tstart\tstate\tis\t0 \u25cb The\tonly\taccepting\tstate\tis\tm \u25cb Time\tto\tbuild\tF\tcan\tbe\tlarge\tif\t\u2211\tis\tlarge \u2022 Scan\tthe\ttext\tstring\tT[0..\tn\t\u2013\t1]\tto\tfind\tall\toccurrences\tof\tthe\tpattern\tP[0..\tm\t\u2013\t1] \u2022 String\tmatching\tis\tefficient:\t\u0398(n) \u25cb Each\tcharacter\tis\texamined\texactly\tonce \u25cb Constant\ttime\tfor\teach\tcharacter \u25cb But\t the\t time\t to\t compute\t \u03b4\t (transition\t function)\t is\t O(m|\u2211|).\t This\t is because\t\u03b4\thas\tO(m|\u2211|)\tentries.\tIf\twe\tassume\t|\u2211|\tis\tconstant\tthen\tthe complexity\tbecomes\tO(m). Algorithm: Time\tComplexity:\tO(m)."
            },
            {
                "subchapter_title": "15.6\tKMP\tAlgorithm",
                "content": "As\tbefore,\tlet\tus\tassume\tthat\tT\tis\tthe\tstring\tto\tbe\tsearched\tand\tP\tis\tthe\tpattern\tto\tbe\tmatched.\tThis algorithm\twas\tpresented\tby\tKnuth,\tMorris\tand\tPratt.\tIt\ttakes\tO(n)\ttime\tcomplexity\tfor\tsearching\ta pattern.\t To\t get\t O(n)\t time\t complexity,\t it\t avoids\t the\t comparisons\t with\t elements\t of\t T\t that\t were previously\tinvolved\tin\tcomparison\twith\tsome\telement\tof\tthe\tpattern\tP. The\t algorithm\t uses\t a\t table\t and\t in\t general\t we\t call\t it\t prefix\t function\t or\t prefix\t table\t or\t fail function\tF.\tFirst\twe\twill\tsee\thow\tto\tfill\tthis\ttable\tand\tlater\thow\tto\tsearch\tfor\ta\tpattern\tusing\tthis table.\tThe\tprefix\tfunction\tF\tfor\ta\tpattern\tstores\tthe\tknowledge\tabout\thow\tthe\tpattern\tmatches against\tshifts\tof\titself.\tThis\tinformation\tcan\tbe\tused\tto\tavoid\tuseless\tshifts\tof\tthe\tpattern\tP.\t It means\tthat\tthis\ttable\tcan\tbe\tused\tfor\tavoiding\tbacktracking\ton\tthe\tstring\tT. Prefix\tTable As\tan\texample,\tassume\tthat\tP\t=\ta\tb\ta\tb\ta\tc\ta.\tFor\tthis\tpattern,\tlet\tus\tfollow\tthe\tstep-by-step instructions\tfor\tfilling\tthe\tprefix\ttable\tF.\tInitially:\tm\t=\tlength[P]\t=\t7,F[0]\t=\t0\tand\tF[1]\t=\t0. Step\t1:\ti\t=\t1,j\t=\t0,F[1]\t=0 Step\t2:\ti\t=\t2,j\t=\t0,F[2]\t=\t1 Step\t3:\ti\t=\t3,j\t=\t1,F[3]\t=2 Step\t4:\ti\t=\t4,j\t=\t2,F[4]\t=3 Step\t5:\ti\t=\t5,j\t=\t3,F[5]\t=\t1 Step\t6:\ti\t=\t6,j\t=\t1,F[6]\t=1 At\tthis\tstep\tthe\tfilling\tof\tthe\tprefix\ttable\tis\tcomplete. Matching\tAlgorithm The\tKMP\talgorithm\ttakes\tpattern\tP,\tstring\tT\tand\tprefix\tfunction\tF\tas\tinput,\tand\tfinds\ta\tmatch\tof\tP in\tT. Time\tComplexity:\tO(m\t+\tn),\twhere\tm\tis\tthe\tlength\tof\tthe\tpattern\tand\tn\tis\tthe\tlength\tof\tthe\ttext\tto be\tsearched.\tSpace\tComplexity:\tO(m). Now,\tto\tunderstand\tthe\tprocess\tlet\tus\tgo\tthrough\tan\texample.\tAssume\tthat\tT\t=\tb\ta\tc\tb\ta\tb\ta\tb\ta\tb a\tc\ta\tc\ta\t&\tP\t=\ta\tb\ta\tb\ta\tc\ta.\tSince\twe\thave\talready\tfilled\tthe\tprefix\ttable,\tlet\tus\tuse\tit\tand\tgo\tto the\tmatching\talgorithm.\tInitially:\tn\t=\tsize\tof\tT\t=\t15;\tm\t=\tsize\tof\tP\t=\t7. Step\t1:\ti\t=\t0,\tj\t=\t0,\tcomparing\tP[0]\twith\tT[0].\tP[0]\tdoes\tnot\tmatch\twith\tT[0].\tP\twill\tbe\tshifted one\tposition\tto\tthe\tright. Step\t2\t:i\t=\t1,\tj\t=\t0,\tcomparing\tP[0]\twith\tT[1].\tP[0]\tmatches\twith\tT[1].\tSince\tthere\tis\ta\tmatch,\tP is\tnot\tshifted. Step\t3:\ti\t=\t2,\tj\t=\t1,\tcomparing\tP[1]\twith\tT[2].\tP[1]\tdoes\tnot\tmatch\twith\tT[2].\tBacktracking\ton\tP, comparing\tP[0]\tand\tT[2]. Step\t4:\ti\t=\t3,\tj\t=\t0,\tcomparing\tP[0]\twith\tT[3].\tP[0]\tdoes\tnot\tmatch\twith\tT[3]. Step\t5:\ti\t=\t4,\tj\t=\t0,\tcomparing\tP[0]\twith\tT[4].\tP[0]\tmatches\twith\tT[4]. Step\t6:\ti\t=\t5,\tj\t=\t1,\tcomparing\tP[1]\twith\tT[5].\tP[1]\tmatches\twith\tT[5]. Step\t7:\ti\t=\t6,\tj\t=\t2,\tcomparing\tP[2]\twith\tT[6].\tP[2]\tmatches\twith\tT[6]. Step\t8:\ti\t=\t7,\tj\t=\t3,\tcomparing\tP[3]\twith\tT[7].\tP[3]\tmatches\twith\tT[7]. Step\t9:\ti\t=\t8,\tj\t=\t4,\tcomparing\tP[4]\twith\tT[8].\tP[4]\tmatches\twith\tT[8]. Step\t10:\ti\t=\t9,\tj\t=\t5,\tcomparing\tP[5]\twith\tT[9].\tP[5]\tdoes\tnot\tmatch\twith\tT[9].\tBacktracking\ton P,\tcomparing\tP[4]\twith\tT[9]\tbecause\tafter\tmismatch\t;\t=\tF[4]\t=\t3. Comparing\tP[3]\twith\tT[9]. Step\t11:\ti\t=\t10,\tj\t=\t4,\tcomparing\tP[4]\twith\tT[10].\tP[4]\tmatches\twith\tT[10]. Step\t12:\ti\t=\t11,\tj\t=\t5,\tcomparing\tP[5]\twith\tT[11].\tP[5]\tmatches\twith\tT[11]. Step\t13:\ti\t=\t12,\tj\t=\t6,\tcomparing\tP[6]\twith\tT[12].\tP[6]\tmatches\twith\tT[12]. Pattern\tP\thas\tbeen\tfound\tto\tcompletely\toccur\tin\tstring\tT.\tThe\ttotal\tnumber\tof\tshifts\tthat\ttook\tplace for\tthe\tmatch\tto\tbe\tfound\tare:\ti\t\u2013\tm=\t13\t\u2013\t7\t=\t6\tshifts. Notes: \u2022 KMP\tperforms\tthe\tcomparisons\tfrom\tleft\tto\tright \u2022 KMP\talgorithm\tneeds\ta\tpreprocessing\t(prefix\tfunction)\twhich\ttakes\tO(m)\tspace\tand time\tcomplexity \u2022 Searching\ttakes\tO(n\t+\tm)\ttime\tcomplexity\t(does\tnot\tdepend\ton\talphabet\tsize)"
            },
            {
                "subchapter_title": "15.7\tBoyer-Moore\tAlgorithm",
                "content": "Like\tthe\tKMP\talgorithm,\tthis\talso\tdoes\tsome\tpre-processing\tand\twe\tcall\tit\tlast\tfunction.\t The algorithm\t scans\t the\t characters\t of\t the\t pattern\t from\t right\t to\t left\t beginning\t with\t the\t rightmost character.\tDuring\tthe\ttesting\tof\ta\tpossible\tplacement\tof\tpattern\tP\tin\tT,\ta\tmismatch\tis\thandled\tas follows:\tLet\tus\tassume\tthat\tthe\tcurrent\tcharacter\tbeing\tmatched\tis\tT[i]\t=\tc\tand\tthe\tcorresponding pattern\tcharacter\tis\tP[j].\tIf\tc\tis\tnot\tcontained\tanywhere\tin\tP,\tthen\tshift\tthe\tpattern\tP\tcompletely past\tT[i].\tOtherwise,\tshift\tP\tuntil\tan\toccurrence\tof\tcharacter\tc\tin\tP\tgets\taligned\twith\tT[i].\tThis technique\tavoids\tneedless\tcomparisons\tby\tshifting\tthe\tpattern\trelative\tto\tthe\ttext. The\tlast\tfunction\ttakes\tO(m\t+\t|\u2211|)\ttime\tand\tthe\tactual\tsearch\ttakes\tO(nm)\ttime.\tTherefore\tthe worst\tcase\trunning\ttime\tof\tthe\tBoyer-Moore\talgorithm\tis\tO(nm\t +\t |\u2211|).\t This\t indicates\t that\t the worst-case\trunning\ttime\tis\tquadratic,\tin\tthe\tcase\tof\tn\t==\tm,\tthe\tsame\tas\tthe\tbrute\tforce\talgorithm. \u2022 The\tBoyer-Moore\talgorithm\tis\tvery\tfast\ton\tthe\tlarge\talphabet\t(relative\tto\tthe\tlength of\tthe\tpattern). \u2022 For\tthe\tsmall\talphabet,\tBoyer-Moore\tis\tnot\tpreferable. \u2022 For\tbinary\tstrings,\tthe\tKMP\talgorithm\tis\trecommended. \u2022 For\tthe\tvery\tshortest\tpatterns,\tthe\tbrute\tforce\talgorithm\tis\tbetter."
            },
            {
                "subchapter_title": "15.8\tData\tStructures\tfor\tStoring\tStrings",
                "content": "If\twe\thave\ta\tset\tof\tstrings\t(for\texample,\tall\tthe\twords\tin\tthe\tdictionary)\tand\ta\tword\twhich\twe want\tto\tsearch\tin\tthat\tset,\tin\torder\tto\tperform\tthe\tsearch\toperation\tfaster,\twe\tneed\tan\tefficient way\tof\tstoring\tthe\tstrings.\tTo\tstore\tsets\tof\tstrings\twe\tcan\tuse\tany\tof\tthe\tfollowing\tdata\tstructures. \u2022 Hashing\tTables \u2022 Binary\tSearch\tTrees \u2022 Tries \u2022 Ternary\tSearch\tTrees"
            },
            {
                "subchapter_title": "15.9\tHash\tTables\tfor\tStrings",
                "content": "As\tseen\tin\tthe\tHashing\tchapter,\twe\tcan\tuse\thash\ttables\tfor\tstoring\tthe\tintegers\tor\tstrings.\tIn\tthis case,\tthe\tkeys\tare\tnothing\tbut\tthe\tstrings.\tThe\tproblem\twith\thash\ttable\timplementation\tis\tthat\twe lose\tthe\tordering\tinformation\t\u2013\tafter\tapplying\tthe\thash\tfunction,\twe\tdo\tnot\tknow\twhere\tit\twill map\tto.\tAs\ta\tresult,\tsome\tqueries\ttake\tmore\ttime.\tFor\texample,\tto\tfind\tall\tthe\twords\tstarting\twith the\tletter\t\u201cK\u201d,\twith\thash\ttable\trepresentation\twe\tneed\tto\tscan\tthe\tcomplete\thash\ttable.\tThis\tis because\tthe\thash\tfunction\ttakes\tthe\tcomplete\tkey,\tperforms\thash\ton\tit,\tand\twe\tdo\tnot\tknow\tthe location\tof\teach\tword."
            },
            {
                "subchapter_title": "15.10\tBinary\tSearch\tTrees\tfor\tStrings",
                "content": "In\tthis\trepresentation,\tevery\tnode\tis\tused\tfor\tsorting\tthe\tstrings\talphabetically.\tThis\tis\tpossible because\tthe\tstrings\thave\ta\tnatural\tordering:\tA\tcomes\tbefore\tB,\twhich\tcomes\tbefore\tC,\tand\tso\ton. This\tis\tbecause\twords\tcan\tbe\tordered\tand\twe\tcan\tuse\ta\tBinary\tSearch\tTree\t(BST)\tto\tstore\tand retrieve\tthem.\tFor\texample,\tlet\tus\tassume\tthat\twe\twant\tto\tstore\tthe\tfollowing\tstrings\tusing\tBSTs: this\tis\ta\tcareer\tmonk\tstring For\tthe\tgiven\tstring\tthere\tare\tmany\tways\tof\trepresenting\tthem\tin\tBST.\tOne\tsuch\tpossibility\tis shown\tin\tthe\ttree\tbelow. Issues\twith\tBinary\tSearch\tTree\tRepresentation This\tmethod\tis\tgood\tin\tterms\tof\tstorage\tefficiency.\tBut\tthe\tdisadvantage\tof\tthis\trepresentation\tis that,\tat\tevery\tnode,\tthe\tsearch\toperation\tperforms\tthe\tcomplete\tmatch\tof\tthe\tgiven\tkey\twith\tthe node\tdata,\tand\tas\ta\tresult\tthe\ttime\tcomplexity\tof\tthe\tsearch\toperation\tincreases.\tSo,\tfrom\tthis\twe can\tsay\tthat\tBST\trepresentation\tof\tstrings\tis\tgood\tin\tterms\tof\tstorage\tbut\tnot\tin\tterms\tof\ttime."
            },
            {
                "subchapter_title": "15.11\tTries",
                "content": "Now,\t let\t us\t see\t the\t alternative\t representation\t that\t reduces\t the\t time\t complexity\t of\t the\t search operation.\tThe\tname\ttrie\tis\ttaken\tfrom\tthe\tword\tre\u201dtrie\u201d. What\tis\ta\tTrie? A\ttrie\t is\t a\t tree\t and\t each\t node\t in\t it\t contains\t the\t number\t of\t pointers\t equal\t to\t the\t number\t of characters\tof\tthe\talphabet.\tFor\texample,\tif\twe\tassume\tthat\tall\tthe\tstrings\tare\tformed\twith\tEnglish alphabet\t characters\t \u201ca\u201d\t to\t \u201cz\u201d\t then\t each\t node\t of\t the\t trie\t contains\t 26\t pointers.\t A\t trie\t data structure\tcan\tbe\tdeclared\tas: Suppose\twe\twant\tto\tstore\tthe\tstrings\t\u201ca\u201d,\u201dall\u201d,\u201dals\u201d,\tand\t\u201cas\u201d\u201c:\ttrie\tfor\tthese\tstrings\twill\tlook like: Why\tTries? The\ttries\tcan\tinsert\tand\tfind\tstrings\tin\tO(L)\ttime\t(where\tL\trepresents\tthe\tlength\tof\ta\tsingle\tword). This\tis\tmuch\tfaster\tthan\thash\ttable\tand\tbinary\tsearch\ttree\trepresentations. Trie\tDeclaration The\tstructure\tof\tthe\tTrieNode\thas\tdata\t(char),\tis_End_Of_String\t(boolean),\tand\thas\ta\tcollection of\tchild\tnodes\t(Collection\tof\tTrieNodes).\tIt\talso\thas\tone\tmore\tmethod\tcalled\tsubNode(char). This\tmethod\ttakes\ta\tcharacter\tas\targument\tand\twill\treturn\tthe\tchild\tnode\tof\tthat\tcharacter\ttype\tif that\tis\tpresent.\tThe\tbasic\telement\t-\tTrieNode\tof\ta\tTRIE\tdata\tstructure\tlooks\tlike\tthis: Now\tthat\twe\thave\tdefined\tour\tTrieNode,\tlet\u2019s\tgo\tahead\tand\tlook\tat\tthe\tother\toperations\tof\tTRIE. Fortunately,\t the\t TRIE\t data\t structure\t is\t simple\t to\t implement\t since\t it\t has\t two\t major\t methods: insert()\tand\tsearch().\tLet\u2019s\tlook\tat\tthe\telementary\timplementation\tof\tboth\tthese\tmethods. Inserting\ta\tString\tin\tTrie To\tinsert\ta\tstring,\twe\tjust\tneed\tto\tstart\tat\tthe\troot\tnode\tand\tfollow\tthe\tcorresponding\tpath\t(path from\troot\tindicates\tthe\tprefix\tof\tthe\tgiven\tstring).\tOnce\twe\treach\tthe\tNULL\tpointer,\twe\tjust\tneed to\tcreate\ta\tskew\tof\ttail\tnodes\tfor\tthe\tremaining\tcharacters\tof\tthe\tgiven\tstring. Time\tComplexity:\tO(L),\twhere\tL\tis\tthe\tlength\tof\tthe\tstring\tto\tbe\tinserted. Note:\t For\t real\t dictionary\t implementation,\t we\t may\t need\t a\t few\t more\t checks\t such\t as\t checking whether\tthe\tgiven\tstring\tis\talready\tthere\tin\tthe\tdictionary\tor\tnot. Searching\ta\tString\tin\tTrie The\tsame\tis\tthe\tcase\twith\tthe\tsearch\toperation:\twe\tjust\tneed\tto\tstart\tat\tthe\troot\tand\tfollow\tthe pointers.\tThe\ttime\tcomplexity\tof\tthe\tsearch\toperation\tis\tequal\tto\tthe\tlength\tof\tthe\tgiven\tstring\tthat want\tto\tsearch. Time\tComplexity:\tO(L),\twhere\tL\tis\tthe\tlength\tof\tthe\tstring\tto\tbe\tsearched. Issues\twith\tTries\tRepresentation The\tmain\tdisadvantage\tof\ttries\tis\tthat\tthey\tneed\tlot\tof\tmemory\tfor\tstoring\tthe\tstrings.\tAs\twe\thave seen\tabove,\tfor\teach\tnode\twe\thave\ttoo\tmany\tnode\tpointers.\tIn\tmany\tcases,\tthe\toccupancy\tof\teach node\tis\tless.\tThe\tfinal\tconclusion\tregarding\ttries\tdata\tstructure\tis\tthat\tthey\tare\tfaster\tbut\trequire huge\tmemory\tfor\tstoring\tthe\tstrings. Note:\tThere\tare\tsome\timproved\ttries\trepresentations\tcalled\ttrie\tcompression\ttechniques.\t But, even\twith\tthose\ttechniques\twe\tcan\treduce\tthe\tmemory\tonly\tat\tthe\tleaves\tand\tnot\tat\tthe\tinternal nodes."
            },
            {
                "subchapter_title": "15.12\tTernary\tSearch\tTrees",
                "content": "This\trepresentation\twas\tinitially\tprovided\tby\tJon\tBentley\tand\tSedgewick.\tA\tternary\tsearch\ttree takes\t the\t advantages\t of\t binary\t search\t trees\t and\t tries.\t That\t means\t it\t combines\t the\t memory efficiency\tof\tBSTs\tand\tthe\ttime\tefficiency\tof\ttries. Ternary\tSearch\tTrees\tDeclaration The\tTernary\tSearch\tTree\t(TST)\tuses\tthree\tpointers: \u2022 The\tleft\tpointer\tpoints\tto\tthe\tTST\tcontaining\tall\tthe\tstrings\twhich\tare\talphabetically less\tthan\tdata. \u2022 The\t right\t pointer\t points\t to\t the\t TST\t containing\t all\t the\t strings\t which\t are alphabetically\tgreater\tthan\tdata. \u2022 The\teq\tpointer\tpoints\tto\tthe\tTST\tcontaining\tall\tthe\tstrings\twhich\tare\talphabetically equal\t to\t data.\t That\t means,\t if\t we\t want\t to\t search\t for\t a\t string,\t and\t if\t the\t current character\tof\tthe\tinput\tstring\tand\tthe\tdata\tof\tcurrent\tnode\tin\tTST\tare\tthe\tsame,\tthen we\t need\t to\t proceed\t to\t the\t next\t character\t in\t the\t input\t string\t and\t search\t it\t in\t the subtree\twhich\tis\tpointed\tby\teq. Inserting\tstrings\tin\tTernary\tSearch\tTree For\tsimplicity\tlet\tus\tassume\tthat\twe\twant\tto\tstore\tthe\tfollowing\twords\tin\tTST\t(also\tassume\tthe same\torder):\tboats,\tboat,\tbat\tand\tbats.\tInitially,\tlet\tus\tstart\twith\tthe\tboats\tstring. Now\tif\twe\twant\tto\tinsert\tthe\tstring\tboat,\tthen\tthe\tTST\tbecomes\t[the\tonly\tchange\tis\tsetting\tthe is_End_Of_String\tflag\tof\t\u201ct\u201d\tnode\tto\t1]: Now,\tlet\tus\tinsert\tthe\tnext\tstring:\tbat Now,\tlet\tus\tinsert\tthe\tfinal\tword:\tbats. Based\ton\tthese\texamples,\twe\tcan\twrite\tthe\tinsertion\talgorithm\tas\tbelow.\tWe\twill\tcombine\tthe insertion\toperation\tof\tBST\tand\ttries. Time\tComplexity:\tO(L),\twhere\tL\tis\tthe\tlength\tof\tthe\tstring\tto\tbe\tinserted. Searching\tin\tTernary\tSearch\tTree If\tafter\tinserting\tthe\twords\twe\twant\tto\tsearch\tfor\tthem,\tthen\twe\thave\tto\tfollow\tthe\tsame\trules\tas that\tof\tbinary\tsearch.\tThe\tonly\tdifference\tis,\tin\tcase\tof\tmatch\twe\tshould\tcheck\tfor\tthe\tremaining characters\t(in\teq\tsubtree)\tinstead\tof\treturn.\tAlso,\tlike\tBSTs\twe\twill\tsee\tboth\trecursive\tand\tnon- recursive\tversions\tof\tthe\tsearch\tmethod. Time\tComplexity:\tO(L),\twhere\tL\tis\tthe\tlength\tof\tthe\tstring\tto\tbe\tsearched. Displaying\tAll\tWords\tof\tTernary\tSearch\tTree If\twe\twant\tto\tprint\tall\tthe\tstrings\tof\tTST\twe\tcan\tuse\tthe\tfollowing\talgorithm.\tIf\twe\twant\tto\tprint them\tin\tsorted\torder,\twe\tneed\tto\tfollow\tthe\tinorder\ttraversal\tof\tTST. Finding\tthe\tLength\tof\tthe\tLargest\tWord\tin\tTST This\tis\tsimilar\tto\tfinding\tthe\theight\tof\tthe\tBST\tand\tcan\tbe\tfound\tas:"
            },
            {
                "subchapter_title": "15.13\tComparing\tBSTs,\tTries\tand\tTSTs",
                "content": "\u2022 Hash\ttable\tand\tBST\timplementation\tstores\tcomplete\tthe\tstring\tat\teach\tnode.\tAs\ta result\tthey\ttake\tmore\ttime\tfor\tsearching.\tBut\tthey\tare\tmemory\tefficient. \u2022 TSTs\tcan\tgrow\tand\tshrink\tdynamically\tbut\thash\ttables\tresize\tonly\tbased\ton\tload factor. \u2022 TSTs\tallow\tpartial\tsearch\twhereas\tBSTs\tand\thash\ttables\tdo\tnot\tsupport\tit. \u2022 TSTs\tcan\tdisplay\tthe\twords\tin\tsorted\torder,\tbut\tin\thash\ttables\twe\tcannot\tget\tthe sorted\torder. \u2022 Tries\tperform\tsearch\toperations\tvery\tfast\tbut\tthey\ttake\thuge\tmemory\tfor\tstoring\tthe string. \u2022 TSTs\t combine\t the\t advantages\t of\t BSTs\t and\t Tries.\t That\t means\t they\t combine\t the memory\tefficiency\tof\tBSTs\tand\tthe\ttime\tefficiency\tof\ttries"
            },
            {
                "subchapter_title": "15.14\tSuffix\tTrees",
                "content": "Suffix\ttrees\tare\tan\timportant\tdata\tstructure\tfor\tstrings.\tWith\tsuffix\ttrees\twe\tcan\tanswer\tthe\tqueries very\tfast.\tBut\tthis\trequires\tsome\tpreprocessing\tand\tconstruction\tof\ta\tsuffix\ttree.\tEven\tthough\tthe construction\tof\ta\tsuffix\ttree\tis\tcomplicated,\tit\tsolves\tmany\tother\tstring-related\tproblems\tin\tlinear time. Note:\tSuffix\ttrees\tuse\ta\ttree\t(suffix\ttree)\tfor\tone\tstring,\twhereas\tHash\ttables,\tBSTs,\tTries\tand TSTs\tstore\ta\tset\tof\tstrings.\tThat\tmeans,\ta\tsuffix\ttree\tanswers\tthe\tqueries\trelated\tto\tone\tstring. Let\tus\tsee\tthe\tterminology\twe\tuse\tfor\tthis\trepresentation. Prefix\tand\tSuffix Given\ta\tstring\tT\t=\tT1T2\t\u2026\tTn,\tthe\tprefix\tof\tT\tis\ta\tstring\tT1\t...Ti\twhere\ti\tcan\ttake\tvalues\tfrom\t1\tto n.\tFor\texample,\tif\tT\t=\tbanana,\tthen\tthe\tprefixes\tof\tT\tare:\tb,\tba,\tban,\tbana,\tbanan,\tbanana. Similarly,\tgiven\ta\tstring\tT\t=\tT1T2\t\u2026\tTn,\tthe\tsuffix\tof\tT\tis\ta\tstring\tTi\t...Tn\twhere\ti\tcan\ttake\tvalues from\tn\tto\t1.\tFor\texample,\tif\tT\t=\tbanana,\tthen\tthe\tsuffixes\tof\tT\tare:\ta,\tna,\tana,\tnana,\tanana, banana. Observation From\tthe\tabove\texample,\twe\tcan\teasily\tsee\tthat\tfor\ta\tgiven\ttext\tT\tand\tpattern\tP,\tthe\texact\tstring matching\tproblem\tcan\talso\tbe\tdefined\tas: \u2022 Find\ta\tsuffix\tof\tT\tsuch\tthat\tP\tis\ta\tprefix\tof\tthis\tsuffix\tor \u2022 Find\ta\tprefix\tof\tT\tsuch\tthat\tP\tis\ta\tsuffix\tof\tthis\tprefix. Example:\tLet\tthe\ttext\tto\tbe\tsearched\tbe\tT\t=\tacebkkbac\tand\tthe\tpattern\tbe\tP\t=\tkkb.\t For\t this example,\tP\tis\ta\tprefix\tof\tthe\tsuffix\tkkbac\tand\talso\ta\tsuffix\tof\tthe\tprefix\tacebkkb. What\tis\ta\tSuffix\tTree? In\tsimple\tterms,\tthe\tsuffix\ttree\tfor\ttext\tT\tis\ta\tTrie-like\tdata\tstructure\tthat\trepresents\tthe\tsuffixes\tof T.\tThe\tdefinition\tof\tsuffix\ttrees\tcan\tbe\tgiven\tas:\tA\tsuffix\ttree\tfor\ta\tn\tcharacter\tstring\tT[1\t...n]\tis\ta rooted\ttree\twith\tthe\tfollowing\tproperties. \u2022 A\tsuffix\ttree\twill\tcontain\tn\tleaves\twhich\tare\tnumbered\tfrom\t1\tto\tn \u2022 Each\tinternal\tnode\t(except\troot)\tshould\thave\tat\tleast\t2\tchildren \u2022 Each\tedge\tin\ta\ttree\tis\tlabeled\tby\ta\tnonempty\tsubstring\tof\tT \u2022 No\ttwo\tedges\tof\ta\tnode\t(children\tedges)\tbegin\twith\tthe\tsame\tcharacter \u2022 The\tpaths\tfrom\tthe\troot\tto\tthe\tleaves\trepresent\tall\tthe\tsuffixes\tof\tT The\tConstruction\tof\tSuffix\tTrees Algorithm"
            }
        ]
    },
    {
        "chapter_title": "1.",
        "subchapters": [
            {
                "subchapter_title": "Let\tS\tbe\tthe\tset\tof\tall\tsuffixes\tof\tT.\tAppend\t$\tto\teach\tof\tthe\tsuffixes.",
                "content": ""
            }
        ]
    },
    {
        "chapter_title": "2.",
        "subchapters": [
            {
                "subchapter_title": "Sort\tthe\tsuffixes\tin\tS\tbased\ton\ttheir\tfirst\tcharacter.",
                "content": ""
            }
        ]
    },
    {
        "chapter_title": "3.",
        "subchapters": [
            {
                "subchapter_title": "For\teach\tgroup\tSc\t(c\t\u2208\t\u2211):",
                "content": "(i)\tIf\tSc\tgroup\thas\tonly\tone\telement,\tthen\tcreate\ta\tleaf\tnode. (ii)\tOtherwise,\tfind\tthe\tlongest\tcommon\tprefix\tof\tthe\tsuffixes\tin\tSc\t group, create\tan\tinternal\tnode,\tand\trecursively\tcontinue\twith\tStep\t2,\tS\tbeing the\t set\t of\t remaining\t suffixes\t from\t Sc\t after\t splitting\t off\t the\t longest common\tprefix. For\tbetter\tunderstanding,\tlet\tus\tgo\tthrough\tan\texample.\tLet\tthe\tgiven\ttext\tbe\tT\t=\ttatat.\tFor\tthis string,\tgive\ta\tnumber\tto\teach\tof\tthe\tsuffixes. Index Suffix 1 $ 2 t$ 3 at$ 4 tat$ 5 atat$ 6 tatat$ Now,\tsort\tthe\tsuffixes\tbased\ton\ttheir\tinitial\tcharacters. In\tthe\tthree\tgroups,\tthe\tfirst\tgroup\thas\tonly\tone\telement.\tSo,\tas\tper\tthe\talgorithm,\tcreate\ta\tleaf node\tfor\tit,\tas\tshown\tbelow. Now,\tfor\tS2\tand\tS3\t(as\tthey\thave\tmore\tthan\tone\telement),\tlet\tus\tfind\tthe\tlongest\tprefix\tin\tthe group,\tand\tthe\tresult\tis\tshown\tbelow. For\tS2\tand\tS3,\tcreate\tinternal\tnodes,\tand\tthe\tedge\tcontains\tthe\tlongest\tcommon\tprefix\tof\tthose groups. Now\twe\thave\tto\tremove\tthe\tlongest\tcommon\tprefix\tfrom\tthe\tS2\tand\tS3\tgroup\telements. Out\tnext\tstep\tis\tsolving\tS2\tand\tS3\trecursively.\tFirst\tlet\tus\ttake\tS2.\tIn\tthis\tgroup,\tif\twe\tsort\tthem based\ton\ttheir\tfirst\tcharacter,\tit\tis\teasy\tto\tsee\tthat\tthe\tfirst\tgroup\tcontains\tonly\tone\telement\t$,\tand the\tsecond\tgroup\talso\tcontains\tonly\tone\telement,\tat$.\tSince\tboth\tgroups\thave\tonly\tone\telement, we\tcan\tdirectly\tcreate\tleaf\tnodes\tfor\tthem. At\tthis\tstep,\tboth\tS1\tand\tS2\telements\tare\tdone\tand\tthe\tonly\tremaining\tgroup\tis\tS3.\tAs\tsimilar\tto earlier\tsteps,\tin\tthe\tS3\tgroup,\tif\twe\tsort\tthem\tbased\ton\ttheir\tfirst\tcharacter,\tit\tis\teasy\tto\tsee\tthat there\tis\tonly\tone\telement\tin\tthe\tfirst\tgroup\tand\tit\tis\t$.\tFor\tS3\tremaining\telements,\tremove\tthe longest\tcommon\tprefix. In\tthe\tS3\tsecond\tgroup,\tthere\tare\ttwo\telements:\t$\tand\tat$.\tWe\tcan\tdirectly\tadd\tthe\tleaf\tnodes\tfor the\tfirst\tgroup\telement\t$.\tLet\tus\tadd\tS3\tsubtree\tas\tshown\tbelow. Now,\tS3\tcontains\ttwo\telements.\tIf\twe\tsort\tthem\tbased\ton\ttheir\tfirst\tcharacter,\tit\tis\teasy\tto\tsee\tthat there\tare\tonly\ttwo\telements\tand\tamong\tthem\tone\tis\t$\tand\tother\tis\tat$.\tWe\tcan\tdirectly\tadd\tthe leaf\tnodes\tfor\tthem.\tLet\tus\tadd\tS3\tsubtree\tas\tshown\tbelow. Since\tthere\tare\tno\tmore\telements,\tthis\tis\tthe\tcompletion\tof\tthe\tconstruction\tof\tthe\tsuffix\ttree\tfor string\tT\t=\ttatat.\tThe\ttime-complexity\tof\tthe\tconstruction\tof\ta\tsuffix\ttree\tusing\tthe\tabove\talgorithm is\tO(n2)\twhere\tn\tis\tthe\tlength\tof\tthe\tinput\tstring\tbecause\tthere\tare\tn\tdistinct\tsuffixes.\tThe\tlongest has\tlength\tn,\tthe\tsecond\tlongest\thas\tlength\tn\t\u2013\t1,\tand\tso\ton. Note: \u2022 There\tare\tO(n)\talgorithms\tfor\tconstructing\tsuffix\ttrees. \u2022 To\timprove\tthe\tcomplexity,\twe\tcan\tuse\tindices\tinstead\tof\tstring\tfor\tbranches. Applications\tof\tSuffix\tTrees All\tthe\tproblems\tbelow\t(but\tnot\tlimited\tto\tthese)\ton\tstrings\tcan\tbe\tsolved\twith\tsuffix\ttrees\tvery efficiently\t(for\talgorithms\trefer\tto\tProblems\tsection). \u2022 Exact\tString\tMatching:\tGiven\ta\ttext\tT\tand\ta\tpattern\tP,\thow\tdo\twe\tcheck\twhether\tP appears\tin\tT\tor\tnot? \u2022 Longest\tRepeated\tSubstring:\tGiven\ta\ttext\tT\thow\tdo\twe\tfind\tthe\tsubstring\tof\tT\tthat is\tthe\tmaximum\trepeated\tsubstring? \u2022 Longest\tPalindrome:\tGiven\ta\ttext\tT\thow\tdo\twe\tfind\tthe\tsubstring\tof\tT\tthat\tis\tthe longest\tpalindrome\tof\tT? \u2022 Longest\t Common\t Substring:\t Given\t two\t strings,\t how\t do\t we\t find\t the\t longest common\tsubstring? \u2022 Longest\tCommon\tPrefix:\tGiven\ttwo\tstrings\tX[i\t...n]\tand\tY[j\t...m],how\tdo\twe\tfind the\tlongest\tcommon\tprefix? \u2022 How\tdo\twe\tsearch\tfor\ta\tregular\texpression\tin\tgiven\ttext\tT? \u2022 Given\ta\ttext\tT\tand\ta\tpattern\tP,\thow\tdo\twe\tfind\tthe\tfirst\toccurrence\tof\tP\tin\tT?"
            },
            {
                "subchapter_title": "15.15\tString\tAlgorithms:\tProblems\t&\tSolutions",
                "content": "Problem-1\u2003\u2003Given\t a\t paragraph\t of\t words,\t give\t an\t algorithm\t for\t finding\t the\t word\t which appears\tthe\tmaximum\tnumber\tof\ttimes.\tIf\tthe\tparagraph\tis\tscrolled\tdown\t(some\twords disappear\tfrom\tthe\tfirst\tframe,\tsome\twords\tstill\tappear,\tand\tsome\tare\tnew\twords),\tgive the\tmaximum\toccurring\tword.\tThus,\tit\tshould\tbe\tdynamic. Solution:\tFor\tthis\tproblem\twe\tcan\tuse\ta\tcombination\tof\tpriority\tqueues\tand\ttries.\tWe\tstart\tby creating\ta\ttrie\tin\twhich\twe\tinsert\ta\tword\tas\tit\tappears,\tand\tat\tevery\tleaf\tof\ttrie.\tIts\tnode\tcontains that\tword\talong\twith\ta\tpointer\tthat\tpoints\tto\tthe\tnode\tin\tthe\theap\t[priority\tqueue]\twhich\twe\talso create.\tThis\theap\tcontains\tnodes\twhose\tstructure\tcontains\ta\tcounter.\tThis\tis\tits\tfrequency\tand also\ta\tpointer\tto\tthat\tleaf\tof\ttrie,\twhich\tcontains\tthat\tword\tso\tthat\tthere\tis\tno\tneed\tto\tstore\tthe word\ttwice. Whenever\t a\t new\t word\t comes\t up,\t we\t find\t it\t in\t trie.\t If\t it\t is\t already\t there,\t we\t increase\t the frequency\tof\tthat\tnode\tin\tthe\theap\tcorresponding\tto\tthat\tword,\tand\twe\tcall\tit\theapify.\tThis\tis\tdone so\tthat\tat\tany\tpoint\tof\ttime\twe\tcan\tget\tthe\tword\tof\tmaximum\tfrequency.\tWhile\tscrolling,\twhen\ta word\tgoes\tout\tof\tscope,\twe\tdecrement\tthe\tcounter\tin\theap.\tIf\tthe\tnew\tfrequency\tis\tstill\tgreater than\tzero,\theapify\tthe\theap\tto\tincorporate\tthe\tmodification.\tIf\tthe\tnew\tfrequency\tis\tzero,\tdelete\tthe node\tfrom\theap\tand\tdelete\tit\tfrom\ttrie. Problem-2\u2003\u2003Given\ttwo\tstrings,\thow\tcan\twe\tfind\tthe\tlongest\tcommon\tsubstring? Solution:\tLet\tus\tassume\tthat\tthe\tgiven\ttwo\tstrings\tare\tT1\tand\tT2.\tThe\tlongest\tcommon\tsubstring\tof two\tstrings,\tT1\tand\tT2,\tcan\tbe\tfound\tby\tbuilding\ta\tgeneralized\tsuffix\ttree\tfor\tT1\t and\tT2.\t That means\twe\tneed\tto\tbuild\ta\tsingle\tsuffix\ttree\tfor\tboth\tthe\tstrings.\tEach\tnode\tis\tmarked\tto\tindicate\tif it\t represents\t a\t suffix\t of\t T1\t or\t T2\t or\t both.\t This\t indicates\t that\t we\t need\t to\t use\t different\t marker symbols\tfor\tboth\tthe\tstrings\t(for\texample,\twe\tcan\tuse\t$\tfor\tthe\tfirst\tstring\tand\t#\tfor\tthe\tsecond symbol).\tAfter\tconstructing\tthe\tcommon\tsuffix\ttree,\tthe\tdeepest\tnode\tmarked\tfor\tboth\tT1\tand\tT2 represents\tthe\tlongest\tcommon\tsubstring. Another\tway\tof\tdoing\tthis\tis:\tWe\tcan\tbuild\ta\tsuffix\ttree\tfor\tthe\tstring\tT1$T2#.\tThis\tis\tequivalent to\tbuilding\ta\tcommon\tsuffix\ttree\tfor\tboth\tthe\tstrings. Time\tComplexity:\tO(m\t+\tn),\twhere\tm\tand\tn\tare\tthe\tlengths\tof\tinput\tstrings\tT1\tand\tT2. Problem-3\u2003\u2003Longest\tPalindrome:\tGiven\ta\ttext\tT\thow\tdo\twe\tfind\tthe\tsubstring\tof\tT\twhich\tis the\tlongest\tpalindrome\tof\tT? Solution:\tThe\tlongest\tpalindrome\tof\tT[1..n]\tcan\tbe\tfound\tin\tO(n)\ttime.\tThe\talgorithm\tis:\tfirst build\ta\tsuffix\ttree\tfor\tT$reverse(T)#\tor\tbuild\ta\tgeneralized\tsuffix\ttree\tfor\tT\tand\treverse(T).\tAfter building\tthe\tsuffix\ttree,\tfind\tthe\tdeepest\tnode\tmarked\twith\tboth\t$\tand\t#.\tBasically\tit\tmeans\tfind the\tlongest\tcommon\tsubstring. Problem-4\u2003\u2003Given\t a\t string\t (word),\t give\t an\t algorithm\t for\t finding\t the\t next\t word\t in\t the dictionary. Solution:\tLet\tus\tassume\tthat\twe\tare\tusing\tTrie\tfor\tstoring\tthe\tdictionary\twords.\tTo\tfind\tthe\tnext word\tin\tTries\twe\tcan\tfollow\ta\tsimple\tapproach\tas\tshown\tbelow.\tStarting\tfrom\tthe\trightmost character,\tincrement\tthe\tcharacters\tone\tby\tone.\tOnce\twe\treach\tZ,\tmove\tto\tthe\tnext\tcharacter\ton the\tleft\tside. Whenever\twe\tincrement,\tcheck\tif\tthe\tword\twith\tthe\tincremented\tcharacter\texists\tin\tthe\tdictionary or\tnot.\tIf\tit\texists,\tthen\treturn\tthe\tword,\totherwise\tincrement\tagain.\tIf\twe\tuse\tTST,\tthen\twe\tcan find\tthe\tinorder\tsuccessor\tfor\tthe\tcurrent\tword. Problem-5\u2003\u2003Give\tan\talgorithm\tfor\treversing\ta\tstring. Solution: Time\tComplexity:\tO(n),\twhere\tn\tis\tthe\tlength\tof\tthe\tgiven\tstring.\tSpace\tComplexity:\tO(n). Problem-6\u2003\u2003If\tthe\tstring\tis\tnot\teditable,\thow\tdo\twe\tcreate\ta\tstring\tthat\tis\tthe\treverse\tof\tthe given\tstring? Solution:\tIf\tthe\tstring\tis\tnot\teditable,\tthen\twe\tneed\tto\tcreate\tan\tarray\tand\treturn\tthe\tpointer\tof that. Time\tComplexity:\t ,\twhere\tn\tis\tthe\tlength\tof\tthe\tgiven\tstring.\tSpace\tComplexity: O(1). Problem-7\u2003\u2003Can\twe\treverse\tthe\tstring\twithout\tusing\tany\ttemporary\tvariable? Solution:\tYes,\twe\tcan\tuse\tXOR\tlogic\tfor\tswapping\tthe\tvariables. Time\tComplexity:\t ,\twhere\tn\tis\tthe\tlength\tof\tthe\tgiven\tstring.\tSpace\tComplexity: O(1). Problem-8\u2003\u2003Given\ta\ttext\tand\ta\tpattern,\tgive\tan\talgorithm\tfor\tmatching\tthe\tpattern\tin\tthe\ttext. Assume\t ?\t (single\t character\t matcher)\t and\t *\t (multi\t character\t matcher)\t are\t the\t wild\t card characters. Solution:\tBrute\tForce\tMethod.\tFor\tefficient\tmethod,\trefer\tto\tthe\ttheory\tsection. Time\tComplexity:\tO(mn),\twhere\tm\tis\tthe\tlength\tof\tthe\ttext\tand\tn\tis\tthe\tlength\tof\tthe\tpattern. Space\tComplexity:\tO(1). Problem-9\u2003\u2003Give\tan\talgorithm\tfor\treversing\twords\tin\ta\tsentence. Example:\tInput:\t\u201cThis\tis\ta\tCareer\tMonk\tString\u201d,\tOutput:\t\u201cString\tMonk\tCareer\ta\tis\tThis\u201d Solution:\tStart\tfrom\tthe\tbeginning\tand\tkeep\ton\treversing\tthe\twords.\tThe\tbelow\timplementation assumes\tthat\t\u2018\t\u2018\t(space)\tis\tthe\tdelimiter\tfor\twords\tin\tgiven\tsentence. Time\tComplexity:\tO(2n)\t\u2248\tO(n),\twhere\tn\tis\tthe\tlength\tof\tthe\tstring.\tSpace\tComplexity:\tO(1). Problem-10\u2003\u2003Permutations\t of\t a\t string\t [anagrams]:\t Give\t an\t algorithm\t for\t printing\t all possible\tpermutations\tof\tthe\tcharacters\tin\ta\tstring.\tUnlike\tcombinations,\ttwo\tpermutations are\t considered\t distinct\t if\t they\t contain\t the\t same\t characters\t but\t in\t a\t different\t order.\t For simplicity\tassume\tthat\teach\toccurrence\tof\ta\trepeated\tcharacter\tis\ta\tdistinct\tcharacter.\tThat is,\tif\tthe\tinput\tis\t\u201caaa\u201d,\tthe\toutput\tshould\tbe\tsix\trepetitions\tof\t\u201caaa\u201d.\tThe\tpermutations\tmay be\toutput\tin\tany\torder. Solution:\tThe\tsolution\tis\treached\tby\tgenerating\tn!\tstrings,\teach\tof\tlength\tn,\twhere\tn\tis\tthe\tlength of\tthe\tinput\tstring. Problem-11\u2003\u2003Combinations\t Combinations\t of\t a\t String:\t Unlike\t permutations,\t two combinations\tare\tconsidered\tto\tbe\tthe\tsame\tif\tthey\tcontain\tthe\tsame\tcharacters,\tbut\tmay\tbe in\t a\t different\t order.\t Give\t an\t algorithm\t that\t prints\t all\t possible\t combinations\t of\t the characters\tin\ta\tstring.\tFor\texample,\t\u201cac\u201d\tand\t\u201cab\u201d\tare\tdifferent\tcombinations\tfrom\tthe input\tstring\t\u201cabc\u201d,\tbut\t\u201cab\u201d\tis\tthe\tsame\tas\t\u201cba\u201d. Solution:\tThe\tsolution\tis\tachieved\tby\tgenerating\tn!/r!\t(n\t\u2013\tr)!\tstrings,\teach\tof\tlength\tbetween\t1 and\tn\twhere\tn\tis\tthe\tlength\tof\tthe\tgiven\tinput\tstring. Algorithm: For\teach\tof\tthe\tinput\tcharacters a. Put\tthe\tcurrent\tcharacter\tin\toutput\tstring\tand\tprint\tit. b. If\t there\t are\t any\t remaining\t characters,\t generate\t combinations\t with\t those remaining\tcharacters. Problem-12\u2003\u2003Given\ta\tstring\t\u201cABCCBCBA\u201d,\tgive\tan\talgorithm\tfor\trecursively\tremoving\tthe adjacent\tcharacters\tif\tthey\tare\tthe\tsame.\tFor\texample,\tABCCBCBA\tnnnnnn>\tABBCBA- >ACBA Solution:\tFirst\twe\tneed\tto\tcheck\tif\twe\thave\ta\tcharacter\tpair;\tif\tyes,\tthen\tcancel\tit.\tNow\tcheck\tfor next\tcharacter\tand\tprevious\telement.\tKeep\tcanceling\tthe\tcharacters\tuntil\twe\teither\treach\tthe\tstart of\tthe\tarray,\treach\tthe\tend\tof\tthe\tarray,\tor\tdon\u2019t\tfind\ta\tpair. Problem-13\u2003\u2003Given\ta\tset\tof\tcharacters\tCHARS\tand\ta\tinput\tstring\tINPUT,\tfind\tthe\tminimum window\tin\tstr\twhich\twill\tcontain\tall\tthe\tcharacters\tin\tCHARS\tin\tcomplexity\tO(n).\t For example,\tINPUT\t=\tABBACBAA\tand\tCHARS\t=\tAAB\thas\tthe\tminimum\twindow\tBAA. Solution:\tThis\talgorithm\tis\tbased\ton\tthe\tsliding\twindow\tapproach.\tIn\tthis\tapproach,\twe\tstart from\tthe\tbeginning\tof\tthe\tarray\tand\tmove\tto\tthe\tright.\tAs\tsoon\tas\twe\thave\ta\twindow\twhich\thas\tall the\t required\t elements,\t try\t sliding\t the\t window\t as\t far\t right\t as\t possible\t with\t all\t the\t required elements.\tIf\tthe\tcurrent\twindow\tlength\tis\tless\tthan\tthe\tminimum\tlength\tfound\tuntil\tnow,\tupdate\tthe minimum\tlength.\tFor\texample,\tif\tthe\tinput\tarray\tis\tABBACBAA\tand\tthe\tminimum\twindow\tshould cover\tcharacters\tAAB,\tthen\tthe\tsliding\twindow\twill\tmove\tlike\tthis: Algorithm:\tThe\tinput\tis\tthe\tgiven\tarray\tand\tchars\tis\tthe\tarray\tof\tcharacters\tthat\tneed\tto\tbe\tfound. 1 Make\tan\tinteger\tarray\tshouldfind[]\tof\tlen\t256.\tThe\tith\telement\tof\tthis\tarray\twill\thave the\tcount\tof\thow\tmany\ttimes\twe\tneed\tto\tfind\tthe\telement\tof\tASCII\tvalue\ti. 2 Make\t another\t array\t hasfound\t of\t 256\t elements,\t which\t will\t have\t the\t count\t of\t the required\telements\tfound\tuntil\tnow. 3 Count\t<=\t0 4 While\tinput[i] a. If\tinput[i]\telement\tis\tnot\tto\tbe\tfound\u2192\tcontinue b. If\tinput[i]\telement\tis\trequired\t=>\tincrease\tcount\tby\t1. c. If\tcount\tis\tlength\tof\tchars[]\tarray,\tslide\tthe\twindow\tas\tmuch\tright\tas possible. d. If\tcurrent\twindow\tlength\tis\tless\tthan\tmin\tlength\tfound\tuntil\tnow,\tupdate min\tlength. Complexity:\tIf\twe\twalk\tthrough\tthe\tcode,\ti\tand\tj\tcan\ttraverse\tat\tmost\tn\tsteps\t(where\tn\tis\tthe\tinput size)\tin\tthe\tworst\tcase,\tadding\tto\ta\ttotal\tof\t2n\ttimes.\tTherefore,\ttime\tcomplexity\tis\tO(n). Problem-14\u2003\u2003We\tare\tgiven\ta\t2D\tarray\tof\tcharacters\tand\ta\tcharacter\tpattern.\tGive\tan\talgorithm to\tfind\tif\tthe\tpattern\tis\tpresent\tin\tthe\t2D\tarray.\tThe\tpattern\tcan\tbe\tin\tany\torder\t(all\t8 neighbors\tto\tbe\tconsidered)\tbut\twe\tcan\u2019t\tuse\tthe\tsame\tcharacter\ttwice\twhile\tmatching. Return\t 1\t if\t match\t is\t found,\t 0\t if\t not.\t For\t example:\t Find\t \u201cMICROSOFT\u201d\t in\t the\t below matrix. Solution:\tManually\tfinding\tthe\tsolution\tof\tthis\tproblem\tis\trelatively\tintuitive;\twe\tjust\tneed\tto describe\tan\talgorithm\tfor\tit.\tIronically,\tdescribing\tthe\talgorithm\tis\tnot\tthe\teasy\tpart. How\tdo\twe\tdo\tit\tmanually?\tFirst\twe\tmatch\tthe\tfirst\telement,\tand\twhen\tit\tis\tmatched\twe\tmatch the\tsecond\telement\tin\tthe\t8\tneighbors\tof\tthe\tfirst\tmatch.\tWe\tdo\tthis\tprocess\trecursively,\tand\twhen the\tlast\tcharacter\tof\tthe\tinput\tpattern\tmatches,\treturn\ttrue. During\tthe\tabove\tprocess,\ttake\tcare\tnot\tto\tuse\tany\tcell\tin\tthe\t2D\tarray\ttwice.\tFor\tthis\tpurpose, you\tmark\tevery\tvisited\tcell\twith\tsome\tsign.\tIf\tyour\tpattern\tmatching\tfails\tat\tsome\tpoint,\tstart matching\tfrom\tthe\tbeginning\t(of\tthe\tpattern)\tin\tthe\tremaining\tcells.\tWhen\treturning,\tyou\tunmark the\tvisited\tcells. Let\u2019s\tconvert\tthe\tabove\tintuitive\tmethod\tinto\tan\talgorithm.\tSince\twe\tare\tdoing\tsimilar\tchecks\tfor pattern\tmatching\tevery\ttime,\ta\trecursive\tsolution\tis\twhat\twe\tneed.\tIn\ta\trecursive\tsolution,\twe need\tto\tcheck\tif\tthe\tsubstring\tpassed\tis\tmatched\tin\tthe\tgiven\tmatrix\tor\tnot.\tThe\tcondition\tis\tnot\tto use\tthe\talready\tused\tcell,\tand\tto\tfind\tthe\talready\tused\tcell,\twe\tneed\tto\tadd\tanother\t2D\tarray\tto\tthe function\t(or\twe\tcan\tuse\tan\tunused\tbit\tin\tthe\tinput\tarray\titself.)\tAlso,\twe\tneed\tthe\tcurrent\tposition of\tthe\tinput\tmatrix\tfrom\twhere\twe\tneed\tto\tstart.\tSince\twe\tneed\tto\tpass\ta\tlot\tmore\tinformation\tthan is\tactually\tgiven,\twe\tshould\tbe\thaving\ta\twrapper\tfunction\tto\tinitialize\tthe\textra\tinformation\tto\tbe passed. Algorithm: If\twe\tare\tpast\tthe\tlast\tcharacter\tin\tthe\tpattern Return\ttrue If\twe\tget\ta\tused\tcell\tagain Return\tfalse\tif\twe\tgot\tpast\tthe\t2D\tmatrix Return\tfalse If\tsearching\tfor\tfirst\telement\tand\tcell\tdoesn\u2019t\tmatch FindMatch\twith\tnext\tcell\tin\trow-first\torder\t(or\tcolumn-first\torder) Otherwise\tif\tcharacter\tmatches mark\tthis\tcell\tas\tused res\t=\tFindMatch\twith\tnext\tposition\tof\tpattern\tin\t8\tneighbors mark\tthis\tcell\tas\tunused Return\tres Otherwise Return\tfalse Problem-15\u2003\u2003Given\ttwo\tstrings\tstr1\tand\tstr2,\twrite\ta\tfunction\tthat\tprints\tall\tinterleavings\tof the\t given\t two\t strings.\t We\t may\t assume\t that\t all\t characters\t in\t both\t strings\t are\t different. Example:\t Input:\t str1\t =\t \u201cAB\u201d,\t str2\t =\t \u201cCD\u201d\t and\t Output:\t ABCD\t ACBD\t ACDB\t CABD CADB\tCDAB.\tAn\tinterleaved\tstring\tof\tgiven\ttwo\tstrings\tpreserves\tthe\torder\tof\tcharacters in\t individual\t strings.\t For\t example,\t in\t all\t the\t interleavings\t of\t above\t first\t example,\t \u2018A\u2019 comes\tbefore\t\u2018B\u2019\tand\t\u2018C\tcomes\tbefore\t\u2018D\u2019. Solution:\tLet\tthe\tlength\tof\tstr1\tbe\tm\tand\tthe\tlength\tof\tstr2\tbe\tn.\tLet\tus\tassume\tthat\tall\tcharacters in\tstr1\tand\tstr2\tare\tdifferent.\tLet\tCount(m,n)\tbe\tthe\tcount\tof\tall\tinterleaved\tstrings\tin\tsuch\tstrings. The\tvalue\tof\tCount(m,n)\tcan\tbe\twritten\tas\tfollowing. To\tprint\tall\tinterleavings,\twe\tcan\tfirst\tfix\tthe\tfirst\tcharacter\tof\tstrl[0..m-1]\tin\toutput\tstring,\tand recursively\t call\t for\t str1[1..m-1]\t and\t str2[0..n-1].\t And\t then\t we\t can\t fix\t the\t first\t character\t of str2[0..n-1]\tand\trecursively\tcall\tfor\tstr1[0..m-1]\tand\tstr2[1..n-1]. Problem-16\u2003\u2003Given\ta\tmatrix\twith\tsize\tn\t\u00d7\tn\tcontaining\trandom\tintegers.\tGive\tan\talgorithm which\t checks\t whether\t rows\t match\t with\t a\t column(s)\t or\t not.\t For\t example,\t if\t ith\t row matches\twith\tjth\tcolumn,\tand\tith\trow\tcontains\tthe\telements\t-\t[2,6,5,8,9].\tThen;\u2019\u20191\tcolumn would\talso\tcontain\tthe\telements\t-\t[2,6,5,8,9]. Solution:\tWe\tcan\tbuild\ta\ttrie\tfor\tthe\tdata\tin\tthe\tcolumns\t(rows\twould\talso\twork).\tThen\twe\tcan compare\tthe\trows\twith\tthe\ttrie.\tThis\twould\tallow\tus\tto\texit\tas\tsoon\tas\tthe\tbeginning\tof\ta\trow does\tnot\tmatch\tany\tcolumn\t(backtracking).\tAlso\tthis\twould\tlet\tus\tcheck\ta\trow\tagainst\tall\tcolumns in\tone\tpass. If\twe\tdo\tnot\twant\tto\twaste\tmemory\tfor\tempty\tpointers\tthen\twe\tcan\tfurther\timprove\tthe\tsolution\tby constructing\ta\tsuffix\ttree. Problem-17\u2003\u2003Write\ta\tmethod\tto\treplace\tall\tspaces\tin\ta\tstring\twith\t\u2018%20\u2019.\tAssume\tstring\thas sufficient\tspace\tat\tend\tof\tstring\tto\thold\tadditional\tcharacters. Solution:\tFind\tthe\tnumber\tof\tspaces.\tThen,\tstarting\tfrom\tend\t(assuming\tstring\thas\tenough\tspace), replace\tthe\tcharacters.\tStarting\tfrom\tend\treduces\tthe\toverwrites. Time\tComplexity:\tO(n).\tSpace\tComplexity:\tO(1).\tHere,\twe\tdo\tnot\thave\tto\tworry\tabout\tthe\tspace needed\tfor\textra\tcharacters. Problem-18\u2003\u2003Running\tlength\tencoding:\tWrite\tan\talgorithm\tto\tcompress\tthe\tgiven\tstring\tby using\tthe\tcount\tof\trepeated\tcharacters\tand\tif\tnew\tcorn-pressed\tstring\tlength\tis\tnot\tsmaller than\tthe\toriginal\tstring\tthen\treturn\tthe\toriginal\tstring. Solution: With\textra\tspace\tof\tO(2): Time\tComplexity:\tO(n).\tSpace\tComplexity:\tO(1),\tbut\tit\tuses\ta\ttemporary\tarray\tof\tsize\ttwo. Without\textra\tspace\t(inplace): Time\tComplexity:\tO(n).\tSpace\tComplexity:\tO(1)."
            },
            {
                "subchapter_title": "16.1\tIntroduction",
                "content": "In\tthe\tprevious\tchapters,\twe\thave\tseen\tmany\talgorithms\tfor\tsolving\tdifferent\tkinds\tof\tproblems. Before\tsolving\ta\tnew\tproblem,\tthe\tgeneral\ttendency\tis\tto\tlook\tfor\tthe\tsimilarity\tof\tthe\tcurrent problem\t to\t other\t problems\t for\t which\t we\t have\t solutions.\t This\t helps\t us\t in\t getting\t the\t solution easily. In\t this\t chapter,\t we\t will\t see\t different\t ways\t of\t classifying\t the\t algorithms\t and\t in\t subsequent chapters\twe\twill\tfocus\ton\ta\tfew\tof\tthem\t(Greedy,\tDivide\tand\tConquer,\tDynamic\tProgramming)."
            },
            {
                "subchapter_title": "16.2\tClassification",
                "content": "There\tare\tmany\tways\tof\tclassifying\talgorithms\tand\ta\tfew\tof\tthem\tare\tshown\tbelow: \u2022 Implementation\tMethod \u2022 Design\tMethod \u2022 Other\tClassifications"
            },
            {
                "subchapter_title": "16.3\tClassification\tby\tImplementation\tMethod",
                "content": "Recursion\tor\tIteration A\trecursive\talgorithm\tis\tone\tthat\tcalls\titself\trepeatedly\tuntil\ta\tbase\tcondition\tis\tsatisfied.\tIt\tis\ta common\tmethod\tused\tin\tfunctional\tprogramming\tlanguages\tlike\tC,C\t+\t+,\tetc. Iterative\talgorithms\tuse\tconstructs\tlike\tloops\tand\tsometimes\tother\tdata\tstructures\tlike\tstacks\tand queues\tto\tsolve\tthe\tproblems. Some\t problems\t are\t suited\t for\t recursive\t and\t others\t are\t suited\t for\t iterative.\t For\t example,\t the Towers\tof\tHanoi\tproblem\tcan\tbe\teasily\tunderstood\tin\trecursive\timplementation.\tEvery\trecursive version\thas\tan\titerative\tversion,\tand\tvice\tversa. Procedural\tor\tDeclarative\t(non-Procedural) In\tdeclarative\tprogramming\tlanguages,\twe\tsay\twhat\twe\twant\twithout\thaving\tto\tsay\thow\tto\tdo\tit. With\tprocedural\tprogramming,\twe\thave\tto\tspecify\tthe\texact\tsteps\tto\tget\tthe\tresult.\tFor\texample, SQL\tis\tmore\tdeclarative\tthan\tprocedural,\tbecause\tthe\tqueries\tdon\u2019t\tspecify\tthe\tsteps\tto\tproduce the\tresult.\tExamples\tof\tprocedural\tlanguages\tinclude:\tC,\tPHP,\tand\tPERL. Serial\tor\tParallel\tor\tDistributed In\tgeneral,\twhile\tdiscussing\tthe\talgorithms\twe\tassume\tthat\tcomputers\texecute\tone\tinstruction\tat\ta time.\tThese\tare\tcalled\tserial\talgorithms. Parallel\talgorithms\ttake\tadvantage\tof\tcomputer\tarchitectures\tto\tprocess\tseveral\tinstructions\tat\ta time.\tThey\tdivide\tthe\tproblem\tinto\tsubproblems\tand\tserve\tthem\tto\tseveral\tprocessors\tor\tthreads. Iterative\talgorithms\tare\tgenerally\tparallelizable. If\tthe\tparallel\talgorithms\tare\tdistributed\ton\tto\tdifferent\tmachines\tthen\twe\tcall\tsuch\talgorithms distributed\talgorithms. Deterministic\tor\tNon-Deterministic Deterministic\t algorithms\t solve\t the\t problem\t with\t a\t predefined\t process,\t whereas\t non\t \u2013 deterministic\talgorithms\tguess\tthe\tbest\tsolution\tat\teach\tstep\tthrough\tthe\tuse\tof\theuristics. Exact\tor\tApproximate As\twe\thave\tseen,\tfor\tmany\tproblems\twe\tare\tnot\table\tto\tfind\tthe\toptimal\tsolutions.\tThat\tmeans, the\talgorithms\tfor\twhich\twe\tare\table\tto\tfind\tthe\toptimal\tsolutions\tare\tcalled\texact\talgorithms.\tIn computer\tscience,\tif\twe\tdo\tnot\thave\tthe\toptimal\tsolution,\twe\tgive\tapproximation\talgorithms. Approximation\t algorithms\t are\t generally\t associated\t with\t NP-hard\t problems\t (refer\t to\t the Complexity\tClasses\tchapter\tfor\tmore\tdetails)."
            },
            {
                "subchapter_title": "16.4\tClassification\tby\tDesign\tMethod",
                "content": "Another\tway\tof\tclassifying\talgorithms\tis\tby\ttheir\tdesign\tmethod. Greedy\tMethod Greedy\talgorithms\twork\tin\tstages.\tIn\teach\tstage,\ta\tdecision\tis\tmade\tthat\tis\tgood\tat\tthat\tpoint, without\tbothering\tabout\tthe\tfuture\tconsequences.\tGenerally,\tthis\tmeans\tthat\tsome\tlocal\t best\t is chosen.\tIt\tassumes\tthat\tthe\tlocal\tbest\tselection\talso\tmakes\tfor\tthe\tglobal\toptimal\tsolution. Divide\tand\tConquer The\tD\t&\tC\tstrategy\tsolves\ta\tproblem\tby: 1) Divide:\t Breaking\t the\t problem\t into\t sub\t problems\t that\t are\t themselves\t smaller instances\tof\tthe\tsame\ttype\tof\tproblem. 2) Recursion:\tRecursively\tsolving\tthese\tsub\tproblems. 3) Conquer:\tAppropriately\tcombining\ttheir\tanswers. Examples:\tmerge\tsort\tand\tbinary\tsearch\talgorithms. Dynamic\tProgramming Dynamic\t programming\t (DP)\t and\t memoization\t work\t together.\t The\t difference\t between\t DP\t and divide\tand\tconquer\tis\tthat\tin\tthe\tcase\tof\tthe\tlatter\tthere\tis\tno\tdependency\tamong\tthe\tsub\tproblems, whereas\tin\tDP\tthere\twill\tbe\tan\toverlap\tof\tsub-problems.\tBy\tusing\tmemoization\t[maintaining\ta table\tfor\talready\tsolved\tsub\tproblems],\tDP\treduces\tthe\texponential\tcomplexity\tto\tpolynomial complexity\t(O(n2),\tO(n3),\tetc.)\tfor\tmany\tproblems. The\tdifference\tbetween\tdynamic\tprogramming\tand\trecursion\tis\tin\tthe\tmemoization\tof\trecursive calls.\tWhen\tsub\tproblems\tare\tindependent\tand\tif\tthere\tis\tno\trepetition,\tmemoization\tdoes\tnot help,\thence\tdynamic\tprogramming\tis\tnot\ta\tsolution\tfor\tall\tproblems. By\t using\t memoization\t [maintaining\t a\t table\t of\t sub\t problems\t already\t solved],\t dynamic programming\treduces\tthe\tcomplexity\tfrom\texponential\tto\tpolynomial. Linear\tProgramming In\tlinear\tprogramming,\tthere\tare\tinequalities\tin\tterms\tof\tinputs\tand\tmaximizing\t(or\tminimizing) some\tlinear\tfunction\tof\tthe\tinputs.\tMany\tproblems\t(example:\tmaximum\tflow\tfor\tdirected\tgraphs) can\tbe\tdiscussed\tusing\tlinear\tprogramming. Reduction\t[Transform\tand\tConquer] In\tthis\tmethod\twe\tsolve\ta\tdifficult\tproblem\tby\ttransforming\tit\tinto\ta\tknown\tproblem\tfor\twhich\twe have\tasymptotically\toptimal\talgorithms.\tIn\tthis\tmethod,\tthe\tgoal\tis\tto\tfind\ta\treducing\talgorithm whose\t complexity\t is\t not\t dominated\t by\t the\t resulting\t reduced\t algorithms.\t For\t example,\t the selection\talgorithm\tfor\tfinding\tthe\tmedian\tin\ta\tlist\tinvolves\tfirst\tsorting\tthe\tlist\tand\tthen\tfinding out\tthe\tmiddle\telement\tin\tthe\tsorted\tlist.\tThese\ttechniques\tare\talso\tcalled\ttransform\tand\tconquer."
            },
            {
                "subchapter_title": "16.5\tOther\tClassifications",
                "content": "Classification\tby\tResearch\tArea In\tcomputer\tscience\teach\tfield\thas\tits\town\tproblems\tand\tneeds\tefficient\talgorithms.\tExamples: search\talgorithms,\tsorting\talgorithms,\tmerge\talgorithms,\tnumerical\talgorithms,\tgraph\talgorithms, string\t algorithms,\t geometric\t algorithms,\t combinatorial\t algorithms,\t machine\t learning, cryptography,\tparallel\talgorithms,\tdata\tcompression\talgorithms,\tparsing\ttechniques,\tand\tmore. Classification\tby\tComplexity In\tthis\tclassification,\talgorithms\tare\tclassified\tby\tthe\ttime\tthey\ttake\tto\tfind\ta\tsolution\tbased\ton their\tinput\tsize.\tSome\talgorithms\ttake\tlinear\ttime\tcomplexity\t(O(n))\tand\tothers\ttake\texponential time,\tand\tsome\tnever\thalt.\tNote\tthat\tsome\tproblems\tmay\thave\tmultiple\talgorithms\twith\tdifferent complexities. Randomized\tAlgorithms A\tfew\talgorithms\tmake\tchoices\trandomly.\tFor\tsome\tproblems,\tthe\tfastest\tsolutions\tmust\tinvolve randomness.\tExample:\tQuick\tSort. Branch\tand\tBound\tEnumeration\tand\tBacktracking These\t were\t used\t in\t Artificial\t Intelligence\t and\t we\t do\t not\t need\t to\t explore\t these\t fully.\t For\t the Backtracking\tmethod\trefer\tto\tthe\tRecusion\tand\tBacktracking\tchapter. Note:\t In\t the\t next\t few\t chapters\t we\t discuss\t the\t Greedy,\t Divide\t and\t Conquer,\t and\t Dynamic Programming]\tdesign\tmethods.\tThese\tmethods\tare\temphasized\tbecause\tthey\tare\tused\tmore\toften than\tother\tmethods\tto\tsolve\tproblems."
            },
            {
                "subchapter_title": "17.1\tIntroduction",
                "content": "Let\tus\tstart\tour\tdiscussion\twith\tsimple\ttheory\tthat\twill\tgive\tus\tan\tunderstanding\tof\tthe\tGreedy technique.\tIn\tthe\tgame\tof\tChess,\tevery\ttime\twe\tmake\ta\tdecision\tabout\ta\tmove,\twe\thave\tto\talso think\tabout\tthe\tfuture\tconsequences.\tWhereas,\tin\tthe\tgame\tof\tTennis\t(or\tVolleyball),\tour\taction\tis based\ton\tthe\timmediate\tsituation. This\tmeans\tthat\tin\tsome\tcases\tmaking\ta\tdecision\tthat\tlooks\tright\tat\tthat\tmoment\tgives\tthe\tbest solution\t(Greedy),\tbut\tin\tother\tcases\tit\tdoesn\u2019t.\tThe\tGreedy\ttechnique\tis\tbest\tsuited\tfor\tlooking\tat the\timmediate\tsituation."
            },
            {
                "subchapter_title": "17.2\tGreedy\tStrategy",
                "content": "Greedy\talgorithms\twork\tin\tstages.\tIn\teach\tstage,\ta\tdecision\tis\tmade\tthat\tis\tgood\tat\tthat\tpoint, without\tbothering\tabout\tthe\tfuture.\tThis\tmeans\tthat\tsome\tlocal\tbest\tis\tchosen.\tIt\tassumes\tthat\ta local\tgood\tselection\tmakes\tfor\ta\tglobal\toptimal\tsolution."
            },
            {
                "subchapter_title": "17.3\tElements\tof\tGreedy\tAlgorithms",
                "content": "The\ttwo\tbasic\tproperties\tof\toptimal\tGreedy\talgorithms\tare: 1) Greedy\tchoice\tproperty 2) Optimal\tsubstructure Greedy\tchoice\tproperty This\tproperty\tsays\tthat\tthe\tglobally\toptimal\tsolution\tcan\tbe\tobtained\tby\tmaking\ta\tlocally\toptimal solution\t(Greedy).\tThe\tchoice\tmade\tby\ta\tGreedy\talgorithm\tmay\tdepend\ton\tearlier\tchoices\tbut\tnot on\tthe\tfuture.\tIt\titeratively\tmakes\tone\tGreedy\tchoice\tafter\tanother\tand\treduces\tthe\tgiven\tproblem to\ta\tsmaller\tone. Optimal\tsubstructure A\tproblem\texhibits\toptimal\tsubstructure\tif\tan\toptimal\tsolution\tto\tthe\tproblem\tcontains\toptimal solutions\tto\tthe\tsubproblems.\tThat\tmeans\twe\tcan\tsolve\tsubproblems\tand\tbuild\tup\tthe\tsolutions\tto solve\tlarger\tproblems."
            },
            {
                "subchapter_title": "17.4\tDoes\tGreedy\tAlways\tWork?",
                "content": "Making\tlocally\toptimal\tchoices\tdoes\tnot\talways\twork.\tHence,\tGreedy\talgorithms\twill\tnot\talways give\t the\t best\t solutions.\t We\t will\t see\t particular\t examples\t in\t the\t Problems\t section\t and\t in\t the Dynamic\tProgramming\tchapter."
            },
            {
                "subchapter_title": "17.5\tAdvantages\tand\tDisadvantages\tof\tGreedy\tMethod",
                "content": "The\tmain\tadvantage\tof\tthe\tGreedy\tmethod\tis\tthat\tit\tis\tstraightforward,\teasy\tto\tunderstand\tand easy\tto\tcode.\tIn\tGreedy\talgorithms,\tonce\twe\tmake\ta\tdecision,\twe\tdo\tnot\thave\tto\tspend\ttime\tre- examining\tthe\talready\tcomputed\tvalues.\tIts\tmain\tdisadvantage\tis\tthat\tfor\tmany\tproblems\tthere\tis no\tgreedy\talgorithm.\tThat\tmeans,\tin\tmany\tcases\tthere\tis\tno\tguarantee\tthat\tmaking\tlocally\toptimal improvements\tin\ta\tlocally\toptimal\tsolution\tgives\tthe\toptimal\tglobal\tsolution."
            },
            {
                "subchapter_title": "17.6\tGreedy\tApplications",
                "content": "\u2022 Sorting:\tSelection\tsort,\tTopological\tsort \u2022 Priority\tQueues:\tHeap\tsort \u2022 Huffman\tcoding\tcompression\talgorithm \u2022 Prim\u2019s\tand\tKruskal\u2019s\talgorithms \u2022 Shortest\tpath\tin\tWeighted\tGraph\t[Dijkstra\u2019s] \u2022 Coin\tchange\tproblem \u2022 Fractional\tKnapsack\tproblem \u2022 Disjoint\tsets-UNION\tby\tsize\tand\tUNION\tby\theight\t(or\trank) \u2022 Job\tscheduling\talgorithm \u2022 Greedy\ttechniques\tcan\tbe\tused\tas\tan\tapproximation\talgorithm\tfor\tcomplex\tproblems"
            },
            {
                "subchapter_title": "17.7\tUnderstanding\tGreedy\tTechnique",
                "content": "For\tbetter\tunderstanding\tlet\tus\tgo\tthrough\tan\texample. Huffman\tCoding\tAlgorithm Definition Given\t a\t set\t of\t n\t characters\t from\t the\t alphabet\t A\t [each\t character\t c\t \u2208\t A]\t and\t their\t associated frequency\t freq(c),\t find\t a\t binary\t code\t for\t each\t character\t c\t \u2208\t A,\t such\t that\t \u2211c\t \u2208\t A freq(c)|binarycode(c)|\tis\tminimum,\twhere\t/binarycode(c)/represents\tthe\tlength\tof\tbinary\tcode\tof character\tc.\tThat\tmeans\tthe\tsum\tof\tthe\tlengths\tof\tall\tcharacter\tcodes\tshould\tbe\tminimum\t[the\tsum of\teach\tcharacter\u2019s\tfrequency\tmultiplied\tby\tthe\tnumber\tof\tbits\tin\tthe\trepresentation]. The\t basic\t idea\t behind\t the\t Huffman\t coding\t algorithm\t is\t to\t use\t fewer\t bits\t for\t more\t frequently occurring\t characters.\t The\t Huffman\t coding\t algorithm\t compresses\t the\t storage\t of\t data\t using variable\tlength\tcodes.\tWe\tknow\tthat\teach\tcharacter\ttakes\t8\tbits\tfor\trepresentation.\tBut\tin\tgeneral, we\t do\t not\t use\t all\t of\t them.\t Also,\t we\t use\t some\t characters\t more\t frequently\t than\t others.\t When reading\t a\t file,\t the\t system\t generally\t reads\t 8\t bits\t at\t a\t time\t to\t read\t a\t single\t character.\t But\t this coding\tscheme\tis\tinefficient.\tThe\treason\tfor\tthis\tis\tthat\tsome\tcharacters\tare\tmore\tfrequently\tused than\tother\tcharacters.\tLet\u2019s\tsay\tthat\tthe\tcharacter\t\u2032e\u2032\tis\tused\t10\ttimes\tmore\tfrequently\tthan\tthe character\t\u2032q\u2032.\tIt\twould\tthen\tbe\tadvantageous\tfor\tus\tto\tinstead\tuse\ta\t7\tbit\tcode\tfor\te\tand\ta\t9\tbit code\tfor\tq\tbecause\tthat\tcould\treduce\tour\toverall\tmessage\tlength. On\taverage,\tusing\tHuffman\tcoding\ton\tstandard\tfiles\tcan\treduce\tthem\tanywhere\tfrom\t10%\tto\t30% depending\ton\tthe\tcharacter\tfrequencies.\tThe\tidea\tbehind\tthe\tcharacter\tcoding\tis\tto\tgive\tlonger binary\tcodes\tfor\tless\tfrequent\tcharacters\tand\tgroups\tof\tcharacters.\tAlso,\tthe\tcharacter\tcoding\tis constructed\tin\tsuch\ta\tway\tthat\tno\ttwo\tcharacter\tcodes\tare\tprefixes\tof\teach\tother. An\tExample Let\u2019s\tassume\tthat\tafter\tscanning\ta\tfile\twe\tfind\tthe\tfollowing\tcharacter\tfrequencies: Character Frequency a 12 b 2 c 7 d 13 e 14 f 85 Given\tthis,\tcreate\ta\tbinary\ttree\tfor\teach\tcharacter\tthat\talso\tstores\tthe\tfrequency\twith\twhich\tit occurs\t(as\tshown\tbelow). The\t algorithm\t works\t as\t follows:\t In\t the\t list,\t find\t the\t two\t binary\t trees\t that\t store\t minimum frequencies\tat\ttheir\tnodes. Connect\tthese\ttwo\tnodes\tat\ta\tnewly\tcreated\tcommon\tnode\tthat\twill\tstore\tno\tcharacter\tbut\twill store\tthe\tsum\tof\tthe\tfrequencies\tof\tall\tthe\tnodes\tconnected\tbelow\tit.\tSo\tour\tpicture\tlooks\tlike this: Repeat\tthis\tprocess\tuntil\tonly\tone\ttree\tis\tleft: Once\tthe\ttree\tis\tbuilt,\teach\tleaf\tnode\tcorresponds\tto\ta\tletter\twith\ta\tcode.\tTo\tdetermine\tthe\tcode for\ta\tparticular\tnode,\ttraverse\tfrom\tthe\troot\tto\tthe\tleaf\tnode.\tFor\teach\tmove\tto\tthe\tleft,\tappend\ta\t0 to\tthe\tcode,\tand\tfor\teach\tmove\tto\tthe\tright,\tappend\ta\t1.\tAs\ta\tresult,\tfor\tthe\tabove\tgenerated\ttree, we\tget\tthe\tfollowing\tcodes: Letter Code a 001 b 0000 c 0001 d 010 e 011 f 1 Calculating\tBits\tSaved Now,\tlet\tus\tsee\thow\tmany\tbits\tthat\tHuffman\tcoding\talgorithm\tis\tsaving.\tAll\twe\tneed\tto\tdo\tfor\tthis calculation\tis\tsee\thow\tmany\tbits\tare\toriginally\tused\tto\tstore\tthe\tdata\tand\tsubtract\tfrom\tthat\tthe number\tof\tbits\tthat\tare\tused\tto\tstore\tthe\tdata\tusing\tthe\tHuffman\tcode.\tIn\tthe\tabove\texample,\tsince we\thave\tsix\tcharacters,\tlet\u2019s\tassume\teach\tcharacter\tis\tstored\twith\ta\tthree\tbit\tcode.\tSince\tthere are\t133\tsuch\tcharacters\t(multiply\ttotal\tfrequencies\tby\t3),\tthe\ttotal\tnumber\tof\tbits\tused\tis\t3\t*\t133 =\t399.\tUsing\tthe\tHuffman\tcoding\tfrequencies\twe\tcan\tcalculate\tthe\tnew\ttotal\tnumber\tof\tbits\tused: Thus,\twe\tsaved\t399\t\u2013\t238\t=\t161\tbits,\tor\tnearly\t40%\tof\tthe\tstorage\tspace. Time\tComplexity:\tO(nlogn),\tsince\tthere\twill\tbe\tone\tbuild_heap,\t2n\t\u2013\t2\tdelete_mins,\tand\tn\t\u2013\t2 inserts,\ton\ta\tpriority\tqueue\tthat\tnever\thas\tmore\tthan\tn\telements.\tRefer\tto\tthe\tPriority\t Queues chapter\tfor\tdetails."
            },
            {
                "subchapter_title": "17.8\tGreedy\tAlgorithms:\tProblems\t&\tSolutions",
                "content": "Problem-1\u2003\u2003Given\tan\tarray\tF\twith\tsize\tn.\tAssume\tthe\tarray\tcontent\tF[i]\tindicates\tthe\tlength\tof the\tith\tfile\tand\twe\twant\tto\tmerge\tall\tthese\tfiles\tinto\tone\tsingle\tfile.\tCheck\twhether\tthe following\talgorithm\tgives\tthe\tbest\tsolution\tfor\tthis\tproblem\tor\tnot? Algorithm:\tMerge\tthe\tfiles\tcontiguously.\tThat\tmeans\tselect\tthe\tfirst\ttwo\tfiles\tand\tmerge them.\tThen\tselect\tthe\toutput\tof\tthe\tprevious\tmerge\tand\tmerge\twith\tthe\tthird\tfile,\tand\tkeep going... Note:\tGiven\ttwo\tfiles\tA\tand\tB\twith\tsizes\tm\tand\tn,\tthe\tcomplexity\tof\tmerging\tis\tO(m\t+\tn). Solution:\t This\t algorithm\t will\t not\t produce\t the\t optimal\t solution.\t For\t a\t counter\t example,\t let\t us consider\tthe\tfollowing\tfile\tsizes\tarray. F\t=\t{10,5,100,50,20,15} As\tper\tthe\tabove\talgorithm,\twe\tneed\tto\tmerge\tthe\tfirst\ttwo\tfiles\t(10\tand\t5\tsize\tfiles),\tand\tas\ta result\twe\tget\tthe\tfollowing\tlist\tof\tfiles.\tIn\tthe\tlist\tbelow,\t15\tindicates\tthe\tcost\tof\tmerging\ttwo files\twith\tsizes\t10\tand\t5. {15,100,50,20,15} Similarly,\tmerging\t15\twith\tthe\tnext\tfile\t100\tproduces:\t{115,50,20,15}.\tFor\tthe\tsubsequent\tsteps the\tlist\tbecomes {165,20,15},\t{185,15} Finally, {200} The\ttotal\tcost\tof\tmerging\t=\tCost\tof\tall\tmerging\toperations\t=\t15\t+\t115\t+\t165\t+\t185\t+\t200\t=\t680. To\tsee\twhether\tthe\tabove\tresult\tis\toptimal\tor\tnot,\tconsider\tthe\torder:\t{5,10,15,20,50,100}.\tFor this\texample,\tfollowing\tthe\tsame\tapproach,\tthe\ttotal\tcost\tof\tmerging\t=\t15\t+\t30\t+\t50\t+\t100\t+\t200 =\t395.\tSo,\tthe\tgiven\talgorithm\tis\tnot\tgiving\tthe\tbest\t(optimal)\tsolution. Problem-2\u2003\u2003Similar\tto\tProblem-1,\tdoes\tthe\tfollowing\talgorithm\tgive\tthe\toptimal\tsolution? Algorithm:\tMerge\tthe\tfiles\tin\tpairs.\tThat\tmeans\tafter\tthe\tfirst\tstep,\tthe\talgorithm\tproduces the\tn/2\tintermediate\tfiles.\tFor\tthe\tnext\tstep,\twe\tneed\tto\tconsider\tthese\tintermediate\tfiles and\tmerge\tthem\tin\tpairs\tand\tkeep\tgoing. Note:\tSometimes\tthis\talgorithm\tis\tcalled\t2-way\tmerging.\tInstead\tof\ttwo\tfiles\tat\ta\ttime,\tif we\tmerge\tK\tfiles\tat\ta\ttime\tthen\twe\tcall\tit\tK-way\tmerging. Solution:\tThis\talgorithm\twill\tnot\tproduce\tthe\toptimal\tsolution\tand\tconsider\tthe\tprevious\texample for\ta\tcounter\texample.\tAs\tper\tthe\tabove\talgorithm,\twe\tneed\tto\tmerge\tthe\tfirst\tpair\tof\tfiles\t(10\tand 5\tsize\tfiles),\tthe\tsecond\tpair\tof\tfiles\t(100\tand\t50)\tand\tthe\tthird\tpair\tof\tfiles\t(20\tand\t15).\tAs\ta result\twe\tget\tthe\tfollowing\tlist\tof\tfiles. {15,150,35} Similarly,\tmerge\tthe\toutput\tin\tpairs\tand\tthis\tstep\tproduces\t[below,\tthe\tthird\telement\tdoes\tnot\thave a\tpair\telement,\tso\tkeep\tit\tthe\tsame]: {165,35} Finally, {185} The\ttotal\tcost\tof\tmerging\t=\tCost\tof\tall\tmerging\toperations\t=\t15\t+\t150\t+\t35\t+\t165\t+\t185\t=\t550. This\tis\tmuch\tmore\tthan\t395\t(of\tthe\tprevious\tproblem).\tSo,\tthe\tgiven\talgorithm\tis\tnot\tgiving\tthe best\t(optimal)\tsolution. Problem-3\u2003\u2003In\tProblem-1,\twhat\tis\tthe\tbest\tway\tto\tmerge\tall\tthe\tfiles\tinto\ta\tsingle\tfile? Solution:\tUsing\tthe\tGreedy\talgorithm\twe\tcan\treduce\tthe\ttotal\ttime\tfor\tmerging\tthe\tgiven\tfiles.\tLet us\tconsider\tthe\tfollowing\talgorithm. Algorithm:"
            }
        ]
    },
    {
        "chapter_title": "1.",
        "subchapters": [
            {
                "subchapter_title": "Store\tfile\tsizes\tin\ta\tpriority\tqueue.\tThe\tkey\tof\telements\tare\tfile\tlengths.",
                "content": ""
            }
        ]
    },
    {
        "chapter_title": "2.",
        "subchapters": [
            {
                "subchapter_title": "Repeat\tthe\tfollowing\tuntil\tthere\tis\tonly\tone\tfile:",
                "content": "a. Extract\ttwo\tsmallest\telements\tX\tand\tY. b. Merge\tX\tand\tY\tand\tinsert\tthis\tnew\tfile\tin\tthe\tpriority\tqueue. Variant\tof\tsame\talgorithm:"
            }
        ]
    },
    {
        "chapter_title": "1.",
        "subchapters": [
            {
                "subchapter_title": "Sort\tthe\tfile\tsizes\tin\tascending\torder.",
                "content": ""
            }
        ]
    },
    {
        "chapter_title": "2.",
        "subchapters": [
            {
                "subchapter_title": "Repeat\tthe\tfollowing\tuntil\tthere\tis\tonly\tone\tfile:",
                "content": "a. Take\tthe\tfirst\ttwo\telements\t(smallest)\tX\tand\tY. b. Merge\tX\tand\tY\tand\tinsert\tthis\tnew\tfile\tin\tthe\tsorted\tlist. To\tcheck\tthe\tabove\talgorithm,\tlet\tus\ttrace\tit\twith\tthe\tprevious\texample.\tThe\tgiven\tarray\tis: F\t=\t{10,5,100,50,20,15} As\tper\tthe\tabove\talgorithm,\tafter\tsorting\tthe\tlist\tit\tbecomes:\t{5,10,15,20,50,100}.\tWe\tneed\tto merge\tthe\ttwo\tsmallest\tfiles\t(5\tand\t10\tsize\tfiles)\tand\tas\ta\tresult\twe\tget\tthe\tfollowing\tlist\tof\tfiles. In\tthe\tlist\tbelow,\t15\tindicates\tthe\tcost\tof\tmerging\ttwo\tfiles\twith\tsizes\t10\tand\t5. {15,15,20,50,100} Similarly,\t merging\t the\t two\t smallest\t elements\t (15\t and\t 15)\t produces:\t {20,30,50,100}.\t For\t the subsequent\tsteps\tthe\tlist\tbecomes {50,50,100}\t//\tmerging\t20\tand\t30 {100,100}\t//\tmerging\t20\tand\t30 Finally, {200} The\ttotal\tcost\tof\tmerging\t=\tCost\tof\tall\tmerging\toperations\t=\t15\t+\t30\t+\t50\t+\t100\t+\t200\t=\t395.\tSo, this\talgorithm\tis\tproducing\tthe\toptimal\tsolution\tfor\tthis\tmerging\tproblem. Time\tComplexity:\tO(nlogn)\ttime\tusing\theaps\tto\tfind\tbest\tmerging\tpattern\tplus\tthe\toptimal\tcost\tof merging\tthe\tfiles. Problem-4\u2003\u2003Interval\tScheduling\tAlgorithm:\tGiven\ta\tset\tof\tn\tintervals\tS\t=\t{(starti,\tendj)|1\t\u2264\ti \u2264\tn}.\tLet\tus\tassume\tthat\twe\twant\tto\tfind\ta\tmaximum\tsubset\tS\u2032\tof\tS\tsuch\tthat\tno\tpair\tof intervals\tin\tS\u2032\toverlaps.\tCheck\twhether\tthe\tfollowing\talgorithm\tworks\tor\tnot. Algorithm: Solution:\t This\t algorithm\t does\t not\t solve\t the\t problem\t of\t finding\t a\t maximum\t subset\t of\t non- overlapping\t intervals.\t Consider\t the\t following\t intervals.\t The\t optimal\t solution\t is\t {M,O,N,K}. However,\t the\t interval\t that\toverlaps\t with\t the\t fewest\t others\t is\t C,\t and\t the\t given\t algorithm\t will select\tC\tfirst. Problem-5\u2003\u2003In\tProblem-4,\tif\twe\tselect\tthe\tinterval\tthat\tstarts\tearliest\t(also\tnot\toverlapping with\talready\tchosen\tintervals),\tdoes\tit\tgive\tthe\toptimal\tsolution? Solution:\tNo.\tIt\twill\tnot\tgive\tthe\toptimal\tsolution.\tLet\tus\tconsider\tthe\texample\tbelow.\tIt\tcan\tbe seen\tthat\tthe\toptimal\tsolution\tis\t4\twhereas\tthe\tgiven\talgorithm\tgives\t1. Problem-6\u2003\u2003In\t Problem-4,\t if\t we\t select\t the\t shortest\t interval\t (but\t it\t is\t not\t overlapping\t the already\tchosen\tintervals),\tdoes\tit\tgive\tthe\toptimal\tsolution? Solution:\tThis\talso\twill\tnot\tgive\tthe\toptimal\tsolution.\tLet\tus\tconsider\tthe\texample\tbelow.\tIt\tcan be\tseen\tthat\tthe\toptimal\tsolution\tis\t2\twhereas\tthe\talgorithm\tgives\t1. Problem-7\u2003\u2003For\tProblem-4,\twhat\tis\tthe\toptimal\tsolution? Solution:\tNow,\tlet\tus\tconcentrate\ton\tthe\toptimal\tgreedy\tsolution. Algorithm: Time\tcomplexity\t=\tTime\tfor\tsorting\t+\tTime\tfor\tscanning\t=\tO(nlogn\t+\tn)\t=\tO(nlogn). Problem-8\u2003\u2003Consider\tthe\tfollowing\tproblem. Input:\tS\t=\t{(starti,endi)|1\t\u2264\ti\t\u2264\tn}\tof\tintervals.\tThe\tinterval\t(starti,endi)\twe\tcan\ttreat\tas\ta request\tfor\ta\troom\tfor\ta\tclass\twith\ttime\tstart;\tto\ttime\tendi. Output:\tFind\tan\tassignment\tof\tclasses\tto\trooms\tthat\tuses\tthe\tfewest\tnumber\tof\trooms. Consider\tthe\tfollowing\titerative\talgorithm.\tAssign\tas\tmany\tclasses\tas\tpossible\tto\tthe\tfirst room,\tthen\tassign\tas\tmany\tclasses\tas\tpossible\tto\tthe\tsecond\troom,\tthen\tassign\tas\tmany classes\tas\tpossible\tto\tthe\tthird\troom,\tetc.\tDoes\tthis\talgorithm\tgive\tthe\tbest\tsolution? Note:\t In\t fact,\t this\t problem\t is\t similar\t to\t the\t interval\t scheduling\t algorithm.\t The\t only difference\tis\tthe\tapplication. Solution:\tThis\talgorithm\tdoes\tnot\tsolve\tthe\tinterval-coloring\tproblem.\tConsider\tthe\tfollowing intervals: Maximizing\tthe\tnumber\tof\tclasses\tin\tthe\tfirst\troom\tresults\tin\thaving\t{B,\tC,\tF,\tG}\tin\tone\troom,\tand classes\tA,\tD,\tand\tE\teach\tin\ttheir\town\trooms,\tfor\ta\ttotal\tof\t4.\tThe\toptimal\tsolution\tis\tto\tput\tA\tin one\troom,\t{\tB,\tC,\tD\t}\tin\tanother,\tand\t{E,F,\tG}\tin\tanother,\tfor\ta\ttotal\tof\t3\trooms. Problem-9\u2003\u2003For\t Problem-8,\t consider\t the\t following\t algorithm.\t Process\t the\t classes\t in increasing\torder\tof\tstart\ttimes.\tAssume\tthat\twe\tare\tprocessing\tclass\tC.\tIf\tthere\tis\ta\troom\tR such\t that\t R\t has\t been\t assigned\t to\t an\t earlier\t class,\t and\t C\t can\t be\t assigned\t to\t R\t without overlapping\tpreviously\tassigned\tclasses,\tthen\tassign\tC\tto\tR.\tOtherwise,\tput\tC\tin\ta\tnew room.\tDoes\tthis\talgorithm\tsolve\tthe\tproblem? Solution:\tThis\talgorithm\tsolves\tthe\tinterval-coloring\tproblem.\tNote\tthat\tif\tthe\tgreedy\talgorithm creates\ta\tnew\troom\tfor\tthe\tcurrent\tclass\tci,\tthen\tbecause\tit\texamines\tclasses\tin\torder\tof\tstart times,\tci\tstart\tpoint\tmust\tintersect\twith\tthe\tlast\tclass\tin\tall\tof\tthe\tcurrent\trooms.\tThus\twhen\tgreedy creates\tthe\tlast\troom,\tn,\tit\tis\tbecause\tthe\tstart\ttime\tof\tthe\tcurrent\tclass\tintersects\twith\tn\t\u2013\t1\tother classes.\tBut\twe\tknow\tthat\tfor\tany\tsingle\tpoint\tin\tany\tclass\tit\tcan\tonly\tintersect\twith\tat\tmost\ts other\tclass,\tso\tit\tmust\tthen\tbe\tthat\tn\t\u2264\tS.\tAs\ts\tis\ta\tlower\tbound\ton\tthe\ttotal\tnumber\tneeded,\tand greedy\tis\tfeasible,\tit\tis\tthus\talso\toptimal. Note:\tFor\toptimal\tsolution\trefer\tto\tProblem-7\tand\tfor\tcode\trefer\tto\tProblem-10. Problem-10\u2003\u2003Suppose\twe\tare\tgiven\ttwo\tarrays\tStart[1\t..n]\tand\tFinish[1\t..n]\tlisting\tthe\tstart and\t finish\t times\t of\t each\t class.\t Our\t task\t is\t to\t choose\t the\t largest\t possible\t subset\t X\t \u2208 {1,2,...,n}\tso\tthat\tfor\tany\tpair\ti,j\t\u2208\tX,\teither\tStart\t[i]\t>\tFinish[j]\tor\tStart\t[j]\t>\tFinish\t[i] Solution:\tOur\taim\tis\tto\tfinish\tthe\tfirst\tclass\tas\tearly\tas\tpossible,\tbecause\tthat\tleaves\tus\twith\tthe most\tremaining\tclasses.\tWe\tscan\tthrough\tthe\tclasses\tin\torder\tof\tfinish\ttime,\tand\twhenever\twe encounter\ta\tclass\tthat\tdoesn\u2019t\tconflict\twith\tthe\tlatest\tclass\tso\tfar,\tthen\twe\ttake\tthat\tclass. This\talgorithm\tclearly\truns\tin\tO(nlogn)\ttime\tdue\tto\tsorting. Problem-11\u2003\u2003Consider\tthe\tmaking\tchange\tproblem\tin\tthe\tcountry\tof\tIndia.\tThe\tinput\tto\tthis problem\tis\tan\tinteger\tM.\tThe\toutput\tshould\tbe\tthe\tminimum\tnumber\tof\tcoins\tto\tmake\tM rupees\tof\tchange.\tIn\tIndia,\tassume\tthe\tavailable\tcoins\tare\t1,5,10,20,25,50\trupees.\tAssume that\twe\thave\tan\tunlimited\tnumber\tof\tcoins\tof\teach\ttype. For\tthis\tproblem,\tdoes\tthe\tfollowing\talgorithm\tproduce\tthe\toptimal\tsolution\tor\tnot? Take\tas\tmany\tcoins\tas\tpossible\tfrom\tthe\thighest\tdenominations.\tSo\tfor\texample,\tto\tmake change\tfor\t234\trupees\tthe\tgreedy\talgorithm\twould\ttake\tfour\t50\trupee\tcoins,\tone\t25\trupee coin,\tone\t5\trupee\tcoin,\tand\tfour\t1\trupee\tcoins. Solution:\t The\t greedy\t algorithm\t is\t not\t optimal\t for\t the\t problem\t of\t making\t change\t with\t the minimum\tnumber\tof\tcoins\twhen\tthe\tdenominations\tare\t1,5,10,20,25,\tand\t50.\tIn\torder\tto\tmake\t40 rupees,\tthe\tgreedy\talgorithm\twould\tuse\tthree\tcoins\tof\t25,10,\tand\t5\trupees.\tThe\toptimal\tsolution is\tto\tuse\ttwo\t20-shilling\tcoins. Note:\tFor\tthe\toptimal\tsolution,\trefer\tto\tthe\tDynamic\tProgramming\tchapter. Problem-12\u2003\u2003Let\tus\tassume\tthat\twe\tare\tgoing\tfor\ta\tlong\tdrive\tbetween\tcities\tA\tand\tB.\tIn preparation\tfor\tour\ttrip,\twe\thave\tdownloaded\ta\tmap\tthat\tcontains\tthe\tdistances\tin\tmiles between\tall\tthe\tpetrol\tstations\ton\tour\troute.\tAssume\tthat\tour\tcar\u2019s\ttanks\tcan\thold\tpetrol\tfor n\tmiles.\tAssume\tthat\tthe\tvalue\tn\tis\tgiven.\tSuppose\twe\tstop\tat\tevery\tpoint.\tDoes\tit\tgive\tthe best\tsolution? Solution:\tHere\tthe\talgorithm\tdoes\tnot\tproduce\toptimal\tsolution.\tObvious\tReason:\tfilling\tat\teach petrol\tstation\tdoes\tnot\tproduce\toptimal\tsolution. Problem-13\u2003\u2003For\tproblem\tProblem-12,\tstop\tif\tand\tonly\tif\tyou\tdon\u2019t\thave\tenough\tpetrol\tto make\t it\t to\t the\t next\t gas\t station,\t and\t if\t you\t stop,\t fill\t the\t tank\t up\t all\t the\t way.\t Prove\t or disprove\tthat\tthis\talgorithm\tcorrectly\tsolves\tthe\tproblem. Solution:\tThe\tgreedy\tapproach\tworks:\tWe\tstart\tour\ttrip\tfrom\tA\twith\ta\tfull\ttank.\tWe\tcheck\tour map\tto\tdetermine\tthe\tfarthest\tpetrol\tstation\ton\tour\troute\twithin\tn\tmiles.\tWe\tstop\tat\tthat\tpetrol station,\tfill\tup\tour\ttank\tand\tcheck\tour\tmap\tagain\tto\tdetermine\tthe\tfarthest\tpetrol\tstation\ton\tour route\twithin\tn\tmiles\tfrom\tthis\tstop.\tRepeat\tthe\tprocess\tuntil\twe\tget\tto\tB. Note:\tFor\tcode,\trefer\tto\tDynamic\tProgramming\tchapter. Problem-14\u2003\u2003Fractional\tKnapsack\tproblem:\tGiven\titems\tt1:\tt2,\t...,tn\t(items\twe\tmight\twant\tto carry\tin\tour\tbackpack)\twith\tassociated\tweights\ts1;\ts2,\t...\t,\tsn\tand\tbenefit\tvalues\tvx,\tv2,\t\u2026, vn,\thow\tcan\twe\tmaximize\tthe\ttotal\tbenefit\tconsidering\tthat\twe\tare\tsubject\tto\tan\tabsolute weight\tlimit\tC? Solution: Algorithm: 1) Compute\tvalue\tper\tsize\tdensity\tfor\teach\titem\t . 2) Sort\teach\titem\tby\tits\tvalue\tdensity. 3) Take\tas\tmuch\tas\tpossible\tof\tthe\tdensity\titem\tnot\talready\tin\tthe\tbag Time\tComplexity:\tO(nlogn)\tfor\tsorting\tand\tO(n)\tfor\tgreedy\tselections. Note:\tThe\titems\tcan\tbe\tentered\tinto\ta\tpriority\tqueue\tand\tretrieved\tone\tby\tone\tuntil\teither\tthe\tbag is\tfull\tor\tall\titems\thave\tbeen\tselected.\tThis\tactually\thas\ta\tbetter\truntime\tof\tO(n\t+\tclogn)\twhere\tc is\tthe\tnumber\tof\titems\tthat\tactually\tget\tselected\tin\tthe\tsolution.\tThere\tis\ta\tsavings\tin\truntime\tif\tc\t= O(n),\tbut\totherwise\tthere\tis\tno\tchange\tin\tthe\tcomplexity. Problem-15\u2003\u2003Number\tof\trailway-platforms:\tAt\ta\trailway\tstation,\twe\thave\ta\ttime-table\twith the\ttrains\u2019\tarrivals\tand\tdepartures.\tWe\tneed\tto\tfind\tthe\tminimum\tnumber\tof\tplatforms\tso that\tall\tthe\ttrains\tcan\tbe\taccommodated\tas\tper\ttheir\tschedule. Example:\tThe\ttimetable\tis\tas\tgiven\tbelow,\tthe\tanswer\tis\t3.\tOtherwise,\tthe\trailway\tstation will\tnot\tbe\table\tto\taccommodate\tall\tthe\ttrains. Solution:\tLet\u2019s\ttake\tthe\tsame\texample\tas\tdescribed\tabove.\tCalculating\tthe\tnumber\tof\tplatforms\tis done\tby\tdetermining\tthe\tmaximum\tnumber\tof\ttrains\tat\tthe\trailway\tstation\tat\tany\ttime. First,\tsort\tall\tthe\tarrival(A)\tand\tdeparture(D)\t times\t in\t an\t array.\t Then,\t save\t the\t corresponding arrivals\tanddepartures\tin\tthe\tarray\talso.\tAfter\tsorting,\tour\tarray\twill\tlook\tlike\tthis: Now\tmodify\tthe\tarray\tby\tplacing\t1\tfor\tA\tand\t-1\tfor\tD.\tThe\tnew\tarray\twill\tlook\tlike\tthis: Finally\tmake\ta\tcumulative\tarray\tout\tof\tthis: Our\tsolution\twill\tbe\tthe\tmaximum\tvalue\tin\tthis\tarray.\tHere\tit\tis\t3. Note:\tIf\twe\thave\ta\ttrain\tarriving\tand\tanother\tdeparting\tat\tthe\tsame\ttime,\tthen\tput\tthe\tdeparture time\tfirst\tin\tthe\tsorted\tarray. Problem-16\u2003\u2003Consider\ta\tcountry\twith\tvery\tlong\troads\tand\thouses\talong\tthe\troad.\tAssume\tthat the\tresidents\tof\tall\thouses\tuse\tcell\tphones.\tWe\twant\tto\tplace\tcell\tphone\ttowers\talong\tthe road,\t and\t each\t cell\t phone\t tower\t covers\t a\t range\t of\t 7\t kilometers.\t Create\t an\t efficient algorithm\tthat\tallow\tfor\tthe\tfewest\tcell\tphone\ttowers. Solution: The\talgorithm\tto\tlocate\tthe\tleast\tnumber\tof\tcell\tphone\ttowers: 1) Start\tfrom\tthe\tbeginning\tof\tthe\troad 2) Find\tthe\tfirst\tuncovered\thouse\ton\tthe\troad 3) If\tthere\tis\tno\tsuch\thouse,\tterminate\tthis\talgorithm.\tOtherwise,\tgo\tto\tnext\tstep 4) Locate\ta\tcell\tphone\ttower\t7\tmiles\taway\tafter\twe\tfind\tthis\thouse\talong\tthe\troad 5) Go\tto\tstep\t2 Problem-17\u2003\u2003Preparing\tSongs\tCassette:\tSuppose\twe\thave\ta\tset\tof\tn\tsongs\tand\twant\tto\tstore these\ton\ta\ttape.\tIn\tthe\tfuture,\tusers\twill\twant\tto\tread\tthose\tsongs\tfrom\tthe\ttape.\tReading\ta song\tfrom\ta\ttape\tis\tnot\tlike\treading\tfrom\ta\tdisk;\tfirst\twe\thave\tto\tfast-forward\tpast\tall\tthe other\tsongs,\tand\tthat\ttakes\ta\tsignificant\tamount\tof\ttime.\tLet\tA[1\t..\tn]\tbe\tan\tarray\tlisting\tthe lengths\tof\teach\tsong,\tspecifically,\tsong\ti\thas\tlength\tA[i].\tIf\tthe\tsongs\tare\tstored\tin\torder from\t1\tto\tn,\tthen\tthe\tcost\tof\taccessing\tthe\tkth\tsong\tis: The\tcost\treflects\tthe\tfact\tthat\tbefore\twe\tread\tsong\tk\twe\tmust\tfirst\tscan\tpast\tall\tthe\tearlier songs\ton\tthe\ttape.\tIf\twe\tchange\tthe\torder\tof\tthe\tsongs\ton\tthe\ttape,\twe\tchange\tthe\tcost\tof accessing\tthe\tsongs,\twith\tthe\tresult\tthat\tsome\tsongs\tbecome\tmore\texpensive\tto\tread,\tbut others\t become\t cheaper.\t Different\t song\t orders\t are\t likely\t to\t result\t in\t different\t expected costs.\tIf\twe\tassume\tthat\teach\tsong\tis\tequally\tlikely\tto\tbe\taccessed,\twhich\torder\tshould\twe use\tif\twe\twant\tthe\texpected\tcost\tto\tbe\tas\tsmall\tas\tpossible? Solution:\tThe\tanswer\tis\tsimple.\tWe\tshould\tstore\tthe\tsongs\tin\tthe\torder\tfrom\tshortest\tto\tlongest. Storing\tthe\tshort\tsongs\tat\tthe\tbeginning\treduces\tthe\tforwarding\ttimes\tfor\tthe\tremaining\tjobs. Problem-18\u2003\u2003Let\t us\t consider\t a\t set\t of\t events\t at\t HITEX\t (Hyderabad\t Convention\t Center). Assume\tthat\tthere\tare\tn\tevents\twhere\teach\ttakes\tone\tunit\tof\ttime.\tEvent\ti\twill\tprovide\ta profit\tof\tP\t[i\t]\trupees\t(P\t[i\t]\t>\t0)\tif\tstarted\tat\tor\tbefore\ttime\tT[i],\twhere\tT[i]\tis\tan\tarbitrary number.\tIf\tan\tevent\tis\tnot\tstarted\tby\tT[i]\tthen\tthere\tis\tno\tbenefit\tin\tscheduling\tit\tat\tall.\tAll events\t can\t start\t as\t early\t as\t time\t 0.\t Give\t the\t efficient\t algorithm\t to\t find\t a\t schedule\t that maximizes\tthe\tprofit. Solution: Algorithm: \u2022 Sort\tthe\tjobs\taccording\tto\tfloor(T[i])\t(sorted\tfrom\tlargest\tto\tsmallest). \u2022 Let\ttime\tt\tbe\tthe\tcurrent\ttime\tbeing\tconsidered\t(where\tinitially\tt\t=\tfloor(T[i])). \u2022 All\tjobs\ti\twhere\tfloor(T[i])\t=\tt\tare\tinserted\tinto\ta\tpriority\tqueue\twith\tthe\tprofit\tg, used\tas\tthe\tkey. \u2022 A\tDeleteMax\tis\tperformed\tto\tselect\tthe\tjob\tto\trun\tat\ttime\tt. \u2022 Then\tt\tis\tdecremented\tand\tthe\tprocess\tis\tcontinued. Clearly\tthe\ttime\tcomplexity\tis\tO(nlogn).\tThe\tsort\ttakes\tO(nlogn)\tand\tthere\tare\tat\tmost\tn\tinsert and\tDeleteMax\toperations\tperformed\ton\tthe\tpriority\tqueue,\teach\tof\twhich\ttakes\tO(logn)\ttime. Problem-19\u2003\u2003Let\t us\t consider\t a\t customer-care\t server\t (say,\t mobile\t customer-care)\t with\t n customers\tto\tbe\tserved\tin\tthe\tqueue.\tFor\tsimplicity\tassume\tthat\tthe\tservice\ttime\trequired by\t each\t customer\t is\t known\t in\t advance\t and\t it\t is\t wt\t minutes\t for\t customer\t i.\t So\t if,\t for example,\tthe\tcustomers\tare\tserved\tin\torder\tof\tincreasing\ti,\tthen\tthe\tith\tcustomer\thas\tto wait:\t \t minutes.\t The\t total\t waiting\t time\t of\t all\t customers\t can\t be\t given\t as\t .\tWhat\tis\tthe\tbest\tway\tto\tserve\tthe\tcustomers\tso\tthat\tthe\ttotal\twaiting time\tcan\tbe\treduced? Solution:\tThis\tproblem\tcan\tbe\teasily\tsolved\tusing\tgreedy\ttechnique.\tSince\tour\tobjective\tis\tto reduce\tthe\ttotal\twaiting\ttime,\twhat\twe\tcan\tdo\tis,\tselect\tthe\tcustomer\twhose\tservice\ttime\tis\tless. That\t means,\t if\t we\t process\t the\t customers\t in\t the\t increasing\t order\t of\t service\t time\t then\t we\t can reduce\tthe\ttotal\twaiting\ttime. Time\tComplexity:\tO(nlogn)."
            },
            {
                "subchapter_title": "18.1\tIntroduction",
                "content": "In\tthe\tGreedy\tchapter,\twe\thave\tseen\tthat\tfor\tmany\tproblems\tthe\tGreedy\tstrategy\tfailed\tto\tprovide optimal\tsolutions.\tAmong\tthose\tproblems,\tthere\tare\tsome\tthat\tcan\tbe\teasily\tsolved\tby\tusing\tthe Divide\tand\tConquer\t(D\t&\tC)\ttechnique.\tDivide\tand\tConquer\tis\tan\timportant\talgorithm\tdesign technique\tbased\ton\trecursion. The\t D\t &\t C\t algorithm\t works\t by\t recursively\t breaking\t down\t a\t problem\t into\t two\t or\t more\t sub problems\tof\tthe\tsame\ttype,\tuntil\tthey\tbecome\tsimple\tenough\tto\tbe\tsolved\tdirectly.\tThe\tsolutions to\tthe\tsub\tproblems\tare\tthen\tcombined\tto\tgive\ta\tsolution\tto\tthe\toriginal\tproblem."
            },
            {
                "subchapter_title": "18.2\tWhat\tis\tDivide\tand\tConquer\tStrategy?",
                "content": "The\tD\t&\tC\tstrategy\tsolves\ta\tproblem\tby: 1) Divide:\t Breaking\t the\t problem\t into\t sub\t problems\t that\t are\t themselves\t smaller instances\tof\tthe\tsame\ttype\tof\tproblem. 2) Recursion:\tRecursively\tsolving\tthese\tsub\tproblems. 3) Conquer:\tAppropriately\tcombining\ttheir\tanswers."
            },
            {
                "subchapter_title": "18.3\tDoes\tDivide\tand\tConquer\tAlways\tWork?",
                "content": "It\u2019s\t not\t possible\t to\t solve\t all\t the\t problems\t with\t the\t Divide\t &\t Conquer\t technique.\t As\t per\t the definition\tof\tD\t&\tC,\tthe\trecursion\tsolves\tthe\tsubproblems\twhich\tare\tof\tthe\tsame\ttype.\tFor\tall problems\tit\tis\tnot\tpossible\tto\tfind\tthe\tsubproblems\twhich\tare\tthe\tsame\tsize\tand\tD\t&\tC\tis\tnot\ta choice\tfor\tall\tproblems."
            },
            {
                "subchapter_title": "18.4\tDivide\tand\tConquer\tVisualization",
                "content": "For\tbetter\tunderstanding,\tconsider\tthe\tfollowing\tvisualization.\tAssume\tthat\tn\tis\tthe\tsize\tof\tthe original\tproblem.\tAs\tdescribed\tabove,\twe\tcan\tsee\tthat\tthe\tproblem\tis\tdivided\tinto\tsub\tproblems with\teach\tof\tsize\tn/b\t(for\tsome\tconstant\tb).\tWe\tsolve\tthe\tsub\tproblems\trecursively\tand\tcombine their\tsolutions\tto\tget\tthe\tsolution\tfor\tthe\toriginal\tproblem."
            },
            {
                "subchapter_title": "18.5\tUnderstanding\tDivide\tand\tConquer",
                "content": "For\ta\tclear\tunderstanding\tof\tD\t&\tC,\tlet\tus\tconsider\ta\tstory.\tThere\twas\tan\told\tman\twho\twas\ta\trich farmer\tand\thad\tseven\tsons.\tHe\twas\tafraid\tthat\twhen\the\tdied,\this\tland\tand\this\tpossessions\twould be\tdivided\tamong\this\tseven\tsons,\tand\tthat\tthey\twould\tquarrel\twith\tone\tanother. So\the\tgathered\tthem\ttogether\tand\tshowed\tthem\tseven\tsticks\tthat\the\thad\ttied\ttogether\tand\ttold\tthem that\tanyone\twho\tcould\tbreak\tthe\tbundle\twould\tinherit\teverything.\tThey\tall\ttried,\tbut\tno\tone\tcould break\t the\t bundle.\t Then\t the\t old\t man\t untied\t the\t bundle\t and\t broke\t the\t sticks\t one\t by\t one.\t The brothers\tdecided\tthat\tthey\tshould\tstay\ttogether\tand\twork\ttogether\tand\tsucceed\ttogether.\tThe\tmoral for\tproblem\tsolvers\tis\tdifferent.\tIf\twe\tcan\u2019t\tsolve\tthe\tproblem,\tdivide\tit\tinto\tparts,\tand\tsolve\tone part\tat\ta\ttime. In\tearlier\tchapters\twe\thave\talready\tsolved\tmany\tproblems\tbased\ton\tD\t&\tC\tstrategy:\tlike\tBinary Search,\tMerge\tSort,\tQuick\tSort,\tetc....\tRefer\tto\tthose\ttopics\tto\tget\tan\tidea\tof\thow\tD\t&\tC\tworks. Below\tare\ta\tfew\tother\treal-time\tproblems\twhich\tcan\teasily\tbe\tsolved\twith\tD\t&\tC\tstrategy.\tFor all\tthese\tproblems\twe\tcan\tfind\tthe\tsubproblems\twhich\tare\tsimilar\tto\tthe\toriginal\tproblem. \u2022 Looking\t for\t a\t name\t in\t a\t phone\t book:\t We\t have\t a\t phone\t book\t with\t names\t in alphabetical\torder.\tGiven\ta\tname,\thow\tdo\twe\tfind\twhether\tthat\tname\tis\tthere\tin\tthe phone\tbook\tor\tnot? \u2022 Breaking\ta\tstone\tinto\tdust:\tWe\twant\tto\tconvert\ta\tstone\tinto\tdust\t(very\tsmall\tstones). \u2022 Finding\tthe\texit\tin\ta\thotel:\tWe\tare\tat\tthe\tend\tof\ta\tvery\tlong\thotel\tlobby\twith\ta\tlong series\tof\tdoors,\twith\tone\tdoor\tnext\tto\tus.\tWe\tare\tlooking\tfor\tthe\tdoor\tthat\tleads\tto the\texit. \u2022 Finding\tour\tcar\tin\ta\tparking\tlot."
            },
            {
                "subchapter_title": "18.6\tAdvantages\tof\tDivide\tand\tConquer",
                "content": "Solving\tdifficult\tproblems:\tD\t&\tC\tis\ta\tpowerful\tmethod\tfor\tsolving\tdifficult\tproblems.\tAs\tan example,\t consider\t the\t Tower\t of\t Hanoi\t problem.\t This\t requires\t breaking\t the\t problem\t into subproblems,\t solving\t the\t trivial\t cases\t and\t combining\t the\t subproblems\t to\t solve\t the\t original problem.\tDividing\tthe\tproblem\tinto\tsubproblems\tso\tthat\tsubproblems\tcan\tbe\tcombined\tagain\tis\ta major\tdifficulty\tin\tdesigning\ta\tnew\talgorithm.\tFor\tmany\tsuch\tproblems\tD\t&\tC\tprovides\ta\tsimple solution. Parallelism:\t Since\t D\t &\t C\t allows\t us\t to\t solve\t the\t subproblems\t independently,\t this\t allows\t for execution\t in\t multiprocessor\t machines,\t especially\t shared-memory\t systems\t where\t the communication\t of\t data\t between\t processors\t does\t not\t need\t to\t be\t planned\t in\t advance,\t because different\tsubproblems\tcan\tbe\texecuted\ton\tdifferent\tprocessors. Memory\taccess:\tD\t&\tC\talgorithms\tnaturally\ttend\tto\tmake\tefficient\tuse\tof\tmemory\tcaches.\tThis\tis because\tonce\ta\tsubproblem\tis\tsmall,\tall\tits\tsubproblems\tcan\tbe\tsolved\twithin\tthe\tcache,\twithout accessing\tthe\tslower\tmain\tmemory."
            },
            {
                "subchapter_title": "18.7\tDisadvantages\tof\tDivide\tand\tConquer",
                "content": "One\t disadvantage\t of\t the\t D\t &\t C\t approach\t is\t that\t recursion\t is\t slow.\t This\t is\t because\t of\t the overhead\tof\tthe\trepeated\tsubproblem\tcalls.\tAlso,\tthe\tD\t&\tC\tapproach\tneeds\tstack\tfor\tstoring\tthe calls\t (the\t state\t at\t each\t point\t in\t the\t recursion).\t Actually\t this\t depends\t upon\t the\t implementation style.\tWith\tlarge\tenough\trecursive\tbase\tcases,\tthe\toverhead\tof\trecursion\tcan\tbecome\tnegligible for\tmany\tproblems. Another\tproblem\twith\tD\t&\tC\tis\tthat,\tfor\tsome\tproblems,\tit\tmay\tbe\tmore\tcomplicated\tthan\tan iterative\tapproach.\tFor\texample,\tto\tadd\tn\tnumbers,\ta\tsimple\tloop\tto\tadd\tthem\tup\tin\tsequence\tis much\teasier\tthan\ta\tD\t&\tC\tapproach\tthat\tbreaks\tthe\tset\tof\tnumbers\tinto\ttwo\thalves,\tadds\tthem recursively,\tand\tthen\tadds\tthe\tsums."
            },
            {
                "subchapter_title": "18.8\tMaster\tTheorem",
                "content": "As\tstated\tabove,\tin\tthe\tD\t&\tC\tmethod,\twe\tsolve\tthe\tsub\tproblems\trecursively.\tAll\tproblems\tare generally\t defined\t in\t terms\t of\t recursive\t definitions.\t These\t recursive\t problems\t can\t easily\t be solved\tusing\tMaster\ttheorem.\tFor\tdetails\ton\tMaster\ttheorem,\trefer\tto\tthe\tIntroduction\tto\tAnalysis of\tAlgorithms\tchapter.\tJust\tfor\tcontinuity,\tlet\tus\treconsider\tthe\tMaster\ttheorem. If\tthe\trecurrence\tis\tof\tthe\tform\t ,\twhere\ta\t\u2265\t1,\tb\t>\t1,\tk\t\u2265 0\tand\tp\tis\ta\treal\tnumber,\tthen\tthe\tcomplexity\tcan\tbe\tdirectly\tgiven\tas: 1) If\ta\t>\tbk,\tthen\t 2) If\ta\t=\tbk a. If\tp\t>\t\u20131,\tthen\t b. If\tp\t=\t\u20131,\tthen\t c. If\tp\t<\t\u20131,\tthen\t 3) If\ta\t<\tbk a. If\tp\t>\t0,\tthen\tT(n)\t=\t\u0398(nklogpn) b. If\tp\t<\t0,\tthen\tT(n)\t=\tO(nk)"
            },
            {
                "subchapter_title": "18.9\tDivide\tand\tConquer\tApplications",
                "content": "\u2022 Binary\tSearch \u2022 Merge\tSort\tand\tQuick\tSort \u2022 Median\tFinding \u2022 Min\tand\tMax\tFinding \u2022 Matrix\tMultiplication \u2022 Closest\tPair\tproblem"
            },
            {
                "subchapter_title": "18.10\tDivide\tand\tConquer:\tProblems\t&\tSolutions",
                "content": "Problem-1\u2003\u2003Let\tus\tconsider\tan\talgorithm\tA\twhich\tsolves\tproblems\tby\tdividing\tthem\tinto\tfive subproblems\tof\thalf\tthe\tsize,\trecursively\tsolving\teach\tsubproblem,\tand\tthen\tcombining\tthe solutions\tin\tlinear\ttime.\tWhat\tis\tthe\tcomplexity\tof\tthis\talgorithm? Solution:\tLet\tus\tassume\tthat\tthe\tinput\tsize\tis\tn\tand\tT(n)\tdefines\tthe\tsolution\tto\tthe\tgiven\tproblem. As\tper\tthe\tdescription,\tthe\talgorithm\tdivides\tthe\tproblem\tinto\t5\tsub\tproblems\twith\teach\tof\tsize\t .\tSo\twe\tneed\tto\tsolve\t \tsubproblems.\tAfter\tsolving\tthese\tsub\tproblems,\tthe\tgiven\tarray (linear\t time)\t is\t scanned\t to\t combine\t these\t solutions.\t The\t total\t recurrence\t algorithm\t for\t this problem\tcan\tbe\tgiven\tas:\t .\tUsing\tthe\tMaster\ttheorem\t(of\tD\t&\tC),\twe get\tthe\tcomplexity\t . Problem-2\u2003\u2003Similar\tto\tProblem-1,\tan\talgorithm\tB\tsolves\tproblems\tof\tsize\tn\tby\trecursively solving\ttwo\tsubproblems\tof\tsize\tn\t\u2013\t1\tand\tthen\tcombining\tthe\tsolutions\tin\tconstant\ttime. What\tis\tthe\tcomplexity\tof\tthis\talgorithm? Solution:\tLet\tus\tassume\tthat\tthe\tinput\tsize\tis\tn\tand\tT(n)\tdefines\tthe\tsolution\tto\tthe\tgiven\tproblem. As\tper\tthe\tdescription\tof\talgorithm\twe\tdivide\tthe\tproblem\tinto\t2\tsub\tproblems\twith\teach\tof\tsize n\t \u2013\t 1.\t So\t we\t have\t to\t solve\t 2T(n\t \u2013\t 1)\t sub\t problems.\t After\t solving\t these\t sub\t problems,\t the algorithm\ttakes\tonly\ta\tconstant\ttime\tto\tcombine\tthese\tsolutions.\tThe\ttotal\trecurrence\talgorithm\tfor this\tproblem\tcan\tbe\tgiven\tas: Using\t Master\t theorem\t (of\t Subtract\t and\t Conquer),\t we\t get\t the\t complexity\t as\t .\t(Refer\tto\tIntroduction\tchapter\tfor\tmore\tdetails). Problem-3\u2003\u2003Again\tsimilar\tto\tProblem-1,\tanother\talgorithm\tC\tsolves\tproblems\tof\tsize\tn\t by dividing\tthem\tinto\tnine\tsubproblems\tof\tsize\t ,\trecursively\tsolving\teach\tsubproblem,\tand then\tcombining\tthe\tsolutions\tin\tO(n2)\ttime.\tWhat\tis\tthe\tcomplexity\tof\tthis\talgorithm? Solution:\tLet\tus\tassume\tthat\tinput\tsize\tis\tn\tand\tT(n)\tdefines\tthe\tsolution\tto\tthe\tgiven\tproblem.\tAs per\tthe\tdescription\tof\talgorithm\twe\tdivide\tthe\tproblem\tinto\t9\tsub\tproblems\twith\teach\tof\tsize\t . So\twe\tneed\tto\tsolve\t \tsub\tproblems.\tAfter\tsolving\tthe\tsub\tproblems,\tthe\talgorithm\ttakes quadratic\ttime\tto\tcombine\tthese\tsolutions.\tThe\ttotal\trecurrence\talgorithm\tfor\tthis\tproblem\tcan\tbe given\tas:\t .\tUsing\tD\t&\tC\tMaster\ttheorem,\twe\tget\tthe\tcomplexity as\tO(n2logn). Problem-4\u2003\u2003Write\ta\trecurrence\tand\tsolve\tit. Solution:\tLet\tus\tassume\tthat\tinput\tsize\tis\tn\tand\tT(n)\tdefines\tthe\tsolution\tto\tthe\tgiven\tproblem.\tAs per\tthe\tgiven\tcode,\tafter\tprinting\tthe\tcharacter\tand\tdividing\tthe\tproblem\tinto\t2\tsubproblems\twith each\tof\tsize\t \tand\tsolving\tthem.\tSo\twe\tneed\tto\tsolve\t \tsubproblems.\tAfter\tsolving\tthese subproblems,\tthe\talgorithm\tis\tnot\tdoing\tanything\tfor\tcombining\tthe\tsolutions.\tThe\ttotal\trecurrence algorithm\tfor\tthis\tproblem\tcan\tbe\tgiven\tas: Using\tMaster\ttheorem\t(of\tD\t&\tC),\twe\tget\tthe\tcomplexity\tas\t . Problem-5\u2003\u2003Given\tan\tarray,\tgive\tan\talgorithm\tfor\tfinding\tthe\tmaximum\tand\tminimum. Solution:\tRefer\tSelection\tAlgorithms\tchapter. Problem-6\u2003\u2003Discuss\tBinary\tSearch\tand\tits\tcomplexity. Solution:\tRefer\tSearching\tchapter\tfor\tdiscussion\ton\tBinary\tSearch. Analysis:\tLet\tus\tassume\tthat\tinput\tsize\tis\tn\tand\tT(n)\tdefines\tthe\tsolution\tto\tthe\tgiven\tproblem. The\telements\tare\tin\tsorted\torder.\tIn\tbinary\tsearch\twe\ttake\tthe\tmiddle\telement\tand\tcheck\twhether the\telement\tto\tbe\tsearched\tis\tequal\tto\tthat\telement\tor\tnot.\tIf\tit\tis\tequal\tthen\twe\treturn\tthat\telement. If\tthe\telement\tto\tbe\tsearched\tis\tgreater\tthan\tthe\tmiddle\telement\tthen\twe\tconsider\tthe\tright\tsub- array\t for\t finding\t the\t element\t and\t discard\t the\t left\t sub-array.\t Similarly,\t if\t the\t element\t to\t be searched\t is\t less\t than\t the\t middle\t element\t then\t we\t consider\t the\t left\t sub-array\t for\t finding\t the element\tand\tdiscard\tthe\tright\tsub-array. What\tthis\tmeans\tis,\tin\tboth\tthe\tcases\twe\tare\tdiscarding\thalf\tof\tthe\tsub-array\tand\tconsidering\tthe remaining\thalf\tonly.\tAlso,\tat\tevery\titeration\twe\tare\tdividing\tthe\telements\tinto\ttwo\tequal\thalves. As\tper\tthe\tabove\tdiscussion\tevery\ttime\twe\tdivide\tthe\tproblem\tinto\t2\tsub\tproblems\twith\teach\tof size\t \tand\tsolve\tone\t \tsub\tproblem.\tThe\ttotal\trecurrence\talgorithm\tfor\tthis\tproblem\tcan\tbe given\tas: Using\tMaster\ttheorem\t(of\tD\t&\tC),\twe\tget\tthe\tcomplexity\tas\tO(logn). Problem-7\u2003\u2003Consider\tthe\tmodified\tversion\tof\tbinary\tsearch.\tLet\tus\tassume\tthat\tthe\tarray\tis divided\tinto\t3\tequal\tparts\t(ternary\tsearch)\tinstead\tof\t2\tequal\tparts.\tWrite\tthe\trecurrence for\tthis\tternary\tsearch\tand\tfind\tits\tcomplexity. Solution:\t From\t the\t discussion\t on\t Problem-5,\t binary\t search\t has\t the\t recurrence\t relation:\t .\tSimilar\tto\tthe\tProblem-5\tdiscussion,\tinstead\tof\t2\tin\tthe\trecurrence relation\twe\tuse\t\u201c3\u201d.\tThat\tindicates\tthat\twe\tare\tdividing\tthe\tarray\tinto\t3\tsub-arrays\twith\tequal size\tand\tconsidering\tonly\tone\tof\tthem.\tSo,\tthe\trecurrence\tfor\tthe\tternary\tsearch\tcan\tbe\tgiven\tas: Using\tMaster\ttheorem\t(of\tD\t&\tC),\twe\tget\tthe\tcomplexity\tas\t \t\u2248\tO(logn) (we\tdon\u2019t\thave\tto\tworry\tabout\tthe\tbase\tof\tlog\tas\tthey\tare\tconstants). Problem-8\u2003\u2003In\tProblem-5,\twhat\tif\twe\tdivide\tthe\tarray\tinto\ttwo\tsets\tof\tsizes\tapproximately one-third\tand\ttwo-thirds. Solution:\t We\t now\t consider\t a\t slightly\t modified\t version\t of\t ternary\t search\t in\t which\t only\t one comparison\tis\tmade,\twhich\tcreates\ttwo\tpartitions,\tone\tof\troughly\t \telements\tand\tthe\tother\tof\t . Here\t the\t worst\t case\t comes\t when\t the\t recursive\t call\t is\t on\t the\t larger\t \t element\t part.\t So\t the recurrence\tcorresponding\tto\tthis\tworst\tcase\tis: Using\tMaster\ttheorem\t(of\tD\t&\tC),\twe\tget\tthe\tcomplexity\tas\tO(logn).\tIt\tis\tinteresting\tto\tnote\tthat we\twill\tget\tthe\tsame\tresults\tfor\tgeneral\tk-ary\tsearch\t(as\tlong\tas\tk\tis\ta\tfixed\tconstant\twhich\tdoes not\tdepend\ton\tn)\tas\tn\tapproaches\tinfinity. Problem-9\u2003\u2003Discuss\tMerge\tSort\tand\tits\tcomplexity. Solution:\tRefer\tto\tSorting\tchapter\tfor\tdiscussion\ton\tMerge\tSort.\tIn\tMerge\tSort,\tif\tthe\tnumber\tof elements\tare\tgreater\tthan\t1,\tthen\tdivide\tthem\tinto\ttwo\tequal\tsubsets,\tthe\talgorithm\tis\trecursively invoked\ton\tthe\tsubsets,\tand\tthe\treturned\tsorted\tsubsets\tare\tmerged\tto\tprovide\ta\tsorted\tlist\tof\tthe original\tset.\tThe\trecurrence\tequation\tof\tthe\tMerge\tSort\talgorithm\tis: If\twe\tsolve\tthis\trecurrence\tusing\tD\t&\tC\tMaster\ttheorem\tit\tgives\tO(nlogn)\tcomplexity. Problem-10\u2003\u2003Discuss\tQuick\tSort\tand\tits\tcomplexity. Solution:\t Refer\t to\t Sorting\t chapter\t for\t discussion\t on\t Quick\t Sort.\t For\t Quick\t Sort\t we\t have different\tcomplexities\tfor\tbest\tcase\tand\tworst\tcase. Best\tCase:\tIn\tQuick\tSort,\tif\tthe\tnumber\tof\telements\tis\tgreater\tthan\t1\tthen\tthey\tare\tdivided\tinto two\tequal\tsubsets,\tand\tthe\talgorithm\tis\trecursively\tinvoked\ton\tthe\tsubsets.\tAfter\tsolving\tthe\tsub problems\t we\t don\u2019t\t need\t to\t combine\t them.\t This\t is\t because\t in\t Quick\t Sort\t they\t are\t already\t in sorted\torder.\tBut,\twe\tneed\tto\tscan\tthe\tcomplete\telements\tto\tpartition\tthe\telements.\tThe\trecurrence equation\tof\tQuick\tSort\tbest\tcase\tis If\twe\tsolve\tthis\trecurrence\tusing\tMaster\ttheorem\tof\tD\t&\tC\tgives\tO(nlogn)\tcomplexity. Worst\tCase:\tIn\tthe\tworst\tcase,\tQuick\tSort\tdivides\tthe\tinput\telements\tinto\ttwo\tsets\tand\tone\tof them\tcontains\tonly\tone\telement.\tThat\tmeans\tother\tset\thas\tn\t\u2013\t1\telements\tto\tbe\tsorted.\tLet\tus assume\tthat\tthe\tinput\tsize\tis\tn\tand\tT(n)\tdefines\tthe\tsolution\tto\tthe\tgiven\tproblem.\tSo\twe\tneed\tto solve\tT(n\t\u2013\t1),\tT(1)\tsubproblems.\tBut\tto\tdivide\tthe\tinput\tinto\ttwo\tsets\tQuick\tSort\tneeds\tone\tscan of\tthe\tinput\telements\t(this\ttakes\tO(n)). After\t solving\t these\t sub\t problems\t the\t algorithm\t takes\t only\t a\t constant\t time\t to\t combine\t these solutions.\tThe\ttotal\trecurrence\talgorithm\tfor\tthis\tproblem\tcan\tbe\tgiven\tas: This\tis\tclearly\ta\tsummation\trecurrence\tequation.\tSo,\t . Note:\tFor\tthe\taverage\tcase\tanalysis,\trefer\tto\tSorting\tchapter. Problem-11\u2003\u2003Given\tan\tinfinite\tarray\tin\twhich\tthe\tfirst\tn\tcells\tcontain\tintegers\tin\tsorted\torder and\tthe\trest\tof\tthe\tcells\tare\tfilled\twith\tsome\tspecial\tsymbol\t(say,\t$).\tAssume\twe\tdo\tnot know\tthe\tn\tvalue.\tGive\tan\talgorithm\tthat\ttakes\tan\tinteger\tK\tas\tinput\tand\tfinds\ta\tposition\tin the\tarray\tcontaining\tK,\tif\tsuch\ta\tposition\texists,\tin\tO(logn)\ttime. Solution:\tSince\twe\tneed\tan\tO(logn)\talgorithm,\twe\tshould\tnot\tsearch\tfor\tall\tthe\telements\tof\tthe given\tlist\t(which\tgives\tO(n)\tcomplexity).\tTo\tget\tO(logn)\tcomplexity\tone\tpossibility\tis\tto\tuse binary\tsearch.\tBut\tin\tthe\tgiven\tscenario\twe\tcannot\tuse\tbinary\tsearch\tas\twe\tdo\tnot\tknow\tthe\tend of\tthe\tlist.\tOur\tfirst\tproblem\tis\tto\tfind\tthe\tend\tof\tthe\tlist.\tTo\tdo\tthat,\twe\tcan\tstart\tat\tthe\tfirst element\tand\tkeep\tsearching\twith\tdoubled\tindex.\tThat\tmeans\twe\tfirst\tsearch\tat\tindex\t1\tthen,\t2,4,8 ... It\tis\tclear\tthat,\tonce\twe\thave\tidentified\ta\tpossible\tinterval\tA[i,...,2i]\tin\twhich\tK\tmight\tbe,\tits length\tis\tat\tmost\tn\t(since\twe\thave\tonly\tn\tnumbers\tin\tthe\tarray\tA),\tso\tsearching\tfor\tK\tusing\tbinary search\ttakes\tO(logn)\ttime. Problem-12\u2003\u2003Given\ta\tsorted\tarray\tof\tnon-repeated\tintegers\tA[1..\tn],\tcheck\twhether\tthere\tis\tan index\ti\tfor\twhich\tA[i]\t=\ti.\tGive\ta\tdivide-and-conquer\talgorithm\tthat\truns\tin\ttime\tO(logn). Solution:\tWe\tcan\u2019t\tuse\tbinary\tsearch\ton\tthe\tarray\tas\tit\tis.\tIf\twe\twant\tto\tkeep\tthe\tO(logn)\tproperty of\tthe\tsolution\twe\thave\tto\timplement\tour\town\tbinary\tsearch.\tIf\twe\tmodify\tthe\tarray\t(in\tplace\tor in\ta\tcopy)\tand\tsubtract\ti\tfrom\tA[i],\twe\tcan\tthen\tuse\tbinary\tsearch.\tThe\tcomplexity\tfor\tdoing\tso\tis O(n). Problem-13\u2003\u2003We\tare\tgiven\ttwo\tsorted\tlists\tof\tsize\tn.\tGive\tan\talgorithm\tfor\tfinding\tthe\tmedian element\tin\tthe\tunion\tof\tthe\ttwo\tlists. Solution:\tWe\tuse\tthe\tMerge\tSort\tprocess.\tUse\tmerge\tprocedure\tof\tmerge\tsort\t(refer\tto\tSorting chapter).\tKeep\ttrack\tof\tthe\tcount\twhile\tcomparing\telements\tof\ttwo\tarrays.\tIf\tthe\tcount\tbecomes\tn (since\tthere\tare\t2n\telements),\twe\thave\treached\tthe\tmedian.\tTake\tthe\taverage\tof\tthe\telements\tat indexes\tn\t\u2013\t1\tand\tn\tin\tthe\tmerged\tarray. Time\tComplexity:\tO(n). Problem-14\u2003\u2003Can\twe\tgive\tthe\talgorithm\tif\tthe\tsize\tof\tthe\ttwo\tlists\tare\tnot\tthe\tsame? Solution:\tThe\tsolution\tis\tsimilar\tto\tthe\tprevious\tproblem.\tLet\tus\tassume\tthat\tthe\tlengths\tof\ttwo lists\tare\tm\tand\tn.\tIn\tthis\tcase\twe\tneed\tto\tstop\twhen\tthe\tcounter\treaches\t(m\t+\tn)/2. Time\tComplexity:\tO((m\t+\tn)/2). Problem-15\u2003\u2003Can\twe\timprove\tthe\ttime\tcomplexity\tof\tProblem-13\tto\tO(logn)? Solution:\tYes,\tusing\tthe\tD\t&\tC\tapproach.\tLet\tus\tassume\tthat\tthe\tgiven\ttwo\tlists\tare\tL1\tand\tL2. Algorithm:"
            }
        ]
    },
    {
        "chapter_title": "1.",
        "subchapters": [
            {
                "subchapter_title": "Find\tthe\tmedians\tof\tthe\tgiven\tsorted\tinput\tarrays\tL1[]\tand\tL2[].\tAssume\tthat\tthose",
                "content": "medians\tare\tm1\tand\tm2."
            }
        ]
    },
    {
        "chapter_title": "2.",
        "subchapters": [
            {
                "subchapter_title": "If\tm1\tand\tm2\tare\tequal\tthen\treturn\tm1\t(or\tm2).",
                "content": ""
            }
        ]
    },
    {
        "chapter_title": "3.",
        "subchapters": [
            {
                "subchapter_title": "If\tm1\tis\tgreater\tthan\tm2,\tthen\tthe\tfinal\tmedian\twill\tbe\tbelow\ttwo\tsub\tarrays.",
                "content": ""
            }
        ]
    },
    {
        "chapter_title": "4.",
        "subchapters": [
            {
                "subchapter_title": "From\tfirst\telement\tof\tL1\tto\tm1.",
                "content": ""
            }
        ]
    },
    {
        "chapter_title": "5.",
        "subchapters": [
            {
                "subchapter_title": "From\tm2\tto\tlast\telement\tof\tL2.",
                "content": ""
            }
        ]
    },
    {
        "chapter_title": "6.",
        "subchapters": [
            {
                "subchapter_title": "If\tm2\tis\tgreater\tthan\tm1,\tthen\tmedian\tis\tpresent\tin\tone\tof\tthe\ttwo\tsub\tarrays\tbelow.",
                "content": ""
            }
        ]
    },
    {
        "chapter_title": "7.",
        "subchapters": [
            {
                "subchapter_title": "From\tm1\tto\tlast\telement\tof\tL1.",
                "content": ""
            }
        ]
    },
    {
        "chapter_title": "8.",
        "subchapters": [
            {
                "subchapter_title": "From\tfirst\telement\tof\tL2\tto\tm2.",
                "content": ""
            }
        ]
    },
    {
        "chapter_title": "9.",
        "subchapters": [
            {
                "subchapter_title": "Repeat\tthe\tabove\tprocess\tuntil\tthe\tsize\tof\tboth\tthe\tsub\tarrays\tbecomes\t2.",
                "content": ""
            }
        ]
    },
    {
        "chapter_title": "10. If\tsize\tof\tthe\ttwo\tarrays\tis\t2,\tthen\tuse\tthe\tformula\tbelow\tto\tget\tthe\tmedian.",
        "subchapters": [
            {
                "subchapter_title": "",
                "content": ""
            }
        ]
    },
    {
        "chapter_title": "11. Median\t=\t(max(L1[0],L2[0])\t+\tmin(L1[1],L2[1])/2",
        "subchapters": [
            {
                "subchapter_title": "Time\t Complexity:\t O(logn)\t since\t we\t are\t considering\t only\t half\t of\t the\t input\t and\t throwing\t the",
                "content": "remaining\thalf. Problem-16\u2003\u2003Given\tan\tinput\tarray\tA.\tLet\tus\tassume\tthat\tthere\tcan\tbe\tduplicates\tin\tthe\tlist. Now\tsearch\tfor\tan\telement\tin\tthe\tlist\tin\tsuch\ta\tway\tthat\twe\tget\tthe\thighest\tindex\tif\tthere are\tduplicates. Solution:\tRefer\tto\tSearching\tchapter. Problem-17\u2003\u2003Discuss\tStrassen\u2019s\tMatrix\tMultiplication\tAlgorithm\tusing\tDivide\tand\tConquer. That\tmeans,\tgiven\ttwo\tn\t\u00d7\tn\tmatrices,\tA\tand\tB,\tcompute\tthe\tn\t\u00d7\tn\tmatrix\tC\t=\tA\t\u00d7\tB,\twhere the\telements\tof\tC\tare\tgiven\tby Solution:\tBefore\tStrassen\u2019s\talgorithm,\tfirst\tlet\tus\tsee\tthe\tbasic\tdivide\tand\tconquer\talgorithm.\tThe general\tapproach\twe\tfollow\tfor\tsolving\tthis\tproblem\tis\tgiven\tbelow.\tTo\tdetermine,\tC[i,j]\t we need\tto\tmultiply\tthe\tith\trow\tof\tA\twith\tjth\tcolumn\tof\tB. The\tmatrix\tmultiplication\tproblem\tcan\tbe\tsolved\twith\tthe\tD\t&\tC\ttechnique.\tTo\timplement\ta\tD\t& C\talgorithm\twe\tneed\tto\tbreak\tthe\tgiven\tproblem\tinto\tseveral\tsubproblems\tthat\tare\tsimilar\tto\tthe original\tone.\tIn\tthis\tinstance\twe\tview\teach\tof\tthe\tn\t\u00d7\tn\tmatrices\tas\ta\t2\t\u00d7\t2\tmatrix,\tthe\telements\tof which\tare\t \tsubmatrices.\tSo,\tthe\toriginal\tmatrix\tmultiplication,\tC\t=\tA\t\u00d7\tB\tcan\tbe\twritten\tas: From\tthe\tgiven\tdefinition\to\tf\tCi,j,\twe\tget\tthat\tthe\tresult\tsub\tmatrices\tcan\tbe\tcomputed\tas\tfollows: Here\t the\t symbols\t +\t and\t \u00d7\t are\t taken\t to\t mean\t addition\t and\t multiplication\t (respectively)\t of\t matrices. In\torder\tto\tcompute\tthe\toriginal\tn\t\u00d7\tn\tmatrix\tmultiplication\twe\tmust\tcompute\teight\t \t matrix products\t(divide)\tfollowed\tby\tfour\t \tmatrix\tsums\t(conquer).\tSince\tmatrix\taddition\tis\tan\tO(n2) operation,\tthe\ttotal\trunning\ttime\tfor\tthe\tmultiplication\toperation\tis\tgiven\tby\tthe\trecurrence: Using\tmaster\ttheorem,\twe\tget\tT(n)\t=\tO(n3). Fortunately,\t it\t turns\t out\t that\t one\t of\t the\t eight\t matrix\t multiplications\t is\t redundant\t (found\t by Strassen).\tConsider\tthe\tfollowing\tseries\tof\tseven\t \tmatrices: Each\t equation\t above\t has\t only\t one\t multiplication.\t Ten\t additions\t and\t seven\t multiplications\t are required\tto\tcompute\tM0\tthrough\tM6.\tGiven\tM0\tthrough\tM6,\twe\tcan\tcompute\tthe\telements\tof\tthe product\tmatrix\tC\tas\tfollows: This\t approach\t requires\t seven\t \t matrix\t multiplications\t and\t 18\t \t additions.\t Therefore,\t the worst-case\trunning\ttime\tis\tgiven\tby\tthe\tfollowing\trecurrence: Using\tmaster\ttheorem,\twe\tget,\t . Problem-18\u2003\u2003Stock\t Pricing\t Problem:\t Consider\t the\t stock\t price\t of\t CareerMonk.com\t in\t n consecutive\t days.\t That\t means\t the\t input\t consists\t of\t an\t array\t with\t stock\t prices\t of\t the company.\tWe\tknow\tthat\tthe\tstock\tprice\twill\tnot\tbe\tthe\tsame\ton\tall\tthe\tdays.\tIn\tthe\tinput stock\t prices\t there\t may\t be\t dates\t where\t the\t stock\t is\t high\t when\t we\t can\t sell\t the\t current holdings,\tand\tthere\tmay\tbe\tdays\twhen\twe\tcan\tbuy\tthe\tstock.\tNow\tour\tproblem\tis\tto\tfind the\tday\ton\twhich\twe\tcan\tbuy\tthe\tstock\tand\tthe\tday\ton\twhich\twe\tcan\tsell\tthe\tstock\tso\tthat we\tcan\tmake\tmaximum\tprofit. Solution:\t As\t given\t in\t the\t problem,\t let\t us\t assume\t that\t the\t input\t is\t an\t array\t with\t stock\t prices [integers].\tLet\tus\tsay\tthe\tgiven\tarray\tis\tA[1],...,A[n].\tFrom\tthis\tarray\twe\thave\tto\tfind\ttwo\tdays [one\tfor\tbuy\tand\tone\tfor\tsel1]\tin\tsuch\ta\tway\tthat\twe\tcan\tmake\tmaximum\tprofit.\tAlso,\tanother point\tto\tmake\tis\tthat\tthe\tbuy\tdate\tshould\tbe\tbefore\tsell\tdate.\tOne\tsimple\tapproach\tis\tto\tlook\tat\tall possible\tbuy\tand\tsell\tdates. The\ttwo\tnested\tloops\ttake\tn(n\t+\tl)/2\tcomputations,\tso\tthis\ttakes\ttime\t\u0398(n2). Problem-19\u2003\u2003For\tProblem-18,\tcan\twe\timprove\tthe\ttime\tcomplexity? Solution:\tYes,\tby\topting\tfor\tthe\tDivide-and-Conquer\t\u0398(nlogn)\tsolution.\tDivide\tthe\tinput\tlist\tinto two\tparts\tand\trecursively\tfind\tthe\tsolution\tin\tboth\tthe\tparts.\tHere,\twe\tget\tthree\tcases: \u2022 buyDatelndex\tand\tsellDatelndex\tboth\tare\tin\tthe\tearlier\ttime\tperiod. \u2022 buyDatelndex\tand\tsellDatelndex\tboth\tare\tin\tthe\tlater\ttime\tperiod. \u2022 buyDatelndex\tis\tin\tthe\tearlier\tpart\tand\tsellDatelndex\tis\tin\tthe\tlater\tpart\tof\tthe\ttime period. The\tfirst\ttwo\tcases\tcan\tbe\tsolved\twith\trecursion.\tThe\tthird\tcase\tneeds\tcare.\tThis\tis\tbecause buyDatelndex\tis\tone\tside\tand\tsellDatelndex\tis\ton\tother\tside.\tIn\tthis\tcase\twe\tneed\tto\tfind\tthe minimum\tand\tmaximum\tprices\tin\tthe\ttwo\tsub-parts\tand\tthis\twe\tcan\tsolve\tin\tlinear-time. Algorithm\tStockStrategy\tis\tused\trecursively\ton\ttwo\tproblems\tof\thalf\tthe\tsize\tof\tthe\tinput,\tand\tin addition\t \u0398(n)\t time\t is\t spent\t searching\t for\t the\t maximum\t and\t minimum\t prices.\t So\t the\t time complexity\tis\tcharacterized\tby\tthe\trecurrence\tT(n)\t=\t2T(n/2)\t+\t\u0398(n)\tand\tby\tthe\tMaster\ttheorem we\tget\tO(nlogn). Problem-20\u2003\u2003We\t are\t testing\t \u201cunbreakable\u201d\t laptops\t and\t our\t goal\t is\t to\t find\t out\t how unbreakable\tthey\treally\tare.\tIn\tparticular,\twe\twork\tin\tan\tn-story\tbuilding\tand\twant\tto\tfind out\tthe\tlowest\tfloor\tfrom\twhich\twe\tcan\tdrop\tthe\tlaptop\twithout\tbreaking\tit\t(call\tthis\t\u201cthe ceiling\u201d).\tSuppose\twe\tare\tgiven\ttwo\tlaptops\tand\twant\tto\tfind\tthe\thighest\tceiling\tpossible. Give\tan\talgorithm\tthat\tminimizes\tthe\tnumber\tof\ttries\twe\tneed\tto\tmake\tf(n)\t(hopefully,\tf(n) is\tsub-linear,\tas\ta\tlinear\tf(n)\tyields\ta\ttrivial\tsolution). Solution:\tFor\tthe\tgiven\tproblem,\twe\tcannot\tuse\tbinary\tsearch\tas\twe\tcannot\tdivide\tthe\tproblem and\tsolve\tit\trecursively.\tLet\tus\ttake\tan\texample\tfor\tunderstanding\tthe\tscenario.\tLet\tus\tsay\t14\tis the\tanswer.\tThat\tmeans\twe\tneed\t14\tdrops\tto\tfind\tthe\tanswer.\tFirst\twe\tdrop\tfrom\theight\t14,\tand\tif it\tbreaks\twe\ttry\tall\tfloors\tfrom\t1\tto\t13.\tIf\tit\tdoesn\u2019t\tbreak\tthen\twe\tare\tleft\t13\tdrops,\tso\twe\twill drop\tit\tfrom\t14\t+\t13\t+\t1\t=\t28th\tfloor.\tThe\treason\tbeing\tif\tit\tbreaks\tat\tthe\t28th\tfloor\twe\tcan\ttry\tall the\tfloors\tfrom\t15\tto\t27\tin\t12\tdrops\t(total\tof\t14\tdrops).\tIf\tit\tdid\tnot\tbreak,\tthen\twe\tare\tleft\twith 11\tdrops\tand\twe\tcan\ttry\tto\tfigure\tout\tthe\tfloor\tin\t14\tdrops. From\t the\t above\t example,\t it\t can\t be\t seen\t that\t we\t first\t tried\t with\t a\t gap\t of\t 14\t floors,\t and\t then followed\tby\t13\tfloors,\tthen\t12\tand\tso\ton.\tSo\tif\tthe\tanswer\tis\tk\tthen\twe\tare\ttrying\tthe\tintervals\tat k,\tk\t\u2013\t1,\tk\t\u2013\t2\t....1.\tGiven\tthat\tthe\tnumber\tof\tfloors\tis\tn,\twe\thave\tto\trelate\tthese\ttwo.\tSince\tthe maximum\tfloor\tfrom\twhich\twe\tcan\ttry\tis\tn,\tthe\ttotal\tskips\tshould\tbe\tless\tthan\tn.\tThis\tgives: Complexity\tof\tthis\tprocess\tis\t . Problem-21\u2003\u2003Given\tn\tnumbers,\tcheck\tif\tany\ttwo\tare\tequal. Solution:\tRefer\tto\tSearching\tchapter. Problem-22\u2003\u2003Give\tan\talgorithm\tto\tfind\tout\tif\tan\tinteger\tis\ta\tsquare?\tE.g.\t16\tis,\t15\tisn\u2019t. Solution:\tInitially\tlet\tus\tsay\ti\t=\t2.\tCompute\tthe\tvalue\ti\t\u00d7\ti\tand\tsee\tif\tit\tis\tequal\tto\tthe\tgiven number.\tIf\tit\tis\tequal\tthen\twe\tare\tdone;\totherwise\tincrement\tthe\ti\tvlaue.\tContinue\tthis\tprocess until\twe\treach\ti\t\u00d7\ti\tgreater\tthan\tor\tequal\tto\tthe\tgiven\tnumber. Time\tComplexity:\t .\tSpace\tComplexity:\tO(1). Problem-23\u2003\u2003Given\tan\tarray\tof\t2n\tintegers\tin\tthe\tfollowing\tformat\ta1\ta2\ta3\t...an\tb1\tb2\tb3 ...bn.\tShuffle\tthe\tarray\tto\ta1\tb1\ta2\tb2\ta3\tb3\t...\tan\tbn\twithout\tany\textra\tmemory\t[MA]. Solution:\tLet\tus\ttake\tan\texample\t(for\tbrute\tforce\tsolution\trefer\tto\tSearching\tchapter)"
            }
        ]
    },
    {
        "chapter_title": "1.",
        "subchapters": [
            {
                "subchapter_title": "Start\twith\tthe\tarray:\ta1\ta2\ta3\ta4\tb1\tb2\tb3\tb4",
                "content": ""
            }
        ]
    },
    {
        "chapter_title": "2.",
        "subchapters": [
            {
                "subchapter_title": "Split\tthe\tarray\tinto\ttwo\thalves:\ta1\ta2\ta3\ta4\t:\tb1\tb2\tb3\tb4",
                "content": ""
            }
        ]
    },
    {
        "chapter_title": "3.",
        "subchapters": [
            {
                "subchapter_title": "Exchange\telements\taround\tthe\tcenter:\texchange\ta3\ta4\twith\tb1\tb2\tyou\tget:\ta1\ta2\tb1",
                "content": "b2\ta3\ta4\tb3\tb4"
            }
        ]
    },
    {
        "chapter_title": "4.",
        "subchapters": [
            {
                "subchapter_title": "Split\ta1\ta2\tb1\tb2\tinto\ta1\ta2\t:\tb1\tb2\tthen\tsplit\ta3\ta4\tb3\tb4\tinto\ta3\ta4\t:\tb3\tb4",
                "content": ""
            }
        ]
    },
    {
        "chapter_title": "5.",
        "subchapters": [
            {
                "subchapter_title": "Exchange\telements\taround\tthe\tcenter\tfor\teach\tsubarray\tyou\tget:\ta1\tb1\ta2\tb2\tand\ta3",
                "content": "b3\ta4\tb4 Please\tnote\tthat\tthis\tsolution\tonly\thandles\tthe\tcase\twhen\tn\t=\t2i\twhere\ti\t=\t0,1,2,3,\tetc.\tIn\tour example\tn\t=\t22\t=\t4\twhich\tmakes\tit\teasy\tto\trecursively\tsplit\tthe\tarray\tinto\ttwo\thalves.\tThe\tbasic idea\t behind\t swapping\t elements\t around\t the\t center\t before\t calling\t the\t recursive\t function\t is\t to produce\tsmaller\tsize\tproblems.\tA\tsolution\twith\tlinear\ttime\tcomplexity\tmay\tbe\tachieved\tif\tthe elements\tare\tof\ta\tspecific\tnature.\tFor\texample\tyou\tcan\tcalculate\tthe\tnew\tposition\tof\tthe\telement using\tthe\tvalue\tof\tthe\telement\titself.\tThis\tis\ta\thashing\ttechnique. Time\tComplexity:\tO(nlogn). Problem-24\u2003\u2003Nuts\tand\tBolts\tProblem:\tGiven\ta\tset\tof\tn\tnuts\tof\tdifferent\tsizes\tand\tn\t bolts such\tthat\tthere\tis\ta\tone-to-one\tcorrespondence\tbetween\tthe\tnuts\tand\tthe\tbolts,\tfind\tfor\teach nut\tits\tcorresponding\tbolt.\tAssume\tthat\twe\tcan\tonly\tcompare\tnuts\tto\tbolts\t(cannot\tcompare nuts\tto\tnuts\tand\tbolts\tto\tbolts). Solution:\tRefer\tto\tSorting\tchapter. Problem-25\u2003\u2003Maximum\t Value\t Contiguous\t Subsequence:\t Given\t a\t sequence\t of\t n\t numbers A(1)\t...A(n),\tgive\tan\talgorithm\tfor\tfinding\ta\tcontiguous\tsubsequence\tA(i)\t...A(j)\tfor\twhich the\tsum\tof\telements\tin\tthe\tsubsequence\tis\tmaximum.\tExample\t:\t{-2,\t11,\t-4,\t13,\t-5,\t2}\t\u2192 20\tand\t{1,\t-3,\t4,\t-2,\t-1,\t6\t}\t\u2192\t7. Solution:\tDivide\tthis\tinput\tinto\ttwo\thalves.\tThe\tmaximum\tcontiguous\tsubsequence\tsum\tcan\toccur in\tone\tof\t3\tways: \u2022 Case\t1:\tIt\tcan\tbe\tcompletely\tin\tthe\tfirst\thalf \u2022 Case\t2:\tIt\tcan\tbe\tcompletely\tin\tthe\tsecond\thalf \u2022 Case\t3:\tIt\tbegins\tin\tthe\tfirst\thalf\tand\tends\tin\tthe\tsecond\thalf We\tbegin\tby\tlooking\tat\tcase\t3.\tTo\tavoid\tthe\tnested\tloop\tthat\tresults\tfrom\tconsidering\tall\tn/2 starting\t points\t and\t n/2\t ending\t points\t independently,\t replace\t two\t nested\t loops\t with\t two consecutive\tloops.\tThe\tconsecutive\tloops,\teach\tof\tsize\tn/2,\tcombine\tto\trequire\tonly\tlinear\twork. Any\tcontiguous\tsubsequence\tthat\tbegins\tin\tthe\tfirst\thalf\tand\tends\tin\tthe\tsecond\thalf\tmust\tinclude both\tthe\tlast\telement\tof\tthe\tfirst\thalf\tand\tthe\tfirst\telement\tof\tthe\tsecond\thalf.\tWhat\twe\tcan\tdo\tin cases\t1\tand\t2\tis\tapply\tthe\tsame\tstrategy\tof\tdividing\tinto\tmore\thalves.\tIn\tsummary,\twe\tdo\tthe following:"
            }
        ]
    },
    {
        "chapter_title": "1.",
        "subchapters": [
            {
                "subchapter_title": "Recursively\tcompute\tthe\tmaximum\tcontiguous\tsubsequence\tthat\tresides\tentirely\tin\tthe",
                "content": "first\thalf."
            }
        ]
    },
    {
        "chapter_title": "2.",
        "subchapters": [
            {
                "subchapter_title": "Recursively\tcompute\tthe\tmaximum\tcontiguous\tsubsequence\tthat\tresides\tentirely\tin\tthe",
                "content": "second\thalf."
            }
        ]
    },
    {
        "chapter_title": "3.",
        "subchapters": [
            {
                "subchapter_title": "Compute,\tvia\ttwo\tconsecutive\tloops,\tthe\tmaximum\tcontiguous\tsubsequence\tsum\tthat",
                "content": "begins\tin\tthe\tfirst\thalf\tbut\tends\tin\tthe\tsecond\thalf."
            }
        ]
    },
    {
        "chapter_title": "4.",
        "subchapters": [
            {
                "subchapter_title": "Choose\tthe\tlargest\tof\tthe\tthree\tsums.",
                "content": "The\tbase\tcase\tcost\tis\t1.\tThe\tprogram\tperforms\ttwo\trecursive\tcalls\tplus\tthe\tlinear\twork\tinvolved in\tcomputing\tthe\tmaximum\tsum\tfor\tcase\t3.\tThe\trecurrence\trelation\tis: Using\tD\t&\tC\tMaster\ttheorem,\twe\tget\tthe\ttime\tcomplexity\tas\tT(n)\t=\tO(nlogn). Note:\tFor\tan\tefficient\tsolution\trefer\tto\tthe\tDynamic\tProgramming\tchapter. Problem-26\u2003\u2003Closest-Pair\tof\tPoints:\tGiven\ta\tset\tof\tn\tpoints,\tS\t=\t{p1,p2,p3,\u2026,pn},\twhere\tpi\t= (xi,yi).\tFind\tthe\tpair\tof\tpoints\thaving\tthe\tsmallest\tdistance\tamong\tall\tpairs\t(assume\tthat\tall points\tare\tin\tone\tdimension). Solution:\tLet\tus\tassume\tthat\twe\thave\tsorted\tthe\tpoints.\tSince\tthe\tpoints\tare\tin\tone\tdimension,\tall the\tpoints\tare\tin\ta\tline\tafter\twe\tsort\tthem\t(either\ton\tX-axis\tor\tY-axis).\tThe\tcomplexity\tof\tsorting is\tO(nlogn).\tAfter\tsorting\twe\tcan\tgo\tthrough\tthem\tto\tfind\tthe\tconsecutive\tpoints\twith\tthe\tleast difference.\t So\t the\t problem\t in\t one\t dimension\t is\t solved\t in\t O(nlogn)\t time\t which\t is\t mainly dominated\tby\tsorting\ttime. Time\tComplexity:\tO(nlogn). Problem-27\u2003\u2003For\tProblem-26,\thow\tdo\twe\tsolve\tit\tif\tthe\tpoints\tare\tin\ttwo-dimensional\tspace? Solution:\tBefore\tgoing\tto\tthe\talgorithm,\tlet\tus\tconsider\tthe\tfollowing\tmathematical\tequation: The\tabove\tequation\tcalculates\tthe\tdistance\tbetween\ttwo\tpoints\tp1\t=\t(x1,y1)\tand\tp2\t=\t(x2,y2). Brute\tForce\tSolution: \u2022 Calculate\tthe\tdistances\tbetween\tall\tthe\tpairs\tof\tpoints.\tFrom\tn\tpoints\tthere\tare\t ways\tof\tselecting\t2\tpoints.\t . \u2022 After\tfinding\tdistances\tfor\tall\tn2\tpossibilities,\twe\tselect\tthe\tone\twhich\tis\tgiving\tthe minimum\tdistance\tand\tthis\ttakes\tO(n2). The\toverall\ttime\tcomplexity\tis\tO(n2). Problem-28\u2003\u2003Give\tO(nlogn)\tsolution\tfor\tclosest\tpair\tproblem\t(Problem-27)? Solution:\tTo\tfind\tO(nlogn)\tsolution,\twe\tcan\tuse\tthe\tD\t&\tC\ttechnique.\tBefore\tstarting\tthe\tdivide- and-conquer\tprocess\tlet\tus\tassume\tthat\tthe\tpoints\tare\tsorted\tby\tincreasing\tx-coordinate.\tDivide the\tpoints\tinto\ttwo\tequal\thalves\tbased\ton\tmedian\tof\tx-coordinates.\tThat\tmeans\tthe\tproblem\tis divided\t into\t that\t of\t finding\t the\t closest\t pair\t in\t each\t of\t the\t two\t halves.\t For\t simplicity\t let\t us consider\tthe\tfollowing\talgorithm\tto\tunderstand\tthe\tprocess. Algorithm: 1) Sort\t the\t given\t points\t in\t S\t (given\t set\t of\t points)\t based\t on\t their\t x\t \u2013coordinates. Partition\tS\tinto\ttwo\tsubsets,\tS1\tand\tS2,\tabout\tthe\tline\tl\tthrough\tmedian\tof\tS.\t This step\tis\tthe\tDivide\tpart\tof\tthe\tD\t&\tC\ttechnique. 2) Find\tthe\tclosest-pairs\tin\tS1\tandS2\tand\tcall\tthem\tL\tand\tR\trecursively. 3) Now,\tsteps\t4\tto\t8\tform\tthe\tCombining\tcomponent\tof\tthe\tD\t&\tC\ttechnique. 4) Let\tus\tassume\tthat\t\u03b4\t=\tmin\t(L,R). 5) Eliminate\tpoints\tthat\tare\tfarther\tthan\t\u03b4\tapart\tfrom\tl. 6) Consider\tthe\tremaining\tpoints\tand\tsort\tbased\ton\ttheir\ty-coordinates. 7) Scan\tthe\tremaining\tpoints\tin\tthe\ty\torder\tand\tcompute\tthe\tdistances\tof\teach\tpoint\tto all\tits\tneighbors\tthat\tare\tdistanced\tno\tmore\tthan\t2\t\u00d7\t\u03b4\t(that\u2019s\tthe\treason\tfor\tsorting according\tto\ty). 8) If\tany\tof\tthese\tdistances\tis\tless\tthan\t\u03b4\tthen\tupdate\t\u03b4. Combining\tthe\tresults\tin\tlinear\ttime Let\t\u03b4\t=\tmin(L,R),\twhere\tL\tis\tthe\tsolution\tto\tfirst\tsub\tproblem\tand\tR\tis\tthe\tsolution\tto\tsecond\tsub problem.\tThe\tpossible\tcandidates\tfor\tclosest-pair,\twhich\tare\tacross\tthe\tdividing\tline,\tare\tthose which\tare\tless\tthan\t\u03b4\tdistance\tfrom\tthe\tline.\tSo\twe\tneed\tonly\tthe\tpoints\twhich\tare\tinside\tthe\t2\t\u00d7\t\u03b4 area\tacross\tthe\tdividing\tline\tas\tshown\tin\tthe\tfigure.\tNow,\tto\tcheck\tall\tpoints\twithin\tdistance\t\u03b4 from\tthe\tline,\tconsider\tthe\tfollowing\tfigure. From\tthe\tabove\tdiagram\twe\tcan\tsee\tthat\ta\tmaximum\tof\t12\tpoints\tcan\tbe\tplaced\tinside\tthe\tsquare with\ta\tdistance\tnot\tless\tthan\t\u03b4.\tThat\tmeans,\twe\tneed\tto\tcheck\tonly\tthe\tdistances\twhich\tare\twithin 11\tpositions\tin\tthe\tsorted\tlist.\tThis\tis\tsimilar\tto\tthe\tone\tabove,\tbut\twith\tthe\tdifference\tthat\tin\tthe above\tcombining\tof\tsubproblems,\tthere\tare\tno\tvertical\tbounds.\tSo\twe\tcan\tapply\tthe\t12-point\tbox tactic\tover\tall\tthe\tpossible\tboxes\tin\tthe\t2\t\u00d7\t\u03b4\tarea\twith\tthe\tdividing\tline\tas\tthe\tmiddle\tline.\tAs there\tcan\tbe\ta\tmaximum\tof\tn\tsuch\tboxes\tin\tthe\tarea,\tthe\ttotal\ttime\tfor\tfinding\tthe\tclosest\tpair\tin the\tcorridor\tis\tO(n). Analysis: 1) Step-1\tand\tStep-2\ttake\tO(nlogn)\tfor\tsorting\tand\trecursively\tfinding\tthe\tminimum. 2) Step-4\ttakes\tO(1). 3) Step-5\ttakes\tO(n)\tfor\tscanning\tand\teliminating. 4) Step-6\ttakes\tO(nlogn)\tfor\tsorting. 5) Step-7\ttakes\tO(n)\tfor\tscanning. The\ttotal\tcomplexity:\tT(n)\t=\tO(nlogn)\t+\tO(1)\t+\tO(n)\t+\tO(n)\t+\tO(n)\t\u2248\tO(nlogn). Problem-29\u2003\u2003To\tcalculate\tkn,\tgive\talgorithm\tand\tdiscuss\tits\tcomplexity. Solution:\tThe\tnaive\talgorithm\tto\tcompute\tkn\tis:\tstart\twith\t1\tand\tmultiply\tby\tk\tuntil\treaching\tkn. For\t this\t approach;\t there\tare\t n\t \u2013\t 1\t multiplications\t and\t each\t takes\t constant\t time\t giving\t a\t \u0398(n) algorithm. But\tthere\tis\ta\tfaster\tway\tto\tcompute\tkn.\tFor\texample, Note\tthat\ttaking\tthe\tsquare\tof\ta\tnumber\tneeds\tonly\tone\tmultiplication;\tthis\tway,\tto\tcompute\t924\twe need\tonly\t5\tmultiplications\tinstead\tof\t23. Let\tT(n)\tbe\tthe\tnumber\tof\tmultiplications\trequired\tto\tcompute\tkn.\tFor\tsimplicity,\tassume\tk\t=\t2i for\tsome\ti\t\u2265\t1. Using\tmaster\ttheorem\twe\tget\tT(n)\t=\tO(logn). Problem-30\u2003\u2003The\tSkyline\tProblem:\tGiven\tthe\texact\tlocations\tand\tshapes\tof\tn\t rectangular buildings\t in\t a\t 2-dimensional\t city.\t There\t is\t no\t particular\t order\t for\t these\t rectangular buildings.\tAssume\tthat\tthe\tbottom\tof\tall\tbuildings\tlie\ton\ta\tfixed\thorizontal\tline\t(bottom edges\t are\t collinear).\t The\t input\t is\t a\t list\t of\t triples;\t one\t per\t building.\t A\t building\t Bi\t is represented\tby\tthe\ttriple\t(li,\thi,\tri)\twhere\tli\tdenote\tthe\tx-position\tof\tthe\tleft\tedge\tand\tri denote\t the\t x-position\t of\t the\t right\t edge,\t and\t hi\t denotes\t the\t building\u2019s\t height.\t Give\t an algorithm\t that\t computes\t the\t skyline\t (in\t 2\t dimensions)\t of\t these\t buildings,\t eliminating hidden\tlines.\tIn\tthe\tdiagram\tbelow\tthere\tare\t8\tbuildings,\trepresented\tfrom\tleft\tto\tright\tby the\ttriplets\t(1,\t14,\t7),\t(3,\t9,\t10),\t(5,\t17,\t12),\t(14,\t11,\t18),\t(15,\t6,\t27),\t(20,\t19,\t22),\t(23,\t15, 30)\tand\t(26,\t14,\t29). The\toutput\tis\ta\tcollection\tof\tpoints\twhich\tdescribe\tthe\tpath\tof\tthe\tskyline.\tIn\tsome\tversions\tof\tthe problem\tthis\tcollection\tof\tpoints\tis\trepresented\tby\ta\tsequence\tof\tnumbers\tp1;\tp2,\t...,\tpn,\tsuch\tthat the\tpoint\tpi\trepresents\ta\thorizontal\tline\tdrawn\tat\theight\tpi\tif\ti\tis\teven,\tand\tit\trepresents\ta\tvertical line\tdrawn\tat\tposition\tpi\tif\ti\tis\todd.\tIn\tour\tcase\tthe\tcollection\tof\tpoints\twill\tbe\ta\tsequence\tof\tp1, p2,\t...,\tpn\tpairs\tof\t(xi,\thi)\twhere\tpi(xi,\thi)\trepresents\tthe\thi\theight\tof\tthe\tskyline\tat\tposition\txi.\tIn\tthe diagram\tabove\tthe\tskyline\tis\tdrawn\twith\ta\tthick\tline\taround\tthe\tbuildings\tand\tit\tis\trepresented\tby the\tsequence\tof\tposition-height\tpairs\t(1,\t14),\t(5,\t17),\t(12,\t0),\t(14,\t11),\t(18,\t6),\t(20,\t19),\t(22,\t6), (23,\t15)\tand\t(30,\t0).\tAlso,\tassume\tthat\tRi\tof\tthe\tright\tmost\tbuilding\tcan\tbe\tmaximum\tof\t1000. That\t means,\t the\t Li\t co-ordinate\t of\t left\t building\t can\t be\t minimum\t of\t 1\t and\t Ri\t of\t the\t right\t most building\tcan\tbe\tmaximum\tof\t1000. Solution:\t The\t most\t important\t piece\t of\t information\t is\t that\t we\t know\t that\t the\t left\t and\t right coordinates\tof\teach\tand\tevery\tbuilding\tare\tnon-negative\tintegers\tless\tthan\t1000.\tNow\twhy\tis\tthis important?\t Because\t we\t can\t assign\t a\t height-value\t to\t every\t distinct\t xi\t coordinate\t where\t i\t is between\t0\tand\t9,999. Algorithm: \u2022 Allocate\tan\tarray\tfor\t1000\telements\tand\tinitialize\tall\tof\tthe\telements\tto\t0.\tLet\u2019s\tcall this\tarray\tauxHeights. \u2022 Iterate\tover\tall\tof\tthe\tbuildings\tand\tfor\tevery\tBi\tbuilding\titerate\ton\tthe\trange\tof\t[li.. ri)\twhere\tli\tis\tthe\tleft,\tri\tis\tthe\tright\tcoordinate\tof\tthe\tbuilding\tBi. \u2022 For\tevery\txj\telement\tof\tthis\trange\tcheck\tif\thi>auxHeights[xj],\tthat\tis\tif\tbuilding\tBi\tis taller\tthan\tthe\tcurrent\theight-value\tat\tposition\txj.\tIf\tso,\treplace\tauxHeights[xj]\twith hi. Once\twe\tchecked\tall\tthe\tbuildings,\tthe\tauxHeights\tarray\tstores\tthe\theights\tof\tthe\ttallest\tbuildings at\tevery\tposition.\tThere\tis\tone\tmore\tthing\tto\tdo:\tconvert\tthe\tauxHeights\tarray\tto\tthe\texpected output\tformat,\tthat\tis\tto\ta\tsequence\tof\tposition-height\tpairs.\tIt\u2019s\talso\teasy:\tjust\tmap\teach\tand every\ti\tindex\tto\tan\t(i,\tauxHeights[i])\tpair. Let\u2019s\thave\ta\tlook\tat\tthe\ttime\tcomplexity\tof\tthis\talgorithm.\tAssume\tthat,\tn\tindicates\tthe\tnumber\tof buildings\tin\tthe\tinput\tsequence\tand\tm\tindicates\tthe\tmaximum\tcoordinate\t(right\tmost\tbuilding\tri). From\tthe\tabove\tcode,\tit\tis\tclear\tthat\tfor\tevery\tnew\tinput\tbuilding,\twe\tare\ttraversing\tfrom\tleft\t(li) to\tright\t(ri)\tto\tupdate\tthe\theights.\tIn\tthe\tworst\tcase,\twith\tn\tequal-size\tbuildings,\teach\thaving\tl\t=\t0 left\tand\tr\t=\tm\t\u2013\t1\tright\tcoordinates,\tthat\tis\tevery\tbuilding\tspans\tover\tthe\twhole\t[0..\tm)\tinterval. Thus\t the\t running\t time\t of\t setting\t the\t height\t of\t every\t position\t is\t O(n\t \u00d7\t m).\t The\t overall\t time- complexity\tis\tO(n\t\u00d7\tm),\twhich\tis\ta\tlot\tlarger\tthan\tO(n2)\tif\tm\t>\tn. Problem-31\u2003\u2003Can\twe\timprove\tthe\tsolution\tof\tthe\tProblem-30? Solution:\tIt\twould\tbe\ta\thuge\tspeed-up\tif\tsomehow\twe\tcould\tdetermine\tthe\tskyline\tby\tcalculating the\theight\tfor\tthose\tcoordinates\tonly\twhere\tit\tmatters,\twouldn\u2019t\tit?\tIntuition\ttells\tus\tthat\tif\twe\tcan insert\ta\tbuilding\tinto\tan\texisting\tskyline\tthen\tinstead\tof\tall\tthe\tcoordinates\tthe\tbuilding\tspans over\twe\tonly\tneed\tto\tcheck\tthe\theight\tat\tthe\tleft\tand\tright\tcoordinates\tof\tthe\tbuilding\tplus\tthose coordinates\tof\tthe\tskyline\tthe\tbuilding\toverlaps\twith\tand\tmay\tmodify. Is\t merging\t two\t skylines\t substantially\t different\t from\t merging\t a\t building\t with\t a\t skyline?\t The answer\tis,\tof\tcourse,\tNo.\tThis\tsuggests\tthat\twe\tuse\tdivide-and-conquer.\tDivide\tthe\tinput\tof\tn buildings\tinto\ttwo\tequal\tsets.\tCompute\t(recursively)\tthe\tskyline\tfor\teach\tset\tthen\tmerge\tthe\ttwo skylines.\tInserting\tthe\tbuildings\tone\tafter\tthe\tother\tis\tnot\tthe\tfastest\tway\tto\tsolve\tthis\tproblem\tas we\u2019ve\tseen\tit\tabove.\tIf,\thowever,\twe\tfirst\tmerge\tpairs\tof\tbuildings\tinto\tskylines,\tthen\twe\tmerge pairs\tof\tthese\tskylines\tinto\tbigger\tskylines\t(and\tnot\ttwo\tsets\tof\tbuildings),\tand\tthen\tmerge\tpairs of\tthese\tbigger\tskylines\tinto\teven\tbigger\tones,\tthen\t-\tsince\tthe\tproblem\tsize\tis\thalved\tin\tevery step\t-after\tlogn\tsteps\twe\tcan\tcompute\tthe\tfinal\tskyline. For\texample,\tgiven\ttwo\tskylines\tA=(a1,\tha1,\ta2,\tha2,\t...,\tan,\t0)\tand\tB=(b1,\thb1,\tb2,\thb2,\t...,\tbm,\t0), we\tmerge\tthese\tlists\tas\tthe\tnew\tlist:\t(c1,\thc1,\tc2,\thc2,\t...,\tcn+m,\t0).\tClearly,\twe\tmerge\tthe\tlist\tof\ta\u2019s and\tb\u2019s\tjust\tlike\tin\tthe\tstandard\tMerge\talgorithm.\tBut,\tin\taddition\tto\tthat,\twe\thave\tto\tdecide\ton\tthe correct\t height\t in\t between\t these\t boundary\t values.\t We\t use\t two\t variables\t currentHeight1\t and currentHeight2\t(note\tthat\tthese\tare\tthe\theights\tprior\tto\tencountering\tthe\theads\tof\tthe\tlists)\tto\tstore the\t current\t height\t of\t the\t first\t and\t the\t second\t skyline,\t respectively.\t When\t comparing\t the\t head entries\t (currentHeight1,\t currentHeight2)\t of\t the\t two\t skylines,\t we\t introduce\t a\t new\t strip\t (and append\tto\tthe\toutput\tskyline)\twhose\tx-coordinate\tis\tthe\tminimum\tof\tthe\tentries\u2019\tx-coordinates\tand whose\t height\t is\t the\t maximum\t of\t currentHeight1\t and\t currentHeight2.\t This\t algorithm\t has\t a structure\tsimilar\tto\tMergesort.\tSo\tthe\toverall\trunning\ttime\tof\tthe\tdivide\tand\tconquer\tapproach will\tbe\tO(nlogn)."
            },
            {
                "subchapter_title": "19.1\tIntroduction",
                "content": "In\tthis\tchapter\twe\twill\ttry\tto\tsolve\tthe\tproblems\tfor\twhich\twe\tfailed\tto\tget\tthe\toptimal\tsolutions using\t other\t techniques\t (say,\t Divide\t &\t Conquer\t and\t Greedy\t methods).\t Dynamic\t Programming (DP)\tis\ta\tsimple\ttechnique\tbut\tit\tcan\tbe\tdifficult\tto\tmaster.\tOne\teasy\tway\tto\tidentify\tand\tsolve\tDP problems\tis\tby\tsolving\tas\tmany\tproblems\tas\tpossible.\tThe\tterm\tProgramming\tis\tnot\trelated\tto coding\tbut\tit\tis\tfrom\tliterature,\tand\tmeans\tfilling\ttables\t(similar\tto\tLinear\tProgramming)."
            },
            {
                "subchapter_title": "19.2\tWhat\tis\tDynamic\tProgramming\tStrategy?",
                "content": "Dynamic\t programming\t and\t memoization\t work\t together.\t The\t main\t difference\t between\t dynamic programming\t and\t divide\t and\t conquer\t is\t that\t in\t the\t case\t of\t the\t latter,\t sub\t problems\t are independent,\t whereas\t in\t DP\t there\t can\t be\t an\t overlap\t of\t sub\t problems.\t By\t using\t memoization [maintaining\t a\t table\t of\t sub\t problems\t already\t solved],\t dynamic\t programming\t reduces\t the exponential\t complexity\t to\t polynomial\t complexity\t (O(n2),\t O(n3),\t etc.)\t for\t many\t problems.\t The major\tcomponents\tof\tDP\tare: \u2022 Recursion:\tSolves\tsub\tproblems\trecursively. \u2022 Memoization:\t Stores\t already\t computed\t values\t in\t table\t (Memoization\t means caching). Dynamic\tProgramming\t=\tRecursion\t+\tMemoization"
            },
            {
                "subchapter_title": "19.3\tProperties\tof\tDynamic\tProgramming\tStrategy",
                "content": "The\ttwo\tdynamic\tprogramming\tproperties\twhich\tcan\ttell\twhether\tit\tcan\tsolve\tthe\tgiven\tproblem or\tnot\tare: \u2022 Optimal\tsubstructure:\tan\toptimal\tsolution\tto\ta\tproblem\tcontains\toptimal\tsolutions to\tsub\tproblems. \u2022 Overlapping\tsub\tproblems:\ta\trecursive\tsolution\tcontains\ta\tsmall\tnumber\tof\tdistinct sub\tproblems\trepeated\tmany\ttimes."
            },
            {
                "subchapter_title": "19.4\tCan\tDynamic\tProgramming\tSolve\tAll\tProblems?",
                "content": "Like\t Greedy\t and\t Divide\t and\t Conquer\t techniques,\t DP\t cannot\t solve\t every\t problem.\t There\t are problems\twhich\tcannot\tbe\tsolved\tby\tany\talgorithmic\ttechnique\t[Greedy,\tDivide\tand\tConquer\tand Dynamic\tProgramming]. The\tdifference\tbetween\tDynamic\tProgramming\tand\tstraightforward\trecursion\tis\tin\tmemoization of\trecursive\tcalls.\tIf\tthe\tsub\tproblems\tare\tindependent\tand\tthere\tis\tno\trepetition\tthen\tmemoization does\tnot\thelp,\tso\tdynamic\tprogramming\tis\tnot\ta\tsolution\tfor\tall\tproblems."
            },
            {
                "subchapter_title": "19.5\tDynamic\tProgramming\tApproaches",
                "content": "Basically\tthere\tare\ttwo\tapproaches\tfor\tsolving\tDP\tproblems: \u2022 Bottom-up\tdynamic\tprogramming \u2022 Top-down\tdynamic\tprogramming Bottom-up\tDynamic\tProgramming In\tthis\tmethod,\twe\tevaluate\tthe\tfunction\tstarting\twith\tthe\tsmallest\tpossible\tinput\targument\tvalue and\t then\t we\t step\t through\t possible\t values,\t slowly\t increasing\t the\t input\t argument\t value.\t While computing\tthe\tvalues\twe\tstore\tall\tcomputed\tvalues\tin\ta\ttable\t(memory).\tAs\tlarger\targuments\tare evaluated,\tpre-computed\tvalues\tfor\tsmaller\targuments\tcan\tbe\tused. Top-down\tDynamic\tProgramming In\tthis\tmethod,\tthe\tproblem\tis\tbroken\tinto\tsub\tproblems;\teach\tof\tthese\tsub\tproblems\tis\tsolved; and\t the\t solutions\t remembered,\t in\t case\t they\t need\t to\t be\t solved.\t Also,\t we\t save\t each\t computed value\tas\tthe\tfinal\taction\tof\tthe\trecursive\tfunction,\tand\tas\tthe\tfirst\taction\twe\tcheck\tif\tpre-computed value\texists. Bottom-up\tversus\tTop-down\tProgramming In\tbottom-up\tprogramming,\tthe\tprogrammer\thas\tto\tselect\tvalues\tto\tcalculate\tand\tdecide\tthe\torder of\tcalculation.\tIn\tthis\tcase,\tall\tsub\tproblems\tthat\tmight\tbe\tneeded\tare\tsolved\tin\tadvance\tand\tthen used\tto\tbuild\tup\tsolutions\tto\tlarger\tproblems.\tIn\ttop-down\tprogramming,\tthe\trecursive\tstructure of\t the\t original\t code\t is\t preserved,\t but\t unnecessary\t recalculation\t is\t avoided.\t The\t problem\t is broken\tinto\tsub\tproblems,\tthese\tsub\tproblems\tare\tsolved\tand\tthe\tsolutions\tremembered,\tin\tcase they\tneed\tto\tbe\tsolved\tagain. Note:\tSome\tproblems\tcan\tbe\tsolved\twith\tboth\tthe\ttechniques\tand\twe\twill\tsee\texamples\tin\tthe next\tsection."
            },
            {
                "subchapter_title": "19.6\tExamples\tof\tDynamic\tProgramming\tAlgorithms",
                "content": "\u2022 Many\tstring\talgorithms\tincluding\tlongest\tcommon\tsubsequence,\tlongest\tincreasing subsequence,\tlongest\tcommon\tsubstring,\tedit\tdistance. \u2022 Algorithms\ton\tgraphs\tcan\tbe\tsolved\tefficiently:\tBellman-Ford\talgorithm\tfor\tfinding the\tshortest\tdistance\tin\ta\tgraph,\tFloyd\u2019s\tAll-Pairs\tshortest\tpath\talgorithm,\tetc. \u2022 Chain\tmatrix\tmultiplication \u2022 Subset\tSum \u2022 0/1\tKnapsack \u2022 Travelling\tsalesman\tproblem,\tand\tmany\tmore"
            },
            {
                "subchapter_title": "19.7\tUnderstanding\tDynamic\tProgramming",
                "content": "Before\tgoing\tto\tproblems,\tlet\tus\tunderstand\thow\tDP\tworks\tthrough\texamples. Fibonacci\tSeries In\tFibonacci\tseries,\tthe\tcurrent\tnumber\tis\tthe\tsum\tof\tprevious\ttwo\tnumbers.\tThe\tFibonacci\tseries is\tdefined\tas\tfollows: The\trecursive\timplementation\tcan\tbe\tgiven\tas: Solving\tthe\tabove\trecurrence\tgives: Note:\tFor\tproof,\trefer\tto\tIntroduction\tchapter. How\tdoes\tMemoization\thelp? Calling\tfib(5)\tproduces\ta\tcall\ttree\tthat\tcalls\tthe\tfunction\ton\tthe\tsame\tvalue\tmany\ttimes: fib(5) fib(4)\t+\tfib(3) (fib(3)\t+\tfib(2))\t+\t(fib(2)\t+\tfib(1)) ((fib(2)\t+\tfib(1))\t+\t(fib(1)\t+\tfib(0)))\t+\t((fib(1)\t+\tfib(0))\t+\tfib(1)) (((fib(1)\t+\tfib(0))\t+\tfib(1))\t+\t(fib(1)\t+\tfib(0)))\t+\t((fib(1)\t+\tfib(0))\t+\tfib(1)) In\tthe\tabove\texample,\tfib(2)\twas\tcalculated\tthree\ttimes\t(overlapping\tof\tsubproblems).\tIf\tn\tis\tbig, then\tmany\tmore\tvalues\tof\tfib\t(sub\tproblems)\tare\trecalculated,\twhich\tleads\tto\tan\texponential\ttime algorithm.\tInstead\tof\tsolving\tthe\tsame\tsub\tproblems\tagain\tand\tagain\twe\tcan\tstore\tthe\tprevious calculated\tvalues\tand\treduce\tthe\tcomplexity. Memoization\t works\t like\t this:\t Start\t with\t a\t recursive\t function\t and\t add\t a\t table\t that\t maps\t the function\u2019s\tparameter\tvalues\tto\tthe\tresults\tcomputed\tby\tthe\tfunction.\tThen\tif\tthis\tfunction\tis\tcalled twice\twith\tthe\tsame\tparameters,\twe\tsimply\tlook\tup\tthe\tanswer\tin\tthe\ttable. Improving:\t Now,\t we\t see\t how\t DP\t reduces\t this\t problem\t complexity\t from\t exponential\t to polynomial.\tAs\tdiscussed\tearlier,\tthere\tare\ttwo\tways\tof\tdoing\tthis.\tOne\tapproach\tis\tbottom-up: these\tmethods\tstart\twith\tlower\tvalues\tof\tinput\tand\tkeep\tbuilding\tthe\tsolutions\tfor\thigher\tvalues. The\t other\t approach\t is\t top-down.\t In\t this\t method,\t we\t preserve\t the\t recursive\t calls\t and\t use\t the values\tif\tthey\tare\talready\tcomputed.\tThe\timplementation\tfor\tthis\tis\tgiven\tas: Note:\tFor\tall\tproblems,\tit\tmay\tnot\tbe\tpossible\tto\tfind\tboth\ttop-down\tand\tbottom-up\tprogramming solutions. Both\tversions\tof\tthe\tFibonacci\tseries\timplementations\tclearly\treduce\tthe\tproblem\tcomplexity\tto O(n).\tThis\tis\tbecause\tif\ta\tvalue\tis\talready\tcomputed\tthen\twe\tare\tnot\tcalling\tthe\tsubproblems again.\tInstead,\twe\tare\tdirectly\ttaking\tits\tvalue\tfrom\tthe\ttable. Time\tComplexity:\tO(n).\tSpace\tComplexity:\tO(n),\tfor\ttable. Further\tImproving:\tOne\tmore\tobservation\tfrom\tthe\tFibonacci\tseries\tis:\tThe\tcurrent\tvalue\tis\tthe sum\t of\t the\t previous\t two\t calculations\t only.\t This\t indicates\t that\t we\t don\u2019t\t have\t to\t store\t all\t the previous\tvalues.\tInstead,\tif\twe\tstore\tjust\tthe\tlast\ttwo\tvalues,\twe\tcan\tcalculate\tthe\tcurrent\tvalue. The\timplementation\tfor\tthis\tis\tgiven\tbelow: Time\tComplexity:\tO(n).\tSpace\tComplexity:\tO(1). Note:\tThis\tmethod\tmay\tnot\tbe\tapplicable\t(available)\tfor\tall\tproblems. Observations While\tsolving\tthe\tproblems\tusing\tDP,\ttry\tto\tfigure\tout\tthe\tfollowing: \u2022 See\thow\tthe\tproblems\tare\tdefined\tin\tterms\tof\tsubproblems\trecursively. \u2022 See\tif\twe\tcan\tuse\tsome\ttable\t[memoization]\tto\tavoid\tthe\trepeated\tcalculations. Factorial\tof\ta\tNumber As\tanother\texample,\tconsider\tthe\tfactorial\tproblem:\tn!\tis\tthe\tproduct\tof\tall\tintegers\tbetween\tn and\t1.\tThe\tdefinition\tof\trecursive\tfactorial\tcan\tbe\tgiven\tas: This\tdefinition\tcan\teasily\tbe\tconverted\tto\timplementation.\tHere\tthe\tproblem\tis\tfinding\tthe\tvalue of\tn!,\tand\tthe\tsub-problem\tis\tfinding\tthe\tvalue\tof\t(n\t\u2013\tl)!.\tIn\tthe\trecursive\tcase,\twhen\tn\tis\tgreater than\t1,\tthe\tfunction\tcalls\titself\tto\tfind\tthe\tvalue\tof\t(n\t\u2013\tl)!\tand\tmultiplies\tthat\twith\tn.\tIn\tthe\tbase case,\twhen\tn\tis\t0\tor\t1,\tthe\tfunction\tsimply\treturns\t1. The\trecurrence\tfor\tthe\tabove\timplementation\tcan\tbe\tgiven\tas:\tT(n)\t=\tn\t\u00d7\tT(n\t\u2013\t1)\t\u2248\tO(n) Time\tComplexity:\tO(n).\tSpace\tComplexity:\tO(n),\trecursive\tcalls\tneed\ta\tstack\tof\tsize\tn. In\t the\t above\t recurrence\t relation\t and\t implementation,\t for\t any\t n\t value,\t there\t are\t no\t repetitive calculations\t(no\toverlapping\tof\tsub\tproblems)\tand\tthe\tfactorial\tfunction\tis\tnot\tgetting\tany\tbenefits with\tdynamic\tprogramming.\tNow,\tlet\tus\tsay\twe\twant\tto\tcompute\ta\tseries\tof\tm!\tfor\tsome\tarbitrary value\tm.\tUsing\tthe\tabove\talgorithm,\tfor\teach\tsuch\tcall\twe\tcan\tcompute\tit\tin\tO(m).\tFor\texample, to\tfind\tboth\tn!\tand\tm!\twe\tcan\tuse\tthe\tabove\tapproach,\twherein\tthe\ttotal\tcomplexity\tfor\tfinding\tn! and\tm!\tis\tO(m\t+\tn). Time\tComplexity:\tO(n\t+\tm). Space\tComplexity:\tO(max(m,n)),\trecursive\tcalls\tneed\ta\tstack\tof\tsize\tequal\tto\tthe\tmaximum\tof\tm and\tn. Improving:\tNow\tlet\tus\tsee\thow\tDP\treduces\tthe\tcomplexity.\tFrom\tthe\tabove\trecursive\tdefinition it\tcan\tbe\tseen\tthat\tfact(n)\tis\tcalculated\tfrom\tfact(n\t-1)\tand\tn\tand\tnothing\telse.\tInstead\tof\tcalling fact(n)\tevery\ttime,\twe\tcan\tstore\tthe\tprevious\tcalculated\tvalues\tin\ta\ttable\tand\tuse\tthese\tvalues\tto calculate\ta\tnew\tvalue.\tThis\timplementation\tcan\tbe\tgiven\tas: For\tsimplicity,\tlet\tus\tassume\tthat\twe\thave\talready\tcalculated\tn!\tand\twant\tto\tfind\tm!.\tFor\tfinding m!,\twe\tjust\tneed\tto\tsee\tthe\ttable\tand\tuse\tthe\texisting\tentries\tif\tthey\tare\talready\tcomputed.\tIf\tm\t<\tn then\twe\tdo\tnot\thave\tto\trecalculate\tm!.\tIf\tm\t>\tn\tthen\twe\tcan\tuse\tn!\tand\tcall\tthe\tfactorial\ton\tthe remaining\tnumbers\tonly. The\tabove\timplementation\tclearly\treduces\tthe\tcomplexity\tto\tO(max(m,n)).\tThis\tis\tbecause\tif\tthe fact(n)\t is\t already\t there,\t then\t we\t are\t not\t recalculating\t the\t value\t again.\t If\t we\t fill\t these\t newly computed\tvalues,\tthen\tthe\tsubsequent\tcalls\tfurther\treduce\tthe\tcomplexity. Time\tComplexity:\tO(max(m,n)).\tSpace\tComplexity:\tO(max(m,n))\tfor\ttable."
            },
            {
                "subchapter_title": "19.8\tLongest\tCommon\tSubsequence",
                "content": "Given\t two\t strings:\t string\t X\t of\t length\t m\t [X(1..m)],\t and\t string\t Y\t of\t length\t n\t [Y(1..n)],\t find\t the longest\tcommon\tsubsequence:\tthe\tlongest\tsequence\tof\tcharacters\tthat\tappear\tleft-to-right\t(but\tnot necessarily\tin\ta\tcontiguous\tblock)\tin\tboth\tstrings.\tFor\texample,\tif\tX\t=\t\u201cABCBDAB\u201d\tand\tY\t = \u201cBDCABA\u201d,\t the\t LCS(X,\t Y)\t =\t {\u201cBCBA\u201d,\t \u201cBDAB\u201d,\t \u201cBCAB\u201d}.\t We\t can\t see\t there\t are\t several optimal\tsolutions. Brute\tForce\tApproach:\tOne\tsimple\tidea\tis\tto\tcheck\tevery\tsubsequence\tof\tX[1..\tm]\t(m\t is\t the length\tof\tsequence\tX)\tto\tsee\tif\tit\tis\talso\ta\tsubsequence\tof\tY[1..n]\t(n\tis\tthe\tlength\tof\tsequence\tY). Checking\t takes\t O(n)\t time,\t and\t there\t are\t 2m\t subsequences\t of\t X.\t The\t running\t time\t thus\t is exponential\tO(n.\t2m)\tand\tis\tnot\tgood\tfor\tlarge\tsequences. Recursive\tSolution:\tBefore\tgoing\tto\tDP\tsolution,\tlet\tus\tform\tthe\trecursive\tsolution\tfor\tthis\tand later\twe\tcan\tadd\tmemoization\tto\treduce\tthe\tcomplexity.\tLet\u2019s\tstart\twith\tsome\tsimple\tobservations about\tthe\tLCS\tproblem.\tIf\twe\thave\ttwo\tstrings,\tsay\t\u201cABCBDAB\u201d\tand\t\u201cBDCABA\u201d,\tand\tif\twe draw\tlines\tfrom\tthe\tletters\tin\tthe\tfirst\tstring\tto\tthe\tcorresponding\tletters\tin\tthe\tsecond,\tno\ttwo lines\tcross: From\tthe\tabove\tobservation,\twe\tcan\tsee\tthat\tthe\tcurrent\tcharacters\tof\tX\tand\tY\tmay\tor\tmay\tnot match.\tThat\tmeans,\tsuppose\tthat\tthe\ttwo\tfirst\tcharacters\tdiffer.\tThen\tit\tis\tnot\tpossible\tfor\tboth\tof them\tto\tbe\tpart\tof\ta\tcommon\tsubsequence\t-\tone\tor\tthe\tother\t(or\tmaybe\tboth)\twill\thave\tto\tbe removed.\tFinally,\tobserve\tthat\tonce\twe\thave\tdecided\twhat\tto\tdo\twith\tthe\tfirst\tcharacters\tof\tthe strings,\tthe\tremaining\tsub\tproblem\tis\tagain\ta\tLCS\tproblem,\ton\ttwo\tshorter\tstrings.\tTherefore\twe can\tsolve\tit\trecursively. The\tsolution\tto\tLCS\tshould\tfind\ttwo\tsequences\tin\tX\tand\tY\tand\tlet\tus\tsay\tthe\tstarting\tindex\tof sequence\tin\tX\tis\ti\tand\tthe\tstarting\tindex\tof\tsequence\tin\tY\tis\tj.\tAlso,\tassume\tthat\tX[i\t...m]\t is\t a substring\tof\tX\tstarting\tat\tcharacter\ti\tand\tgoing\tuntil\tthe\tend\tof\tX,\tand\tthat\tY[j\t...n]\tis\ta\tsubstring\tof Y\tstarting\tat\tcharacter\tj\tand\tgoing\tuntil\tthe\tend\tof\tY. Based\ton\tthe\tabove\tdiscussion,\there\twe\tget\tthe\tpossibilities\tas\tdescribed\tbelow: 1) If\tX[i]\t==\tY[j]\t:\t1\t+\tLCS(i\t+\t1,j\t+\t1) 2) If\tX[i]\t\u2260\tY[j].\tLCS(i,j\t+\t1)\t//\tskipping\tjth\tcharacter\tof\tY 3) If\tX[i]\t\u2260\tY[j].\tLCS(i\t+\t1,j)\t//\tskipping\tith\tcharacter\tof\tX In\tthe\tfirst\tcase,\tif\tX[i]\tis\tequal\tto\tY[j],\twe\tget\ta\tmatching\tpair\tand\tcan\tcount\tit\ttowards\tthe\ttotal length\tof\tthe\tLCS.\tOtherwise,\twe\tneed\tto\tskip\teither\tith\tcharacter\tof\tX\tor\tjth\tcharacter\tof\tY\tand find\tthe\tlongest\tcommon\tsubsequence.\tNow,\tLCS(i,j)\tcan\tbe\tdefined\tas: LCS\thas\tmany\tapplications.\tIn\tweb\tsearching,\tif\twe\tfind\tthe\tsmallest\tnumber\tof\tchanges\tthat\tare needed\tto\tchange\tone\tword\tinto\tanother.\tA\tchange\there\tis\tan\tinsertion,\tdeletion\tor\treplacement\tof a\tsingle\tcharacter. This\tis\ta\tcorrect\tsolution\tbut\tit\tis\tvery\ttime\tconsuming.\tFor\texample,\tif\tthe\ttwo\tstrings\thave\tno matching\tcharacters,\tthe\tlast\tline\talways\tgets\texecuted\twhich\tgives\t(if\tm\t==\tn)\tclose\tto\tO(2n). DP\tSolution:\tAdding\tMemoization:\tThe\tproblem\twith\tthe\trecursive\tsolution\tis\tthat\tthe\tsame subproblems\tget\tcalled\tmany\tdifferent\ttimes.\tA\tsubproblem\tconsists\tof\ta\tcall\tto\tLCS_length,\twith the\t arguments\t being\t two\t suffixes\t of\t X\t and\t Y,\t so\t there\t are\t exactly\t (i\t +\t 1)(j\t +\t 1)\t possible subproblems\t(a\trelatively\tsmall\tnumber).\tIf\tthere\tare\tnearly\t2n\trecursive\tcalls,\tsome\tof\tthese subproblems\tmust\tbe\tbeing\tsolved\tover\tand\tover. The\tDP\tsolution\tis\tto\tcheck,\twhenever\twe\twant\tto\tsolve\ta\tsub\tproblem,\twhether\twe\u2019ve\talready done\tit\tbefore.\tSo\twe\tlook\tup\tthe\tsolution\tinstead\tof\tsolving\tit\tagain.\tImplemented\tin\tthe\tmost direct\tway,\twe\tjust\tadd\tsome\tcode\tto\tour\trecursive\tsolution.\tTo\tdo\tthis,\tlook\tup\tthe\tcode.\tThis can\tbe\tgiven\tas: First,\ttake\tcare\tof\tthe\tbase\tcases.\tWe\thave\tcreated\tan\tLCS\ttable\twith\tone\trow\tand\tone\tcolumn larger\tthan\tthe\tlengths\tof\tthe\ttwo\tstrings.\tThen\trun\tthe\titerative\tDP\tloops\tto\tfill\teach\tcell\tin\tthe table.\tThis\tis\tlike\tdoing\trecursion\tbackwards,\tor\tbottom\tup. The\tvalue\tof\tLCS[i][j]\tdepends\ton\t3\tother\tvalues\t(LCS[i\t+\t1][j\t+\t1],\tLCS[i][j\t+\t1]\tand\tLCS[i\t+ 1][j]),\t all\t of\t which\t have\t larger\t values\t of\t i\t or\t j.\t They\t go\t through\t the\t table\t in\t the\t order\t of decreasing\ti\tand\tj\tvalues.\tThis\twill\tguarantee\tthat\twhen\twe\tneed\tto\tfill\tin\tthe\tvalue\tof\tLCS[i][j], we\talready\tknow\tthe\tvalues\tof\tall\tthe\tcells\ton\twhich\tit\tdepends. Time\tComplexity:\tO(mn),\tsince\ti\ttakes\tvalues\tfrom\t1\tto\tm\tand\tand\tj\ttakes\tvalues\tfrom\t1\tto\tn. Space\tComplexity:\tO(mn). Note:\tIn\tthe\tabove\tdiscussion,\twe\thave\tassumed\tLCS(i,j)\tis\tthe\tlength\tof\tthe\tLCS\twith\tX[i\t...m] and\tY[j\t...n].\tWe\tcan\tsolve\tthe\tproblem\tby\tchanging\tthe\tdefinition\tas\tLCS(i,j)\tis\tthe\tlength\tof\tthe LCS\twith\tX[1\t...i]\tand\tY[1...j]. Printing\t the\t subsequence:\t The\t above\t algorithm\t can\t find\t the\t length\t of\t the\t longest\t common subsequence\t but\t cannot\t give\t the\t actual\t longest\t subsequence.\t To\t get\t the\t sequence,\t we\t trace\t it through\tthe\ttable.\tStart\tat\tcell\t(0,0).\tWe\tknow\tthat\tthe\tvalue\tof\tLC5[0][0]\twas\tthe\tmaximum\tof\t3 values\tof\tthe\tneighboring\tcells.\tSo\twe\tsimply\trecompute\tLC5[0][0]\tand\tnote\twhich\tcell\tgave\tthe maximum\tvalue.\tThen\twe\tmove\tto\tthat\tcell\t(it\twill\tbe\tone\tof\t(1,1),\t(0,1)\tor\t(1,0))\tand\trepeat\tthis until\twe\thit\tthe\tboundary\tof\tthe\ttable.\tEvery\ttime\twe\tpass\tthrough\ta\tcell\t(i,j\u2019)\twhere\tX[i]\t==\tY[j], we\thave\ta\tmatching\tpair\tand\tprint\tX[i].\tAt\tthe\tend,\twe\twill\thave\tprinted\tthe\tlongest\tcommon subsequence\tin\tO(mn)\ttime. An\talternative\tway\tof\tgetting\tpath\tis\tto\tkeep\ta\tseparate\ttable\tfor\teach\tcell.\tThis\twill\ttell\tus\twhich direction\twe\tcame\tfrom\twhen\tcomputing\tthe\tvalue\tof\tthat\tcell.\tAt\tthe\tend,\twe\tagain\tstart\tat\tcell (0,0)\tand\tfollow\tthese\tdirections\tuntil\tthe\topposite\tcorner\tof\tthe\ttable. From\t the\t above\t examples,\t I\t hope\t you\t understood\t the\t idea\t behind\t DP.\t Now\t let\t us\t see\t more problems\twhich\tcan\tbe\teasily\tsolved\tusing\tthe\tDP\ttechnique. Note:\tAs\twe\thave\tseen\tabove,\tin\tDP\tthe\tmain\tcomponent\tis\trecursion.\tIf\twe\tknow\tthe\trecurrence then\tconverting\tthat\tto\tcode\tis\ta\tminimal\ttask.\tFor\tthe\tproblems\tbelow,\twe\tconcentrate\ton\tgetting the\trecurrence."
            },
            {
                "subchapter_title": "19.9\tDynamic\tProgramming:\tProblems\t&\tSolutions",
                "content": "Problem-1\u2003\u2003Convert\tthe\tfollowing\trecurrence\tto\tcode. Solution:\tThe\tcode\tfor\tthe\tgiven\trecursive\tformula\tcan\tbe\tgiven\tas: Problem-2\u2003\u2003Can\twe\timprove\tthe\tsolution\tto\tProblem-1\tusing\tmemoization\tof\tDP? Solution:\tYes.\tBefore\tfinding\ta\tsolution,\tlet\tus\tsee\thow\tthe\tvalues\tare\tcalculated. T(0)\t=\tT(1)\t=\t2 T(2)\t=\t2\t*\tT(1)\t*\tT(0) T(3)\t=\t2\t*\tT(1)\t*\tT(0)\t+\t2\t*\tT(2)\t*\tT(1) T(4)\t=\t2\t*\tT(1)\t*\tT(0)\t+\t2\t*\tT(2)\t*\tT(1)\t+\t2\t*\tT(3)\t*\tT(2) From\tthe\tabove\tcalculations\tit\tis\tclear\tthat\tthere\tare\tlots\tof\trepeated\tcalculations\twith\tthe\tsame input\tvalues.\tLet\tus\tuse\ta\ttable\tfor\tavoiding\tthese\trepeated\tcalculations,\tand\tthe\timplementation can\tbe\tgiven\tas: Time\tComplexity:\tO(n2),\ttwo\tfor\tloops.\tSpace\tComplexity:\tO(n),\tfor\ttable. Problem-3\u2003\u2003Can\twe\tfurther\timprove\tthe\tcomplexity\tof\tProblem-2? Solution:\tYes,\tsince\tall\tsub\tproblem\tcalculations\tare\tdependent\tonly\ton\tprevious\tcalculations, code\tcan\tbe\tmodified\tas: Time\tComplexity:\tO(n),\tsince\tonly\tone\tfor\tloop.\tSpace\tComplexity:\tO(n). Problem-4\u2003\u2003Maximum\tValue\tContiguous\tSubsequence:\tGiven\tan\tarray\tof\tn\tnumbers,\tgive an\t algorithm\t for\t finding\t a\t contiguous\t subsequence\t A(i)...\t A(j)\t for\t which\t the\t sum\t of elements\tis\tmaximum.\tExample:\t{-2,\t11,\t-4,\t13,\t-5,\t2}\t\u2192\t20\tand\t{1,\t-3,\t4,\t-2,\t-1,\t6}\t\u2192\t7 Solution: Input:\tArray.\tA(1)\t...\tA(n)\tof\tn\tnumbers. Goal:\tIf\tthere\tare\tno\tnegative\tnumbers,\tthen\tthe\tsolution\tis\tjust\tthe\tsum\tof\tall\telements\tin\tthe given\tarray.\tIf\tnegative\tnumbers\tare\tthere,\tthen\tour\taim\tis\tto\tmaximize\tthe\tsum\t[there\tcan\tbe\ta negative\tnumber\tin\tthe\tcontiguous\tsum]. One\tsimple\tand\tbrute\tforce\tapproach\tis\tto\tsee\tall\tpossible\tsums\tand\tselect\tthe\tone\twhich\thas maximum\tvalue. Time\tComplexity:\tO(n3).\tSpace\tComplexity:\tO(1). Problem-5\u2003\u2003Can\twe\timprove\tthe\tcomplexity\tof\tProblem-4? Solution:\tYes.\tOne\timportant\tobservation\tis\tthat,\tif\twe\thave\talready\tcalculated\tthe\tsum\tfor\tthe subsequence\ti,...,j\t\u2013\t1,\tthen\twe\tneed\tonly\tone\tmore\taddition\tto\tget\tthe\tsum\tfor\tthe\tsubsequence i,...,j.\tBut,\tthe\tProblem-4\talgorithm\tignores\tthis\tinformation.\tIf\twe\tuse\tthis\tfact,\twe\tcan\tget\tan improved\talgorithm\twith\tthe\trunning\ttime\tO(n2). Time\tComplexity:\tO(n2).\tSpace\tComplexity:\tO(1). Problem-6\u2003\u2003Can\twe\tsolve\tProblem-4\tusing\tDynamic\tProgramming? Solution:\tYes.\tFor\tsimplicity,\tlet\tus\tsay,\tM(i)\tindicates\tmaximum\tsum\tover\tall\twindows\tending\tat i. To\tfind\tmaximum\tsum\twe\thave\tto\tdo\tone\tof\tthe\tfollowing\tand\tselect\tmaximum\tamong\tthem. \u2022 Either\textend\tthe\told\tsum\tby\tadding\tA[i] \u2022 or\tstart\tnew\twindow\tstarting\twith\tone\telement\tA[i] Where,\tM(i\t\u2013\t1)\t+\tA[i]\tindicates\tthe\tcase\tof\textending\tthe\tprevious\tsum\tby\tadding\tA[i]\tand\t0 indicates\tthe\tnew\twindow\tstarting\tat\tA[i]. Time\tComplexity:\tO(n).\tSpace\tComplexity:\tO(n),\tfor\ttable. Problem-7\u2003\u2003Is\tthere\tany\tother\tway\tof\tsolving\tProblem-4? Solution:\tYes.\tWe\tcan\tsolve\tthis\tproblem\twithout\tDP\ttoo\t(without\tmemory).\tThe\talgorithm\tis\ta little\t tricky.\t One\t simple\t way\t is\t to\t look\t for\t all\t positive\t contiguous\t segments\t of\t the\t array (sumEndingHere)\t and\t keep\t track\t of\t the\t maximum\t sum\t contiguous\t segment\t among\t all\t positive segments\t (sumSoFar).\t Each\t time\t we\t get\t a\t positive\t sum\t compare\t it\t (sumEndingHere)\t with sumSoFar\tand\tupdate\tsumSoFar\tif\tit\tis\tgreater\tthan\tsumSoFar.\tLet\tus\tconsider\tthe\tfollowing code\tfor\tthe\tabove\tobservation. Note:\tThe\talgorithm\tdoesn\u2019t\twork\tif\tthe\tinput\tcontains\tall\tnegative\tnumbers.\tIt\treturns\t0\tif\tall numbers\t are\t negative.\t To\t overcome\t this,\t we\t can\t add\t an\t extra\t check\t before\t the\t actual implementation.\tThe\tphase\twill\tlook\tif\tall\tnumbers\tare\tnegative,\tand\tif\tthey\tare\tit\twill\treturn maximum\tof\tthem\t(or\tsmallest\tin\tterms\tof\tabsolute\tvalue). Time\tComplexity:\tO(n),\tbecause\twe\tare\tdoing\tonly\tone\tscan.\tSpace\tComplexity:\tO(1),\tfor\ttable. Problem-8\u2003\u2003In\tProblem-7\tsolution,\twe\thave\tassumed\tthat\tM(i)\tindicates\tmaximum\tsum\tover all\twindows\tending\tat\ti.\tCan\twe\tassume\tM(i)\tindicates\tmaximum\tsum\tover\tall\twindows starting\tat\ti\tand\tending\tat\tn? Solution:\tYes.\tFor\tsimplicity,\tlet\tus\tsay,\tM(i)\tindicates\tmaximum\tsum\tover\tall\twindows\tstarting at\ti. To\tfind\tmaximum\twindow\twe\thave\tto\tdo\tone\tof\tthe\tfollowing\tand\tselect\tmaximum\tamong\tthem. \u2022 Either\textend\tthe\told\tsum\tby\tadding\tA[i] \u2022 Or\tstart\tnew\twindow\tstarting\twith\tone\telement\tA[i] Where,\tM(i\t+\t1)\t+\tA[t]\tindicates\tthe\tcase\tof\textending\tthe\tprevious\tsum\tby\tadding\tA[i],\tand\t0 indicates\tthe\tnew\twindow\tstarting\tat\tA[i]. Time\tComplexity:\tO(n).\tSpace\tComplexity:\tO(n),\tfor\ttable. Note:\tFor\tO(nlogn)\tsolution,\trefer\tto\tthe\tDivide\tand\tConquer\tchapter. Problem-9\u2003\u2003Given\t a\t sequence\t of\t n\t numbers\t A(1)\t ...A(n),\t give\t an\t algorithm\t for\t finding\t a contiguous\tsubsequence\tA(i)\t...A(j)\tfor\twhich\tthe\tsum\tof\telements\tin\tthe\tsubsequence\tis maximum.\tHere\tthe\tcondition\tis\twe\tshould\tnot\tselect\ttwo\tcontiguous\tnumbers. Solution:\tLet\tus\tsee\thow\tDP\tsolves\tthis\tproblem.\tAssume\tthat\tM(i)\trepresents\tthe\tmaximum\tsum from\t 1\t to\t i\t numbers\t without\t selecting\t two\t contiguous\t numbers.\t While\t computing\t M(i),\t the decision\t we\t have\t to\t make\t is,\t whether\t to\t select\t the\t ith\t element\t or\t not.\t This\t gives\t us\t two possibilities\tand\tbased\ton\tthis\twe\tcan\twrite\tthe\trecursive\tformula\tas: \u2022 The\tfirst\tcase\tindicates\twhether\twe\tare\tselecting\tthe\tith\telement\tor\tnot.\tIf\twe\tdon\u2019t select\tthe\tith\telement\tthen\twe\thave\tto\tmaximize\tthe\tsum\tusing\tthe\telements\t1\tto\ti\t\u2013"
            }
        ]
    },
    {
        "chapter_title": "1.\tIf\tith\telement\tis\tselected\tthen\twe\tshould\tnot\tselect\ti\t\u2013\t1th\telement\tand\tneed\tto",
        "subchapters": [
            {
                "subchapter_title": "maximize\tthe\tsum\tusing\t1\tto\ti\t\u2013\t2\telements.",
                "content": "\u2022 In\tthe\tabove\trepresentation,\tthe\tlast\ttwo\tcases\tindicate\tthe\tbase\tcases. Time\tComplexity:\tO(n).\tSpace\tComplexity:\tO(n). Problem-10\u2003\u2003In\tProblem-9,\twe\tassumed\tthat\tM(i)\trepresents\tthe\tmaximum\tsum\tfrom\t1\tto\ti numbers\twithout\tselecting\ttwo\tcontiguous\tnumbers.\tCan\twe\tsolve\tthe\tsame\tproblem\tby changing\tthe\tdefinition\tas:\tM(i)\trepresents\tthe\tmaximum\tsum\tfrom\ti\tto\tn\tnumbers\twithout selecting\ttwo\tcontiguous\tnumbers? Solution:\tYes.\tLet\tus\tassume\tthat\tM(i)\trepresents\tthe\tmaximum\tsum\tfrom\ti\tto\tn\tnumbers\twithout selecting\ttwo\tcontiguous\tnumbers: As\tsimilar\tto\tProblem-9\tsolution,\twe\tcan\twrite\tthe\trecursive\tformula\tas: \u2022 The\tfirst\tcase\tindicates\twhether\twe\tare\tselecting\tthe\tith\telement\tor\tnot.\tIf\twe\tdon\u2019t select\tthe\tith\telement\tthen\twe\thave\tto\tmaximize\tthe\tsum\tusing\tthe\telements\ti\t+\t1\tto n.\t If\t ith\t element\t is\t selected\t then\t we\t should\t not\t select\t i\t +\t 1th\t element\t need\t to maximize\tthe\tsum\tusing\ti\t+\t2\tto\tn\telements. \u2022 In\tthe\tabove\trepresentation,\tthe\tlast\ttwo\tcases\tindicate\tthe\tbase\tcases. Time\tComplexity:\tO(n).\tSpace\tComplexity:\tO(n). Problem-11\u2003\u2003Given\t a\t sequence\t of\t n\t numbers\t A(1)\t ...A(n),\t give\t an\t algorithm\t for\t finding\t a contiguous\tsubsequence\tA(i)\t...A(j)\tfor\twhich\tthe\tsum\tof\telements\tin\tthe\tsubsequence\tis maximum.\tHere\tthe\tcondition\tis\twe\tshould\tnot\tselect\tthree\tcontinuous\tnumbers. Solution:\tInput:\tArray\tA(1)\t...A(n)\tof\tn\tnumbers. Assume\t that\t M(i)\t represents\t the\t maximum\t sum\t from\t 1\t to\t i\t numbers\t without\t selecting\t three contiguous\tnumbers.\tWhile\tcomputing\tM(i),\tthe\tdecision\twe\thave\tto\tmake\tis,\twhether\tto\tselect\tith element\tor\tnot.\tThis\tgives\tus\tthe\tfollowing\tpossibilities: \u2022 In\tthe\tgiven\tproblem\tthe\trestriction\tis\tnot\tto\tselect\tthree\tcontinuous\tnumbers,\tbut\twe can\tselect\ttwo\telements\tcontinuously\tand\tskip\tthe\tthird\tone.\tThat\tis\twhat\tthe\tfirst case\tsays\tin\tthe\tabove\trecursive\tformula.\tThat\tmeans\twe\tare\tskipping\tA[i\t\u2013\t2]. \u2022 The\tother\tpossibility\tis,\tselecting\tith\telement\tand\tskipping\tsecond\ti\t\u2013\t1th\t element. This\tis\tthe\tsecond\tcase\t(skipping\tA[i\t\u2013\t1]). \u2022 The\tthird\tterm\tdefines\tthe\tcase\tof\tnot\tselecting\tith\telement\tand\tas\ta\tresult\twe\tshould solve\tthe\tproblem\twith\ti\t\u2013\t1\telements. Time\tComplexity:\tO(n).\tSpace\tComplexity:\tO(n). Problem-12\u2003\u2003In\tProblem-11,\twe\tassumed\tthat\tM(i)\trepresents\tthe\tmaximum\tsum\tfrom\t1\tto\ti numbers\twithout\tselecting\tthree\tcontiguous\tnumbers.\tCan\twe\tsolve\tthe\tsame\tproblem\tby changing\tthe\tdefinition\tas:\tM(i)\trepresents\tthe\tmaximum\tsum\tfrom\ti\tto\tn\tnumbers\twithout selecting\tthree\tcontiguous\tnumbers? Solution:\t Yes.\t The\t reasoning\t is\t very\t much\t similar.\t Let\t us\t see\t how\t DP\t solves\t this\t problem. Assume\t that\t M(i)\t represents\t the\t maximum\t sum\t from\t i\t to\t n\t numbers\t without\t selecting\t three contiguous\tnumbers. While\tcomputing\tM(i),\tthe\tdecision\twe\thave\tto\tmake\tis,\twhether\tto\tselect\tith\telement\tor\tnot.\tThis gives\tus\tthe\tfollowing\tpossibilities: \u2022 In\tthe\tgiven\tproblem\tthe\trestriction\tis\tto\tnot\tselect\tthree\tcontinuous\tnumbers,\tbut\twe can\tselect\ttwo\telements\tcontinuously\tand\tskip\tthe\tthird\tone.\tThat\tis\twhat\tthe\tfirst case\tsays\tin\tthe\tabove\trecursive\tformula.\tThat\tmeans\twe\tare\tskipping\tA[i\t+\t2]. \u2022 The\tother\tpossibility\tis,\tselecting\tith\telement\tand\tskipping\tsecond\ti\t\u2013\t1th\t element. This\tis\tthe\tsecond\tcase\t(skipping\tA[i\t+\t1]). \u2022 And\tthe\tthird\tcase\tis\tnot\tselecting\tith\telement\tand\tas\ta\tresult\twe\tshould\tsolve\tthe problem\twith\ti\t+\t1\telements. Time\tComplexity:\tO(n).\tSpace\tComplexity:\tO(n). Problem-13\u2003\u2003Catalan\tNumbers:\tHow\tmany\tbinary\tsearch\ttrees\tare\tthere\twith\tn\tvertices? Solution:\tBinary\tSearch\tTree\t(BST)\tis\ta\ttree\twhere\tthe\tleft\tsubtree\telements\tare\tless\tthan\tthe root\t element,\t and\t the\t right\t subtree\t elements\t are\t greater\t than\t the\t root\t element.\t This\t property should\tbe\tsatisfied\tat\tevery\tnode\tin\tthe\ttree.\tThe\tnumber\tof\tBSTs\twith\tn\tnodes\tis\tcalled\tCatalan Number\tand\tis\tdenoted\tby\tCn.\tFor\texample,\tthere\tare\t2\tBSTs\twith\t2\tnodes\t(2\tchoices\tfor\tthe root)\tand\t5\tBSTs\twith\t3\tnodes. Let\tus\tassume\tthat\tthe\tnodes\tof\tthe\ttree\tare\tnumbered\tfrom\t1\tto\tn.\tAmong\tthe\tnodes,\twe\thave\tto select\tsome\tnode\tas\troot,\tand\tthen\tdivide\tthe\tnodes\twhich\tare\tless\tthan\troot\tnode\tinto\tleft\tsub tree,\tand\telements\tgreater\tthan\troot\tnode\tinto\tright\tsub\ttree.\tSince\twe\thave\talready\tnumbered\tthe vertices,\tlet\tus\tassume\tthat\tthe\troot\telement\twe\tselected\tis\tith\telement. If\twe\tselect\tith\telement\tas\troot\tthen\twe\tget\ti\t\u2013\t1\telements\ton\tleft\tsub-tree\tand\tn\t\u2013\ti\telements\ton right\tsub\ttree.\tSince\tCn\tis\tthe\tCatalan\tnumber\tfor\tn\telements,\tCi\u20131\trepresents\tthe\tCatalan\tnumber for\tleft\tsub\ttree\telements\t(i\t\u2013\t1\telements)\tand\tCn\u2013i\trepresents\tthe\tCatalan\tnumber\tfor\tright\tsub tree\telements.\tThe\ttwo\tsub\ttrees\tare\tindependent\tof\teach\tother,\tso\twe\tsimply\tmultiply\tthe\ttwo numbers.\tThat\tmeans,\tthe\tCatalan\tnumber\tfor\ta\tfixed\ti\tvalue\tis\tCi\u20131\t\u00d7\tCn\u2013i. Since\tthere\tare\tn\tnodes,\tfor\ti\twe\twill\tget\tn\tchoices.\tThe\ttotal\tCatalan\tnumber\twith\tn\tnodes\tcan be\tgiven\tas: Time\tComplexity:\tO(4n).\tFor\tproof,\trefer\tIntroduction\tchapter. Problem-14\u2003\u2003Can\twe\timprove\tthe\ttime\tcomplexity\tof\tProblem-13\tusing\tDP? Solution:\tThe\trecursive\tcall\tCn\tdepends\tonly\ton\tthe\tnumbers\tC0\tto\tCn\u20131\tand\tfor\tany\tvalue\tof\ti, there\tare\ta\tlot\tof\trecalculations.\tWe\twill\tkeep\ta\ttable\tof\tpreviously\tcomputed\tvalues\tof\tCi.\tIf\tthe function\tCatalanNumber()\tis\tcalled\twith\tparameter\ti,\tand\tif\tit\thas\talready\tbeen\tcomputed\tbefore, then\twe\tcan\tsimply\tavoid\trecalculating\tthe\tsame\tsubproblem. The\ttime\tcomplexity\tof\tthis\timplementation\tO(n2),\tbecause\tto\tcompute\tCatalanNumber(n),\t we need\tto\tcompute\tall\tof\tthe\tCatalanNumber(i)\tvalues\tbetween\t0\tand\tn\t\u2013\t1,\tand\teach\tone\twill\tbe computed\texactly\tonce,\tin\tlinear\ttime. In\tmathematics,\tCatalan\tNumber\tcan\tbe\trepresented\tby\tdirect\tequation\tas:\t Problem-15\u2003\u2003Matrix\tProduct\tParenthesizations:\tGiven\ta\tseries\tof\tmatrices:\tA1\t\u00d7\tA2\t\u00d7\tA3\t\u00d7 .\t .\t .\t \u00d7\t An\t with\t their\t dimensions,\t what\t is\t the\t best\t way\t to\t parenthesize\t them\t so\t that\t it produces\tthe\tminimum\tnumber\tof\ttotal\tmultiplications.\tAssume\tthat\twe\tare\tusing\tstandard matrix\tand\tnot\tStrassen\u2019s\tmatrix\tmultiplication\talgorithm. Solution:\tInput:\tSequence\tof\tmatrices\tA1\t\u00d7\tA2\t\u00d7\tA3\t\u00d7\t.\t.\t.\t\u00d7\tAn,\twhere\tAi\tis\ta\tPi\u20131\t\u00d7\tPi.\t The dimensions\tare\tgiven\tin\tan\tarray\tP. Goal:\t Parenthesize\t the\t given\t matrices\t in\t such\t a\t way\t that\t it\t produces\t the\t optimal\t number\t of multiplications\tneeded\tto\tcompute\tA1\t\u00d7\tA2\t\u00d7\tA3\t\u00d7\t.\t.\t.\t\u00d7\tAn. For\t the\t matrix\t multiplication\t problem,\t there\t are\t many\t possibilities.\t This\t is\t because\t matrix multiplication\tis\tassociative.\tIt\tdoes\tnot\tmatter\thow\twe\tparenthesize\tthe\tproduct,\tthe\tresult\twill be\tthe\tsame.\tAs\tan\texample,\tfor\tfour\tmatrices\tA,\tB,\tC,\tand\tD,\tthe\tpossibilities\tcould\tbe: (ABC)D\t=\t(AB)(CD)\t=\tA(BCD)\t=\tA(BC)D\t=.. Multiplying\t(p\t\u00d7\tq)\tmatrix\twith\t(q\t\u00d7\tr)\tmatrix\trequires\tpqr\tmultiplications.\tEach\tof\tthe\tabove possibilities\t produces\t a\t different\t number\t of\t products\t during\t multiplication.\t To\t select\t the\t best one,\twe\tcan\tgo\tthrough\teach\tpossible\tparenthesization\t(brute\tforce),\tbut\tthis\trequires\tO(2n)\ttime and\t is\t very\t slow.\t Now\t let\t us\t use\t DP\t to\t improve\t this\t time\t complexity.\t Assume\t that,\t M[i,j] represents\tthe\tleast\tnumber\tof\tmultiplications\tneeded\tto\tmultiply\tAi\t\u2026\tAj. The\tabove\trecursive\tformula\tsays\tthat\twe\thave\tto\tfind\tpoint\tk\tsuch\tthat\tit\tproduces\tthe\tminimum number\tof\tmultiplications.\tAfter\tcomputing\tall\tpossible\tvalues\tfor\tk,\twe\thave\tto\tselect\tthe\tk\tvalue which\tgives\tminimum\tvalue.\tWe\tcan\tuse\tone\tmore\ttable\t(say,\tS[i,j])\tto\treconstruct\tthe\toptimal parenthesizations.\tCompute\tthe\tM[i,j]\tand\tS[i,j]\tin\ta\tbottom-up\tfashion. How\tmany\tsub\tproblems\tare\tthere?\tIn\tthe\tabove\tformula,\ti\tcan\trange\tfrom\t1\tto\tn\tand\tj\t can range\tfrom\t1\tto\tn.\tSo\tthere\tare\ta\ttotal\tof\tn2\tsubproblems,\tand\talso\twe\tare\tdoing\tn\t \u2013\t 1\t such operations\t[since\tthe\ttotal\tnumber\tof\toperations\twe\tneed\tfor\tA1\t\u00d7\tA2\t\u00d7A3\t\u00d7.\t.\t.\t\u00d7\tAn\tise\tn\t\u2013\t1].\tSo the\ttime\tcomplexity\tis\tO(n3). Space\tComplexity:\tO(n2). Problem-16\u2003\u2003For\tthe\tProblem-15,\tcan\twe\tuse\tgreedy\tmethod? Solution:\tGreedy\tmethod\tis\tnot\tan\toptimal\tway\tof\tsolving\tthis\tproblem.\tLet\tus\tgo\tthrough\tsome counter\texample\tfor\tthis.\tAs\twe\thave\tseen\talready,\tgreedy\tmethod\tmakes\tthe\tdecision\tthat\tis\tgood locally\tand\tit\tdoes\tnot\tconsider\tthe\tfuture\toptimal\tsolutions.\tIn\tthis\tcase,\tif\twe\tuse\tGreedy,\tthen we\talways\tdo\tthe\tcheapest\tmultiplication\tfirst.\tSometimes\tit\treturns\ta\tparenthesization\tthat\tis\tnot optimal. Example:\tConsider\tA1\t\u00d7\tA2\t\u00d7\tA3\twith\tdimentions\t3\t\u00d7\t100,\t100\t\u00d7\t2\tand\t2\t\u00d7\t2.\tBased\ton\tgreedy we\tparenthesize\tthem\tas:\tA1\t\u00d7\t(A2\t\u00d7A3)\twith\t100\t\u00b7\t2\t\u00b7\t2\t+\t3\t\u00b7\t100\t\u00b7\t2\t=\t1000\tmultiplications.\tBut the\t optimal\t solution\t to\t this\t problem\t is:\t (A1\t \u00d7\t A2)\t \u00d7\t A3\t with\t 3\t \u00b7\t 100\t \u00b7\t 2\t +\t 3\t \u00b7\t 2\t \u00b7\t 2\t =\t 612 multiplications.\t\u2234\twe\tcannot\tuse\tgreedy\tfor\tsolving\tthis\tproblem. Problem-17\u2003\u2003Integer\t Knapsack\t Problem\t [Duplicate\t Items\t Permitted]:\t Given\t n\t types\t of items,\t where\t the\t ith\t item\t type\t has\t an\t integer\t size\t si\t and\t a\t value\t vi.\t We\t need\t to\t fill\t a knapsack\tof\ttotal\tcapacity\tC\twith\titems\tof\tmaximum\tvalue.\tWe\tcan\tadd\tmultiple\titems\tof the\tsame\ttype\tto\tthe\tknapsack. Note:\tFor\tFractional\tKnapsack\tproblem\trefer\tto\tGreedy\tAlgorithms\tchapter. Solution:\tInput:\tn\ttypes\tof\titems\twhere\tith\ttype\titem\thas\tthe\tsize\tsi\tand\tvalue\tvi.\tAlso,\tassume infinite\tnumber\tof\titems\tfor\teach\titem\ttype. Goal:\tFill\tthe\tknapsack\twith\tcapacity\tC\tby\tusing\tn\ttypes\tof\titems\tand\twith\tmaximum\tvalue. One\timportant\tnote\tis\tthat\tit\u2019s\tnot\tcompulsory\tto\tfill\tthe\tknapsack\tcompletely.\tThat\tmeans,\tfilling the\t knapsack\t completely\t [of\t size\t C]\t if\t we\t get\t a\t value\t V\t and\t without\t filling\t the\t knapsack completely\t[1et\tus\tsay\tC\t\u2013\t1]\twith\tvalue\tU\tand\tif\tV\t<\tU\tthen\twe\tconsider\tthe\tsecond\tone.\tIn\tthis case,\twe\tare\tbasically\tfilling\tthe\tknapsack\tof\tsize\tC\t\u2013\t1.\tIf\twe\tget\tthe\tsame\tsituation\tfor\tC\t\u2013\t1 also,\tthen\twe\ttry\tto\tfill\tthe\tknapsack\twith\tC\t\u2013\t2\tsize\tand\tget\tthe\tmaximum\tvalue. Let\tus\tsay\tM(j)\tdenotes\tthe\tmaximum\tvalue\twe\tcan\tpack\tinto\ta\tj\tsize\tknapsack.\tWe\tcan\texpress M(j)\trecursively\tin\tterms\tof\tsolutions\tto\tsub\tproblems\tas\tfollows: For\tthis\tproblem\tthe\tdecision\tdepends\ton\twhether\twe\tselect\ta\tparticular\tith\titem\tor\tnot\tfor\ta knapsack\tof\tsize\tj. \u2022 If\twe\tselect\tith\titem,\tthen\twe\tadd\tits\tvalue\tvi\tto\tthe\toptimal\tsolution\tand\tdecrease\tthe size\tof\tthe\tknapsack\tto\tbe\tsolved\tto\tj\t\u2013\tsi. \u2022 If\twe\tdo\tnot\tselect\tthe\titem\tthen\tcheck\twhether\twe\tcan\tget\ta\tbetter\tsolution\tfor\tthe knapsack\tof\tsize\tj\t\u2013\t1. The\tvalue\tof\tM(C)\twill\tcontain\tthe\tvalue\tof\tthe\toptimal\tsolution.\tWe\tcan\tfind\tthe\tlist\tof\titems\tin the\toptimal\tsolution\tby\tmaintaining\tand\tfollowing\t\u201cback\tpointers\u201d. Time\tComplexity:\tFinding\teach\tM(j)\tvalue\twill\trequire\t\u0398(n)\ttime,\tand\twe\tneed\tto\tsequentially compute\tC\tsuch\tvalues.\tTherefore,\ttotal\trunning\ttime\tis\t\u0398(nC). Space\tComplexity:\t\u0398(C). Problem-18\u2003\u20030-1\tKnapsack\tProblem:\tFor\tProblem-17,\thow\tdo\twe\tsolve\tit\tif\tthe\titems\tare not\t duplicated\t (not\t having\t an\t infinite\t number\t of\t items\t for\t each\t type,\t and\t each\t item\t is allowed\tto\tbe\tused\tfor\t0\tor\t1\ttime)? Real-time\t example:\t Suppose\t we\t are\t going\t by\t flight,\t and\t we\t know\t that\t there\t is\t a limitation\ton\tthe\tluggage\tweight.\tAlso,\tthe\titems\twhich\twe\tare\tcarrying\tcan\tbe\tof\tdifferent types\t(like\tlaptops,\tetc.).\tIn\tthis\tcase,\tour\tobjective\tis\tto\tselect\tthe\titems\twith\tmaximum value.\tThat\tmeans,\twe\tneed\tto\ttell\tthe\tcustoms\tofficer\tto\tselect\tthe\titems\twhich\thave\tmore weight\tand\tless\tvalue\t(profit). Solution:\tInput\tis\ta\tset\tof\tn\titems\twith\tsizes\tsi\tand\tvalues\tvi\tand\ta\tKnapsack\tof\tsize\tC\twhich\twe need\tto\tfill\twith\ta\tsubset\tof\titems\tfrom\tthe\tgiven\tset.\tLet\tus\ttry\tto\tfind\tthe\trecursive\tformula\tfor this\tproblem\tusing\tDP.\tLet\tM(i,j)\trepresent\tthe\toptimal\tvalue\twe\tcan\tget\tfor\tfilling\tup\ta\tknapsack of\tsize\tj\twith\titems\t1...\ti.\tThe\trecursive\tformula\tcan\tbe\tgiven\tas: Time\tComplexity:\tO(nC),\tsince\tthere\tare\tnC\tsubproblems\tto\tbe\tsolved\tand\teach\tof\tthem\ttakes O(1)\tto\tcompute.\tSpace\tComplexity:\tO(nC),\twhere\tas\tInteger\tKnapsack\ttakes\tonly\tO(C). Now\tlet\tus\tconsider\tthe\tfollowing\tdiagram\twhich\thelps\tus\tin\treconstructing\tthe\toptimal\tsolution and\talso\tgives\tfurther\tunderstanding.\tSize\tof\tbelow\tmatrix\tis\tM. Since\ti\ttakes\tvalues\tfrom\t1\t...n\tand\tj\ttakes\tvalues\tfrom\t1...\tC,\tthere\tare\ta\ttotal\tof\tnC\tsubproblems. Now\tlet\tus\tsee\twhat\tthe\tabove\tformula\tsays: \u2022 M(i\t\u2013\t1,j):\tIndicates\tthe\tcase\tof\tnot\tselecting\tthe\tith\titem.\tIn\tthis\tcase,\tsince\twe\tare not\t adding\t any\t size\t to\t the\t knapsack\t we\t have\t to\t use\t the\t same\t knapsack\t size\t for subproblems\tbut\texcluding\tthe\tith\titem.\tThe\tremaining\titems\tare\ti\t\u2013\t1. \u2022 M(i\t\u2013\t1,j\t\u2013\tsi)\t+\tvi\tindicates\tthe\tcase\twhere\twe\thave\tselected\tthe\tith\titem.\tIf\twe\tadd the\tith\titem\tthen\twe\thave\tto\treduce\tthe\tsubproblem\tknapsack\tsize\tto\tj\t\u2013\tsi\tand\tat\tthe same\ttime\twe\tneed\tto\tadd\tthe\tvalue\tvi\tto\tthe\toptimal\tsolution.\tThe\tremaining\titems are\ti\t\u2013\t1. Now,\t after\t finding\t all\t M(i,j)\t values,\t the\t optimal\t objective\t value\t can\t be\t obtained\t as: Maxj{M(n,j)} This\tis\tbecause\twe\tdo\tnot\tknow\twhat\tamount\tof\tcapacity\tgives\tthe\tbest\tsolution. In\torder\tto\tcompute\tsome\tvalue\tM(i,j),\twe\ttake\tthe\tmaximum\tof\tM(i\t\u2013\t1,j)\tand\tM(i\t\u2013\t1,j\t\u2013\tsi)\t+\tvi. These\t two\t values\t (M(i,j)\t and\t M(i\t \u2013\t 1,j\t \u2013\t si))\t appear\t in\t the\t previous\t row\t and\t also\t in\t some previous\tcolumns.\tSo,\tM(i,j)\tcan\tbe\tcomputed\tjust\tby\tlooking\tat\ttwo\tvalues\tin\tthe\tprevious\trow in\tthe\ttable. Problem-19\tMaking\tChange:\tGiven\tn\ttypes\tof\tcoin\tdenominations\tof\tvalues\tv1\t<\tv2\t <...<\t vn (integers).\tAssume\tv1\t=\t1,\tso\tthat\twe\tcan\talways\tmake\tchange\tfor\tany\tamount\tof\tmoney\tC. Give\tan\talgorithm\twhich\tmakes\tchange\tfor\tan\tamount\tof\tmoney\tC\twith\tas\tfew\tcoins\tas possible. Solution: This\t problem\t is\t identical\t to\t the\t Integer\t Knapsack\t problem.\t In\t our\t problem,\t we\t have\t coin denominations,\teach\tof\tvalue\tvi.\tWe\tcan\tconstruct\tan\tinstance\tof\ta\tKnapsack\tproblem\tfor\teach item\tthat\thas\ta\tsizes\tsi,\twhich\tis\tequal\tto\tthe\tvalue\tof\tvi\tcoin\tdenomination.\tIn\tthe\tKnapsack\twe can\tgive\tthe\tvalue\tof\tevery\titem\tas\t\u20131. Now\t it\t is\t easy\t to\t understand\t an\t optimal\t way\t to\t make\t money\t C\t with\t the\t fewest\t coins\t is completely\tequivalent\tto\tthe\toptimal\tway\tto\tfill\tthe\tKnapsack\tof\tsize\tC.\tThis\tis\tbecause\tsince every\tvalue\thas\ta\tvalue\tof\t\u20131,\tand\tthe\tKnapsack\talgorithm\tuses\tas\tfew\titems\tas\tpossible\twhich correspond\tto\tas\tfew\tcoins\tas\tpossible. Let\tus\ttry\tformulating\tthe\trecurrence.\tLet\tM(j)\tindicate\tthe\tminimum\tnumber\tof\tcoins\trequired\tto make\tchange\tfor\tthe\tamount\tof\tmoney\tequal\tto\tj. M(j)\t=\tMini{M(j\t\u2013\tvj)}\t+\t1 What\tthis\tsays\tis,\tif\tcoin\tdenomination\ti\twas\tthe\tlast\tdenomination\tcoin\tadded\tto\tthe\tsolution, then\t the\t optimal\t way\t to\t finish\t the\t solution\t with\t that\t one\t is\t to\t optimally\t make\t change\t for\t the amount\tof\tmoney\tj\t\u2013\tvi\tand\tthen\tadd\tone\textra\tcoin\tof\tvalue\tvi. Time\t Complexity:\t O(nC).\t Since\t we\t are\t solving\t C\t sub-problems\t and\t each\t of\t them\t requires minimization\tof\tn\tterms.\tSpace\tComplexity:\tO(nC). Problem-20\u2003\u2003Longest\tIncreasing\tSubsequence:\tGiven\ta\tsequence\tof\tn\tnumbers\tA1\t.\t.\t.\tAn, determine\t a\t subsequence\t (not\t necessarily\t contiguous)\t of\t maximum\t length\t in\t which\t the values\tin\tthe\tsubsequence\tform\ta\tstrictly\tincreasing\tsequence. Solution: Input:\tSequence\tof\tn\tnumbers\tA1\t.\t.\t.\tAn. Goal:\t To\t find\t a\t subsequence\t that\t is\t just\t a\t subset\t of\t elements\t and\t does\t not\t happen\t to\t be contiguous.\tBut\tthe\telements\tin\tthe\tsubsequence\tshould\tform\ta\tstrictly\tincreasing\tsequence\tand\tat the\tsame\ttime\tthe\tsubsequence\tshould\tcontain\tas\tmany\telements\tas\tpossible. For\texample,\tif\tthe\tsequence\tis\t(5,6,2,3,4,1.9,9,8,9,5),\tthen\t(5,6),\t(3,5),\t(1,8,9)\tare\tall\tincreasing sub-sequences.\tThe\tlongest\tone\tof\tthem\tis\t(2,3,4,8,9),\tand\twe\twant\tan\talgorithm\tfor\tfinding\tit. First,\tlet\tus\tconcentrate\ton\tthe\talgorithm\tfor\tfinding\tthe\tlongest\tsubsequence.\tLater,\twe\tcan\ttry printing\tthe\tsequence\titself\tby\ttracing\tthe\ttable.\tOur\tfirst\tstep\tis\tfinding\tthe\trecursive\tformula. First,\tlet\tus\tcreate\tthe\tbase\tconditions.\tIf\tthere\tis\tonly\tone\telement\tin\tthe\tinput\tsequence\tthen\twe don\u2019t\thave\tto\tsolve\tthe\tproblem\tand\twe\tjust\tneed\tto\treturn\tthat\telement.\tFor\tany\tsequence\twe\tcan start\twith\tthe\tfirst\telement\t(A[1]).\tSince\twe\tknow\tthe\tfirst\tnumber\tin\tthe\tLIS,\tlet\u2019s\tfind\tthe\tsecond number\t(A[2]).\tIf\tA[2]\tis\tlarger\tthan\tA[1]\tthen\tinclude\tA[2]\talso.\tOtherwise,\twe\tare\tdone\t-\tthe\tLIS is\tthe\tone\telement\tsequence(A[1]). Now,\tlet\tus\tgeneralize\tthe\tdiscussion\tand\tdecide\tabout\tith\telement.\tLet\tL(i)\trepresent\tthe\toptimal subsequence\twhich\tis\tstarting\tat\tposition\tA[1]\tand\tending\tat\tA[i].\tThe\toptimal\tway\tto\tobtain\ta strictly\t increasing\t subsequence\t ending\t at\t position\t i\t is\t to\t extend\t some\t subsequence\t starting\t at some\tearlier\tposition\tj.\tFor\tthis\tthe\trecursive\tformula\tcan\tbe\twritten\tas: L(i)\t=\tMaxj\t<\ti\tand\tA\t[j]\t<\tA\t[i]{L(j)}\t+\t1 The\t above\t recurrence\t says\t that\t we\t have\t to\t select\t some\t earlier\t position\t j\t which\t gives\t the maximum\tsequence.\tThe\t1\tin\tthe\trecursive\tformula\tindicates\tthe\taddition\tof\tith\telement. Now\tafter\tfinding\tthe\tmaximum\tsequence\tfor\tall\tpositions\twe\thave\tto\tselect\tthe\tone\tamong\tall positions\twhich\tgives\tthe\tmaximum\tsequence\tand\tit\tis\tdefined\tas: Maxi{L(i)} Time\tComplexity:\tO(n2),\tsince\ttwo\tfor\tloops.\tSpace\tComplexity:\tO(n),\tfor\ttable. Problem-21\u2003\u2003Longest\t Increasing\t Subsequence:\t In\t Problem-20,\t we\t assumed\t that\t L(i) represents\tthe\toptimal\tsubsequence\twhich\tis\tstarting\tat\tposition\tA[1]\tand\tending\tat\tA[i]. Now,\tlet\tus\tchange\tthe\tdefinition\tof\tL(i)\tas:\tL(i)\trepresents\tthe\toptimal\tsubsequence\twhich is\t starting\t at\t position\t A[i]\t and\t ending\t at\t A[n].\t With\t this\t approach\t can\t we\t solve\t the problem? Solution:\tYes. Let\tL(i)\trepresent\tthe\toptimal\tsubsequence\twhich\tis\tstarting\tat\tposition\tA[i]\tand\tending\tat\tA[n]. The\toptimal\tway\tto\tobtain\ta\tstrictly\tincreasing\tsubsequence\tstarting\tat\tposition\ti\tis\tgoing\tto\tbe\tto extend\tsome\tsubsequence\tstarting\tat\tsome\tlater\tposition\tj.\tFor\tthis\tthe\trecursive\tformula\tcan\tbe written\tas: L(i)\t=\tMaxj\t<\ti\tand\tA\t[j]\t<\tA\t[i]{L(j)}\t+\t1 We\thave\tto\tselect\tsome\tlater\tposition\tj\twhich\tgives\tthe\tmaximum\tsequence.\tThe\t1\tin\tthe\trecursive formula\tis\tthe\taddition\tof\tith\telement.\tAfter\tfinding\tthe\tmaximum\tsequence\tfor\tall\tpositions\tselect the\tone\tamong\tall\tpositions\twhich\tgives\tthe\tmaximum\tsequence\tand\tit\tis\tdefined\tas: Maxi{L(i)} Time\tComplexity:\tO(n2)\tsince\ttwo\tnested\tfor\tloops.\tSpace\tComplexity:\tO(n),\tfor\ttable. Problem-22\u2003\u2003Is\tthere\tan\talternative\tway\tof\tsolving\tProblem-21? Solution:\tYes.\tThe\tother\tmethod\tis\tto\tsort\tthe\tgiven\tsequence\tand\tsave\tit\tinto\tanother\tarray\tand then\ttake\tout\tthe\t\u201cLongest\tCommon\tSubsequence\u201d\t(LCS)\tof\tthe\ttwo\tarrays.\tThis\tmethod\thas\ta complexity\tof\tO(n2).\tFor\tLCS\tproblem\trefer\ttheory\tsection\tof\tthis\tchapter. Problem-23\u2003\u2003Box\tStacking:\tAssume\tthat\twe\tare\tgiven\ta\tset\tof\tn\trectangular\t3\t\u2013\tD\tboxes.\tThe dimensions\tof\tith\tbox\tare\theight\thi,\twidth\twi\tand\tdepth\tdi.\tNow\twe\twant\tto\tcreate\ta\tstack of\tboxes\twhich\tis\tas\ttall\tas\tpossible,\tbut\twe\tcan\tonly\tstack\ta\tbox\ton\ttop\tof\tanother\tbox\tif the\tdimensions\tof\tthe\t2\t\u2013D\tbase\tof\tthe\tlower\tbox\tare\teach\tstrictly\tlarger\tthan\tthose\tof\tthe\t2 \u2013D\tbase\tof\tthe\thigher\tbox.\tWe\tcan\trotate\ta\tbox\tso\tthat\tany\tside\tfunctions\tas\tits\tbase.\tIt\tis possible\tto\tuse\tmultiple\tinstances\tof\tthe\tsame\ttype\tof\tbox. Solution:\tBox\tstacking\tproblem\tcan\tbe\treduced\tto\tLIS\t[Problem-21. Input:\t n\t boxes\t where\t ith\t with\t height\t hi,\t width\t wi\t and\t depth\t di.\t For\t all\t n\t boxes\t we\t have\t to consider\tall\tthe\torientations\twith\trespect\tto\trotation.\tThat\tis,\tif\twe\thave,\tin\tthe\toriginal\tset,\ta\tbox with\tdimensions\t1\t\u00d7\t2\t\u00d7\t3,\tthen\twe\tconsider\t3\tboxes, This\tsimplification\tallows\tus\tto\tforget\tabout\tthe\trotations\tof\tthe\tboxes\tand\twe\tjust\tfocus\ton\tthe stacking\tof\tn\tboxes\twith\teach\theight\tas\thi\tand\ta\tbase\tarea\tof\t(wi\tx\tdi).\tAlso\tassume\tthat\twi\t\u2264\tdi. Now\twhat\twe\tdo\tis,\tmake\ta\tstack\tof\tboxes\tthat\tis\tas\ttall\tas\tpossible\tand\thas\tmaximum\theight.\tWe allow\ta\tbox\ti\ton\ttop\tof\tbox\tj\tonly\tif\tbox\ti\tis\tsmaller\tthan\tbox\tj\tin\tboth\tthe\tdimensions.\tThat means,\tif\twi\t<\twj\t&&\tdi\t<\tdj.\tNow\tlet\tus\tsolve\tthis\tusing\tDP.\tFirst\tselect\tthe\tboxes\tin\tthe\torder of\tdecreasing\tbase\tarea. Now,\tlet\tus\tsay\tH(j)\trepresents\tthe\ttallest\tstack\tof\tboxes\twith\tbox\tj\ton\ttop.\tThis\tis\tvery\tsimilar\tto the\tLIS\tproblem\tbecause\tthe\tstack\tof\tn\tboxes\twith\tending\tbox\tj\tis\tequal\tto\tfinding\ta\tsubsequence with\tthe\tfirst\tj\tboxes\tdue\tto\tthe\tsorting\tby\tdecreasing\tbase\tarea.\tThe\torder\tof\tthe\tboxes\ton\tthe stack\tis\tgoing\tto\tbe\tequal\tto\tthe\torder\tof\tthe\tsequence. Now\twe\tcan\twrite\tH(j)\trecursively.\tIn\torder\tto\tform\ta\tstack\twhich\tends\ton\tbox\tj,\twe\tneed\tto extend\ta\tprevious\tstack\tending\tat\ti.\tThat\tmeans,\twe\tneed\tto\tput\tj\tbox\tat\tthe\ttop\tof\tthe\tstack\t[i\tbox is\tthe\tcurrent\ttop\tof\tthe\tstack].\tTo\tput\tj\tbox\tat\tthe\ttop\tof\tthe\tstack\twe\tshould\tsatisfy\tthe\tcondition wi\t>\twj\tand\tdi\t>\tdj\t[this\tensures\tthat\tthe\tlow\tlevel\tbox\thas\tmore\tbase\tthan\tthe\tboxes\tabove\tit]. Based\ton\tthis\tlogic,\twe\tcan\twrite\tthe\trecursive\tformula\tas: Similar\tto\tthe\tLIS\tproblem,\tat\tthe\tend\twe\thave\tto\tselect\tthe\tbest\tj\tover\tall\tpotential\tvalues.\tThis is\tbecause\twe\tare\tnot\tsure\twhich\tbox\tmight\tend\tup\ton\ttop. Maxj{H(j)} Time\tComplexity:\tO(n2). Problem-24\u2003\u2003Building\tBridges\tin\tIndia:\t Consider\t a\t very\t long,\t straight\t river\t which\t moves from\tnorth\tto\tsouth.\tAssume\tthere\tare\tn\tcities\ton\tboth\tsides\tof\tthe\triver:\tn\tcities\ton\tthe\tleft of\tthe\triver\tand\tn\tcities\ton\tthe\tright\tside\tof\tthe\triver.\tAlso,\tassume\tthat\tthese\tcities\tare numbered\tfrom\t1\tto\tn\tbut\tthe\torder\tis\tnot\tknown.\tNow\twe\twant\tto\tconnect\tas\tmany\tleft- right\t pairs\t of\t cities\t as\t possible\t with\t bridges\t such\t that\t no\t two\t bridges\t cross.\t When connecting\tcities,\twe\tcan\tonly\tconnect\tcity\ti\ton\tthe\tleft\tside\tto\tcity\ti\ton\tthe\tright\tside. Solution: Input:\tTwo\tpairs\tof\tsets\twith\teach\tnumbered\tfrom\t1\tto\tn. Goal:\tConstruct\tas\tmany\tbridges\tas\tpossible\twithout\tany\tcrosses\tbetween\tleft\tside\tcities\tto\tright side\tcities\tof\tthe\triver. To\tunderstand\tbetter\tlet\tus\tconsider\tthe\tdiagram\tbelow.\tIn\tthe\tdiagram\tit\tcan\tbe\tseen\tthat\tthere are\tn\tcities\ton\tthe\tleft\tside\tof\triver\tand\tn\tcities\ton\tthe\tright\tside\tof\triver.\tAlso,\tnote\tthat\twe\tare connecting\tthe\tcities\twhich\thave\tthe\tsame\tnumber\t[a\trequirement\tin\tthe\tproblem].\tOur\tgoal\tis\tto connect\tthe\tmaximum\tcities\ton\tthe\tleft\tside\tof\triver\tto\tcities\ton\tthe\tright\tside\tof\tthe\triver,\twithout any\tcross\tedges.\tJust\tto\tmake\tit\tsimple,\tlet\tus\tsort\tthe\tcities\ton\tone\tside\tof\tthe\triver. If\twe\tobserve\tcarefully,\tsince\tthe\tcities\ton\tthe\tleft\tside\tare\talready\tsorted,\tthe\tproblem\tcan\tbe simplified\t to\t finding\t the\t maximum\t increasing\t sequence.\t That\t means\t we\t have\t to\t use\t the\t LIS solution\tfor\tfinding\tthe\tmaximum\tincreasing\tsequence\ton\tthe\tright\tside\tcities\tof\tthe\triver. Time\tComplexity:\tO(n2),\t(same\tas\tLIS). Problem-25\u2003\u2003Subset\t Sum:\t Given\t a\t sequence\t of\t n\t positive\t numbers\t A1\t .\t .\t .\t An,\t give\t an algorithm\twhich\tchecks\twhether\tthere\texists\ta\tsubset\tof\tA\twhose\tsum\tof\tall\tnumbers\tis\tT? Solution:\tThis\tis\ta\tvariation\tof\tthe\tKnapsack\tproblem.\tAs\tan\texample,\tconsider\tthe\tfollowing array: A\t=\t[3,2,4,19,3,7,13,10,6,11] Suppose\t we\t want\t to\t check\t whether\t there\t is\t any\t subset\t whose\t sum\t is\t 17.\t The\t answer\t is\t yes, because\tthe\tsum\tof\t4\t+\t13\t=\t17\tand\ttherefore\t{4,13}\tis\tsuch\ta\tsubset. Let\tus\ttry\tsolving\tthis\tproblem\tusing\tDP.\tWe\twill\tdefine\tn\t\u00d7\tT\tmatrix,\twhere\tn\tis\tthe\tnumber\tof elements\tin\tour\tinput\tarray\tand\tT\tis\tthe\tsum\twe\twant\tto\tcheck. Let,\tM[i,j]\t=\t1\tif\tit\tis\tpossible\tto\tfind\ta\tsubset\tof\tthe\tnumbers\t1\tthrough\ti\tthat\tproduce\tsum/\tand M[i,j]\t=\t0\totherwise. M[i,\tj]\t=\tMax(M[i\t\u2013\t1,j],\tM[i\t\u2013\t1,\tj\t\u2013\tAi]) According\tto\tthe\tabove\trecursive\tformula\tsimilar\tto\tthe\tKnapsack\tproblem,\twe\tcheck\tif\twe\tcan get\tthe\tsum\tj\tby\tnot\tincluding\tthe\telement\ti\tin\tour\tsubset,\tand\twe\tcheck\tif\twe\tcan\tget\tthe\tsum\tj\tby including\t i\t and\t checking\t if\t the\t sum\t j\t \u2013\t Ai\t exists\t without\t the\t ith\t element.\t This\t is\t identical\t to Knapsack,\texcept\tthat\twe\tare\tstoring\t0/1\u2019s\tinstead\tof\tvalues.\tIn\tthe\tbelow\timplementation\twe\tcan use\tbinary\tOR\toperation\tto\tget\tthe\tmaximum\tamong\tM[i\t\u2013\t1,j]\tand\tM[i\t\u2013\t1,j\t\u2013\tAi]. How\tmany\tsubproblems\tare\tthere?\tIn\tthe\tabove\tformula,\ti\tcan\trange\tfrom\t1\tto\tn\tand\tj\tcan\trange from\tl\tto\tT.\tThere\tare\ta\ttotal\tof\tnT\tsubproblems\tand\teach\tone\ttakes\tO(1).\tSo\tthe\ttime\tcomplexity is\tO(nT)\tand\tthis\tis\tnot\tpolynomial\tas\tthe\trunning\ttime\tdepends\ton\ttwo\tvariables\t[n\tand\tT],\tand we\tcan\tsee\tthat\tthey\tare\tanexponential\tfunction\tof\tthe\tother. Space\tComplexity:\tO(nT). Problem-26\u2003\u2003Given\ta\tset\tof\tn\tintegers\tand\tthe\tsum\tof\tall\tnumbers\tis\tat\tmost\tif.\tFind\tthe\tsubset of\tthese\tn\telements\twhose\tsum\tis\texactly\thalf\tof\tthe\ttotal\tsum\tof\tn\tnumbers. Solution:\tAssume\tthat\tthe\tnumbers\tare\tA1\t.\t.\t.\tAn.\tLet\tus\tuse\tDP\tto\tsolve\tthis\tproblem.\tWe\twill create\ta\tboolean\tarray\tT\twith\tsize\tequal\tto\tK\t+\t1.\tAssume\tthat\tT[x]\tis\t1\tif\tthere\texists\ta\tsubset\tof given\tn\telements\twhose\tsum\tis\tx.\tThat\tmeans,\tafter\tthe\talgorithm\tfinishes,\tT[K]\twill\tbe\t1,\tif\tand only\tif\tthere\tis\ta\tsubset\tof\tthe\tnumbers\tthat\thas\tsum\tK.\tOnce\twe\thave\tthat\tvalue\tthen\twe\tjust\tneed to\treturn\tT[K/2].\tIf\tit\tis\t1,\tthen\tthere\tis\ta\tsubset\tthat\tadds\tup\tto\thalf\tthe\ttotal\tsum. Initially\twe\tset\tall\tvalues\tof\tT\tto\t0.\tThen\twe\tset\tT[0]\tto\t1.\tThis\tis\tbecause\twe\tcan\talways\tbuild\t0 by\ttaking\tan\tempty\tset.\tIf\twe\thave\tno\tnumbers\tin\tA,\tthen\twe\tare\tdone!\tOtherwise,\twe\tpick\tthe\tfirst number,\tA[0].\tWe\tcan\teither\tthrow\tit\taway\tor\ttake\tit\tinto\tour\tsubset.\tThis\tmeans\tthat\tthe\tnew\tT[] should\thave\tT[0]\tand\tT[A[0]]\tset\tto\t1.\tThis\tcreates\tthe\tbase\tcase.\tWe\tcontinue\tby\ttaking\tthe\tnext element\tof\tA. Suppose\tthat\twe\thave\talready\ttaken\tcare\tof\tthe\tfirst\ti\t\u2013\t1\telements\tof\tA.\tNow\twe\ttake\tA[i]\tand look\tat\tour\ttable\tT[].\tAfter\tprocessing\ti\t\u2013\t1\telements,\tthe\tarray\tT\thas\ta\t1\tin\tevery\tlocation\tthat corresponds\tto\ta\tsum\tthat\twe\tcan\tmake\tfrom\tthe\tnumbers\twe\thave\talready\tprocessed.\tNow\twe add\tthe\tnew\tnumber,\tA[i].\tWhat\tshould\tthe\ttable\tlook\tlike?\tFirst\tof\tall,\twe\tcan\tsimply\tignore A[i].\tThat\tmeans,\tno\tone\tshould\tdisappear\tfrom\tT[]\t-\twe\tcan\tstill\tmake\tall\tthose\tsums.\tNow consider\tsome\tlocation\tof\tT[j]\tthat\thas\ta\t1\tin\tit.\tIt\tcorresponds\tto\tsome\tsubset\tof\tthe\tprevious numbers\tthat\tadd\tup\tto\tj.\tIf\twe\tadd\tA[i]\tto\tthat\tsubset,\twe\twill\tget\ta\tnew\tsubset\twith\ttotal\tsum\tj\t+ A[i].\tSo\twe\tshould\tset\tT[j\t+\tA[i]]\tto\t1\tas\twell.\tThat\u2019s\tall.\tBased\ton\tthe\tabove\tdiscussion,\twe\tcan write\tthe\talgorithm\tas: In\tthe\tabove\tcode,\tj\tloop\tmoves\tfrom\tright\tto\tleft.\tThis\treduces\tthe\tdouble\tcounting\tproblem.\tThat means,\tif\twe\tmove\tfrom\tleft\tto\tright,\tthen\twe\tmay\tdo\tthe\trepeated\tcalculations. Time\tComplexity:\tO(nK),\tfor\tthe\ttwo\tfor\tloops.\tSpace\tComplexity:\tO(K),\tfor\tthe\tboolean\ttable\tT. Problem-27\u2003\u2003Can\twe\timprove\tthe\tperformance\tof\tProblem-26? Solution:\tYes.\tIn\tthe\tabove\tcode\twhat\twe\tare\tdoing\tis,\tthe\tinner\tj\tloop\tis\tstarting\tfrom\tK\t and moving\tleft.\tThat\tmeans,\tit\tis\tunnecessarily\tscanning\tthe\twhole\ttable\tevery\ttime. What\twe\tactually\twant\tis\tto\tfind\tall\tthe\t1\tentries.\tAt\tthe\tbeginning,\tonly\tthe\t0th\tentry\tis\t1.\tIf\twe keep\tthe\tlocation\tof\tthe\trightmost\t1\tentry\tin\ta\tvariable,\twe\tcan\talways\tstart\tat\tthat\tspot\tand\tgo\tleft instead\tof\tstarting\tat\tthe\tright\tend\tof\tthe\ttable. To\ttake\tfull\tadvantage\tof\tthis,\twe\tcan\tsort\tA[]\tfirst.\tThat\tway,\tthe\trightmost\t1\tentry\twill\tmove\tto the\tright\tas\tslowly\tas\tpossible.\tFinally,\twe\tdon\u2019t\treally\tcare\tabout\twhat\thappens\tin\tthe\tright\thalf of\t the\t table\t (after\t T[K/2])\t because\t if\t T[x]\t is\t 1,\t then\t T[Kx]\t must\t also\t be\t 1\t eventually\t \u2013\t it corresponds\tto\tthe\tcomplement\tof\tthe\tsubset\tthat\tgave\tus\tx.\tThe\tcode\tbased\ton\tabove\tdiscussion is\tgiven\tbelow. After\tthe\timprovements,\tthe\ttime\tcomplexity\tis\tstill\tO(nK),\tbut\twe\thave\tremoved\tsome\tuseless steps. Problem-28\u2003\u2003Partition\t partition\t problem\t is\t to\t determine\t whether\t a\t given\t set\t can\t be partitioned\tinto\ttwo\tsubsets\tsuch\tthat\tthe\tsum\tof\telements\tin\tboth\tsubsets\tis\tthe\tsame\t[the same\tas\tthe\tprevious\tproblem\tbut\ta\tdifferent\tway\tof\tasking].\tFor\texample,\tif\tA[]\t=\t{1,\t5, 11,\t5},\tthe\tarray\tcan\tbe\tpartitioned\tas\t{1,\t5,\t5}\tand\t{11}.\tSimilarly,\tif\tA[]\t=\t{1,\t5,\t3},\tthe array\tcannot\tbe\tpartitioned\tinto\tequal\tsum\tsets. Solution:\tLet\tus\ttry\tsolving\tthis\tproblem\tanother\tway.\tFollowing\tare\tthe\ttwo\tmain\tsteps\tto\tsolve this\tproblem:"
            }
        ]
    },
    {
        "chapter_title": "1.",
        "subchapters": [
            {
                "subchapter_title": "Calculate\tthe\tsum\tof\tthe\tarray.\tIf\tthe\tsum\tis\todd,\tthere\tcannot\tbe\ttwo\tsubsets\twith\tan",
                "content": "equal\tsum,\tso\treturn\tfalse."
            }
        ]
    },
    {
        "chapter_title": "2.",
        "subchapters": [
            {
                "subchapter_title": "If\tthe\tsum\tof\tthe\tarray\telements\tis\teven,\tcalculate\tsum/2\tand\tfind\ta\tsubset\tof\tthe\tarray",
                "content": "with\ta\tsum\tequal\tto\tsum/2. The\tfirst\tstep\tis\tsimple.\tThe\tsecond\tstep\tis\tcrucial,\tand\tit\tcan\tbe\tsolved\teither\tusing\trecursion\tor Dynamic\tProgramming. Recursive\tSolution:\tFollowing\tis\tthe\trecursive\tproperty\tof\tthe\tsecond\tstep\tmentioned\tabove.\tLet subsetSum(A,\tn,\tsum/2)\tbe\tthe\tfunction\tthat\treturns\ttrue\tif\tthere\tis\ta\tsubset\tof\tA[0..n-1]\twith\tsum equal\tto\tsum/2.\tThe\tisSubsetSum\tproblem\tcan\tbe\tdivided\tinto\ttwo\tsub\tproblems: a) isSubsetSum()\twithout\tconsidering\tlast\telement\t(reducing\tn\tto\tn\t\u2013\t1) b) isSubsetSum\tconsidering\tthe\tlast\telement\t(reducing\tsum/2\tby\tA[n-1]\tand\tn\tto\tn\t\u2013\t1) If\tany\tof\tthe\tabove\tsub\tproblems\treturn\ttrue,\tthen\treturn\ttrue. subsetSum\t(A,n,sum/2)\t=\tisSubsetSum\t(A,n\t\u2013\t1,sum/2)\t\\\\\tsubsetSum\t(A,n\t\u2013\t1,sum/2\t\u2013\tA[n\t\u2013\t1]) Time\tComplexity:\tO(2n)\tIn\tworst\tcase,\tthis\tsolution\ttries\ttwo\tpossibilities\t(whether\tto\tinclude\tor exclude)\tfor\tevery\telement. Dynamic\tProgramming\tSolution:\tThe\tproblem\tcan\tbe\tsolved\tusing\tdynamic\tprogramming\twhen the\tsum\tof\tthe\telements\tis\tnot\ttoo\tbig.\tWe\tcan\tcreate\ta\t2D\tarray\tpart[][]\tof\tsize\t(sum/2)*(n\t+\t1). And\t we\t can\t construct\t the\t solution\t in\t a\t bottom-up\t manner\t such\t that\t every\t filled\t entry\t has\t a following\tproperty part\t[i][j]\t=\ttrue\tif\ta\tsubset\tof\t{A[0],A[1],..A[j\t\u2013\t1]}\thas\tsum\tequal\tto\tsum/2,\totherwise\tfalse Time\tComplexity:\tO(sum\t\u00d7\tn).\tSpace\tComplexity:\tO(sum\t\u00d7\tn).\tPlease\tnote\tthat\tthis\tsolution\twill not\tbe\tfeasible\tfor\tarrays\twith\ta\tbig\tsum. Problem-29\u2003\u2003Counting\t Boolean\t Parenthesizations:\t Let\t us\t assume\t that\t we\t are\t given\t a boolean\texpression\tconsisting\tof\tsymbols\t\u2018true\u2019,\t\u2018false\u2019,\t\u2018and\u2019,\t\u2018or\u2019,\tand\t\u2018xor\u2019.\tFind\tthe number\t of\t ways\t to\t parenthesize\t the\t expression\t such\t that\t it\t will\t evaluate\t to\t true.\t For example,\t there\t is\t only\t 1\t way\t to\t parenthesize\t \u2018true\t and\t false\t xor\t true\u2019\t such\t that\t it evaluates\tto\ttrue. Solution:\tLet\tthe\tnumber\tof\tsymbols\tbe\tn\tand\tbetween\tsymbols\tthere\tare\tboolean\toperators\tlike and,\tor,\txor,\tetc.\tFor\texample,\tif\tn\t=\t4,\tT\tor\tF\tand\tT\txor\tF.\tOur\tgoal\tis\tto\tcount\tthe\tnumbers\tof ways\tto\tparenthesize\tthe\texpression\twith\tboolean\toperators\tso\tthat\tit\tevaluates\tto\ttrue.\t In\t the above\tcase,\tif\twe\tuse\tT\tor\t(\t(F\tand\tT)\txor\tF)\tthen\tit\tevaluates\tto\ttrue. T\tor{\t(F\tand\tT)xor\tF)\t=\tTrue Now\t let\t us\t see\t how\t DP\t solves\t this\t problem.\t Let\t T(i,j)\t represent\t the\t number\t of\t ways\t to parenthesize\t the\t sub\t expression\t with\t symbols\t i\t ...j\t [symbols\t means\t only\t T\t and\t F\t and\t not\t the operators]\twith\tboolean\toperators\tso\tthat\tit\tevaluates\tto\ttrue.\tAlso,\ti\tand\tj\ttake\tthe\tvalues\tfrom\t1 to\tn.\tFor\texample,\tin\tthe\tabove\tcase,\tT(2,4)\t =\t 0\t because\t there\t is\t no\t way\t to\tparenthesize\t the expression\tF\tand\tT\txor\tF\tto\tmake\tit\ttrue. Just\tfor\tsimplicity\tand\tsimilarity,\tlet\tF(i,j)\trepresent\tthe\tnumber\tof\tways\tto\tparenthesize\tthe\tsub expression\twith\tsymbols\ti\t...j\twith\tboolean\toperators\tso\tthat\tit\tevaluates\tto\tfalse.\tThe\tbase\tcases are\tT(i,i)\tand\tF(i,i). Now\twe\tare\tgoing\tto\tcompute\tT(i,\ti\t+\t1)\tand\tF(i,\ti\t+\t1)\tfor\tall\tvalues\tof\ti.\tSimilarly,\tT(i,\ti\t+\t2) and\tF(i,\ti\t+\t2)\tfor\tall\tvalues\tof\ti\tand\tso\ton.\tNow\tlet\u2019s\tgeneralize\tthe\tsolution. What\tthis\tabove\trecursive\tformula\tsays\tis,\tT(i,j)\tindicates\tthe\tnumber\tof\tways\tto\tparenthesize\tthe expression.\tLet\tus\tassume\tthat\twe\thave\tsome\tsub\tproblems\twhich\tare\tending\tat\tk.\tThen\tthe\ttotal number\tof\tways\tto\tparenthesize\tfrom\ti\tto\tj\tis\tthe\tsum\tof\tcounts\tof\tparenthesizing\tfrom\ti\tto\tk\tand from\tk\t+\t1\tto\tj.\tTo\tparenthesize\tbetween\tk\tand\tk\t+\t1\tthere\tare\tthree\tways:\t\u201cand\u201d,\t \u201cor\u201d\t and \u201cxor\u201d. \u2022 If\twe\tuse\t\u201cand\u201d\tbetween\tk\tand\tk\t+\t1,\tthen\tthe\tfinal\texpression\tbecomes\ttrue\tonly when\tboth\tare\ttrue.\tIf\tboth\tare\ttrue\tthen\twe\tcan\tinclude\tthem\tto\tget\tthe\tfinal\tcount. \u2022 If\twe\tuse\t\u201cor\u201d,\tthen\tif\tat\tleast\tone\tof\tthem\tis\ttrue,\tthe\tresult\tbecomes\ttrue.\tInstead of\tincluding\tall\tthree\tpossibilities\tfor\t\u201cor\u201d,\twe\tare\tgiving\tone\talternative\twhere\twe are\tsubtracting\tthe\t\u201cfalse\u201d\tcases\tfrom\ttotal\tpossibilities. \u2022 The\tsame\tis\tthe\tcase\twith\t\u201cxor\u201d.\tThe\tconversation\tis\tas\tin\tthe\tabove\ttwo\tcases. After\tfinding\tall\tthe\tvalues\twe\thave\tto\tselect\tthe\tvalue\tof\tk,\twhich\tproduces\tthe\tmaximum\tcount, and\tfor\tk\tthere\tare\ti\tto\tj\t\u2013\t1\tpossibilities. How\tmany\tsubproblems\tare\tthere?\tIn\tthe\tabove\tformula,\ti\tcan\trange\tfrom\t1\tto\tn,\t and\t j\t can range\tfrom\t1\tto\tn.\tSo\tthere\tare\ta\ttotal\tof\tn2\tsubproblems,\tand\talso\twe\tare\tdoing\tsummation\tfor\tall such\tvalues.\tSo\tthe\ttime\tcomplexity\tis\tO(n3). Problem-30\u2003\u2003Optimal\tBinary\tSearch\tTrees:\tGiven\ta\tset\tof\tn\t(sorted)\tkeys\tA[1..n],\tbuild\tthe best\tbinary\tsearch\ttree\tfor\tthe\telements\tof\tA.\tAlso\tassume\tthat\teach\telement\tis\tassociated with\tfrequency\twhich\tindicates\tthe\tnumber\tof\ttimes\tthat\ta\tparticular\titem\tis\tsearched\tin\tthe binary\tsearch\ttrees.\tThat\tmeans\twe\tneed\tto\tconstruct\ta\tbinary\tsearch\ttree\tso\tthat\tthe\ttotal search\ttime\twill\tbe\treduced. Solution:\t Before\t solving\t the\t problem\t let\t us\t understand\t the\t problem\t with\t an\t example.\t Let\t us assume\t that\t the\t given\t array\t is\t A\t =\t [3,12,21,32,35].\t There\t are\t many\t ways\t to\t represent\t these elements,\ttwo\tof\twhich\tare\tlisted\tbelow. Of\tthe\ttwo,\twhich\trepresentation\tis\tbetter?\tThe\tsearch\ttime\tfor\tan\telement\tdepends\ton\tthe depth\tof\tthe\tnode.\tThe\taverage\tnumber\tof\tcomparisons\tfor\tthe\tfirst\ttree\tis:\t \tand for\tthe\tsecond\ttree,\tthe\taverage\tnumber\tof\tcomparisons\tis:\t .\tOf\tthe\ttwo,\tthe\tfirst tree\tgives\tbetter\tresults. If\t frequencies\t are\t not\t given\t and\t if\t we\t want\t to\t search\t all\t elements,\t then\t the\t above\t simple calculation\tis\tenough\tfor\tdeciding\tthe\tbest\ttree.\tIf\tthe\tfrequencies\tare\tgiven,\tthen\tthe\tselection depends\ton\tthe\tfrequencies\tof\tthe\telements\tand\talso\tthe\tdepth\tof\tthe\telements.\tFor\tsimplicity\tlet us\tassume\tthat\tthe\tgiven\tarray\tis\tA\tand\tthe\tcorresponding\tfrequencies\tare\tin\tarray\tF.\tF[i]\tindicates the\tfrequency\tof\tith\telement\tA[i].\tWith\tthis,\tthe\ttotal\tsearch\ttime\tS(root)\tof\tthe\ttree\twith\troot\tcan be\tdefined\tas: In\tthe\tabove\texpression,\tdepth(root,\ti)\t+\t1\tindicates\tthe\tnumber\tof\tcomparisons\tfor\tsearching\tthe ith\telement.\tSince\twe\tare\ttrying\tto\tcreate\ta\tbinary\tsearch\ttree,\tthe\tleft\tsubtree\telements\tare\tless than\troot\telement\tand\tthe\tright\tsubtree\telements\tare\tgreater\tthan\troot\telement.\tIf\twe\tseparate\tthe left\tsubtree\ttime\tand\tright\tsubtree\ttime,\tthen\tthe\tabove\texpression\tcan\tbe\twritten\tas: If\twe\treplace\tthe\tleft\tsubtree\tand\tright\tsubtree\ttimes\twith\ttheir\tcorresponding\trecursive\tcalls,\tthen the\texpression\tbecomes: Binary\tSearch\tTree\tnode\tdeclaration Refer\tto\tTrees\tchapter. Implementation: Problem-31\u2003\u2003Edit\tDistance:\tGiven\ttwo\tstrings\tA\tof\tlength\tm\tand\tB\tof\tlength\tn,\ttransform\tA into\tB\twith\ta\tminimum\tnumber\tof\toperations\tof\tthe\tfollowing\ttypes:\tdelete\ta\tcharacter from\tA,\tinsert\ta\tcharacter\tinto\tA,\tor\tchange\tsome\tcharacter\tin\tA\tinto\ta\tnew\tcharacter.\tThe minimal\t number\t of\t such\t operations\t required\t to\t transform\t A\t into\t B\t is\t called\t the\t edit distance\tbetween\tA\tand\tB. Solution: Input:\tTwo\ttext\tstrings\tA\tof\tlength\tm\tand\tB\tof\tlength\tn. Goal:\tConvert\tstring\tA\tinto\tB\twith\tminimal\tconversions. Before\tgoing\tto\ta\tsolution,\tlet\tus\tconsider\tthe\tpossible\toperations\tfor\tconverting\tstring\tA\tinto\tB. \u2022 If\tm\t>\tn,\twe\tneed\tto\tremove\tsome\tcharacters\tof\tA \u2022 If\tm\t==\tn,\twe\tmay\tneed\tto\tconvert\tsome\tcharacters\tof\tA \u2022 If\tm\t<\tn,\twe\tneed\tto\tremove\tsome\tcharacters\tfrom\tA So\tthe\toperations\twe\tneed\tare\tthe\tinsertion\tof\ta\tcharacter,\tthe\treplacement\tof\ta\tcharacter\tand\tthe deletion\tof\ta\tcharacter,\tand\ttheir\tcorresponding\tcost\tcodes\tare\tdefined\tbelow. Costs\tof\toperations: Insertion\tof\ta\tcharacter ci Replacement\tof\ta\tcharacter cr Deletion\tof\ta\tcharacter cd Now\t let\t us\t concentrate\t on\t the\t recursive\t formulation\t of\t the\t problem.\t Let,\t T(i,j)\t represents\t the minimum\tcost\trequired\tto\ttransform\tfirst\ti\tcharacters\tof\tA\tto\tfirst;\tcharacters\tof\tB.\tThat\tmeans, A[1...\ti]\tto\tB[1...j]. Based\ton\tthe\tabove\tdiscussion\twe\thave\tthe\tfollowing\tcases. \u2022 If\twe\tdelete\tith\tcharacter\tfrom\tA,\tthen\twe\thave\tto\tconvert\tremaining\ti\t\u2013\t1\tcharacters of\tA\tto\tj\tcharacters\tof\tB \u2022 If\twe\tinsert\tith\tcharacter\tin\tA,\tthen\tconvert\tthese\ti\tcharacters\tof\tA\tto\tj\t\u2013\t1\tcharacters of\tB \u2022 If\tA[i]\t==\tB[j],\tthen\twe\thave\tto\tconvert\tthe\tremaining\ti\t\u2013\t1\tcharacters\tof\tA\tto\tj\t\u2013\t1 characters\tof\tB \u2022 If\tA[i]\t\u2260\tB[j],\tthen\twe\thave\tto\treplace\tith\tcharacter\tof\tA\tto\tjth\tcharacter\tof\tB\tand convert\tremaining\ti\t\u2013\t1\tcharacters\tof\tA\tto\tj\t\u2013\t1\tcharacters\tof\tB After\tcalculating\tall\tthe\tpossibilities\twe\thave\tto\tselect\tthe\tone\twhich\tgives\tthe\tlowest\tcost. How\tmany\tsubproblems\tare\tthere?\tIn\tthe\tabove\tformula,\ti\tcan\trange\tfrom\tl\tto\tm\tand\tj\tcan\trange from\t 1\t to\t n.\t This\t gives\t mn\t subproblems\t and\t each\t one\t takes\t O(1)\t and\t the\t time\t complexity\t is O(mn).\tSpace\tComplexity:\tO(mn)\twhere\tm\tis\tnumber\tof\trows\tand\tn\tis\tnumber\tof\tcolumns\tin\tthe given\tmatrix. Problem-32\u2003\u2003All\t Pairs\t Shortest\t Path\t Problem:\t Floyd\u2019s\t Algorithm:\t Given\t a\t weighted directed\tgraph\tG\t=\t(V,E),\twhere\tV\t=\t{1,2,...,n}.\tFind\tthe\tshortest\tpath\tbetween\tany\tpair\tof nodes\tin\tthe\tgraph.\tAssume\tthe\tweights\tare\trepresented\tin\tthe\tmatrix\tC[V][V],\twhere\tC[i] [j]\tindicates\tthe\tweight\t(or\tcost)\tbetween\tthe\tnodes\ti\tand\tj.\tAlso,\tC[i][j]\t=\t\u221e\tor\t-1\tif\tthere is\tno\tpath\tfrom\tnode\ti\tto\tnode\tj. Solution:\tLet\tus\ttry\tto\tfind\tthe\tDP\tsolution\t(Floyd\u2019s\talgorithm)\tfor\tthis\tproblem.\tThe\tFloyd\u2019s algorithm\tfor\tall\tpairs\tshortest\tpath\tproblem\tuses\tmatrix\tA[1.\t.n][1..n]\tto\tcompute\tthe\tlengths\tof the\tshortest\tpaths.\tInitially, From\tthe\tdefinition,\tC[i,j]\t=\t\u221e\tif\tthere\tis\tno\tpath\tfrom\ti\tto\tj.\tThe\talgorithm\tmakes\tn\tpasses\tover A.\tLet\tA0,A1,\t...,An\tbe\tthe\tvalues\tof\tA\ton\tthe\tn\tpasses,\twith\tA0\tbeing\tthe\tinitial\tvalue. Just\tafter\tthe\tk\u2013\t1th\titeration,\tAk\u20131[i,j]\t=\tsmallest\tlength\tof\tany\tpath\tfrom\tvertex\ti\tto\tvertex\tj\tthat does\tnot\tpass\tthrough\tthe\tvertices\t{k\t+\t1,\tk\t+\t2,....\tn}.\tThat\tmeans,\tit\tpasses\tthrough\tthe\tvertices possibly\tthrough\t{1,2,3,...,\tk\t\u2013\t1}. In\teach\titeration,\tthe\tvalue\tA[i][j]\tis\tupdated\twith\tminimum\tof\tAk\u20131[i,j]\tand\tAk\u20131[i,\tk]\t+\tAk\u20131[k,j]. The\tkth\tpass\texplores\twhether\tthe\tvertex\tk\tlies\ton\tan\toptimal\tpath\tfrom\ti\tto\tj,\tfor\tall\ti,j.\tThe\tsame is\tshown\tin\tthe\tdiagram\tbelow. Time\tComplexity:\tO(n3). Problem-33\u2003\u2003Optimal\tStrategy\tfor\ta\tGame:\tConsider\ta\trow\tof\tn\tcoins\tof\tvalues\tv1\t...\tvn, where\tn\tis\teven\t[since\tit\u2019s\ta\ttwo\tplayer\tgame].\tWe\tplay\tthis\tgame\twith\tthe\topponent.\tIn each\tturn,\ta\tplayer\tselects\teither\tthe\tfirst\tor\tlast\tcoin\tfrom\tthe\trow,\tremoves\tit\tfrom\tthe row\t permanently,\t and\t receives\t the\t value\t of\t the\t coin.\t Determine\t the\t maximum\t possible amount\tof\tmoney\twe\tcan\tdefinitely\twin\tif\twe\tmove\tfirst. Alternative\tway\tof\tframing\tthe\tquestion:\tGiven\tn\tpots,\teach\twith\tsome\tnumber\tof\tgold coins,\tare\tarranged\tin\ta\tline.\tYou\tare\tplaying\ta\tgame\tagainst\tanother\tplayer.\tYou\ttake\tturns picking\ta\tpot\tof\tgold.\tYou\tmay\tpick\ta\tpot\tfrom\teither\tend\tof\tthe\tline,\tremove\tthe\tpot,\tand keep\tthe\tgold\tpieces.\tThe\tplayer\twith\tthe\tmost\tgold\tat\tthe\tend\twins.\tDevelop\ta\tstrategy\tfor playing\tthis\tgame. Solution:\t Let\t us\t solve\t the\t problem\t using\t our\t DP\t technique.\t For\t each\t turn\t either\t we\t or\t our opponent\tselects\tthe\tcoin\tonly\tfrom\tthe\tends\tof\tthe\trow.\tLet\tus\tdefine\tthe\tsubproblems\tas: V(i,j):\tdenotes\tthe\tmaximum\tpossible\tvalue\twe\tcan\tdefinitely\twin\tif\tit\tis\tour\tturn\tand\tthe\tonly coins\tremaining\tare\tvi\t...\tvj. Base\tCases:\tV(i,i),V(i,\ti\t+\t1)\tfor\tall\tvalues\tof\ti. From\tthese\tvalues,\twe\tcan\tcompute\tV(i,\ti\t+\t2),V(i,i\t+\t3)\tand\tso\ton.\tNow\tlet\tus\tdefine\tV(i,j)\tfor each\tsub\tproblem\tas: In\tthe\trecursive\tcall\twe\thave\tto\tfocus\ton\tith\tcoin\tto\tjth\tcoin\t(vi...\tvj).\tSince\tit\tis\tour\tturn\tto\tpick\tthe coin,\twe\thave\ttwo\tpossibilities:\teither\twe\tcan\tpick\tvi\tor\tvj.\tThe\tfirst\tterm\tindicates\tthe\tcase\tif\twe select\tith\tcoin\t(vi)\tand\tthe\tsecond\tterm\tindicates\tthe\tcase\tif\twe\tselect\tjth\tcoin\t(vj).\tThe\touter\tMax indicates\tthat\twe\thave\tto\tselect\tthe\tcoin\twhich\tgives\tmaximum\tvalue.\tNow\tlet\tus\tfocus\ton\tthe terms: \u2022 Selecting\tith\tcoin:\tIf\twe\tselect\tthe\tith\tcoin\tthen\tthe\tremaining\trange\tis\tfrom\ti\t+\t1\tto\tj. Since\twe\tselected\tthe\tith\tcoin\twe\tget\tthe\tvalue\tvi\tfor\tthat.\tFrom\tthe\tremaining\trange i\t+\t1\tto\tj,\tthe\topponents\tcan\tselect\teither\ti\t+\t1th\tcoin\tor\tjth\tcoin.\tBut\tthe\topoonents selection\tshould\tbe\tminimized\tas\tmuch\tas\tpossible\t[the\tMin\t term].\t The\t same\t is described\tin\tthe\tbelow\tfigure. \u2022 Selecting\tthe\tjth\tcoin:\tHere\talso\tthe\targument\tis\tthe\tsame\tas\tabove.\tIf\twe\tselect\tthe jth\tcoin,\tthen\tthe\tremaining\trange\tis\tfromitoj-1.\tSince\twe\tselected\tthe\tjth\tcoin\twe\tget the\tvalue\tvj\tfor\tthat.\tFrom\tthe\tremaining\trange\ti\tto\tj\t-\t1,\tthe\topponent\tcan\tselect either\t the\t ith\t coin\t or\t the\t j\t \u2013\t 1th\t coin.\t But\t the\t opponent\u2019s\t selection\t should\t be minimized\tas\tmuch\tas\tpossible\t[the\tMin\tterm]. How\tmany\tsubproblems\tare\tthere?\tIn\tthe\tabove\tformula,\ti\tcan\trange\tfrom\t1\tto\tn\tand\tj\tcan\trange from\t1\tto\tn.\tThere\tare\ta\ttotal\tof\tn2\tsubproblems\tand\teach\ttakes\tO(1)\tand\tthe\ttotal\ttime\tcomplexity is\tO(n2). Problem-34\u2003\u2003Tiling:\tAssume\tthat\twe\tuse\tdominoes\tmeasuring\t2\t\u00d7\t1\tto\ttile\tan\tinfinite\tstrip\tof height\t2.\tHow\tmany\tways\tcan\tone\ttile\ta\t2\t\u00d7\tn\tstrip\tof\tsquare\tcells\twith\t1x2\tdominoes? Solution:\t Notice\t that\t we\t can\t place\t tiles\t either\t vertically\t or\t horizontally.\t For\t placing\t vertical tiles,\twe\tneed\ta\tgap\tof\tat\tleast\t2\t\u00d7\t2.\tFor\tplacing\thorizontal\ttiles,\twe\tneed\ta\tgap\tof\t2\t\u00d7\t1.\tIn\tthis manner,\tthe\tproblem\tis\treduced\tto\tfinding\tthe\tnumber\tof\tways\tto\tpartition\tn\tusing\tthe\tnumbers\t1 and\t2\twith\torder\tconsidered\trelevant\t[1].\tFor\texample:\t11\t=\t1\t+\t2\t+\t2+1+2\t+\t2\t+\t1. If\twe\thave\tto\tfind\tsuch\tarrangements\tfor\t12,\twe\tcan\teither\tplace\ta\t1\tat\tthe\tend\tor\twe\tcan\tadd\t2\tin the\tarrangements\tpossible\twith\t10.\tSimilarly,\tlet\tus\tsay\twe\thave\tFn\tpossible\tarrangements\tfor\tn. Then\tfor\t(n\t+\t1),\twe\tcan\teither\tplace\tjust\t1\tat\tthe\tend\tor\twe\tcan\tfind\tpossible\tarrangements\tfor\t(n \u2013\t1)\tand\tput\ta\t2\tat\tthe\tend.\tGoing\tby\tthe\tabove\ttheory: Let\u2019s\tverify\tthe\tabove\ttheory\tfor\tour\toriginal\tproblem: \u2022 In\thow\tmany\tways\tcan\twe\tfill\ta\t2\t\u00d7\t1\tstrip:\t1\t\u2192\tOnly\tone\tvertical\ttile. \u2022 In\thow\tmany\tways\tcan\twe\tfill\ta\t2\t\u00d7\t2\tstrip:\t2\t\u2192\tEither\t2\thorizontal\tor\t2\tvertical tiles. \u2022 In\thow\tmany\tways\tcan\twe\tfill\ta\t2\t\u00d7\t3\tstrip:\t3\t\u2192\tEither\tput\ta\tvertical\ttile\tin\tthe\t2 solutions\tpossible\tfor\ta\t2\t\u00d7\t2\tstrip,\tor\tput\t2\thorizontal\ttiles\tin\tthe\tonly\tsolution possible\tfor\ta\t2\t\u00d7\t1\tstrip.\t(2\t+\t1\t=\t3). \u2022 Similarly,\tin\thow\tmany\tways\tcan\twe\tfill\ta\t2\t\u00d7\tn\tstrip:\tEither\tput\ta\tvertical\ttile\tin\tthe solutions\t possible\t for\t 2\t X\t (n\t \u2013\t 1)\t strip\t or\t put\t 2\t horizontal\t tiles\t in\t the\t solution possible\tfor\ta\t2\t\u00d7\t(n\t\u2013\t2)\tstrip.\t(Fn\u20131\t+\tFn\u20132). \u2022 That\u2019s\thow\twe\tverified\tthat\tour\tfinal\tsolution\tis:\tFn\t=\tFn\u20131\t+\tFn\u20132\twith\tF1\t=\t1\tand F2\t=\t2. Problem-35\u2003\u2003Longest\tPalindrome\tSubsequence:\tA\tsequence\tis\ta\tpalindrome\tif\tit\treads\tthe same\twhether\twe\tread\tit\tleft\tto\tright\tor\tright\tto\tleft.\tFor\texample\tA,\tC,\tG,\tG,\tG,\tG,C,A. Given\t a\t sequence\t of\t length\t n,\t devise\t an\t algorithm\t to\t output\t the\t length\t of\t the\t longest palindrome\t subsequence.\t For\t example,\t the\t string\t A,G,C,T,C,B,M,A,A,C,T,G,G,A,M\t has many\tpalindromes\tas\tsubsequences,\tfor\tinstance:\tA,G,T,C,M,C,T,G,A\thas\tlength\t9. Solution:\tLet\tus\tuse\tDP\tto\tsolve\tthis\tproblem.\tIf\twe\tlook\tat\tthe\tsub-string\tA[i,..,j]\tof\tthe\tstring\tA, then\twe\tcan\tfind\ta\tpalindrome\tsequence\tof\tlength\tat\tleast\t2\tif\tA[i]\t==\tA[j].\tIf\tthey\tare\tnot\tthe same,\tthen\twe\thave\tto\tfind\tthe\tmaximum\tlength\tpalindrome\tin\tsubsequences\tA[i\t+\t1,...,\tj]\tand A[i,...,\tj\t\u2013\t1]. Also,\tevery\tcharacter\tA[i]\tis\ta\tpalindrome\tof\tlength\t1.\tTherefore\tthe\tbase\tcases\tare\tgiven\tby\tA[i, i]\t=\t1.\tLet\tus\tdefine\tthe\tmaximum\tlength\tpalindrome\tfor\tthe\tsubstring\tA[i,...,j]\tas\tL(i,j). Time\tComplexity:\tFirst\t\u2018for\u2019\tloop\ttakes\tO(n)\ttime\twhile\tthe\tsecond\t\u2018for\u2019\tloop\ttakes\tO(n\t\u2013\tk) which\tis\talso\tO(n).\tTherefore,\tthe\ttotal\trunning\ttime\tof\tthe\talgorithm\tis\tgiven\tby\tO(n2). Problem-36\u2003\u2003Longest\tPalindrome\tSubstring:\tGiven\ta\tstring\tA,\twe\tneed\tto\tfind\tthe\tlongest sub-string\tof\tA\tsuch\tthat\tthe\treverse\tof\tit\tis\texactly\tthe\tsame. Solution:\t The\t basic\t difference\t between\t the\t longest\t palindrome\t substring\t and\t the\t longest palindrome\tsubsequence\tis\tthat,\tin\tthe\tcase\tof\tthe\tlongest\tpalindrome\tsubstring,\tthe\toutput\tstring should\tbe\tthe\tcontiguous\tcharacters,\twhich\tgives\tthe\tmaximum\tpalindrome;\tand\tin\tthe\tcase\tof\tthe longest\tpalindrome\tsubsequence,\tthe\toutput\tis\tthe\tsequence\tof\tcharacters\twhere\tthe\tcharacters might\t not\t be\t contiguous\t but\t they\t should\t be\t in\t an\t increasing\t sequence\t with\t respect\t to\t their positions\tin\tthe\tgiven\tstring. Brute-force\tsolution\texhaustively\tchecks\tall\tn\t(n\t+\t1)\t/\t2\tpossible\tsubstrings\tof\tthe\tgiven\tn-length string,\ttests\teach\tone\tif\tit\u2019s\ta\tpalindrome,\tand\tkeeps\ttrack\tof\tthe\tlongest\tone\tseen\tso\tfar.\tThis\thas worst-case\t complexity\t O(n3),\t but\t we\t can\t easily\t do\t better\t by\t realizing\t that\t a\t palindrome\t is centered\t on\t either\t a\t letter\t (for\t odd-length\t palindromes)\t or\t a\t space\t between\t letters\t (for\t even- length\tpalindromes).\tTherefore\twe\tcan\texamine\tall\tn\t+\t1\tpossible\tcenters\tand\tfind\tthe\tlongest palindrome\tfor\tthat\tcenter,\tkeeping\ttrack\tof\tthe\toverall\tlongest\tpalindrome.\tThis\thas\tworst-case complexity\tO(n2). Let\tus\tuse\tDP\tto\tsolve\tthis\tproblem.\tIt\tis\tworth\tnoting\tthat\tthere\tare\tno\tmore\tthan\tO(n2)\tsubstrings in\ta\tstring\tof\tlength\tn\t(while\tthere\tare\texactly\t2n\tsubsequences).\tTherefore,\twe\tcould\tscan\teach substring,\t check\t for\t a\t palindrome,\t and\t update\t the\t length\t of\t the\t longest\t palindrome\t substring discovered\tso\tfar.\tSince\tthe\tpalindrome\ttest\ttakes\ttime\tlinear\tin\tthe\tlength\tof\tthe\tsubstring,\tthis idea\ttakes\tO(n3)\talgorithm.\tWe\tcan\tuse\tDP\tto\timprove\tthis.\tFor\t1\t\u2264\ti\t\u2264\tj\t\u2264\tn,\tdefine Also,\tfor\tstring\tof\tlength\tat\tleast\t3, Note\tthat\tin\torder\tto\tobtain\ta\twell-defined\trecurrence,\twe\tneed\tto\texplicitly\tinitialize\ttwo\tdistinct diagonals\tof\tthe\tboolean\tarray\tL[i,j],\tsince\tthe\trecurrence\tfor\tentry\t[i,j]\tuses\tthe\tvalue\t[i\t\u2013\t1,j\t\u2013 1],\twhich\tis\ttwo\tdiagonals\taway\tfrom\t[i,j]\t(that\tmeans,\tfor\ta\tsubstring\tof\tlength\tk,\twe\tneed\tto know\tthe\tstatus\tof\ta\tsubstring\tof\tlength\tk\t\u2013\t2). Time\tComplexity:\tFirst\tfor\tloop\ttakes\tO(n)\ttime\twhile\tthe\tsecond\tfor\tloop\ttakes\tO(n\t\u2013\tk)\twhich is\talso\tO(n).\tTherefore\tthe\ttotal\trunning\ttime\tof\tthe\talgorithm\tis\tgiven\tby\tO(n2). Problem-37\u2003\u2003Given\t two\t strings\t S\t and\t T,\t give\t an\t algorithm\t to\t find\t the\t number\t of\t times\t S appears\tin\tT.\tIt\u2019s\tnot\tcompulsory\tthat\tall\tcharacters\tof\tS\tshould\tappear\tcontiguous\tto\tT. For\texample,\tif\tS\t=\tab\tand\tT\t=\tabadcb\tthen\tthe\tsolution\tis\t4,\tbecause\tab\tis\tappearing\t4 times\tin\tabadcb. Solution: Input:\tGiven\ttwo\tstrings\tS[1..\tm]\tand\tT[1\t...m]. Goal:\tCount\tthe\tnumber\tof\ttimes\tthat\tS\tappears\tin\tT. Assume\t L(i,j)\t represents\t the\t count\t of\t how\t many\t times\t i\t characters\t of\t S\t are\t appearing\t in\t j characters\tof\tT. If\twe\tconcentrate\ton\tthe\tcomponents\tof\tthe\tabove\trecursive\tformula, \u2022 If\tj\t=\t0,\tthen\tsince\tT\tis\tempty\tthe\tcount\tbecomes\t0. \u2022 If\ti\t=\t0,\tthen\twe\tcan\ttreat\tempty\tstring\tS\talso\tappearing\tin\tT\tand\twe\tcan\tgive\tthe count\tas\t1. \u2022 If\tS[i]\t==\tT[i],\tit\tmeans\tith\tcharacter\tof\tS\tand\tjth\tcharacter\tof\tT\tare\tthe\tsame.\tIn\tthis case\t we\t have\t to\t check\t the\t subproblems\t with\t i\t \u2013\t 1\t characters\t of\t S\t and\t j\t \u2013\t 1 characters\tof\tT\tand\talso\twe\thave\tto\tcount\tthe\tresult\tof\ti\tcharacters\tof\tS\twithy\t\u2013\t1 characters\tof\tT.\tThis\tis\tbecause\teven\tall\ti\tcharacters\tof\tS\tmight\tbe\tappearing\tin\tj\t\u2013 1\tcharacters\tof\tT. \u2022 If\tS[i]\t\u2260\tT[i],\tthen\twe\thave\tto\tget\tthe\tresult\tof\tsubproblem\twith\ti\t\u2013\t1\tcharacters\tof\tS and\tj\tcharacters\tof\tT. After\tcomputing\tall\tthe\tvalues,\twe\thave\tto\tselect\tthe\tone\twhich\tgives\tthe\tmaximum\tcount. How\tmany\tsubproblems\tare\tthere?\tIn\tthe\tabove\tformula,\ti\tcan\trange\tfrom\t1\tto\tm\tand\tj\t can range\t from\t 1\t to\t n.\t There\t are\t a\t total\t of\t ran\t subproblems\t and\t each\t one\t takes\t O(1).\t Time Complexity\tis\tO(mn). Space\tComplexity:\tO(mn)\twhere\tm\tis\tnumber\tof\trows\tand\tn\tis\tnumber\tof\tcolumns\tin\tthe\tgiven matrix. Problem-38\u2003\u2003Given\ta\tmatrix\twith\tn\trows\tand\tm\tcolumns\t(n\t\u00d7\tm).\tIn\teach\tcell\tthere\tare\ta number\tof\tapples.\tWe\tstart\tfrom\tthe\tupper-left\tcorner\tof\tthe\tmatrix.\tWe\tcan\tgo\tdown\tor right\tone\tcell.\tFinally,\twe\tneed\tto\tarrive\tat\tthe\tbottom-right\tcorner.\tFind\tthe\tmaximum number\tof\tapples\tthat\twe\tcan\tcollect.\tWhen\twe\tpass\tthrough\ta\tcell,\twe\tcollect\tall\tthe apples\tleft\tthere. Solution:\tLet\tus\tassume\tthat\tthe\tgiven\tmatrix\tis\tA[n][m].\tThe\tfirst\tthing\tthat\tmust\tbe\tobserved\tis that\tthere\tare\tat\tmost\t2\tways\twe\tcan\tcome\tto\ta\tcell\t-\tfrom\tthe\tleft\t(if\tit\u2019s\tnot\tsituated\ton\tthe\tfirst column)\tand\tfrom\tthe\ttop\t(if\tit\u2019s\tnot\tsituated\ton\tthe\tmost\tupper\trow). To\tfind\tthe\tbest\tsolution\tfor\tthat\tcell,\twe\thave\tto\thave\talready\tfound\tthe\tbest\tsolutions\tfor\tall\tof the\tcells\tfrom\twhich\twe\tcan\tarrive\tto\tthe\tcurrent\tcell.\tFrom\tabove,\ta\trecurrent\trelation\tcan\tbe easily\tobtained\tas: S(i,j)\tmust\tbe\tcalculated\tby\tgoing\tfirst\tfrom\tleft\tto\tright\tin\teach\trow\tand\tprocess\tthe\trows\tfrom top\tto\tbottom,\tor\tby\tgoing\tfirst\tfrom\ttop\tto\tbottom\tin\teach\tcolumn\tand\tprocess\tthe\tcolumns\tfrom left\tto\tright. How\tmany\tsuch\tsubproblems\tare\tthere?\tIn\tthe\tabove\tformula,\ti\tcan\trange\tfrom\t1\tto\tn\tand\tj\tcan range\t from\t 1\t to\t m.\t There\t are\t a\t total\t of\t run\t subproblems\t and\t each\t one\t takes\t O(1).\t Time Complexity\tis\tO(nm).\tSpace\tComplexity:\tO(nm),\twhere\tm\tis\tnumber\tof\trows\tand\tn\tis\tnumber\tof columns\tin\tthe\tgiven\tmatrix. Problem-39\u2003\u2003Similar\tto\tProblem-38,\tassume\tthat\twe\tcan\tgo\tdown,\tright\tone\tcell,\tor\teven\tin\ta diagonal\tdirection.\tWe\tneed\tto\tarrive\tat\tthe\tbottom-right\tcorner.\tGive\tDP\tsolution\tto\tfind the\tmaximum\tnumber\tof\tapples\twe\tcan\tcollect. Solution:\tYes.\tThe\tdiscussion\tis\tvery\tsimilar\tto\tProblem-38.\tLet\tus\tassume\tthat\tthe\tgiven\tmatrix is\tA[n][m].\tThe\tfirst\tthing\tthat\tmust\tbe\tobserved\tis\tthat\tthere\tare\tat\tmost\t3\tways\twe\tcan\tcome\tto\ta cell\t -\t from\t the\t left,\t from\t the\t top\t (if\t it\u2019s\t not\t situated\t on\t the\t uppermost\t row)\t or\t from\t the\t top diagonal.\tTo\tfind\tthe\tbest\tsolution\tfor\tthat\tcell,\twe\thave\tto\thave\talready\tfound\tthe\tbest\tsolutions for\tall\tof\tthe\tcells\tfrom\twhich\twe\tcan\tarrive\tto\tthe\tcurrent\tcell.\tFrom\tabove,\ta\trecurrent\trelation can\tbe\teasily\tobtained: S(i,j)\tmust\tbe\tcalculated\tby\tgoing\tfirst\tfrom\tleft\tto\tright\tin\teach\trow\tand\tprocess\tthe\trows\tfrom top\tto\tbottom,\tor\tby\tgoing\tfirst\tfrom\ttop\tto\tbottom\tin\teach\tcolumn\tand\tprocess\tthe\tcolumns\tfrom left\tto\tright. How\tmany\tsuch\tsubproblems\tare\tthere?\tIn\tthe\tabove\tformula,\ti\tcan\trange\tfrom\t1\tto\tn\tand\tj\tcan range\t from\t 1\t to\t m.\t There\t are\t a\t total\t of\t mn\t subproblems\t and\t and\t each\t one\t takes\t O(1).\t Time Complexity\tis\tO(nm). Space\tComplexity:\tO(nm)\twhere\tm\tis\tnumber\tof\trows\tand\tn\tis\tnumber\tof\tcolumns\tin\tthe\tgiven matrix. Problem-40\u2003\u2003Maximum\tsize\tsquare\tsub-matrix\twith\tall\t1\u2019s:\tGiven\ta\tmatrix\twith\t0\u2019s\tand 1\u2019s,\t give\t an\t algorithm\t for\t finding\t the\t maximum\t size\t square\t sub-matrix\t with\t all\t Is.\t For example,\tconsider\tthe\tbinary\tmatrix\tbelow. The\tmaximum\tsquare\tsub-matrix\twith\tall\tset\tbits\tis Solution:\tLet\tus\ttry\tsolving\tthis\tproblem\tusing\tDP.\tLet\tthe\tgiven\tbinary\tmatrix\tbe\tB[m][m].\tThe idea\t of\t the\t algorithm\t is\t to\t construct\t a\t temporary\t matrix\t L[][]\t in\t which\t each\t entry\t L[i][j] represents\tsize\tof\tthe\tsquare\tsub-matrix\twith\tall\t1\u2019s\tincluding\tB[i][j]\tand\tB[i][j]\tis\tthe\trightmost and\tbottom-most\tentry\tin\tthe\tsub-matrix. Algorithm: 1) Construct\ta\tsum\tmatrix\tL[m][n]\tfor\tthe\tgiven\tmatrix\tB[m][n]. a. Copy\tfirst\trow\tand\tfirst\tcolumns\tas\tis\tfrom\tB[\t][\t]\tto\tL[\t][\t]. b. For\tother\tentries,\tuse\tthe\tfollowing\texpressions\tto\tconstruct\tL[\t][\t] 2) Find\tthe\tmaximum\tentry\tin\tL[m][n]. 3) Using\tthe\tvalue\tand\tcoordinates\tof\tmaximum\tentry\tin\tL[i],\tprint\tsub-matrix\tof\tB[][]. How\tmany\tsubproblems\tare\tthere?\tIn\tthe\tabove\tformula,\ti\tcan\trange\tfrom\t1\tto\tn\tand\tj\tcan\trange from\t1\tto\tm.\tThere\tare\ta\ttotal\tof\tnm\tsubproblems\tand\teach\tone\ttakes\tO(1).\tTime\tComplexity\tis O(nm).\tSpace\tComplexity\tis\tO(nm),\twhere\tn\tis\tnumber\tof\trows\tand\tm\tis\tnumber\tof\tcolumns\tin the\tgiven\tmatrix. Problem-41\u2003\u2003Maximum\tsize\tsub-matrix\twith\tall\t1\u2019s:\tGiven\ta\tmatrix\twith\t0\u2019s\tand\t1\u2019s,\tgive an\talgorithm\tfor\tfinding\tthe\tmaximum\tsize\tsub-matrix\twith\tall\tIs.\tFor\texample,\tconsider the\tbinary\tmatrix\tbelow. The\tmaximum\tsub-matrix\twith\tall\tset\tbits\tis Solution:\tIf\twe\tdraw\ta\thistogram\tof\tall\t1\u2019s\tcells\tin\tthe\tabove\trows\tfor\ta\tparticular\trow,\tthen maximum\tall\t1\u2019s\tsub-matrix\tending\tin\tthat\trow\twill\tbe\tequal\tto\tmaximum\tarea\trectangle\tin\tthat histogram.\tBelow\tis\tan\texample\tfor\t3rdrow\tin\tthe\tabove\tdiscussed\tmatrix\t[1]: If\twe\tcalculate\tthis\tarea\tfor\tall\tthe\trows,\tmaximum\tarea\twill\tbe\tour\tanswer.\tWe\tcan\textend\tour solution\tvery\teasily\tto\tfind\tstart\tand\tend\tco-ordinates.\tFor\tthis,\twe\tneed\tto\tgenerate\tan\tauxiliary matrix\tS[][]\twhere\teach\telement\trepresents\tthe\tnumber\tof\tIs\tabove\tand\tincluding\tit,\tup\tuntil\tthe first\t0.\tS[][]\tfor\tthe\tabove\tmatrix\twill\tbe\tas\tshown\tbelow: Now\twe\tcan\tsimply\tcall\tour\tmaximum\trectangle\tin\thistogram\ton\tevery\trow\tin\tS[][]\tand\tupdate the\tmaximum\tarea\tevery\ttime.\tAlso\twe\tdon\u2019t\tneed\tany\textra\tspace\tfor\tsaving\tS.\tWe\tcan\tupdate original\tmatrix\t(A)\tto\tS\tand\tafter\tcalculation,\twe\tcan\tconvert\tS\tback\tto\tA. Problem-42\u2003\u2003Maximum\tsum\tsub-matrix:\tGiven\tan\tn\t\u00d7\tn\tmatrix\tM\tof\tpositive\tand\tnegative integers,\tgive\tan\talgorithm\tto\tfind\tthe\tsub-matrix\twith\tthe\tlargest\tpossible\tsum. Solution:\tLet\tAux[r,\tc]\trepresent\tthe\tsum\tof\trectangular\tsubarray\tof\tM\twith\tone\tcorner\tat\tentry [1,1]\tand\tthe\tother\tat\t[r,c].\tSince\tthere\tare\tn2\tsuch\tpossibilities,\twe\tcan\tcompute\tthem\tin\tO(n2) time.\t After\t computing\t all\t possible\t sums,\t the\t sum\t of\t any\t rectangular\t subarray\t of\t M\t can\t be computed\tin\tconstant\ttime.\tThis\tgives\tan\tO(n4)\talgorithm:\twe\tsimply\tguess\tthe\tlower-left\tand\tthe upper-right\tcorner\tof\tthe\trectangular\tsubarray\tand\tuse\tthe\tAux\ttable\tto\tcompute\tits\tsum. Problem-43\u2003\u2003Can\twe\timprove\tthe\tcomplexity\tof\tProblem-42? Solution:\t We\t can\t use\t the\t Problem-4\t solution\t with\t little\t variation,\t as\t we\t have\t seen\t that\t the maximum\tsum\tarray\tof\ta\t1\t\u2013\tD\tarray\talgorithm\tscans\tthe\tarray\tone\tentry\tat\ta\ttime\tand\tkeeps\ta running\t total\t of\t the\t entries.\t At\t any\t point,\t if\t this\t total\t becomes\t negative,\t then\t set\t it\t to\t 0.\t This algorithm\t is\t called\t Kadane\u2019s\t algorithm.\t We\t use\t this\t as\t an\t auxiliary\t function\t to\t solve\t a\t two- dimensional\tproblem\tin\tthe\tfollowing\tway. Time\tComplexity:\tO(n3). Problem-44\u2003\u2003Given\ta\tnumber\tn,\tfind\tthe\tminimum\tnumber\tof\tsquares\trequired\tto\tsum\ta\tgiven number\tn. Examples:\tmin[1]\t=\t1\t=\t12,\tmin[2]\t=\t2\t=\t12\t+\t12,\tmin[4]\t=\t1\t=\t22,\tmin[13]\t=\t2\t=\t32\t+\t22. Solution:\tThis\tproblem\tcan\tbe\treduced\tto\ta\tcoin\tchange\tproblem.\tThe\tdenominations\tare\t1\tto\t .\tNow,\twe\tjust\tneed\tto\tmake\tchange\tfor\tn\twith\ta\tminimum\tnumber\tof\tdenominations. Problem-45\u2003\u2003Finding\tOptimal\tNumber\tof\tJumps\tTo\tReach\tLast\tElement:\tGiven\tan\tarray, start\tfrom\tthe\tfirst\telement\tand\treach\tthe\tlast\tby\tjumping.\tThe\tjump\tlength\tcan\tbe\tat\tmost the\tvalue\tat\tthe\tcurrent\tposition\tin\tthe\tarray.\tThe\toptimum\tresult\tis\twhen\tyou\treach\tthe\tgoal in\tthe\tminimum\tnumber\tof\tjumps.\tExample:\tGiven\tarray\tA\t=\t{2,3,1,1,4}.\tPossible\tways to\treach\tthe\tend\t(index\tlist)\tare: \u2022 0,2,3,4\t(jump\t2\tto\tindex\t2,\tand\tthen\tjump\t1\tto\tindex\t3,\tand\tthen\tjump\t1\tto index\t4) \u2022 0,1,4\t(jump\t1\tto\tindex\t1,\tand\tthen\tjump\t3\tto\tindex\t4) Since\tsecond\tsolution\thas\tonly\t2\tjumps\tit\tis\tthe\toptimum\tresult. Solution:\tThis\tproblem\tis\ta\tclassic\texample\tof\tDynamic\tProgramming.\tThough\twe\tcan\tsolve\tthis by\tbrute-force,\tit\twould\tbe\tcomplex.\tWe\tcan\tuse\tthe\tLIS\tproblem\tapproach\tfor\tsolving\tthis.\tAs soon\tas\twe\ttraverse\tthe\tarray,\twe\tshould\tfind\tthe\tminimum\tnumber\tof\tjumps\tfor\treaching\tthat position\t (index)\t and\t update\t our\t result\t array.\t Once\t we\t reach\t the\t end,\t we\t have\t the\t optimum solution\tat\tlast\tindex\tin\tresult\tarray. How\tcan\twe\tfind\tthe\toptimum\tnumber\tof\tjumps\tfor\tevery\tposition\t(index)?\tFor\tfirst\tindex,\tthe optimum\tnumber\tof\tjumps\twill\tbe\tzero.\tPlease\tnote\tthat\tif\tvalue\tat\tfirst\tindex\tis\tzero,\twe\tcan\u2019t jump\tto\tany\telement\tand\treturn\tinfinite.\tFor\tn\t+\t1th\telement,\tinitialize\tresult[n\t+\t1]\tas\tinfinite. Then\twe\tshould\tgo\tthrough\ta\tloop\tfrom\t0\t...\tn,\tand\tat\tevery\tindex\ti,\twe\tshould\tsee\tif\twe\tare\table to\tjump\tto\tn\t+\t1\tfrom\ti\tor\tnot.\tIf\tpossible,\tthen\tsee\tif\ttotal\tnumber\tof\tjumps\t(result[i]\t+\t1)\tis\tless than\tresult[n\t+\t1],\tthen\tupdate\tresult[n\t+\t1],\telse\tjust\tcontinue\tto\tnext\tindex. The\tabove\tcode\twill\treturn\toptimum\tnumber\tof\tjumps.\tTo\tfind\tthe\tjump\tindexes\tas\twell,\twe\tcan very\teasily\tmodify\tthe\tcode\tas\tper\trequirement. Time\tComplexity:\tSince\twe\tare\trunning\t2\tloops\there\tand\titerating\tfrom\t0\tto\ti\tin\tevery\tloop\tthen total\ttime\ttakes\twill\tbe\t1\t+\t2\t+\t3\t+\t4\t+\t...\t+\tn\t\u2013\t1.\tSo\ttime\tefficiency\tO(n)\t=\tO(n\t*\t(n\t\u2013\t1)/2)\t= O(n2). Space\tComplexity:\tO(n)\tspace\tfor\tresult\tarray. Problem-46\u2003\u2003Explain\twhat\twould\thappen\tif\ta\tdynamic\tprogramming\talgorithm\tis\tdesigned\tto solve\ta\tproblem\tthat\tdoes\tnot\thave\toverlapping\tsub-problems. Solution:\tIt\twill\tbe\tjust\ta\twaste\tof\tmemory,\tbecause\tthe\tanswers\tof\tsub-problems\twill\tnever\tbe used\tagain.\tAnd\tthe\trunning\ttime\twill\tbe\tthe\tsame\tas\tusing\tthe\tDivide\t&\tConquer\talgorithm. Problem-47\u2003\u2003Christmas\t is\t approaching.\t You\u2019re\t helping\t Santa\t Claus\t to\t distribute\t gifts\t to children.\tFor\tease\tof\tdelivery,\tyou\tare\tasked\tto\tdivide\tn\tgifts\tinto\ttwo\tgroups\tsuch\tthat\tthe weight\tdifference\tof\tthese\ttwo\tgroups\tis\tminimized.\tThe\tweight\tof\teach\tgift\tis\ta\tpositive integer.\t Please\t design\t an\t algorithm\t to\t find\t an\t optimal\t division\t minimizing\t the\t value difference.\t The\t algorithm\t should\t find\t the\t minimal\t weight\t difference\t as\t well\t as\t the groupings\tin\tO(nS)\ttime,\twhere\tS\tis\tthe\ttotal\tweight\tof\tthese\tn\tgifts.\tBriefly\tjustify\tthe correctness\tof\tyour\talgorithm. Solution:\t This\t problem\t can\t be\t converted\t into\t making\t one\t set\t as\t close\t to\t \t as\t possible.\t We consider\t an\t equivalent\t problem\t of\t making\t one\t set\t as\t close\t to\t \t as\t possible.\t Define FD(i,w)\tto\tbe\tthe\tminimal\tgap\tbetween\tthe\tweight\tof\tthe\tbag\tand\tW\twhen\tusing\tthe\tfirst\ti\tgifts only.\tWLOG,\twe\tcan\tassume\tthe\tweight\tof\tthe\tbag\tis\talways\tless\tthan\tor\tequal\tto\tW.\tThen\tfill\tthe DP\ttable\tfor\t0\u2264i\u2264\tn\tand\t0\u2264\tw\t\u2264W\tin\twhich\tF(0,\tw)\t=\tW\tfor\tall\tw,\tand This\t takes\t O(nS)\t time.\t FD(n,W)\t is\t the\t minimum\t gap.\t Finally,\t to\t reconstruct\t the\t answer,\t we backtrack\tfrom\t(n,W).\tDuring\tbacktracking,\tif\tFD(i,j)\t=\tFD(i\t\u2013\t1,j)\tthen\ti\tis\tnot\tselected\tin\tthe bag\tand\twe\tmove\tto\tF(i\t\u2013\t1,j).\tOtherwise,\ti\tis\tselected\tand\twe\tmove\tto\tF(i\t\u2013\t1,j\t\u2013\twi). Problem-48\u2003\u2003A\t circus\t is\t designing\t a\t tower\t routine\t consisting\t of\t people\t standing\t atop\t one another\u2019s\tshoulders.\tFor\tpractical\tand\taesthetic\treasons,\teach\tperson\tmust\tbe\tboth\tshorter and\tlighter\tthan\tthe\tperson\tbelow\thim\tor\ther.\tGiven\tthe\theights\tand\tweights\tof\teach\tperson in\tthe\tcircus,\twrite\ta\tmethod\tto\tcompute\tthe\tlargest\tpossible\tnumber\tof\tpeople\tin\tsuch\ta tower. Solution:\tIt\tis\tsame\tas\tBox\tstacking\tand\tLongest\tincreasing\tsubsequence\t(LIS)\tproblem."
            },
            {
                "subchapter_title": "20.1\tIntroduction",
                "content": "In\tthe\tprevious\tchapters\twe\thave\tsolved\tproblems\tof\tdifferent\tcomplexities.\tSome\talgorithms have\tlower\trates\tof\tgrowth\twhile\tothers\thave\thigher\trates\tof\tgrowth.\tThe\tproblems\twith\tlower rates\tof\tgrowth\tare\tcalled\teasy\tproblems\t(or\teasy\tsolved\tproblems)\tand\tthe\tproblems\twith\thigher rates\tof\tgrowth\tare\tcalled\thard\tproblems\t(or\thard\tsolved\tproblems).\tThis\tclassification\tis\tdone based\ton\tthe\trunning\ttime\t(or\tmemory)\tthat\tan\talgorithm\ttakes\tfor\tsolving\tthe\tproblem. There\tare\tlots\tof\tproblems\tfor\twhich\twe\tdo\tnot\tknow\tthe\tsolutions.\tAll\tthe\tproblems\twe\thave seen\tso\tfar\tare\tthe\tones\twhich\tcan\tbe\tsolved\tby\tcomputer\tin\tdeterministic\ttime.\tBefore\tstarting our\tdiscussion\tlet\tus\tlook\tat\tthe\tbasic\tterminology\twe\tuse\tin\tthis\tchapter."
            },
            {
                "subchapter_title": "20.2\tPolynomial/Exponential\tTime",
                "content": "Exponential\t time\t means,\t in\t essence,\t trying\t every\t possibility\t (for\t example,\t backtracking algorithms)\t and\t they\t are\t very\t slow\t in\t nature.\t Polynomial\t time\t means\t having\t some\t clever algorithm\t to\t solve\t a\t problem,\t and\t we\t don\u2019t\t try\t every\t possibility.\t Mathematically,\t we\t can represent\tthese\tas: \u2022 Polynomial\ttime\tis\tO(nk),\tfor\tsome\tk. \u2022 Exponential\ttime\tis\tO(kn),\tfor\tsome\tk."
            },
            {
                "subchapter_title": "20.3\tWhat\tis\ta\tDecision\tProblem?",
                "content": "A\tdecision\tproblem\tis\ta\tquestion\twith\ta\tyes/no\tanswer\tand\tthe\tanswer\tdepends\ton\tthe\tvalues\tof input.\t For\t example,\t the\t problem\t \u201cGiven\t an\t array\t of\t n\t numbers,\t check\t whether\t there\t are\t any duplicates\tor\tnot?\u201d\tis\ta\tdecision\tproblem.\tThe\tanswer\tfor\tthis\tproblem\tcan\tbe\teither\tyes\tor\tno depending\ton\tthe\tvalues\tof\tthe\tinput\tarray."
            },
            {
                "subchapter_title": "20.4\tDecision\tProcedure",
                "content": "For\ta\tgiven\tdecision\tproblem\tlet\tus\tassume\twe\thave\tgiven\tsome\talgorithm\tfor\tsolving\tit.\tThe process\t of\t solving\t a\t given\t decision\t problem\t in\t the\t form\t of\t an\t algorithm\t is\t called\t a\t decision procedure\tfor\tthat\tproblem."
            },
            {
                "subchapter_title": "20.5\tWhat\tis\ta\tComplexity\tClass?",
                "content": "In\tcomputer\tscience,\tin\torder\tto\tunderstand\tthe\tproblems\tfor\twhich\tsolutions\tare\tnot\tthere,\tthe problems\tare\tdivided\tinto\tclasses\tand\twe\tcall\tthem\tas\tcomplexity\tclasses.\tIn\tcomplexity\ttheory,\ta complexity\t class\t is\t a\t set\t of\t problems\t with\t related\t complexity.\t It\t is\t the\t branch\t of\t theory\t of computation\tthat\tstudies\tthe\tresources\trequired\tduring\tcomputation\tto\tsolve\ta\tgiven\tproblem. The\tmost\tcommon\tresources\tare\ttime\t(how\tmuch\ttime\tthe\talgorithm\ttakes\tto\tsolve\ta\tproblem)\tand space\t(how\tmuch\tmemory\tit\ttakes)."
            },
            {
                "subchapter_title": "20.6\tTypes\tof\tComplexity\tClasses",
                "content": "P\tClass The\t complexity\t class\t P\t is\t the\t set\t of\t decision\t problems\t that\t can\t be\t solved\t by\t a\t deterministic machine\tin\tpolynomial\ttime\t(P\tstands\tfor\tpolynomial\ttime).\tP\tproblems\tare\ta\tset\tof\tproblems whose\tsolutions\tare\teasy\tto\tfind. NP\tClass The\tcomplexity\tclass\tNP\t(NP\tstands\tfor\tnon-deterministic\tpolynomial\ttime)\tis\tthe\tset\tof\tdecision problems\t that\t can\t be\t solved\t by\t a\t non-deterministic\t machine\t in\t polynomial\t time.\t NP\t class problems\trefer\tto\ta\tset\tof\tproblems\twhose\tsolutions\tare\thard\tto\tfind,\tbut\teasy\tto\tverify. For\t better\t understanding\t let\t us\t consider\t a\t college\t which\t has\t 500\t students\t on\t its\t roll.\t Also, assume\tthat\tthere\tare\t100\trooms\tavailable\tfor\tstudents.\tA\tselection\tof\t100\tstudents\tmust\tbe\tpaired together\tin\trooms,\tbut\tthe\tdean\tof\tstudents\thas\ta\tlist\tof\tpairings\tof\tcertain\tstudents\twho\tcannot room\ttogether\tfor\tsome\treason. The\ttotal\tpossible\tnumber\tof\tpairings\tis\ttoo\tlarge.\tBut\tthe\tsolutions\t(the\tlist\tof\tpairings)\tprovided to\tthe\tdean,\tare\teasy\tto\tcheck\tfor\terrors.\tIf\tone\tof\tthe\tprohibited\tpairs\tis\ton\tthe\tlist,\tthat\u2019s\tan\terror. In\tthis\tproblem,\twe\tcan\tsee\tthat\tchecking\tevery\tpossibility\tis\tvery\tdifficult,\tbut\tthe\tresult\tis\teasy to\tvalidate. That\tmeans,\tif\tsomeone\tgives\tus\ta\tsolution\tto\tthe\tproblem,\twe\tcan\ttell\tthem\twhether\tit\tis\tright\tor not\tin\tpolynomial\ttime.\tBased\ton\tthe\tabove\tdiscussion,\tfor\tNP\tclass\tproblems\tif\tthe\tanswer\tis yes,\tthen\tthere\tis\ta\tproof\tof\tthis\tfact,\twhich\tcan\tbe\tverified\tin\tpolynomial\ttime. Co-NP\tClass Co\t\u2013\tNP\tis\tthe\topposite\tof\tNP\t(complement\tof\tNP).\tIf\tthe\tanswer\tto\ta\tproblem\tin\tCo\t\u2013\tNP\tis\tno, then\tthere\tis\ta\tproof\tof\tthis\tfact\tthat\tcan\tbe\tchecked\tin\tpolynomial\ttime. P Solvable\tin\tpolynomial\ttime NP Yes\tanswers\tcan\tbe\tchecked\tin\tpolynomial\ttime Co-NP No\tanswers\tcan\tbe\tchecked\tin\tpolynomial\ttime Relationship\tbetween\tP,\tNP\tand\tCo-NP Every\tdecision\tproblem\tin\tP\tis\talso\tin\tNP.\tIf\ta\tproblem\tis\tin\tP,\twe\tcan\tverify\tYES\tanswers\tin polynomial\ttime.\tSimilarly,\tany\tproblem\tin\tP\tis\talso\tin\tCo\t\u2013\tNP. One\tof\tthe\timportant\topen\tquestions\tin\ttheoretical\tcomputer\tscience\tis\twhether\tor\tnot\tP\t=\tNP. Nobody\tknows.\tIntuitively,\tit\tshould\tbe\tobvious\tthat\tP\t\u2260\tNP,\tbut\tnobody\tknows\thow\tto\tprove\tit. Another\topen\tquestion\tis\twhether\tNP\tand\tCo\t\u2013\tNP\tare\tdifferent.\tEven\tif\twe\tcan\tverify\tevery YES\tanswer\tquickly,\tthere\u2019s\tno\treason\tto\tthink\tthat\twe\tcan\talso\tverify\tNO\tanswers\tquickly. It\tis\tgenerally\tbelieved\tthat\tNP\t\u2260\tCo\t\u2013\tNP,\tbut\tagain\tnobody\tknows\thow\tto\tprove\tit. NP-hard\tClass It\tis\ta\tclass\tof\tproblems\tsuch\tthat\tevery\tproblem\tin\tNP\treduces\tto\tit.\tAll\tNP-hard\tproblems\tare not\tin\tNP,\tso\tit\ttakes\ta\tlong\ttime\tto\teven\tcheck\tthem.\tThat\tmeans,\tif\tsomeone\tgives\tus\ta\tsolution for\tNP-hard\tproblem,\tit\ttakes\ta\tlong\ttime\tfor\tus\tto\tcheck\twhether\tit\tis\tright\tor\tnot. A\tproblem\tK\tis\tNP-hard\tindicates\tthat\tif\ta\tpolynomial-time\talgorithm\t(solution)\texists\tfor\tK\tthen a\tpolynomial-time\talgorithm\tfor\tevery\tproblem\tis\tNP.\tThus: NP-complete\tClass Finally,\ta\tproblem\tis\tNP-complete\tif\tit\tis\tpart\tof\tboth\tNP-hard\tand\tNP.\tNP-complete\tproblems are\tthe\thardest\tproblems\tin\tNP.\tIf\tanyone\tfinds\ta\tpolynomial-time\talgorithm\tfor\tone\tNP-complete problem,\t then\t we\t can\t find\t polynomial-time\t algorithm\t for\t every\t NP-complete\t problem.\t This means\tthat\twe\tcan\tcheck\tan\tanswer\tfast\tand\tevery\tproblem\tin\tNP\treduces\tto\tit. Relationship\tbetween\tP,\tNP\tCo-NP,\tNP-Hard\tand\tNP-Complete From\t the\t above\t discussion,\t we\t can\t write\t the\t relationships\t between\t different\t components\t as shown\tbelow\t(remember,\tthis\tis\tjust\tan\tassumption). The\tset\tof\tproblems\tthat\tare\tNP-hard\tis\ta\tstrict\tsuperset\tof\tthe\tproblems\tthat\tare\tNP-complete. Some\tproblems\t(like\tthe\thalting\tproblem)\tare\tNP-hard,\tbut\tnot\tin\tNP.\tNP-hard\tproblems\tmight\tbe impossible\tto\tsolve\tin\tgeneral.\tWe\tcan\ttell\tthe\tdifference\tin\tdifficulty\tbetween\tNP-hard\tand\tNP- complete\tproblems\tbecause\tthe\tclass\tNP\tincludes\teverything\teasier\tthan\tits\t\u201ctoughest\u201d\tproblems\t- if\ta\tproblem\tis\tnot\tin\tNP,\tit\tis\tharder\tthan\tall\tthe\tproblems\tin\tNP. Does\tP==NP? If\t P\t =\t NP,\t it\t means\t that\t every\t problem\t that\t can\t be\t checked\t quickly\t can\t be\t solved\t quickly (remember\tthe\tdifference\tbetween\tchecking\tif\tan\tanswer\tis\tright\tand\tactually\tsolving\ta\tproblem). This\tis\ta\tbig\tquestion\t(and\tnobody\tknows\tthe\tanswer),\tbecause\tright\tnow\tthere\tare\tlots\tof\tNP- complete\tproblems\tthat\tcan\u2019t\tbe\tsolved\tquickly.\tIf\tP\t=\tNP,\tthat\tmeans\tthere\tis\ta\tway\tto\tsolve them\tfast.\tRemember\tthat\t\u201cquickly\u201d\tmeans\tnot\ttrial-and-error.\tIt\tcould\ttake\ta\tbillion\tyears,\tbut\tas long\tas\twe\tdidn\u2019t\tuse\ttrial\tand\terror,\tit\twas\tquick.\tIn\tfuture,\ta\tcomputer\twill\tbe\table\tto\tchange that\tbillion\tyears\tinto\ta\tfew\tminutes."
            },
            {
                "subchapter_title": "20.7\tReductions",
                "content": "Before\t discussing\t reductions,\t let\t us\t consider\t the\t following\t scenario.\t Assume\t that\t we\t want\t to solve\tproblem\tX\tbut\tfeel\tit\u2019s\tvery\tcomplicated.\tIn\tthis\tcase\twhat\tdo\twe\tdo? The\tfirst\tthing\tthat\tcomes\tto\tmind\tis,\tif\twe\thave\ta\tsimilar\tproblem\tto\tthat\tof\tX\t(let\tus\tsay\tY),\tthen we\ttry\tto\tmap\tX\tto\tY\tand\tuse\tY\u2019s\tsolution\tto\tsolve\tX\talso.\tThis\tprocess\tis\tcalled\treduction. In\torder\tto\tmap\tproblem\tX\tto\tproblem\tY,\twe\tneed\tsome\talgorithm\tand\tthat\tmay\ttake\tlinear\ttime\tor more.\tBased\ton\tthis\tdiscussion\tthe\tcost\tof\tsolving\tproblem\tX\tcan\tbe\tgiven\tas: Cost\tof\tsolving\tX\t=\tCost\tof\tsolving\tY\t+\tReduction\ttime Now,\tlet\tus\tconsider\tthe\tother\tscenario.\tFor\tsolving\tproblem\tX,\tsometimes\twe\tmay\tneed\tto\tuse Y\u2019s\talgorithm\t(solution)\tmultiple\ttimes.\tIn\tthat\tcase, Cost\tof\tsolving\tX\t=\tNumber\tof\tTimes\t*\tCost\tof\tsolving\tX\t+\tReduction\ttime The\tmain\tthing\tin\tNP-Complete\tis\treducibility.\tThat\tmeans,\twe\treduce\t(or\ttransform)\tgiven\tNP- Complete\tproblems\tto\tother\tknown\tNP-Complete\tproblem.\tSince\tthe\tNP-Complete\tproblems\tare hard\tto\tsolve\tand\tin\torder\tto\tprove\tthat\tgiven\tNP-Complete\tproblem\tis\thard,\twe\ttake\tone\texisting hard\tproblem\t(which\twe\tcan\tprove\tis\thard)\tand\ttry\tto\tmap\tgiven\tproblem\tto\tthat\tand\tfinally\twe prove\tthat\tthe\tgiven\tproblem\tis\thard. Note:\t It\u2019s\t not\t compulsory\t to\t reduce\t the\t given\t problem\t to\t known\t hard\t problem\t to\t prove\t its hardness.\tSometimes,\twe\treduce\tthe\tknown\thard\tproblem\tto\tgiven\tproblem. Important\tNP-Complete\tProblems\t(Reductions) Satisfiability\t Problem:\t A\t boolean\t formula\t is\t in\t conjunctive\t normal\t form\t (CNF)\t if\t it\t is\t a conjunction\t(AND)\tof\tseveral\tclauses,\teach\tof\twhich\tis\tthe\tdisjunction\t(OR)\tof\tseveral\tliterals, each\tof\twhich\tis\teither\ta\tvariable\tor\tits\tnegation.\tFor\texample:\t(a\t\u2228\tb\t\u2228\tc\t\u2228\td\t\u2228\te)\u2227(b\t\u2228\t~c\t\u2228 ~d)\t\u2227\t(~a\t\u2228\tc\t\u2228\td)\t\u2228\t(a\t\u2228\t~b) A\t3-CNF\tformula\tis\ta\tCNF\tformula\twith\texactly\tthree\tliterals\tper\tclause.\tThe\tprevious\texample is\tnot\ta\t3-CNF\tformula,\tsince\tits\tfirst\tclause\thas\tfive\tliterals\tand\tits\tlast\tclause\thas\tonly\ttwo. 2-SAT\tProblem:\t3-SAT\tis\tjust\tSAT\trestricted\tto\t3-CNF\tformulas:\tGiven\ta\t3-CNF\tformula,\tis there\tan\tassignment\tto\tthe\tvariables\tso\tthat\tthe\tformula\tevaluates\tto\tTRUE? 2-SAT\tProblem:\t2-SAT\tis\tjust\tSAT\trestricted\tto\t2-CNF\tformulas:\tGiven\ta\t2-CNF\tformula,\tis there\tan\tassignment\tto\tthe\tvariables\tso\tthat\tthe\tformula\tevaluates\tto\tTRUE? Circuit-Satisfiability\tProblem:\tGiven\ta\tboolean\tcombinational\tcircuit\tcomposed\tof\tAND,\tOR and\tNOT\tgates,\tis\tit\tsatisfiable?.\tThat\tmeans,\tgiven\ta\tboolean\tcircuit\tconsisting\tof\tAND,\tOR\tand NOT\t gates\t properly\t connected\t by\t wires,\t the\t Circuit-SAT\t problem\t is\t to\t decide\t whether\t there exists\tan\tinput\tassignment\tfor\twhich\tthe\toutput\tis\tTRUE. Hamiltonian\tPath\tProblem\t(Ham-Path):\tGiven\tan\tundirected\tgraph,\tis\tthere\ta\tpath\tthat\tvisits every\tvertex\texactly\tonce? Hamiltonian\tCycle\tProblem\t(Ham-Cycle):\tGiven\tan\tundirected\tgraph,\tis\tthere\ta\tcycle\t(where start\tand\tend\tvertices\tare\tsame)\tthat\tvisits\tevery\tvertex\texactly\tonce? Directed\t Hamiltonian\t Cycle\t Problem\t (Dir-Ham-Cycle):\t Given\t a\t directed\t graph,\t is\t there\t a cycle\t(where\tstart\tand\tend\tvertices\tare\tsame)\tthat\tvisits\tevery\tvertex\texactly\tonce? Travelling\tSalesman\tProblem\t(TSP):\tGiven\ta\tlist\tof\tcities\tand\ttheir\tpair-wise\tdistances,\tthe problem\tis\tto\tfind\tthe\tshortest\tpossible\ttour\tthat\tvisits\teach\tcity\texactly\tonce. Shortest\tPath\tProblem\t(Shortest-Path):\tGiven\ta\tdirected\tgraph\tand\ttwo\tvertices\ts\tand\tt,\tcheck whether\tthere\tis\ta\tshortest\tsimple\tpath\tfrom\ts\tto\tt. Graph\tColoring:\tA\tk-coloring\tof\ta\tgraph\tis\tto\tmap\tone\tof\tk\t\u2018colors\u2019\tto\teach\tvertex,\tso\tthat\tevery edge\thas\ttwo\tdifferent\tcolors\tat\tits\tendpoints.\tThe\tgraph\tcoloring\tproblem\tis\tto\tfind\tthe\tsmallest possible\tnumber\tof\tcolors\tin\ta\tlegal\tcoloring. 3-Color\tproblem:\tGiven\ta\tgraph,\tis\tit\tpossible\tto\tcolor\tthe\tgraph\twith\t3\tcolors\tin\tsuch\ta\tway\tthat every\tedge\thas\ttwo\tdifferent\tcolors? Clique\t(also\tcalled\tcomplete\tgraph):\tGiven\ta\tgraph,\tthe\tCLIQUE\tproblem\tis\tto\tcompute\tthe number\t of\t nodes\t in\t its\t largest\t complete\t subgraph.\t That\t means,\t we\t need\t to\t find\t the\t maximum subgraph\twhich\tis\talso\ta\tcomplete\tgraph. Independent\tSet\tProblem\t(Ind_Set):\tLet\tG\tbe\tan\tarbitrary\tgraph.\tAn\tindependent\tset\tin\tG\tis\ta subset\tof\tthe\tvertices\tof\tG\twith\tno\tedges\tbetween\tthem.\tThe\tmaximum\tindependent\tset\tproblem\tis the\tsize\tof\tthe\tlargest\tindependent\tset\tin\ta\tgiven\tgraph. Vertex\t Cover\t Problem\t (Vertex-Cover):\t A\t vertex\t cover\t of\t a\t graph\t is\t a\t set\t of\t vertices\t that touches\tevery\tedge\tin\tthe\tgraph.\tThe\tvertex\tcover\tproblem\tis\tto\tfind\tthe\tsmallest\tvertex\tcover\tin a\tgiven\tgraph. Subset\t Sum\t Problem\t (Subset-Sum):\t Given\t a\t set\t S\t of\t integers\t and\t an\t integer\t T,\t determine whether\t5\thas\ta\tsubset\twhose\telements\tsum\tto\tT. Integer\tProgramming:\tGiven\tintegers\tbi,\taij\tfind\t0/1\tvariables\txi\tthat\tsatisfy\ta\tlinear\tsystem\tof equations. In\t the\t figure,\t arrows\t indicate\t the\t reductions.\t For\t example,\t Ham-Cycle\t (Hamiltonian\t Cycle Problem)\t can\t be\t reduced\t to\t CNF-SAT.\t Same\t is\t the\t case\t with\t any\t pair\t of\t problems.\t For\t our discussion,\twe\tcan\tignore\tthe\treduction\tprocess\tfor\teach\tof\tthe\tproblems.\tThere\tis\ta\ttheorem called\tCook\u2019s\tTheorem\twhich\tproves\tthat\tCircuit\tsatisfiability\tproblem\tis\tNP-hard.\tThat\tmeans, Circuit\tsatisfiability\tis\ta\tknown\tNP-hard\tproblem. Note:\tSince\tthe\tproblems\tbelow\tare\tNP-Complete,\tthey\tare\tNP\tand\tNP-hard\ttoo.\tFor\tsimplicity we\tcan\tignore\tthe\tproofs\tfor\tthese\treductions."
            },
            {
                "subchapter_title": "20.8\tComplexity\tClasses:\tProblems\t&\tSolutions",
                "content": "Problem-1\u2003\u2003What\tis\ta\tquick\talgorithm? Solution:\tA\tquick\talgorithm\t(solution)\tmeans\tnot\ttrial-and-error\tsolution.\tIt\tcould\ttake\ta\tbillion years,\tbut\tas\tlong\tas\twe\tdo\tnot\tuse\ttrial\tand\terror,\tit\tis\tefficient.\tFuture\tcomputers\twill\tchange those\tbillion\tyears\tto\ta\tfew\tminutes. Problem-2\u2003\u2003What\tis\tan\tefficient\talgorithm? Solution:\tAn\talgorithm\tis\tsaid\tto\tbe\tefficient\tif\tit\tsatisfies\tthe\tfollowing\tproperties: \u2022 Scale\twith\tinput\tsize. \u2022 Don\u2019t\tcare\tabout\tconstants. \u2022 Asymptotic\trunning\ttime:\tpolynomial\ttime. Problem-3\u2003\u2003Can\twe\tsolve\tall\tproblems\tin\tpolynomial\ttime? Solution:\tNo.\tThe\tanswer\tis\ttrivial\tbecause\twe\thave\tseen\tlots\tof\tproblems\twhich\ttake\tmore\tthan polynomial\ttime. Problem-4\u2003\u2003Are\tthere\tany\tproblems\twhich\tare\tNP-hard? Solution:\tBy\tdefinition,\tNP-hard\timplies\tthat\tit\tis\tvery\thard.\tThat\tmeans\tit\tis\tvery\thard\tto\tprove and\tto\tverify\tthat\tit\tis\thard.\tCook\u2019s\tTheorem\tproves\tthat\tCircuit\tsatisfiability\tproblem\tis\tNP-hard. Problem-5\u2003\u2003For\t2-SAT\tproblem,\twhich\tof\tthe\tfollowing\tare\tapplicable? (a) P (b) NP (c) CoNP (d) NP-Hard (e) CoNP-Hard (f) NP-Complete (g) CoNP-Complete Solution:\t2-SAT\tis\tsolvable\tin\tpoly-time.\tSo\tit\tis\tP,\tNP,\tand\tCoNP. Problem-6\u2003\u2003For\t3-SAT\tproblem,\twhich\tof\tthe\tfollowing\tare\tapplicable? (a) P (b) NP (c) CoNP (d) NP-Hard (e) CoNP-Hard (f) NP-Complete (g) CoNP-Complete Solution:\t3-SAT\tis\tNP-complete.\tSo\tit\tis\tNP,\tNP-Hard,\tand\tNP-complete. Problem-7\u2003\u2003For\t2-Clique\tproblem,\twhich\tof\tthe\tfollowing\tare\tapplicable? (a) P (b) NP (c) CoNP (d) NP-Hard (e) CoNP-Hard (f) NP-Complete (g) CoNP-Complete Solution:\t2-Clique\tis\tsolvable\tin\tpoly-time\t(check\tfor\tan\tedge\tbetween\tall\tvertex-pairs\tin\tO(n2) time).\tSo\tit\tis\tP.NP,\tand\tCoNP. Problem-8\u2003\u2003For\t3-Clique\tproblem,\twhich\tof\tthe\tfollowing\tare\tapplicable? (a) P (b) NP (c) CoNP (d) NP-Hard (e) CoNP-Hard (f) NP-Complete (g) CoNP-Complete Solution:\t3-Clique\tis\tsolvable\tin\tpoly-time\t(check\tfor\ta\ttriangle\tbetween\tall\tvertex-triplets\tin O(n3)\ttime).\tSo\tit\tis\tP,\tNP,\tand\tCoNP. Problem-9\u2003\u2003Consider\t the\t problem\t of\t determining.\t For\t a\t given\t boolean\t formula,\t check whether\t every\t assignment\t to\t the\t variables\t satisfies\t it.\t Which\t of\t the\t following\t is applicable? (a) P (b) NP (c) CoNP (d) NP-Hard (e) CoNP-Hard (f) NP-Complete (g) CoNP-Complete Solution:\t Tautology\t is\t the\t complimentary\t problem\t to\t Satisfiability,\t which\t is\t NP-complete,\t so Tautology\tis\tCoNP-complete.\tSo\tit\tis\tCoNP,\tCoNP-hard,\tand\tCoNP-complete. Problem-10\u2003\u2003Let\tS\t be\t an\t NP-complete\t problem\t and\t Q\t and\t R\t be\t two\t other\t problems\t not known\tto\tbe\tin\tNP.\tQ\tis\tpolynomial\ttime\treducible\tto\tS\tand\tS\tis\tpolynomial-time\treducible to\tR.\tWhich\tone\tof\tthe\tfollowing\tstatements\tis\ttrue? (a) R\tis\tNP-complete (b) R\tis\tNP-hard (c) Q\tis\tNP-complete (d) Q\tis\tNP\t-hard. Solution:\tR\tis\tNP-hard\t(b). Problem-11\u2003\u2003Let\tA\tbe\tthe\tproblem\tof\tfinding\ta\tHamiltonian\tcycle\tin\ta\tgraph\tG\t=\t(V\t,E),\twith |V|\tdivisible\tby\t3\tand\tB\tthe\tproblem\tof\tdetermining\tif\tHamiltonian\tcycle\texists\tin\tsuch graphs.\tWhich\tone\tof\tthe\tfollowing\tis\ttrue? (a) Both\tA\tand\tB\tare\tNP-hard (b) A\tis\tNP-hard,\tbut\tB\tis\tnot (c) A\tis\tNP-hard,\tbut\tB\tis\tnot (d) Neither\tA\tnor\tB\tis\tNP-hard Solution:\tBoth\tA\tand\tB\tare\tNP-hard\t(a). Problem-12\u2003\u2003Let\tA\tbe\ta\tproblem\tthat\tbelongs\tto\tthe\tclass\tNP.\tState\twhich\tof\tthe\tfollowing\tis true? (a) There\tis\tno\tpolynomial\ttime\talgorithm\tfor\tA. (b) If\tA\tcan\tbe\tsolved\tdeterministically\tin\tpolynomial\ttime,\tthen\tP\t=\tNP. (c) If\tA\tis\tNP-hard,\tthen\tit\tis\tNP-complete. (d) A\tmay\tbe\tundecidable. Solution:\tIf\tA\tis\tNP-hard,\tthen\tit\tis\tNP-complete\t(c). Problem-13\u2003\u2003Suppose\twe\tassume\tVertex\t\u2013\tCover\tis\tknown\tto\tbe\tNP-complete.\tBased\ton\tour reduction,\tcan\twe\tsay\tIndependent\t\u2013\tSet\tis\tNP-complete? Solution:\tYes.\tThis\tfollows\tfrom\tthe\ttwo\tconditions\tnecessary\tto\tbe\tNP-complete: \u2022 Independent\tSet\tis\tin\tNP,\tas\tstated\tin\tthe\tproblem. \u2022 A\treduction\tfrom\ta\tknown\tNP-complete\tproblem. Problem-14\u2003\u2003Suppose\tIndependent\tSet\tis\tknown\tto\tbe\tNP-complete.\tBased\ton\tour\treduction, is\tVertex\tCover\tNP-complete? Solution:\tNo.\tBy\treduction\tfrom\tVertex-Cover\tto\tIndependent-Set,\twe\tdo\tnot\tknow\tthe\tdifficulty of\tsolving\tIndependent-Set.\tThis\tis\tbecause\tIndependent-Set\tcould\tstill\tbe\ta\tmuch\tharder\tproblem than\tVertex-Cover.\tWe\thave\tnot\tproved\tthat. Problem-15\u2003\u2003The\tclass\tof\tNP\tis\tthe\tclass\tof\tlanguages\tthat\tcannot\tbe\taccepted\tin\tpolynomial time.\tIs\tit\ttrue?\tExplain. Solution: \u2022 The\tclass\tof\tNP\tis\tthe\tclass\tof\tlanguages\tthat\tcan\tbe\tverified\tin\tpolynomial\ttime. \u2022 The\tclass\tof\tP\tis\tthe\tclass\tof\tlanguages\tthat\tcan\tbe\tdecided\tin\tpolynomial\ttime. \u2022 The\tclass\tof\tP\tis\tthe\tclass\tof\tlanguages\tthat\tcan\tbe\taccepted\tin\tpolynomial\ttime. P\t\u2286\tNP\tand\t\u201clanguages\tin\tP\tcan\tbe\taccepted\tin\tpolynomial\ttime\u201d,\tthe\tdescription\t\u201clanguages\tin NP\tcannot\tbe\taccepted\tin\tpolynomial\ttime\u201d\tis\twrong. The\tterm\tNP\tcomes\tfrom\tnondeterministic\tpolynomial\ttime\tand\tis\tderived\tfrom\tan\talternative characterization\tby\tusing\tnondeterministic\tpolynomial\ttime\tTuring\tmachines.\tIt\thas\tnothing\tto\tdo with\t\u201ccannot\tbe\taccepted\tin\tpolynomial\ttime\u201d. Problem-16\u2003\u2003Different\t encodings\t would\t cause\t different\t time\t complexity\t for\t the\t same algorithm.\tIs\tit\ttrue? Solution:\tTrue.\tThe\ttime\tcomplexity\tof\tthe\tsame\talgorithm\tis\tdifferent\tbetween\tunary\tencoding and\tbinary\tencoding.\tBut\tif\tthe\ttwo\tencodings\tare\tpolynomially\trelated\t(e.g.\tbase\t2\t&\tbase\t3 encodings),\tthen\tchanging\tbetween\tthem\twill\tnot\tcause\tthe\ttime\tcomplexity\tto\tchange. Problem-17\u2003\u2003If\tP\t=\tNP,\tthen\tNPC\t(NP\tComplete)\t\u2286\tP.\tIs\tit\ttrue? Solution:\tTrue.\tIf\tP\t=\tNP,\tthen\tfor\tany\tlanguage\tL\t\u2208\tNP\tC\t(1)\tL\t\u2208\tNPC\t(2)\tL\tis\tNP-hard.\tBy\tthe first\tcondition,\tL\t\u2208\tNPC\t\u2286\tNP\t=\tP\t\u21d2\tNPC\t\u2286\tP. Problem-18\u2003\u2003If\tNPC\t\u2286\tP,\tthen\tP\t=\tNP.\tIs\tit\ttrue? Solution:\tTrue.\tAll\tthe\tNP\tproblem\tcan\tbe\treduced\tto\tarbitrary\tNPC\tproblem\tin\tpolynomial\ttime, and\tNPC\tproblems\tcan\tbe\tsolved\tin\tpolynomial\ttime\tbecause\tNPC\t\u2286\tP.\t\u21d2\tNP\tproblem\tsolvable in\tpolynomial\ttime\t\u21d2\tNP\t\u2286\tP\tand\ttrivially\tP\t\u2286\tNP\timplies\tNP\t=\tP."
            },
            {
                "subchapter_title": "21.1\tIntroduction",
                "content": "In\tthis\tchapter\twe\twill\tcover\tthe\ttopics\twhich\tare\tuseful\tfor\tinterviews\tand\texams."
            },
            {
                "subchapter_title": "21.2\tHacks\ton\tBitwise\tProgramming",
                "content": "In\tC\tand\tC\t+\t+\twe\tcan\twork\twith\tbits\teffectively.\tFirst\tlet\tus\tsee\tthe\tdefinitions\tof\teach\tbit operation\tand\tthen\tmove\tonto\tdifferent\ttechniques\tfor\tsolving\tthe\tproblems.\tBasically,\tthere\tare six\toperators\tthat\tC\tand\tC\t+\t+\tsupport\tfor\tbit\tmanipulation: Symbol Operation & Bitwise\tAND 1 Bitwise\tOR A Bitwise\tExclusive-OR \u226a Bitwise\tleft\tshift \u226b Bitwise\tright\tshift ~ Bitwise\tcomplement 21.2.1\tBitwise\tAND The\tbitwise\tAND\ttests\ttwo\tbinary\tnumbers\tand\treturns\tbit\tvalues\tof\t1\tfor\tpositions\twhere\tboth numbers\thad\ta\tone,\tand\tbit\tvalues\tof\t0\twhere\tboth\tnumbers\tdid\tnot\thave\tone: 21.2.2\tBitwise\tOR The\tbitwise\tOR\ttests\ttwo\tbinary\tnumbers\tand\treturns\tbit\tvalues\tof\t1\tfor\tpositions\twhere\teither\tbit or\tboth\tbits\tare\tone,\tthe\tresult\tof\t0\tonly\thappens\twhen\tboth\tbits\tare\t0: 21.2.3\tBitwise\tExclusive-OR The\t bitwise\t Exclusive-OR\t tests\t two\t binary\t numbers\t and\t returns\t bit\t values\t of\t 1\t for\t positions where\tboth\tbits\tare\tdifferent;\tif\tthey\tare\tthe\tsame\tthen\tthe\tresult\tis\t0: 21.2.4\tBitwise\tLeft\tShift The\tbitwise\tleft\tshift\tmoves\tall\tbits\tin\tthe\tnumber\tto\tthe\tleft\tand\tfills\tvacated\tbit\tpositions\twith\t0. 21.2.5\tBitwise\tRight\tShift The\tbitwise\tright\tshift\tmoves\tall\tbits\tin\tthe\tnumber\tto\tthe\tright. Note\tthe\tuse\tof\t?\tfor\tthe\tfill\tbits.\tWhere\tthe\tleft\tshift\tfilled\tthe\tvacated\tpositions\twith\t0,\ta\tright shift\twill\tdo\tthe\tsame\tonly\twhen\tthe\tvalue\tis\tunsigned.\tIf\tthe\tvalue\tis\tsigned\tthen\ta\tright\tshift\twill fill\tthe\tvacated\tbit\tpositions\twith\tthe\tsign\tbit\tor\t0,\twhichever\tone\tis\timplementation-defined.\tSo the\tbest\toption\tis\tto\tnever\tright\tshift\tsigned\tvalues. 21.2.6\tBitwise\tComplement The\tbitwise\tcomplement\tinverts\tthe\tbits\tin\ta\tsingle\tbinary\tnumber. 21.2.7\tChecking\tWhether\tK-th\tBit\tis\tSet\tor\tNot Let\tus\tassume\tthat\tthe\tgiven\tnumber\tis\tn.\tThen\tfor\tchecking\tthe\tKth\tbit\twe\tcan\tuse\tthe\texpression: n\t&\t(1\t\u226a\tK\t1).\tIf\tthe\texpression\tis\ttrue\tthen\twe\tcan\tsay\tthe\tKth\tbit\tis\tset\t(that\tmeans,\tset\tto\t1). Example: 21.2.8\tSetting\tK-th\tBit For\ta\tgiven\tnumber\tn,\tto\tset\tthe\tKth\tbit\twe\tcan\tuse\tthe\texpression:\tn\t|\t1\t\u226a\t(K\t\u2013\t1) Example: 21.2.9\tClearing\tK-th\tBit To\tclear\tKth\tbit\tof\ta\tgiven\tnumber\tn,\twe\tcan\tuse\tthe\texpression:\tn\t&\t~(1\t\u226a\tK\t\u2013\t1) Example: 21.2.10\tToggling\tK-th\tBit For\ta\tgiven\tnumber\tn,\tfor\ttoggling\tthe\tKth\tbit\twe\tcan\tuse\tthe\texpression:\tn\t^(1\t\u226a\tK\t\u2013\t1) Example: 21.2.11\tToggling\tRightmost\tOne\tBit For\ta\tgiven\tnumber\tn,\tfor\ttoggling\trightmost\tone\tbit\twe\tcan\tuse\tthe\texpression:\tn\t&\tn\t\u2013\t1 Example: 21.2.12\tIsolating\tRightmost\tOne\tBit For\ta\tgiven\tnumber\tn,\tfor\tisolating\trightmost\tone\tbit\twe\tcan\tuse\tthe\texpression:\tn\t&\t\u2013\tn Example: Note:\tFor\tcomputing\t\u2013n,\tuse\ttwo\u2019s\tcomplement\trepresentation.\tThat\tmeans,\ttoggle\tall\tbits\tand add\t1. 21.2.13\tIsolating\tRightmost\tZero\tBit For\ta\tgiven\tnumber\tn,\tfor\tisolating\trightmost\tzero\tbit\twe\tcan\tuse\tthe\texpression:\t~n\t&\tn\t+\t1 Example: 21.2.14\tChecking\tWhether\tNumber\tis\tPower\tof\t2\tor\tNot Given\tnumber\tn,\tto\tcheck\twhether\tthe\tnumber\tis\tin\t2n\tform\tfor\tnot,\twe\tcan\tuse\tthe\texpression: if(n\t&\tn\t\u2013\t1\t==\t0) Example: 21.2.15\tMultiplying\tNumber\tby\tPower\tof\t2 For\ta\tgiven\tnumber\tn,\tto\tmultiply\tthe\tnumber\twith\t2K\twe\tcan\tuse\tthe\texpression:\tn\t\u226a\tK Example: 21.2.16\tDividing\tNumber\tby\tPower\tof\t2 For\ta\tgiven\tnumber\tn,\tto\tdivide\tthe\tnumber\twith\t2K\twe\tcan\tuse\tthe\texpression:\tn\t\u226b\tK Example: 21.2.17\tFinding\tModulo\tof\ta\tGiven\tNumber For\ta\tgiven\tnumber\tn,\tto\tfind\tthe\t%8\twe\tcan\tuse\tthe\texpression:\tn\t&\t0x7.\tSimilarly,\tto\tfind\t%32, use\tthe\texpression:\tn\t&\t0x1F Note:\tSimilarly,\twe\tcan\tfind\tmodulo\tvalue\tof\tany\tnumber. 21.2.18\tReversing\tthe\tBinary\tNumber For\ta\tgiven\tnumber\tn,\tto\treverse\tthe\tbits\t(reverse\t(mirror)\tof\tbinary\tnumber)\twe\tcan\tuse\tthe following\tcode\tsnippet: Time\tComplexity:\tThis\trequires\tone\titeration\tper\tbit\tand\tthe\tnumber\tof\titerations\tdepends\ton\tthe size\tof\tthe\tnumber. 21.2.19\tCounting\tNumber\tof\tOne\u2019s\tin\tNumber For\ta\tgiven\tnumber\tn,\tto\tcount\tthe\tnumber\tof\t1\u2019s\tin\tits\tbinary\trepresentation\twe\tcan\tuse\tany\tof\tthe following\tmethods. Method\t1:\tProcess\tbit\tby\tbit\twith\tbitwise\tand\toperator Time\t Complexity:\t This\t approach\t requires\t one\t iteration\t per\t bit\t and\t the\t number\t of\t iterations depends\ton\tsystem. Method\t2:\tUsing\tmodulo\tapproach Time\tComplexity:\tThis\trequires\tone\titeration\tper\tbit\tand\tthe\tnumber\tof\titerations\tdepends\ton system. Method\t3:\tUsing\ttoggling\tapproach:\tn\t&\tn\t\u2013\t1 Time\tComplexity:\tThe\tnumber\tof\titerations\tdepends\ton\tthe\tnumber\tof\t1\tbits\tin\tthe\tnumber. Method\t4:\tUsing\tpreprocessing\tidea.\tIn\tthis\tmethod,\twe\tprocess\tthe\tbits\tin\tgroups.\tFor\texample if\twe\tprocess\tthem\tin\tgroups\tof\t4\tbits\tat\ta\ttime,\twe\tcreate\ta\ttable\twhich\tindicates\tthe\tnumber\tof one\u2019s\tfor\teach\tof\tthose\tpossibilities\t(as\tshown\tbelow). The\tfollowing\tcode\tto\tcount\tthe\tnumber\tof\tIs\tin\tthe\tnumber\twith\tthis\tapproach: Time\tComplexity:\tThis\tapproach\trequires\tone\titeration\tper\t4\tbits\tand\tthe\tnumber\tof\titerations depends\ton\tsystem. 21.2.20\tCreating\tMask\tfor\tTrailing\tZero\u2019s For\ta\tgiven\tnumber\tn,\tto\tcreate\ta\tmask\tfor\ttrailing\tzeros,\twe\tcan\tuse\tthe\texpression:\t(n\t&\t\u2013\tn)\t\u2013\t1 Example: Note:\tIn\tthe\tabove\tcase\twe\tare\tgetting\tthe\tmask\tas\tall\tzeros\tbecause\tthere\tare\tno\ttrailing\tzeros. 27.2.21\tSwap\tall\todd\tand\teven\tbits Example: 21.2.22\tPerforming\tAverage\twithout\tDivision Is\tthere\ta\tbit-twiddling\talgorithm\tto\treplace\tmid\t=\t(low\t+\thigh)\t/\t2\t(used\tin\tBinary\tSearch\tand Merge\tSort)\twith\tsomething\tmuch\tfaster? We\tcan\tuse\tmid\t=\t(low\t+\thigh)\t>>\t1.\tNote\tthat\tusing\t(low\t+\thigh)\t/\t2\tfor\tmidpoint\tcalculations won\u2019t\twork\tcorrectly\twhen\tinteger\toverflow\tbecomes\tan\tissue.\tWe\tcan\tuse\tbit\tshifting\tand\talso overcome\ta\tpossible\toverflow\tissue:\tlow\t+\t((high\t\u2013\tlow)/\t2)\tand\tthe\tbit\tshifting\toperation\tfor this\tis\tlow\t+\t((high\t\u2013\tlow)\t>>\t1)."
            },
            {
                "subchapter_title": "21.3\tOther\tProgramming\tQuestions\twith\tSolutions",
                "content": "Problem-1\u2003\u2003Give\tan\talgorithm\tfor\tprinting\tthe\tmatrix\telements\tin\tspiral\torder. Solution:\t Non-recursive\t solution\t involves\t directions\t right,\t left,\t up,\t down,\t and\t dealing\t their corresponding\tindices.\tOnce\tthe\tfirst\trow\tis\tprinted,\tdirection\tchanges\t(from\tright)\tto\tdown,\tthe row\t is\t discarded\t by\t incrementing\t the\t upper\t limit.\t Once\t the\t last\t column\t is\t printed,\t direction changes\tto\tleft,\tthe\tcolumn\tis\tdiscarded\tby\tdecrementing\tthe\tright\thand\tlimit. Time\tComplexity:\tO(n2).\tSpace\tComplexity:\tO(1). Problem-2\u2003\u2003Give\tan\talgorithm\tfor\tshuffling\tthe\tdesk\tof\tcards. Solution:\tAssume\tthat\twe\twant\tto\tshuffle\tan\tarray\tof\t52\tcards,\tfrom\t0\tto\t51\twith\tno\trepeats,\tsuch as\twe\tmight\twant\tfor\ta\tdeck\tof\tcards.\tFirst\tfill\tthe\tarray\twith\tthe\tvalues\tin\torder,\tthen\tgo\tthrough the\tarray\tand\texchange\teach\telement\twith\ta\trandomly\tchosen\telement\tin\tthe\trange\tfrom\titself\tto the\tend.\tIt\u2019s\tpossible\tthat\tan\telement\twill\tswap\twith\titself,\tbut\tthere\tis\tno\tproblem\twith\tthat. Time\tComplexity:\tO(n).\tSpace\tComplexity:\tO(1). Problem-3\u2003\u2003Reversal\t algorithm\t for\t array\t rotation:\t Write\t a\t function\t rotate(A[],\t d,\t n)\t that rotates\t A[]\t of\t size\t n\t by\t d\t elements.\t For\t example,\t the\t array\t 1,2,3,4,5,6,7\t becomes 3,4,5,6,7,1,2\tafter\t2\trotations. Solution:\tConsider\tthe\tfollowing\talgorithm. Algorithm: rotate(Array[],\td,\tn) reverse(Array[],\t1,\td)\t;\treverse(Array[],\td\t+\t1,\tn); reverse(Array[],\t1,\tn); Let\tAB\tbe\tthe\ttwo\tparts\tof\tthe\tinput\tArrays\twhere\tA\t=\tArray[0..d-1]\tand\tB\t=\tArray[d..n-1].\tThe idea\tof\tthe\talgorithm\tis: Reverse\tA\tto\tget\tArB.\t/*\tAr\tis\treverse\tof\tA\t*/ Reverse\tB\tto\tget\tArBr.\t/*\tBr\tis\treverse\tof\tB\t*/ Reverse\tall\tto\tget\t(ArBr)\tr\t=\tBA. For\texample,\tif\tArray[]\t=\t[1,\t2,\t3,\t4,\t5,\t6,\t7],\td\t=2\tand\tn\t=\t7\tthen,\tA\t=\t[1,\t2]\tand\tB\t=\t[3, 4,\t5,\t6,\t7] Reverse\tA,\twe\tget\tArB\t=\t[2,\t1,\t3,\t4,\t5,\t6,\t7],\tReverse\tB,\twe\tget\tArBr\t=\t[2,\t1,\t7,\t6,\t5,\t4, 3] Reverse\tall,\twe\tget\t(ArBr)r\t=\t[3,\t4,\t5,\t6,\t7,\t1,\t2] Implementation\t: Problem-4\u2003\u2003Suppose\t you\t are\t given\t an\t array\t s[1...n]\t and\t a\t procedure\t reverse\t (s,i,j)\t which reverses\tthe\torder\tof\telements\tin\tbetween\tpositions\ti\tand\tj\t(both\tinclusive).\tWhat\tdoes\tthe following\tsequence a) Rotates\ts\tleft\tby\tk\tpositions b) Leaves\ts\tunchanged c) Reverses\tall\telements\tof\ts d) None\tof\tthe\tabove Solution:\t(b).\tEffect\tof\tthe\tabove\t3\treversals\tfor\tany\tk\tis\tequivalent\tto\tleft\trotation\tof\tthe\tarray\tof size\tn\tby\tk\t[refer\tProblem-3]. Problem-5\u2003\u2003Finding\tAnagrams\tin\tDictionary:\tyou\tare\tgiven\tthese\t2\tfiles:\tdictionary.txt\tand jumbles.txt Thejumbles.txt\tfile\tcontains\ta\tbunch\tof\tscrambled\twords.\tYour\tjob\tis\tto\tprint\tout\tthose\tjumbles words,\t1\tword\tto\ta\tline.\tAfter\teach\tjumbled\tword,\tprint\ta\tlist\tof\treal\tdictionary\twords\tthat\tcould be\tformed\tby\tunscrambling\tthe\tjumbled\tword.\tThe\tdictionary\twords\tthat\tyou\thave\tto\tchoose\tfrom are\tin\tthe\tdictionary.txt\tfile.\tSample\tcontent\tof\tjumbles.txt: Solution:\tStep-By-Step Step\t1:\tInitialization \u2022 Open\tthe\tdictionary.txt\tfile\tand\tread\tthe\twords\tinto\tan\tarray\t(before\tgoing\tfurther verify\tby\techoing\tout\tthe\twords\tback\tfrom\tthe\tarray\tout\tto\tthe\tscreen). \u2022 Declare\ta\thash\ttable\tvariable. Step\t2:\tProcess\tthe\tDictionary\tfor\teach\tdictionary\tword\tin\tthe\tarray.\tDo\tthe\tfollowing: We\tnow\thave\ta\thash\ttable\twhere\teach\tkey\tis\tthe\tsorted\tform\tof\ta\tdictionary\tword\tand\tthe\tvalue associated\tto\tit\tis\ta\tstring\tor\tarray\tof\tdictionary\twords\tthat\tsort\tto\tthat\tsame\tkey. \u2022 Remove\tthe\tnewline\toff\tthe\tend\tof\teach\tword\tvia\tchomp($word); \u2022 Make\ta\tsorted\tcopy\tof\tthe\tword\t-\ti.e.\trearrange\tthe\tindividual\tchars\tin\tthe\tstring\tto be\tsorted\talphabetically \u2022 Think\tof\tthe\tsorted\tword\tas\tthe\tkey\tvalue\tand\tthink\tof\tthe\tset\tof\tall\tdictionary\twords that\tsort\tto\tthe\texact\tsame\tkey\tword\tas\tbeing\tthe\tvalue\tof\tthe\tkey \u2022 Query\tthe\thashtable\tto\tsee\tif\tthe\tsortedWord\tis\talready\tone\tof\tthe\tkeys \u2022 If\t it\t is\t not\t already\t present\t then\t insert\t the\t sorted\t word\t as\t key\t and\t the\t unsorted original\tof\tthe\tword\tas\tthe\tvalue \u2022 Else\tconcat\tthe\tunsorted\tword\tonto\tthe\tvalue\tstring\talready\tout\tthere\t(put\ta\tspace\tin between) Step\t3:\tProcess\tthe\tjumbled\tword\tfile \u2022 Read\tthrough\tthe\tjumbled\tword\tfile\tone\tword\tat\ta\ttime.\tAs\tyou\tread\teach\tjumbled word\tchomp\tit\tand\tmake\ta\tsorted\tcopy\t(the\tsorted\tcopy\tis\tyour\tkey) \u2022 Print\tthe\tunsorted\tjumble\tword \u2022 Query\tthe\thashtable\tfor\tthe\tsorted\tcopy.\tIf\tfound,\tprint\tthe\tassociated\tvalue\ton\tsame line\tas\tkey\tand\tthen\ta\tnew\tline. Step\t4:\tCelebrate,\twe\tare\tall\tdone Sample\tcode\tin\tPerl: Problem-6\t Pathways:\t Given\t a\t matrix\t as\t shown\t below,\t calculate\t the\t number\t of\t ways\t for reaching\tdestination\tB\tfrom\tA. Solution:\tBefore\tfinding\tthe\tsolution,\twe\ttry\tto\tunderstand\tthe\tproblem\twith\ta\tsimpler\tversion. The\tsmallest\tproblem\tthat\twe\tcan\tconsider\tis\tthe\tnumber\tof\tpossible\troutes\tin\ta\t1\t\u00d7\t1\tgrid. From\tthe\tabove\tfigure,\tit\tcan\tbe\tseen\tthat: \u2022 From\tboth\tthe\tbottom-left\tand\tthe\ttop-right\tcorners\tthere\u2019s\tonly\tone\tpossible\troute\tto the\tdestination. \u2022 From\tthe\ttop-left\tcorner\tthere\tare\ttrivially\ttwo\tpossible\troutes. Similarly,\tfor\t2x2\tand\t3x3\tgrids,\twe\tcan\tfill\tthe\tmatrix\tas: From\tthe\tabove\tdiscussion,\tit\tis\tclear\tthat\tto\treach\tthe\tbottom\tright\tcorner\tfrom\tleft\ttop\tcorner,\tthe paths\tare\toverlapping.\tAs\tunique\tpaths\tcould\toverlap\tat\tcertain\tpoints\t(grid\tcells),\twe\tcould\ttry to\talter\tthe\tprevious\talgorithm,\tas\ta\tway\tto\tavoid\tfollowing\tthe\tsame\tpath\tagain.\tIf\twe\tstart\tfilling 4x4\tand\t5x5,\twe\tcan\teasily\tfigure\tout\tthe\tsolution\tbased\ton\tour\tchildhood\tmathematics\tconcepts. Are\tyou\table\tto\tfigure\tout\tthe\tpattern?\tIt\tis\tthe\tsame\tas\tPascals\ttriangle.\tSo,\tto\tfind\tthe\tnumber\tof ways,\twe\tcan\tsimply\tscan\tthrough\tthe\ttable\tand\tkeep\tcounting\tthem\twhile\twe\tmove\tfrom\tleft\tto right\tand\ttop\tto\tbottom\t(starting\twith\tleft-top).\tWe\tcan\teven\tsolve\tthis\tproblem\twith\tmathematical equation\tof\tPascals\ttriangle. Problem-7\u2003\u2003Given\ta\tstring\tthat\thas\ta\tset\tof\twords\tand\tspaces,\twrite\ta\tprogram\tto\tmove\tthe spaces\tto\tfront\tof\tstring.\tYou\tneed\tto\ttraverse\tthe\tarray\tonly\tonce\tand\tyou\tneed\tto\tadjust the\tstring\tin\tplace. Input\t=\t\u201cmove\tthese\tspaces\tto\tbeginning\u201d\tOutput\t=\u201c\tmovethesepacestobeginning\u201d Solution:\t Maintain\t two\t indices\t i\t and\t j;\t traverse\t from\t end\t to\t beginning.\t If\t the\t current\t index contains\tchar,\tswap\tchars\tin\tindex\ti\twith\tindex\tj.\tThis\twill\tmove\tall\tthe\tspaces\tto\tbeginning\tof the\tarray. Time\tComplexity:\tO(n)\twhere\tn\tis\tthe\tnumber\tof\tcharacters\tin\tthe\tinput\tarray.\tSpace\tComplexity: O(1). Problem-8\u2003\u2003For\tthe\tProblem-7,\tcan\twe\timprove\tthe\tcomplexity? Solution:\t We\t can\t avoid\t a\t swap\t operation\t with\t a\t simple\t counter.\t But,\t it\t does\t not\t reduce\t the overall\tcomplexity. Time\tComplexity:\tO(n)\twhere\tn\tis\tthe\tnumber\tof\tcharacters\tin\tinput\tarray.\tSpace\tComplexity: O(1). Problem-9\u2003\u2003Given\ta\tstring\tthat\thas\ta\tset\tof\twords\tand\tspaces,\twrite\ta\tprogram\tto\tmove\tthe spaces\tto\tend\tof\tstring.\tYou\tneed\tto\ttraverse\tthe\tarray\tonly\tonce\tand\tyou\tneed\tto\tadjust\tthe string\tin\tplace. Input\t=\t\u201cmove\tthese\tspaces\tto\tend\u201d\tOutput\t=\t\u201cmovethesepacestoend\t\u201c Solution:\tTraverse\tthe\tarray\tfrom\tleft\tto\tright.\tWhile\ttraversing,\tmaintain\ta\tcounter\tfor\tnon-space elements\tin\tarray.\tFor\tevery\tnon-space\tcharacter\tA[i],\tput\tthe\telement\tat\tA[count]\tand\tincrement count.\tAfter\tcomplete\ttraversal,\tall\tnon-space\telements\thave\talready\tbeen\tshifted\tto\tfront\tend\tand count\tis\tset\tas\tindex\tof\tfirst\t0.\tNow,\tall\twe\tneed\tto\tdo\tis\trun\ta\tloop\twhich\tfills\tall\telements\twith spaces\tfrom\tcount\ttill\tend\tof\tthe\tarray. Time\tComplexity:\tO(n)\twhere\tn\tis\tnumber\tof\tcharacters\tin\tinput\tarray.\tSpace\tComplexity:\tO(1). Problem-10\u2003\u2003Moving\tZeros\tto\tend:\tGiven\tan\tarray\tof\tn\tintegers,\tmove\tall\tthe\tzeros\tof\ta\tgiven array\tto\tthe\tend\tof\tthe\tarray.\tFor\texample,\tif\tthe\tgiven\tarray\tis\t{1,\t9,\t8,\t4,\t0,\t0,\t2,\t7,\t0,\t6, 0},\tit\tshould\tbe\tchanged\tto\t{1,\t9,\t8,\t4,\t2,\t7,\t6,\t0,\t0,\t0,\t0}.\tThe\torder\tof\tall\tother\telements should\tbe\tsame. Solution:\tMaintain\ttwo\tvariables\ti\tand\tj;\tand\tinitialize\twith\t0.\tFor\teach\tof\tthe\tarray\telement\tA[i], if\tA[i]\tnon-zero\telement,\tthen\treplace\tthe\telement\tA[j]\twith\telement\tA[i].\tVariable\ti\twill\talways be\tincremented\ttill\tn\t-\t1\tbut\twe\twill\tincrement\tj\tonly\twhen\tthe\telement\tpointed\tby\ti\tis\tnon-zero. Time\tComplexity:\tO(n).\tSpace\tComplexity:\tO(1). Problem-11\u2003\u2003For\tProblem-10,\tcan\twe\timprove\tthe\tcomplexity? Solution:\tUsing\tsimple\tswap\ttechnique\twe\tcan\tavoid\tthe\tunnecessary\tsecond\twhile\tloop\tfrom\tthe above\tcode. Time\tComplexity:\tO(n).\tSpace\tComplexity:\tO(1). Problem-12\u2003\u2003Variant\tof\tProblem-10\tand\tProblem-11:\tGiven\tan\tarray\tcontaining\tnegative\tand positive\t numbers;\t give\t an\t algorithm\t for\t separating\t positive\t and\t negative\t numbers\t in\t it. Also,\tmaintain\tthe\trelative\torder\tof\tpositive\tand\tnegative\tnumbers.\tInput:\t-5,\t3,\t2,\t-1,\t4,\t-8 Output:\t-5-1\t-8342 Solution:\tIn\tthe\tmoveZerosToEnd\tfunction,\tjust\treplace\tthe\tcondition\tA[i]\t!=0\twith\tA[i]\t<\t0. Problem-13\u2003\u2003Given\ta\tnumber,\tswap\todd\tand\teven\tbits. Solution: Problem-14\u2003\u2003Count\tthe\tnumber\tof\tset\tbits\tin\tall\tnumbers\tfrom\t1\tto\tn Solution:\tWe\tcan\tuse\tthe\ttechnique\tof\tsection\t21.2.19\tand\titerate\tthrough\tall\tthe\tnumbers\tfrom\t1 to\tn. Problem-15\u2003\u2003Count\tthe\tnumber\tof\tset\tbits\tin\tall\tnumbers\tfrom\t1\tto\tn Solution:\tWe\tcan\tuse\tthe\ttechnique\tof\tsection\t21.2.19\tand\titerate\tthrough\tall\tthe\tnumbers\tfrom\t1 to\tn. Time\tcomplexity:\tO(number\tof\tset\tbits\tin\tall\tnumbers\tfrom\t1\tto\tn). REFERENCES [1] Akash.\tProgramming\tInterviews,\ttech-queries.blogspot.com. [2] Alfred\tV.Aho,J.\tE.\t(1983).\tData\tStructures\tand\tAlgorithms.\tAddison-Wesley. [3] Algorithms.Retrieved\tfrom\tcs.princeton.edu/algs4/home [4] Anderson.,\t S.\t E.\t Bit\t Twiddling\t Hacks.\t Retrieved\t 2010,\t from\t Bit\t Twiddling\t Hacks: graphics.\tStanford.\tedu [5] Bentley,\tJ.\tAT&T\tBell\tLaboratories.\tRetrieved\tfrom\tAT&T\tBell\tLaboratories. [6] Bondalapati,\tK.\tInterview\tQuestion\tBank.\tRetrieved\t2010,\tfrom\tInterview\tQuestion\tBank: halcyon.usc.edu/~kiran/msqs.html [7] Chen.\tAlgorithms\thawaii.edu/~chenx. [8] Database,\t P.Problem\t Database.\t Retrieved\t 2010,\t from\t Problem\t Database: datastructures.net [9] Drozdek,\tA.\t(1996).\tData\tStructures\tand\tAlgorithms\tin\tC++. [10] Ellis\tHorowitz,\tS.\tS.\tFundamentals\tof\tData\tStructures. [11] Gilles\tBrassard,\tP.\tB.\t(1996).\tFundamentals\tof\tAlgorithmics. [12] Hunter.,\t J.\t Introduction\t to\t Data\t Structures\t and\t Algorithms.\t Retrieved\t 2010,\t from Introduction\tto\tData\tStructures\tand\tAlgorithms. [13] James\tF.\tKorsh,\tL.\tJ.\tData\tStructures,\tAlgorithms\tand\tProgram\tStyle\tUsing\tC. [14] John\tMongan,\tN.\tS.\t(2002).\tProgramming\tInterviews\tExposed.\tWiley-India.\t. [15] Judges.\t Comments\t on\t Problems\t and\t Solutions.\t http://www.informatik.uni- ulm.de/acm/Locals/2003/html/judge,\thtml. [16] Kalid.\t P,\t NP,\t and\t NP-Complete.\t Retrieved\t from\t P,\t NP,\t and\t NP-Complete.: cs.princeton.edu/~kazad [17] Knuth.,\t D.\t E.\t (1973).\t Fundamental\t Algorithms,\t volume\t 1\t of\t The\t Art\t of\t Computer Programming.\tAddison-Wesley. [18] Leon,\t J.\t S.\t Computer\t Algorithms.\t Retrieved\t 2010,\t from\t Computer\t Algorithms\t : math.uic.edu/~leon [19] Leon.,\tJ.\tS.\tComputer\tAlgorithms,\tmath.uic.edu/~leon/cs-mcs401-s08. [20] OCF.\tAlgorithms.\tRetrieved\t2010,\tfrom\tAlgorithms:\tocf.berkeley.edu [21] Parlante.,\t N.\t Binary\t Trees.\t Retrieved\t 2010,\t from\t cslibrary.stanford.edu: cslibrary.stanford.edu [22] Patil.,\tV.\tFundamentals\tof\tdata\tstructures.\tNirali\tPrakashan. [23] Poundstone.,\tW.\tHOW\tWOULD\tYOU\tMOVE\tMOUNT\tFUJI?\tNew\tYork\tBoston.:\tLittle, Brown\tand\tCompany. [24] Pryor,\tM.\tTech\tInterview.\tRetrieved\t2010,\tfrom\tTech\tInterview:\ttechinterview.org [25] Questions,\tA.\tC.\tA\tCollection\tof\tTechnical\tInterview\tQuestions.\tRetrieved\t2010,\tfrom\tA Collection\tof\tTechnical\tInterview\tQuestions [26] S.\tDasgupta,\tC.\tP.\tAlgorithms\tcs.berkeley.edu/~vazirani. [27] Sedgewick.,\tR.\t(1988).\tAlgorithms.\tAddison-Wesley. [28] Sells,\t C.\t (2010).\t Interviewing\t at\t Microsoft.\t Retrieved\t 2010,\t from\t Interviewing\t at Microsoft [29] Shene,\tC.-K.\tLinked\tLists\tMerge\tSort\tImplementation. [30] Sinha,\tP.\tLinux\tJournal.\tRetrieved\t2010,\tfrom:\tlinuxjournal.com/article/6828. [31] Structures.,\t d.\t D.\t www.math-cs.gordon.edu.\t Retrieved\t 2010,\t from\t www.math- cs.gordon.edu [32] T.\tH.\tCormen,\tC.\tE.\t(1997).\tIntroduction\tto\tAlgorithms.\tCambridge:\tThe\tMIT\tpress. [33] Tsiombikas,\tJ.\tPointers\tExplained,\tnuclear.sdf-eu.org. [34] Warren.,\tH.\tS.\t(2003).\tHackers\tDelight.\tAddison-Wesley. [35] Weiss.,\tM.\tA.\t(1992).\tData\tStructures\tand\tAlgorithm\tAnalysis\tin\tC. [36] SANDRASI\thttp://sandrasi-sw.blogspot.in/"
            }
        ]
    }
]
