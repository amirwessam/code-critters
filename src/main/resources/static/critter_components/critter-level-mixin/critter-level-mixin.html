<link rel="import" href="../../bower_components/polymer/polymer.html">
<link rel="import" href="../critter-toaster/critter-toaster.html">
<script src="../../bower_components/pathfinding/pathfinding-browser.min.js"></script>
<link rel="import" href="../../bower_components/iron-ajax/iron-ajax.html">

<!--
#CritterMixins.Level

Holds general functions for code-critter Levels

-->

<script>
    window.CritterMixins = window.CritterMixins || {};


    /**
     * # CritterMixins.Level
     *
     * Shortcuts for common gui element interaction.
     *
     * @polymerBehavior CritterMixins.Level
     */

    CritterMixins.Level = Polymer.dedupingMixin(function (superClass) {
        return class extends superClass {

            static get properties() {
                return {
                    levelName: {
                        type: String,
                        value: '',
                        observer: '_updateLevelData'
                    },

                    level: {
                        type: Array,
                        notify: true
                    },

                    tower: {
                        type: Object,
                        notify: true
                    },

                    spawn: {
                        type: Object,
                        notify: true
                    },

                    width: {
                        type: Number,
                        value: 16,
                        notify: true
                    },

                    height: {
                        type: Number,
                        value: 16,
                        notify: true
                    },

                    mines: {
                        type: Array,
                        value: [],
                        notify: true
                    },

                    towers: {
                        type: Array,
                        value: [],
                        notify: true
                    },

                    modder: {
                        type: Array,
                        value: [],
                        notify: true
                    }

                };
            }

            /** returns weather there is a path from source to the tower or not**/
            existPath(source) {
                return this.findPathLib(source).length ? true : false;
            }


            /** returns a path from source to the tower using the lib **/
            findPathLib(source) {
                if (!this.tower || !this.level || !this.spawn) {
                    return [];
                }

                let tempArray = this._computeGrid();
                if (source.x !== this.spawn.x || source.y !== this.spawn.y) {
                    tempArray[this.spawn.x][this.spawn.y] = 1;
                }
                let grid = new PF.Grid(tempArray);
                let finder = new PF.AStarFinder();
                let path = finder.findPath(source.x, source.y, this.tower.x, this.tower.y, grid);

                return path;
            }

            /** returns a radnom path from source to the tower **/
            findPath(source, steps = 0) {
                if (!this.tower || !this.level || !this.spawn) {
                    return [];
                }

                let tempArray = this._computeGrid();

                tempArray[this.spawn.x][this.spawn.y] = 1;

                let path = [source];
                let possibilities = this._findPossibility(tempArray, source);
                while (possibilities.length !== 1 || !(possibilities[0].x === this.tower.x && possibilities[0].y === this.tower.y)) {
                    if (possibilities.length > 0) {
                        source = possibilities[this._randomNumber(0, possibilities.length - 1)];
                        path.push(source);
                        tempArray[source.y][source.x] = 1;
                    } else if (possibilities.length === 0) {
                        path.pop();
                        if (path.length === 0) {
                            if (steps < 3) {
                                console.log((steps + 1) + "steps were needed!");
                                return this.findPath(source, ++steps);
                            } else {
                                console.log("No Path was found after 3 times with standard algorithm.\nAstar will be used now");
                                let pathBuffer = this.findPathLib(source);
                                path = [source];
                                for (let i = 1; i < pathBuffer.length - 1; ++i) {
                                    path.push({
                                        x: pathBuffer[i][0],
                                        y: pathBuffer[i][1]
                                    });
                                }
                                path.push(this.tower);
                                return path;
                            }
                        }
                        source = path[path.length - 1];
                    }
                    possibilities = this._findPossibility(tempArray, source);
                }
                path.push(this.tower);
                return path;
            }

            /** returns a random number between min and mam**/
            _randomNumber(min, max) {
                return Math.floor((Math.random() * ((max - min) + 1)) + min);
            }


            /** searches for possibilities and return list of possible waypoints or the location of the tower, if the tower
             * is in range **/
            _findPossibility(tempArray, source) {
                let possibilities = [];
                if (tempArray[source.y][source.x + 1] === 0) {
                    possibilities.push({y: source.y, x: (source.x + 1)});
                }
                if (tempArray[source.y][source.x - 1] === 0) {
                    possibilities.push({y: source.y, x: (source.x - 1)});
                }
                if (tempArray[source.y + 1] && tempArray[source.y + 1][source.x] === 0) {
                    possibilities.push({y: (source.y + 1), x: source.x});
                }
                if (tempArray[source.y - 1] && tempArray[source.y - 1][source.x] === 0) {
                    possibilities.push({y: (source.y) - 1, x: source.x});
                }
                for (let i = 0; i < possibilities.length; ++i) {
                    if (possibilities[i].x === this.tower.x && possibilities[i].y === this.tower.y) {
                        return [this.tower];
                    }
                }
                return possibilities;
            }

            /** computes the grid used for finding a path through the map **/
            _computeGrid() {
                let tempArray = new Array(this.height);
                for (let i = 0; i < this.height; ++i) {
                    tempArray[i] = new Array(this.width);
                    for (let j = 0; j < this.width; ++j) {
                        if (this.level[i][j] === "grass" || this.level[i][j] === "dirt" || (this.level[i][j] === "water" && this.canWalkOnWater) || this.level[i][j] === "ice" || (this.level[i][j] === "lava" && this.canWalkOnLava)) {
                            tempArray[i][j] = 0;
                        }
                        else {
                            tempArray[i][j] = 1;
                        }
                    }
                }

                return tempArray;
            }

            /** computes weather an element is already at that position or not**/
            _isElementOnPosition(j, i) {
                if(this.tower && this.tower.y=== i && this.tower.x === j) {
                    return true;
                }
                if(this.spawn && this.spawn.y === i && this.spawn.x === j) {
                    return true;
                }
                this.mines.forEach((mine) => {
                    if (mine.x === i && mine.y === j) {
                        return true;
                    }
                });
                this.towers.forEach((tower) => {
                    if (tower.x === i && tower.y === j) {
                        return true;
                    }
                });
                this.modder.forEach((modder) => {
                    if (modder.x === i && modder.y === j) {
                        return true;
                    }
                });
            }

            /** performs an ajax call to get level data from the server **/
            getLevelData() {
                let req = document.createElement('iron-ajax');
                req.url = "/level/get";
                req.method = "GET";
                req.handleAs = 'json';
                req.contentType = 'application/json';
                req.bubbles = true;
                req.rejectWithRequest = true;
                req.params = {level: this.levelName};

                req.addEventListener('response', e => {
                    let data = e.detail.__data.response;
                    this.level = data.level;
                    this.spawn = data.spawn;
                    this.tower = data.tower;
                    this.width = data.width;
                    this.height = data.height;
                    this.numberOfHumans = data.numberOfHumans;
                    this.numberOfCritters = data.numberOfCritters;
                });

                let genRequest = req.generateRequest();
                req.completes = genRequest.completes;
                return req;
            }

            /** updates the level Data needed for the game **/
            _updateLevelData() {
                if (this.levelName === '' || this.generator) {
                    return;
                }
                this.getLevelData();
            }

            _shuffleArray(array) {
                let currentIndex = array.length, temporaryValue, randomIndex;
                while (0 !== currentIndex) {
                    randomIndex = Math.floor(Math.random() * currentIndex);
                    currentIndex -= 1;
                    temporaryValue = array[currentIndex];
                    array[currentIndex] = array[randomIndex];
                    array[randomIndex] = temporaryValue;
                }

                return array;
            }

        }
    });
</script>
